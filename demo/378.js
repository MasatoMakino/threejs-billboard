(self.webpackChunk_masatomakino_threejs_billboard=self.webpackChunk_masatomakino_threejs_billboard||[]).push([[378],{1379:module=>{eval("\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3OS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9wYXJzZS1zdmctcGF0aC9pbmRleC5qcz83NjgwIl0sInNvdXJjZXNDb250ZW50IjpbIlxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuXG4vKipcbiAqIGV4cGVjdGVkIGFyZ3VtZW50IGxlbmd0aHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxudmFyIGxlbmd0aCA9IHthOiA3LCBjOiA2LCBoOiAxLCBsOiAyLCBtOiAyLCBxOiA0LCBzOiA0LCB0OiAyLCB2OiAxLCB6OiAwfVxuXG4vKipcbiAqIHNlZ21lbnQgcGF0dGVyblxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuXG52YXIgc2VnbWVudCA9IC8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWdcblxuLyoqXG4gKiBwYXJzZSBhbiBzdmcgcGF0aCBkYXRhIHN0cmluZy4gR2VuZXJhdGVzIGFuIEFycmF5XG4gKiBvZiBjb21tYW5kcyB3aGVyZSBlYWNoIGNvbW1hbmQgaXMgYW4gQXJyYXkgb2YgdGhlXG4gKiBmb3JtIGBbY29tbWFuZCwgYXJnMSwgYXJnMiwgLi4uXWBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuXHR2YXIgZGF0YSA9IFtdXG5cdHBhdGgucmVwbGFjZShzZWdtZW50LCBmdW5jdGlvbihfLCBjb21tYW5kLCBhcmdzKXtcblx0XHR2YXIgdHlwZSA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKVxuXHRcdGFyZ3MgPSBwYXJzZVZhbHVlcyhhcmdzKVxuXG5cdFx0Ly8gb3ZlcmxvYWRlZCBtb3ZlVG9cblx0XHRpZiAodHlwZSA9PSAnbScgJiYgYXJncy5sZW5ndGggPiAyKSB7XG5cdFx0XHRkYXRhLnB1c2goW2NvbW1hbmRdLmNvbmNhdChhcmdzLnNwbGljZSgwLCAyKSkpXG5cdFx0XHR0eXBlID0gJ2wnXG5cdFx0XHRjb21tYW5kID0gY29tbWFuZCA9PSAnbScgPyAnbCcgOiAnTCdcblx0XHR9XG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09IGxlbmd0aFt0eXBlXSkge1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoY29tbWFuZClcblx0XHRcdFx0cmV0dXJuIGRhdGEucHVzaChhcmdzKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MubGVuZ3RoIDwgbGVuZ3RoW3R5cGVdKSB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBwYXRoIGRhdGEnKVxuXHRcdFx0ZGF0YS5wdXNoKFtjb21tYW5kXS5jb25jYXQoYXJncy5zcGxpY2UoMCwgbGVuZ3RoW3R5cGVdKSkpXG5cdFx0fVxuXHR9KVxuXHRyZXR1cm4gZGF0YVxufVxuXG52YXIgbnVtYmVyID0gLy0/WzAtOV0qXFwuP1swLTldKyg/OmVbLStdP1xcZCspPy9pZ1xuXG5mdW5jdGlvbiBwYXJzZVZhbHVlcyhhcmdzKSB7XG5cdHZhciBudW1iZXJzID0gYXJncy5tYXRjaChudW1iZXIpXG5cdHJldHVybiBudW1iZXJzID8gbnVtYmVycy5tYXAoTnVtYmVyKSA6IFtdXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1379\n")},4687:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/ResizePlugin.mjs\n\n\n"use strict";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      "resizeTo",\n      /**\n       * The HTML element or window to automatically resize the\n       * renderer\'s view element to match width and height.\n       * @member {Window|HTMLElement}\n       * @name resizeTo\n       * @memberof app.Application#\n       */\n      {\n        set(dom) {\n          globalThis.removeEventListener("resize", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener("resize", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @static\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener("resize", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = Extensions/* ExtensionType */.nw.Application;\n\n\n//# sourceMappingURL=ResizePlugin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(901);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(9366);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/TickerPlugin.mjs\n\n\n\n\n"use strict";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      "ticker",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, ticker_const/* UPDATE_PRIORITY */.u.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker/* Ticker */.v.shared : new Ticker/* Ticker */.v();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = Extensions/* ExtensionType */.nw.Application;\n\n\n//# sourceMappingURL=TickerPlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(ResizePlugin);\nExtensions/* extensions */.Rw.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWE7O0FBRWQ7QUFDeEI7Ozs7Ozs7QUN4RjZEO0FBQ1A7QUFDUjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUNBQWU7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFNLGNBQWMsb0JBQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFhOztBQUVkO0FBQ3hCOzs7QUNoRTBEO0FBQ1I7QUFDQTs7QUFFbEQ7QUFDQSw2QkFBVSxLQUFLLFlBQVk7QUFDM0IsNkJBQVUsS0FBSyxZQUFZO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hcHAvUmVzaXplUGx1Z2luLm1qcz80NDA1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXBwL1RpY2tlclBsdWdpbi5tanM/NTllMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9pbml0Lm1qcz9mYmY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBSZXNpemVQbHVnaW4ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcGx1Z2luIHdpdGggc2NvcGUgb2YgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gU2VlIGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBpbml0KG9wdGlvbnMpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgXCJyZXNpemVUb1wiLFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSFRNTCBlbGVtZW50IG9yIHdpbmRvdyB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSB0aGVcbiAgICAgICAqIHJlbmRlcmVyJ3MgdmlldyBlbGVtZW50IHRvIG1hdGNoIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgKiBAbWVtYmVyIHtXaW5kb3d8SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAbmFtZSByZXNpemVUb1xuICAgICAgICogQG1lbWJlcm9mIGFwcC5BcHBsaWNhdGlvbiNcbiAgICAgICAqL1xuICAgICAge1xuICAgICAgICBzZXQoZG9tKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpO1xuICAgICAgICAgIHRoaXMuX3Jlc2l6ZVRvID0gZG9tO1xuICAgICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnF1ZXVlUmVzaXplKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNpemVUbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jYW5jZWxSZXNpemUoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMucmVzaXplKCkpO1xuICAgIH07XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3Jlc2l6ZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3Jlc2l6ZUlkKTtcbiAgICAgICAgdGhpcy5fcmVzaXplSWQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Jlc2l6ZVRvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbmNlbFJlc2l6ZSgpO1xuICAgICAgbGV0IHdpZHRoO1xuICAgICAgbGV0IGhlaWdodDtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVUbyA9PT0gZ2xvYmFsVGhpcy53aW5kb3cpIHtcbiAgICAgICAgd2lkdGggPSBnbG9iYWxUaGlzLmlubmVyV2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGdsb2JhbFRoaXMuaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB3aWR0aCA9IGNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfTtcbiAgICB0aGlzLl9yZXNpemVJZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzaXplVG8gPSBudWxsO1xuICAgIHRoaXMucmVzaXplVG8gPSBvcHRpb25zLnJlc2l6ZVRvIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aWNrZXIsIHNjb3BlZCB0byBhcHBsaWNhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZGVzdHJveSgpIHtcbiAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5xdWV1ZVJlc2l6ZSk7XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplKCk7XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZVRvID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5SZXNpemVQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcblxuZXhwb3J0IHsgUmVzaXplUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSAnLi4vdGlja2VyL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBUaWNrZXIgfSBmcm9tICcuLi90aWNrZXIvVGlja2VyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgVGlja2VyUGx1Z2luIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHBsdWdpbiB3aXRoIHNjb3BlIG9mIGFwcGxpY2F0aW9uIGluc3RhbmNlXG4gICAqIEBzdGF0aWNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFNlZSBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAqL1xuICBzdGF0aWMgaW5pdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgICAgc2hhcmVkVGlja2VyOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICBcInRpY2tlclwiLFxuICAgICAge1xuICAgICAgICBzZXQodGlja2VyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5fdGlja2VyLnJlbW92ZSh0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3RpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgICB0aWNrZXIuYWRkKHRoaXMucmVuZGVyLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuTE9XKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnN0b3AgPSAoKSA9PiB7XG4gICAgICB0aGlzLl90aWNrZXIuc3RvcCgpO1xuICAgIH07XG4gICAgdGhpcy5zdGFydCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3RpY2tlci5zdGFydCgpO1xuICAgIH07XG4gICAgdGhpcy5fdGlja2VyID0gbnVsbDtcbiAgICB0aGlzLnRpY2tlciA9IG9wdGlvbnMuc2hhcmVkVGlja2VyID8gVGlja2VyLnNoYXJlZCA6IG5ldyBUaWNrZXIoKTtcbiAgICBpZiAob3B0aW9ucy5hdXRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aWNrZXIsIHNjb3BlZCB0byBhcHBsaWNhdGlvbi5cbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgY29uc3Qgb2xkVGlja2VyID0gdGhpcy5fdGlja2VyO1xuICAgICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgICAgb2xkVGlja2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5UaWNrZXJQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcblxuZXhwb3J0IHsgVGlja2VyUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgUmVzaXplUGx1Z2luIH0gZnJvbSAnLi9SZXNpemVQbHVnaW4ubWpzJztcbmltcG9ydCB7IFRpY2tlclBsdWdpbiB9IGZyb20gJy4vVGlja2VyUGx1Z2luLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoUmVzaXplUGx1Z2luKTtcbmV4dGVuc2lvbnMuYWRkKFRpY2tlclBsdWdpbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4687\n')},9249:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/FilterPipe.mjs\n\n\n"use strict";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      canBundle: false,\n      action: "pushFilter",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      action: "popFilter",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === "pushFilter") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === "popFilter") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "filter"\n};\n\n\n//# sourceMappingURL=FilterPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(9818);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs + 2 modules\nvar Geometry = __webpack_require__(1980);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(4537);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs\nvar matrixAndBoundsPool = __webpack_require__(2692);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.y();\nfunction getFastGlobalBounds(target, bounds) {\n  bounds.clear();\n  _getGlobalBoundsRecursive(target, bounds);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  if (!target.renderGroup) {\n    bounds.applyMatrix(target.parentRenderGroup.worldTransform);\n  } else {\n    bounds.applyMatrix(target.renderGroup.localTransform);\n  }\n  return bounds;\n}\nfunction _getGlobalBoundsRecursive(target, bounds) {\n  if (target.localDisplayStatus !== 7 || !target.measurable) {\n    return;\n  }\n  const manageEffects = !!target.effects.length;\n  let localBounds = bounds;\n  if (target.renderGroup || manageEffects) {\n    localBounds = matrixAndBoundsPool/* boundsPool */.W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, target.worldTransform);\n  } else {\n    if (target.renderPipeId) {\n      const viewBounds = target.bounds;\n      localBounds.addFrame(\n        viewBounds.minX,\n        viewBounds.minY,\n        viewBounds.maxX,\n        viewBounds.maxY,\n        target.groupTransform\n      );\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getGlobalBoundsRecursive(children[i], localBounds);\n    }\n  }\n  if (manageEffects) {\n    let advanced = false;\n    for (let i = 0; i < target.effects.length; i++) {\n      if (target.effects[i].addBounds) {\n        if (!advanced) {\n          advanced = true;\n          localBounds.applyMatrix(target.parentRenderGroup.worldTransform);\n        }\n        target.effects[i].addBounds(localBounds, true);\n      }\n    }\n    if (advanced) {\n      localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix).invert());\n      bounds.addBounds(localBounds, target.relativeGroupTransform);\n    }\n    bounds.addBounds(localBounds);\n    matrixAndBoundsPool/* boundsPool */.W.return(localBounds);\n  } else if (target.renderGroup) {\n    bounds.addBounds(localBounds, target.relativeGroupTransform);\n    matrixAndBoundsPool/* boundsPool */.W.return(localBounds);\n  }\n}\n\n\n//# sourceMappingURL=getFastGlobalBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs\n\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const tempMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    bounds.matrix = renderable.worldTransform;\n    renderable.addBounds(bounds);\n  }\n  bounds.matrix = tempMatrix;\n  return bounds;\n}\n\n\n//# sourceMappingURL=getRenderableBounds.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/FilterSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst quadGeometry = new Geometry/* Geometry */.Z({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      location: 0,\n      format: "float32x2",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup/* UniformGroup */.o({\n      uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },\n      uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },\n      uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },\n      uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },\n      uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },\n      uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }\n    });\n    this._globalFilterBindGroup = new BindGroup/* BindGroup */.v({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      getFastGlobalBounds(instruction.container, bounds);\n    }\n    const colorTextureSource = renderer.renderTarget.rootRenderTarget.colorTexture.source;\n    let resolution = colorTextureSource._resolution;\n    let padding = 0;\n    let antialias = colorTextureSource.antialias;\n    let blendRequired = false;\n    let enabled = false;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias !== "inherit") {\n        if (filter.antialias === "on") {\n          antialias = true;\n        } else {\n          antialias = false;\n        }\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        (0,warn/* warn */.Z)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired = blendRequired || filter.blendRequired;\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    const viewPort = renderer.renderTarget.rootViewPort;\n    bounds.scale(resolution).fitBounds(0, viewPort.width, 0, viewPort.height).scale(1 / resolution).pad(padding).ceil();\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool/* TexturePool */.z.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      resolution,\n      antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture/* Texture */.x.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool/* TexturePool */.z.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool/* TexturePool */.z.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool/* TexturePool */.z.returnTexture(flip);\n      TexturePool/* TexturePool */.z.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool/* TexturePool */.z.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool/* TexturePool */.z.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point/* Point */.E.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture/* Texture */.x) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: "triangle-list"\n    });\n    if (renderer.type === types/* RendererType */.g.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds/* Bounds */.Y(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix/* Matrix */.y.shared);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.frame.width,\n      1 / sprite.texture.frame.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem\n  ],\n  name: "filter"\n};\n\n\n//# sourceMappingURL=FilterSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(FilterSystem);\nExtensions/* extensions */.Rw.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI0OS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFc0I7QUFDdEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0MwRDtBQUNHOztBQUU3RDtBQUNBLHVCQUF1QixvQkFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQ0FBVTtBQUNkLElBQUk7QUFDSjtBQUNBLElBQUkscUNBQVU7QUFDZDtBQUNBOztBQUUwRDtBQUMxRDs7O0FDckVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDckM7Ozs7O0FDakI2RDtBQUNUO0FBQ0g7QUFDMkI7QUFDRztBQUNNO0FBQ1Q7QUFDUTtBQUNwQjtBQUNGO0FBQzBCO0FBQ007QUFDN0M7O0FBRWpEO0FBQ0EseUJBQXlCLHdCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0NBQVk7QUFDakQsb0JBQW9CLCtDQUErQztBQUNuRSxxQkFBcUIsK0NBQStDO0FBQ3BFLHFCQUFxQiwrQ0FBK0M7QUFDcEUsc0JBQXNCLCtDQUErQztBQUNyRSxzQkFBc0IsK0NBQStDO0FBQ3JFLHdCQUF3QjtBQUN4QixLQUFLO0FBQ0wsc0NBQXNDLDBCQUFTLEdBQUc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUJBQXlCO0FBQy9CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSxtQkFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOEJBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4QkFBVztBQUNqQixNQUFNO0FBQ047QUFDQSxpQkFBaUIsOEJBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOEJBQVc7QUFDakIsTUFBTSw4QkFBVztBQUNqQjtBQUNBO0FBQ0EsTUFBTSw4QkFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE1BQU07QUFDZCxRQUFRLGVBQWU7QUFDdkIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBTztBQUNqQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEJBQTBCLHlCQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG9CQUFNO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEI7OztBQ3ZWMEQ7QUFDWjtBQUNJOztBQUVsRDtBQUNBLDZCQUFVLEtBQUssWUFBWTtBQUMzQiw2QkFBVSxLQUFLLFVBQVU7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvRmlsdGVyUGlwZS5tanM/YzcwYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0RmFzdEdsb2JhbEJvdW5kcy5tanM/NGNlZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0UmVuZGVyYWJsZUJvdW5kcy5tanM/NGRhYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qcz9hYTc1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9pbml0Lm1qcz9mZjlmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBGaWx0ZXJQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHB1c2goZmlsdGVyRWZmZWN0LCBjb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgcmVuZGVyUGlwZXMgPSB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcztcbiAgICByZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgIHJlbmRlclBpcGVJZDogXCJmaWx0ZXJcIixcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2UsXG4gICAgICBhY3Rpb246IFwicHVzaEZpbHRlclwiLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgZmlsdGVyRWZmZWN0XG4gICAgfSk7XG4gIH1cbiAgcG9wKF9maWx0ZXJFZmZlY3QsIF9jb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGluc3RydWN0aW9uU2V0LmFkZCh7XG4gICAgICByZW5kZXJQaXBlSWQ6IFwiZmlsdGVyXCIsXG4gICAgICBhY3Rpb246IFwicG9wRmlsdGVyXCIsXG4gICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZXhlY3V0ZShpbnN0cnVjdGlvbikge1xuICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwicHVzaEZpbHRlclwiKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5maWx0ZXIucHVzaChpbnN0cnVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwicG9wRmlsdGVyXCIpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmZpbHRlci5wb3AoKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbkZpbHRlclBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcImZpbHRlclwiXG59O1xuXG5leHBvcnQgeyBGaWx0ZXJQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXJQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IGJvdW5kc1Bvb2wgfSBmcm9tICcuL3V0aWxzL21hdHJpeEFuZEJvdW5kc1Bvb2wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuZnVuY3Rpb24gZ2V0RmFzdEdsb2JhbEJvdW5kcyh0YXJnZXQsIGJvdW5kcykge1xuICBib3VuZHMuY2xlYXIoKTtcbiAgX2dldEdsb2JhbEJvdW5kc1JlY3Vyc2l2ZSh0YXJnZXQsIGJvdW5kcyk7XG4gIGlmICghYm91bmRzLmlzVmFsaWQpIHtcbiAgICBib3VuZHMuc2V0KDAsIDAsIDAsIDApO1xuICB9XG4gIGlmICghdGFyZ2V0LnJlbmRlckdyb3VwKSB7XG4gICAgYm91bmRzLmFwcGx5TWF0cml4KHRhcmdldC5wYXJlbnRSZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRzLmFwcGx5TWF0cml4KHRhcmdldC5yZW5kZXJHcm91cC5sb2NhbFRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cbmZ1bmN0aW9uIF9nZXRHbG9iYWxCb3VuZHNSZWN1cnNpdmUodGFyZ2V0LCBib3VuZHMpIHtcbiAgaWYgKHRhcmdldC5sb2NhbERpc3BsYXlTdGF0dXMgIT09IDcgfHwgIXRhcmdldC5tZWFzdXJhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1hbmFnZUVmZmVjdHMgPSAhIXRhcmdldC5lZmZlY3RzLmxlbmd0aDtcbiAgbGV0IGxvY2FsQm91bmRzID0gYm91bmRzO1xuICBpZiAodGFyZ2V0LnJlbmRlckdyb3VwIHx8IG1hbmFnZUVmZmVjdHMpIHtcbiAgICBsb2NhbEJvdW5kcyA9IGJvdW5kc1Bvb2wuZ2V0KCkuY2xlYXIoKTtcbiAgfVxuICBpZiAodGFyZ2V0LmJvdW5kc0FyZWEpIHtcbiAgICBib3VuZHMuYWRkUmVjdCh0YXJnZXQuYm91bmRzQXJlYSwgdGFyZ2V0LndvcmxkVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGFyZ2V0LnJlbmRlclBpcGVJZCkge1xuICAgICAgY29uc3Qgdmlld0JvdW5kcyA9IHRhcmdldC5ib3VuZHM7XG4gICAgICBsb2NhbEJvdW5kcy5hZGRGcmFtZShcbiAgICAgICAgdmlld0JvdW5kcy5taW5YLFxuICAgICAgICB2aWV3Qm91bmRzLm1pblksXG4gICAgICAgIHZpZXdCb3VuZHMubWF4WCxcbiAgICAgICAgdmlld0JvdW5kcy5tYXhZLFxuICAgICAgICB0YXJnZXQuZ3JvdXBUcmFuc2Zvcm1cbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIF9nZXRHbG9iYWxCb3VuZHNSZWN1cnNpdmUoY2hpbGRyZW5baV0sIGxvY2FsQm91bmRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1hbmFnZUVmZmVjdHMpIHtcbiAgICBsZXQgYWR2YW5jZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5lZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGFyZ2V0LmVmZmVjdHNbaV0uYWRkQm91bmRzKSB7XG4gICAgICAgIGlmICghYWR2YW5jZWQpIHtcbiAgICAgICAgICBhZHZhbmNlZCA9IHRydWU7XG4gICAgICAgICAgbG9jYWxCb3VuZHMuYXBwbHlNYXRyaXgodGFyZ2V0LnBhcmVudFJlbmRlckdyb3VwLndvcmxkVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuZWZmZWN0c1tpXS5hZGRCb3VuZHMobG9jYWxCb3VuZHMsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWR2YW5jZWQpIHtcbiAgICAgIGxvY2FsQm91bmRzLmFwcGx5TWF0cml4KHRhcmdldC5wYXJlbnRSZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybS5jb3B5VG8odGVtcE1hdHJpeCkuaW52ZXJ0KCkpO1xuICAgICAgYm91bmRzLmFkZEJvdW5kcyhsb2NhbEJvdW5kcywgdGFyZ2V0LnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBib3VuZHMuYWRkQm91bmRzKGxvY2FsQm91bmRzKTtcbiAgICBib3VuZHNQb29sLnJldHVybihsb2NhbEJvdW5kcyk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0LnJlbmRlckdyb3VwKSB7XG4gICAgYm91bmRzLmFkZEJvdW5kcyhsb2NhbEJvdW5kcywgdGFyZ2V0LnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0pO1xuICAgIGJvdW5kc1Bvb2wucmV0dXJuKGxvY2FsQm91bmRzKTtcbiAgfVxufVxuXG5leHBvcnQgeyBfZ2V0R2xvYmFsQm91bmRzUmVjdXJzaXZlLCBnZXRGYXN0R2xvYmFsQm91bmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGYXN0R2xvYmFsQm91bmRzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0R2xvYmFsUmVuZGVyYWJsZUJvdW5kcyhyZW5kZXJhYmxlcywgYm91bmRzKSB7XG4gIGJvdW5kcy5jbGVhcigpO1xuICBjb25zdCB0ZW1wTWF0cml4ID0gYm91bmRzLm1hdHJpeDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlbmRlcmFibGUgPSByZW5kZXJhYmxlc1tpXTtcbiAgICBpZiAocmVuZGVyYWJsZS5nbG9iYWxEaXNwbGF5U3RhdHVzIDwgNykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJvdW5kcy5tYXRyaXggPSByZW5kZXJhYmxlLndvcmxkVHJhbnNmb3JtO1xuICAgIHJlbmRlcmFibGUuYWRkQm91bmRzKGJvdW5kcyk7XG4gIH1cbiAgYm91bmRzLm1hdHJpeCA9IHRlbXBNYXRyaXg7XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmV4cG9ydCB7IGdldEdsb2JhbFJlbmRlcmFibGVCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFJlbmRlcmFibGVCb3VuZHMubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9tYXRocy9wb2ludC9Qb2ludC5tanMnO1xuaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVQb29sLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0RmFzdEdsb2JhbEJvdW5kcyB9IGZyb20gJy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0RmFzdEdsb2JhbEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsUmVuZGVyYWJsZUJvdW5kcyB9IGZyb20gJy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0UmVuZGVyYWJsZUJvdW5kcy5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHF1YWRHZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSh7XG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBhUG9zaXRpb246IHtcbiAgICAgIGJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pLFxuICAgICAgbG9jYXRpb246IDAsXG4gICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICBzdHJpZGU6IDIgKiA0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfVxuICB9LFxuICBpbmRleEJ1ZmZlcjogbmV3IFVpbnQzMkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSlcbn0pO1xuY2xhc3MgRmlsdGVyU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9maWx0ZXJTdGFja0luZGV4ID0gMDtcbiAgICB0aGlzLl9maWx0ZXJTdGFjayA9IFtdO1xuICAgIHRoaXMuX2ZpbHRlckdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1SW5wdXRTaXplOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1SW5wdXRQaXhlbDogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdUlucHV0Q2xhbXA6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoNCksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVPdXRwdXRGcmFtZTogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdUdsb2JhbEZyYW1lOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1T3V0cHV0VGV4dHVyZTogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9XG4gICAgfSk7XG4gICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwID0gbmV3IEJpbmRHcm91cCh7fSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFjayB0ZXh0dXJlIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGZpbHRlci4gUmVxdWlyZXMgdGhlIGZpbHRlciB0byBoYXZlIGBibGVuZFJlcXVpcmVkYCBzZXQgdG8gdHJ1ZS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYWN0aXZlQmFja1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUZpbHRlckRhdGE/LmJhY2tUZXh0dXJlO1xuICB9XG4gIHB1c2goaW5zdHJ1Y3Rpb24pIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgZmlsdGVycyA9IGluc3RydWN0aW9uLmZpbHRlckVmZmVjdC5maWx0ZXJzO1xuICAgIGlmICghdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF0pIHtcbiAgICAgIHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrSW5kZXhdID0gdGhpcy5fZ2V0RmlsdGVyRGF0YSgpO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJEYXRhID0gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF07XG4gICAgdGhpcy5fZmlsdGVyU3RhY2tJbmRleCsrO1xuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZmlsdGVyRGF0YS5za2lwID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYm91bmRzID0gZmlsdGVyRGF0YS5ib3VuZHM7XG4gICAgaWYgKGluc3RydWN0aW9uLnJlbmRlcmFibGVzKSB7XG4gICAgICBnZXRHbG9iYWxSZW5kZXJhYmxlQm91bmRzKGluc3RydWN0aW9uLnJlbmRlcmFibGVzLCBib3VuZHMpO1xuICAgIH0gZWxzZSBpZiAoaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0LmZpbHRlckFyZWEpIHtcbiAgICAgIGJvdW5kcy5jbGVhcigpO1xuICAgICAgYm91bmRzLmFkZFJlY3QoaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0LmZpbHRlckFyZWEpO1xuICAgICAgYm91bmRzLmFwcGx5TWF0cml4KGluc3RydWN0aW9uLmNvbnRhaW5lci53b3JsZFRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldEZhc3RHbG9iYWxCb3VuZHMoaW5zdHJ1Y3Rpb24uY29udGFpbmVyLCBib3VuZHMpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvclRleHR1cmVTb3VyY2UgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQucm9vdFJlbmRlclRhcmdldC5jb2xvclRleHR1cmUuc291cmNlO1xuICAgIGxldCByZXNvbHV0aW9uID0gY29sb3JUZXh0dXJlU291cmNlLl9yZXNvbHV0aW9uO1xuICAgIGxldCBwYWRkaW5nID0gMDtcbiAgICBsZXQgYW50aWFsaWFzID0gY29sb3JUZXh0dXJlU291cmNlLmFudGlhbGlhcztcbiAgICBsZXQgYmxlbmRSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGxldCBlbmFibGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgcmVzb2x1dGlvbiA9IE1hdGgubWluKHJlc29sdXRpb24sIGZpbHRlci5yZXNvbHV0aW9uKTtcbiAgICAgIHBhZGRpbmcgKz0gZmlsdGVyLnBhZGRpbmc7XG4gICAgICBpZiAoZmlsdGVyLmFudGlhbGlhcyAhPT0gXCJpbmhlcml0XCIpIHtcbiAgICAgICAgaWYgKGZpbHRlci5hbnRpYWxpYXMgPT09IFwib25cIikge1xuICAgICAgICAgIGFudGlhbGlhcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW50aWFsaWFzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQ29tcGF0aWJsZSA9ICEhKGZpbHRlci5jb21wYXRpYmxlUmVuZGVyZXJzICYgcmVuZGVyZXIudHlwZSk7XG4gICAgICBpZiAoIWlzQ29tcGF0aWJsZSkge1xuICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGZpbHRlci5ibGVuZFJlcXVpcmVkICYmICEocmVuZGVyZXIuYmFja0J1ZmZlcj8udXNlQmFja0J1ZmZlciA/PyB0cnVlKSkge1xuICAgICAgICB3YXJuKFwiQmxlbmQgZmlsdGVyIHJlcXVpcmVzIGJhY2tCdWZmZXIgb24gV2ViR0wgcmVuZGVyZXIgdG8gYmUgZW5hYmxlZC4gU2V0IGB1c2VCYWNrQnVmZmVyOiB0cnVlYCBpbiB0aGUgcmVuZGVyZXIgb3B0aW9ucy5cIik7XG4gICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlbmFibGVkID0gZmlsdGVyLmVuYWJsZWQgfHwgZW5hYmxlZDtcbiAgICAgIGJsZW5kUmVxdWlyZWQgPSBibGVuZFJlcXVpcmVkIHx8IGZpbHRlci5ibGVuZFJlcXVpcmVkO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIGZpbHRlckRhdGEuc2tpcCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXdQb3J0ID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJvb3RWaWV3UG9ydDtcbiAgICBib3VuZHMuc2NhbGUocmVzb2x1dGlvbikuZml0Qm91bmRzKDAsIHZpZXdQb3J0LndpZHRoLCAwLCB2aWV3UG9ydC5oZWlnaHQpLnNjYWxlKDEgLyByZXNvbHV0aW9uKS5wYWQocGFkZGluZykuY2VpbCgpO1xuICAgIGlmICghYm91bmRzLmlzUG9zaXRpdmUpIHtcbiAgICAgIGZpbHRlckRhdGEuc2tpcCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpbHRlckRhdGEuc2tpcCA9IGZhbHNlO1xuICAgIGZpbHRlckRhdGEuYm91bmRzID0gYm91bmRzO1xuICAgIGZpbHRlckRhdGEuYmxlbmRSZXF1aXJlZCA9IGJsZW5kUmVxdWlyZWQ7XG4gICAgZmlsdGVyRGF0YS5jb250YWluZXIgPSBpbnN0cnVjdGlvbi5jb250YWluZXI7XG4gICAgZmlsdGVyRGF0YS5maWx0ZXJFZmZlY3QgPSBpbnN0cnVjdGlvbi5maWx0ZXJFZmZlY3Q7XG4gICAgZmlsdGVyRGF0YS5wcmV2aW91c1JlbmRlclN1cmZhY2UgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQucmVuZGVyU3VyZmFjZTtcbiAgICBmaWx0ZXJEYXRhLmlucHV0VGV4dHVyZSA9IFRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKFxuICAgICAgYm91bmRzLndpZHRoLFxuICAgICAgYm91bmRzLmhlaWdodCxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICBhbnRpYWxpYXNcbiAgICApO1xuICAgIHJlbmRlcmVyLnJlbmRlclRhcmdldC5iaW5kKGZpbHRlckRhdGEuaW5wdXRUZXh0dXJlLCB0cnVlKTtcbiAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy5wdXNoKHtcbiAgICAgIG9mZnNldDogYm91bmRzXG4gICAgfSk7XG4gIH1cbiAgcG9wKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICB0aGlzLl9maWx0ZXJTdGFja0luZGV4LS07XG4gICAgY29uc3QgZmlsdGVyRGF0YSA9IHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrSW5kZXhdO1xuICAgIGlmIChmaWx0ZXJEYXRhLnNraXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlRmlsdGVyRGF0YSA9IGZpbHRlckRhdGE7XG4gICAgY29uc3QgaW5wdXRUZXh0dXJlID0gZmlsdGVyRGF0YS5pbnB1dFRleHR1cmU7XG4gICAgY29uc3QgYm91bmRzID0gZmlsdGVyRGF0YS5ib3VuZHM7XG4gICAgbGV0IGJhY2tUZXh0dXJlID0gVGV4dHVyZS5FTVBUWTtcbiAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQuZmluaXNoUmVuZGVyUGFzcygpO1xuICAgIGlmIChmaWx0ZXJEYXRhLmJsZW5kUmVxdWlyZWQpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQm91bmRzID0gdGhpcy5fZmlsdGVyU3RhY2tJbmRleCA+IDAgPyB0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFja0luZGV4IC0gMV0uYm91bmRzIDogbnVsbDtcbiAgICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLnJlbmRlclRhcmdldC5nZXRSZW5kZXJUYXJnZXQoZmlsdGVyRGF0YS5wcmV2aW91c1JlbmRlclN1cmZhY2UpO1xuICAgICAgYmFja1RleHR1cmUgPSB0aGlzLmdldEJhY2tUZXh0dXJlKHJlbmRlclRhcmdldCwgYm91bmRzLCBwcmV2aW91c0JvdW5kcyk7XG4gICAgfVxuICAgIGZpbHRlckRhdGEuYmFja1RleHR1cmUgPSBiYWNrVGV4dHVyZTtcbiAgICBjb25zdCBmaWx0ZXJzID0gZmlsdGVyRGF0YS5maWx0ZXJFZmZlY3QuZmlsdGVycztcbiAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoaW5wdXRUZXh0dXJlLnNvdXJjZS5zdHlsZSwgMik7XG4gICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwLnNldFJlc291cmNlKGJhY2tUZXh0dXJlLnNvdXJjZSwgMyk7XG4gICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMucG9wKCk7XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBmaWx0ZXJzWzBdLmFwcGx5KHRoaXMsIGlucHV0VGV4dHVyZSwgZmlsdGVyRGF0YS5wcmV2aW91c1JlbmRlclN1cmZhY2UsIGZhbHNlKTtcbiAgICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoaW5wdXRUZXh0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGZsaXAgPSBmaWx0ZXJEYXRhLmlucHV0VGV4dHVyZTtcbiAgICAgIGxldCBmbG9wID0gVGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUoXG4gICAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgICAgYm91bmRzLmhlaWdodCxcbiAgICAgICAgZmxpcC5zb3VyY2UuX3Jlc29sdXRpb24sXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGZpbHRlcnNbaV07XG4gICAgICAgIGZpbHRlci5hcHBseSh0aGlzLCBmbGlwLCBmbG9wLCB0cnVlKTtcbiAgICAgICAgY29uc3QgdCA9IGZsaXA7XG4gICAgICAgIGZsaXAgPSBmbG9wO1xuICAgICAgICBmbG9wID0gdDtcbiAgICAgIH1cbiAgICAgIGZpbHRlcnNbaV0uYXBwbHkodGhpcywgZmxpcCwgZmlsdGVyRGF0YS5wcmV2aW91c1JlbmRlclN1cmZhY2UsIGZhbHNlKTtcbiAgICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoZmxpcCk7XG4gICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKGZsb3ApO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyRGF0YS5ibGVuZFJlcXVpcmVkKSB7XG4gICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKGJhY2tUZXh0dXJlKTtcbiAgICB9XG4gIH1cbiAgZ2V0QmFja1RleHR1cmUobGFzdFJlbmRlclN1cmZhY2UsIGJvdW5kcywgcHJldmlvdXNCb3VuZHMpIHtcbiAgICBjb25zdCBiYWNrZ3JvdW5kUmVzb2x1dGlvbiA9IGxhc3RSZW5kZXJTdXJmYWNlLmNvbG9yVGV4dHVyZS5zb3VyY2UuX3Jlc29sdXRpb247XG4gICAgY29uc3QgYmFja1RleHR1cmUgPSBUZXh0dXJlUG9vbC5nZXRPcHRpbWFsVGV4dHVyZShcbiAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgICBiYWNrZ3JvdW5kUmVzb2x1dGlvbixcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBsZXQgeCA9IGJvdW5kcy5taW5YO1xuICAgIGxldCB5ID0gYm91bmRzLm1pblk7XG4gICAgaWYgKHByZXZpb3VzQm91bmRzKSB7XG4gICAgICB4IC09IHByZXZpb3VzQm91bmRzLm1pblg7XG4gICAgICB5IC09IHByZXZpb3VzQm91bmRzLm1pblk7XG4gICAgfVxuICAgIHggPSBNYXRoLmZsb29yKHggKiBiYWNrZ3JvdW5kUmVzb2x1dGlvbik7XG4gICAgeSA9IE1hdGguZmxvb3IoeSAqIGJhY2tncm91bmRSZXNvbHV0aW9uKTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChib3VuZHMud2lkdGggKiBiYWNrZ3JvdW5kUmVzb2x1dGlvbik7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKGJvdW5kcy5oZWlnaHQgKiBiYWNrZ3JvdW5kUmVzb2x1dGlvbik7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXJUYXJnZXQuY29weVRvVGV4dHVyZShcbiAgICAgIGxhc3RSZW5kZXJTdXJmYWNlLFxuICAgICAgYmFja1RleHR1cmUsXG4gICAgICB7IHgsIHkgfSxcbiAgICAgIHsgd2lkdGgsIGhlaWdodCB9LFxuICAgICAgeyB4OiAwLCB5OiAwIH1cbiAgICApO1xuICAgIHJldHVybiBiYWNrVGV4dHVyZTtcbiAgfVxuICBhcHBseUZpbHRlcihmaWx0ZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGZpbHRlckRhdGEgPSB0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFja0luZGV4XTtcbiAgICBjb25zdCBib3VuZHMgPSBmaWx0ZXJEYXRhLmJvdW5kcztcbiAgICBjb25zdCBvZmZzZXQgPSBQb2ludC5zaGFyZWQ7XG4gICAgY29uc3QgcHJldmlvdXNSZW5kZXJTdXJmYWNlID0gZmlsdGVyRGF0YS5wcmV2aW91c1JlbmRlclN1cmZhY2U7XG4gICAgY29uc3QgaXNGaW5hbFRhcmdldCA9IHByZXZpb3VzUmVuZGVyU3VyZmFjZSA9PT0gb3V0cHV0O1xuICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUYXJnZXQucm9vdFJlbmRlclRhcmdldC5jb2xvclRleHR1cmUuc291cmNlLl9yZXNvbHV0aW9uO1xuICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLl9maWx0ZXJTdGFja0luZGV4IC0gMTtcbiAgICB3aGlsZSAoY3VycmVudEluZGV4ID4gMCAmJiB0aGlzLl9maWx0ZXJTdGFja1tjdXJyZW50SW5kZXhdLnNraXApIHtcbiAgICAgIC0tY3VycmVudEluZGV4O1xuICAgIH1cbiAgICBpZiAoY3VycmVudEluZGV4ID4gMCkge1xuICAgICAgcmVzb2x1dGlvbiA9IHRoaXMuX2ZpbHRlclN0YWNrW2N1cnJlbnRJbmRleF0uaW5wdXRUZXh0dXJlLnNvdXJjZS5fcmVzb2x1dGlvbjtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyVW5pZm9ybXMgPSB0aGlzLl9maWx0ZXJHbG9iYWxVbmlmb3JtcztcbiAgICBjb25zdCB1bmlmb3JtcyA9IGZpbHRlclVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIGNvbnN0IG91dHB1dEZyYW1lID0gdW5pZm9ybXMudU91dHB1dEZyYW1lO1xuICAgIGNvbnN0IGlucHV0U2l6ZSA9IHVuaWZvcm1zLnVJbnB1dFNpemU7XG4gICAgY29uc3QgaW5wdXRQaXhlbCA9IHVuaWZvcm1zLnVJbnB1dFBpeGVsO1xuICAgIGNvbnN0IGlucHV0Q2xhbXAgPSB1bmlmb3Jtcy51SW5wdXRDbGFtcDtcbiAgICBjb25zdCBnbG9iYWxGcmFtZSA9IHVuaWZvcm1zLnVHbG9iYWxGcmFtZTtcbiAgICBjb25zdCBvdXRwdXRUZXh0dXJlID0gdW5pZm9ybXMudU91dHB1dFRleHR1cmU7XG4gICAgaWYgKGlzRmluYWxUYXJnZXQpIHtcbiAgICAgIGxldCBsYXN0SW5kZXggPSB0aGlzLl9maWx0ZXJTdGFja0luZGV4O1xuICAgICAgd2hpbGUgKGxhc3RJbmRleCA+IDApIHtcbiAgICAgICAgbGFzdEluZGV4LS07XG4gICAgICAgIGNvbnN0IGZpbHRlckRhdGEyID0gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleCAtIDFdO1xuICAgICAgICBpZiAoIWZpbHRlckRhdGEyLnNraXApIHtcbiAgICAgICAgICBvZmZzZXQueCA9IGZpbHRlckRhdGEyLmJvdW5kcy5taW5YO1xuICAgICAgICAgIG9mZnNldC55ID0gZmlsdGVyRGF0YTIuYm91bmRzLm1pblk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dHB1dEZyYW1lWzBdID0gYm91bmRzLm1pblggLSBvZmZzZXQueDtcbiAgICAgIG91dHB1dEZyYW1lWzFdID0gYm91bmRzLm1pblkgLSBvZmZzZXQueTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0RnJhbWVbMF0gPSAwO1xuICAgICAgb3V0cHV0RnJhbWVbMV0gPSAwO1xuICAgIH1cbiAgICBvdXRwdXRGcmFtZVsyXSA9IGlucHV0LmZyYW1lLndpZHRoO1xuICAgIG91dHB1dEZyYW1lWzNdID0gaW5wdXQuZnJhbWUuaGVpZ2h0O1xuICAgIGlucHV0U2l6ZVswXSA9IGlucHV0LnNvdXJjZS53aWR0aDtcbiAgICBpbnB1dFNpemVbMV0gPSBpbnB1dC5zb3VyY2UuaGVpZ2h0O1xuICAgIGlucHV0U2l6ZVsyXSA9IDEgLyBpbnB1dFNpemVbMF07XG4gICAgaW5wdXRTaXplWzNdID0gMSAvIGlucHV0U2l6ZVsxXTtcbiAgICBpbnB1dFBpeGVsWzBdID0gaW5wdXQuc291cmNlLnBpeGVsV2lkdGg7XG4gICAgaW5wdXRQaXhlbFsxXSA9IGlucHV0LnNvdXJjZS5waXhlbEhlaWdodDtcbiAgICBpbnB1dFBpeGVsWzJdID0gMSAvIGlucHV0UGl4ZWxbMF07XG4gICAgaW5wdXRQaXhlbFszXSA9IDEgLyBpbnB1dFBpeGVsWzFdO1xuICAgIGlucHV0Q2xhbXBbMF0gPSAwLjUgKiBpbnB1dFBpeGVsWzJdO1xuICAgIGlucHV0Q2xhbXBbMV0gPSAwLjUgKiBpbnB1dFBpeGVsWzNdO1xuICAgIGlucHV0Q2xhbXBbMl0gPSBpbnB1dC5mcmFtZS53aWR0aCAqIGlucHV0U2l6ZVsyXSAtIDAuNSAqIGlucHV0UGl4ZWxbMl07XG4gICAgaW5wdXRDbGFtcFszXSA9IGlucHV0LmZyYW1lLmhlaWdodCAqIGlucHV0U2l6ZVszXSAtIDAuNSAqIGlucHV0UGl4ZWxbM107XG4gICAgY29uc3Qgcm9vdFRleHR1cmUgPSB0aGlzLnJlbmRlcmVyLnJlbmRlclRhcmdldC5yb290UmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZTtcbiAgICBnbG9iYWxGcmFtZVswXSA9IG9mZnNldC54ICogcmVzb2x1dGlvbjtcbiAgICBnbG9iYWxGcmFtZVsxXSA9IG9mZnNldC55ICogcmVzb2x1dGlvbjtcbiAgICBnbG9iYWxGcmFtZVsyXSA9IHJvb3RUZXh0dXJlLnNvdXJjZS53aWR0aCAqIHJlc29sdXRpb247XG4gICAgZ2xvYmFsRnJhbWVbM10gPSByb290VGV4dHVyZS5zb3VyY2UuaGVpZ2h0ICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLnJlbmRlclRhcmdldC5nZXRSZW5kZXJUYXJnZXQob3V0cHV0KTtcbiAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQuYmluZChvdXRwdXQsICEhY2xlYXIpO1xuICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICBvdXRwdXRUZXh0dXJlWzBdID0gb3V0cHV0LmZyYW1lLndpZHRoO1xuICAgICAgb3V0cHV0VGV4dHVyZVsxXSA9IG91dHB1dC5mcmFtZS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dFRleHR1cmVbMF0gPSByZW5kZXJUYXJnZXQud2lkdGg7XG4gICAgICBvdXRwdXRUZXh0dXJlWzFdID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcbiAgICB9XG4gICAgb3V0cHV0VGV4dHVyZVsyXSA9IHJlbmRlclRhcmdldC5pc1Jvb3QgPyAtMSA6IDE7XG4gICAgZmlsdGVyVW5pZm9ybXMudXBkYXRlKCk7XG4gICAgaWYgKHJlbmRlcmVyLnJlbmRlclBpcGVzLnVuaWZvcm1CYXRjaCkge1xuICAgICAgY29uc3QgYmF0Y2hVbmlmb3JtcyA9IHJlbmRlcmVyLnJlbmRlclBpcGVzLnVuaWZvcm1CYXRjaC5nZXRVYm9SZXNvdXJjZShmaWx0ZXJVbmlmb3Jtcyk7XG4gICAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoYmF0Y2hVbmlmb3JtcywgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2dsb2JhbEZpbHRlckJpbmRHcm91cC5zZXRSZXNvdXJjZShmaWx0ZXJVbmlmb3JtcywgMCk7XG4gICAgfVxuICAgIHRoaXMuX2dsb2JhbEZpbHRlckJpbmRHcm91cC5zZXRSZXNvdXJjZShpbnB1dC5zb3VyY2UsIDEpO1xuICAgIHRoaXMuX2dsb2JhbEZpbHRlckJpbmRHcm91cC5zZXRSZXNvdXJjZShpbnB1dC5zb3VyY2Uuc3R5bGUsIDIpO1xuICAgIGZpbHRlci5ncm91cHNbMF0gPSB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXA7XG4gICAgcmVuZGVyZXIuZW5jb2Rlci5kcmF3KHtcbiAgICAgIGdlb21ldHJ5OiBxdWFkR2VvbWV0cnksXG4gICAgICBzaGFkZXI6IGZpbHRlcixcbiAgICAgIHN0YXRlOiBmaWx0ZXIuX3N0YXRlLFxuICAgICAgdG9wb2xvZ3k6IFwidHJpYW5nbGUtbGlzdFwiXG4gICAgfSk7XG4gICAgaWYgKHJlbmRlcmVyLnR5cGUgPT09IFJlbmRlcmVyVHlwZS5XRUJHTCkge1xuICAgICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmZpbmlzaFJlbmRlclBhc3MoKTtcbiAgICB9XG4gIH1cbiAgX2dldEZpbHRlckRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNraXA6IGZhbHNlLFxuICAgICAgaW5wdXRUZXh0dXJlOiBudWxsLFxuICAgICAgYm91bmRzOiBuZXcgQm91bmRzKCksXG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICBmaWx0ZXJFZmZlY3Q6IG51bGwsXG4gICAgICBibGVuZFJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIHByZXZpb3VzUmVuZGVyU3VyZmFjZTogbnVsbFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE11bHRpcGx5IF9pbnB1dCBub3JtYWxpemVkIGNvb3JkaW5hdGVzXyB0byB0aGlzIG1hdHJpeCB0byBnZXQgX3Nwcml0ZSB0ZXh0dXJlIG5vcm1hbGl6ZWQgY29vcmRpbmF0ZXNfLlxuICAgKlxuICAgKiBVc2UgYG91dHB1dE1hdHJpeCAqIHZUZXh0dXJlQ29vcmRgIGluIHRoZSBzaGFkZXIuXG4gICAqIEBwYXJhbSBvdXRwdXRNYXRyaXggLSBUaGUgbWF0cml4IHRvIG91dHB1dCB0by5cbiAgICogQHBhcmFtIHtTcHJpdGV9IHNwcml0ZSAtIFRoZSBzcHJpdGUgdG8gbWFwIHRvLlxuICAgKiBAcmV0dXJucyBUaGUgbWFwcGVkIG1hdHJpeC5cbiAgICovXG4gIGNhbGN1bGF0ZVNwcml0ZU1hdHJpeChvdXRwdXRNYXRyaXgsIHNwcml0ZSkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9hY3RpdmVGaWx0ZXJEYXRhO1xuICAgIGNvbnN0IG1hcHBlZE1hdHJpeCA9IG91dHB1dE1hdHJpeC5zZXQoXG4gICAgICBkYXRhLmlucHV0VGV4dHVyZS5fc291cmNlLndpZHRoLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBkYXRhLmlucHV0VGV4dHVyZS5fc291cmNlLmhlaWdodCxcbiAgICAgIGRhdGEuYm91bmRzLm1pblgsXG4gICAgICBkYXRhLmJvdW5kcy5taW5ZXG4gICAgKTtcbiAgICBjb25zdCB3b3JsZFRyYW5zZm9ybSA9IHNwcml0ZS53b3JsZFRyYW5zZm9ybS5jb3B5VG8oTWF0cml4LnNoYXJlZCk7XG4gICAgd29ybGRUcmFuc2Zvcm0uaW52ZXJ0KCk7XG4gICAgbWFwcGVkTWF0cml4LnByZXBlbmQod29ybGRUcmFuc2Zvcm0pO1xuICAgIG1hcHBlZE1hdHJpeC5zY2FsZShcbiAgICAgIDEgLyBzcHJpdGUudGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgIDEgLyBzcHJpdGUudGV4dHVyZS5mcmFtZS5oZWlnaHRcbiAgICApO1xuICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoc3ByaXRlLmFuY2hvci54LCBzcHJpdGUuYW5jaG9yLnkpO1xuICAgIHJldHVybiBtYXBwZWRNYXRyaXg7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5GaWx0ZXJTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcImZpbHRlclwiXG59O1xuXG5leHBvcnQgeyBGaWx0ZXJTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlclN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBGaWx0ZXJQaXBlIH0gZnJvbSAnLi9GaWx0ZXJQaXBlLm1qcyc7XG5pbXBvcnQgeyBGaWx0ZXJTeXN0ZW0gfSBmcm9tICcuL0ZpbHRlclN5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKEZpbHRlclN5c3RlbSk7XG5leHRlbnNpb25zLmFkZChGaWx0ZXJQaXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9249\n')},2971:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ BatchGeometry)\n/* harmony export */ });\n/* harmony import */ var _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7494);\n/* harmony import */ var _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5324);\n/* harmony import */ var _renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1980);\n\n\n\n\n"use strict";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends _renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .Z {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .l({\n      data: placeHolderBufferData,\n      label: "attribute-batch-buffer",\n      usage: _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.VERTEX | _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .l({\n      data: placeHolderIndexData,\n      label: "index-batch-buffer",\n      usage: _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.INDEX | _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: "float32x2",\n          stride,\n          offset: 0,\n          location: 1\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: "float32x2",\n          stride,\n          offset: 2 * 4,\n          location: 3\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: "unorm8x4",\n          stride,\n          offset: 4 * 4,\n          location: 0\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: "uint16x2",\n          stride,\n          offset: 5 * 4,\n          location: 2\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\n\n//# sourceMappingURL=BatchGeometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk3MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0U7QUFDSTtBQUNFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0ZBQVE7QUFDcEM7QUFDQTtBQUNBLGdDQUFnQyxnRkFBTTtBQUN0QztBQUNBO0FBQ0EsYUFBYSxvRkFBVyxVQUFVLG9GQUFXO0FBQzdDO0FBQ0EsS0FBSztBQUNMLDRCQUE0QixnRkFBTTtBQUNsQztBQUNBO0FBQ0EsYUFBYSxvRkFBVyxTQUFTLG9GQUFXO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9iYXRjaGVyL2dwdS9CYXRjaEdlb21ldHJ5Lm1qcz9lNzE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgQnVmZmVyVXNhZ2UgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci9jb25zdC5tanMnO1xuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgcGxhY2VIb2xkZXJCdWZmZXJEYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbmNvbnN0IHBsYWNlSG9sZGVySW5kZXhEYXRhID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuY2xhc3MgQmF0Y2hHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgdmVydGV4U2l6ZSA9IDY7XG4gICAgY29uc3QgYXR0cmlidXRlQnVmZmVyID0gbmV3IEJ1ZmZlcih7XG4gICAgICBkYXRhOiBwbGFjZUhvbGRlckJ1ZmZlckRhdGEsXG4gICAgICBsYWJlbDogXCJhdHRyaWJ1dGUtYmF0Y2gtYnVmZmVyXCIsXG4gICAgICB1c2FnZTogQnVmZmVyVXNhZ2UuVkVSVEVYIHwgQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICBzaHJpbmtUb0ZpdDogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogcGxhY2VIb2xkZXJJbmRleERhdGEsXG4gICAgICBsYWJlbDogXCJpbmRleC1iYXRjaC1idWZmZXJcIixcbiAgICAgIHVzYWdlOiBCdWZmZXJVc2FnZS5JTkRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNULFxuICAgICAgLy8gfCBCdWZmZXJVc2FnZS5TVEFUSUMsXG4gICAgICBzaHJpbmtUb0ZpdDogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBzdHJpZGUgPSB2ZXJ0ZXhTaXplICogNDtcbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGFQb3NpdGlvbjoge1xuICAgICAgICAgIGJ1ZmZlcjogYXR0cmlidXRlQnVmZmVyLFxuICAgICAgICAgIGZvcm1hdDogXCJmbG9hdDMyeDJcIixcbiAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgIGxvY2F0aW9uOiAxXG4gICAgICAgIH0sXG4gICAgICAgIGFVVjoge1xuICAgICAgICAgIGJ1ZmZlcjogYXR0cmlidXRlQnVmZmVyLFxuICAgICAgICAgIGZvcm1hdDogXCJmbG9hdDMyeDJcIixcbiAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgb2Zmc2V0OiAyICogNCxcbiAgICAgICAgICBsb2NhdGlvbjogM1xuICAgICAgICB9LFxuICAgICAgICBhQ29sb3I6IHtcbiAgICAgICAgICBidWZmZXI6IGF0dHJpYnV0ZUJ1ZmZlcixcbiAgICAgICAgICBmb3JtYXQ6IFwidW5vcm04eDRcIixcbiAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgb2Zmc2V0OiA0ICogNCxcbiAgICAgICAgICBsb2NhdGlvbjogMFxuICAgICAgICB9LFxuICAgICAgICBhVGV4dHVyZUlkQW5kUm91bmQ6IHtcbiAgICAgICAgICBidWZmZXI6IGF0dHJpYnV0ZUJ1ZmZlcixcbiAgICAgICAgICBmb3JtYXQ6IFwidWludDE2eDJcIixcbiAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgb2Zmc2V0OiA1ICogNCxcbiAgICAgICAgICBsb2NhdGlvbjogMlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5kZXhCdWZmZXJcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXRjaEdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaEdlb21ldHJ5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2971\n')},3018:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ getTextureBatchBindGroup)\n/* harmony export */ });\n/* harmony import */ var _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9818);\n/* harmony import */ var _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9853);\n/* harmony import */ var _renderers_shared_texture_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9131);\n\n\n\n\n"use strict";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size) {\n  let uid = 0;\n  for (let i = 0; i < size; i++) {\n    uid = uid * 31 + textures[i].uid >>> 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, uid);\n}\nlet maxTextures = 0;\nfunction generateTextureBatchBindGroup(textures, key) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  if (!maxTextures)\n    maxTextures = (0,_renderers_shared_texture_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__/* .maxRecommendedTextures */ .I)();\n  for (let i = 0; i < maxTextures; i++) {\n    const texture = i < textures.length ? textures[i] : _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BindGroup */ .v(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\n\n//# sourceMappingURL=getTextureBatchBindGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAxOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUU7QUFDQTtBQUNvQzs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkhBQXNCO0FBQ3hDLGtCQUFrQixpQkFBaUI7QUFDbkMsd0RBQXdELG1GQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRkFBUztBQUNqQztBQUNBO0FBQ0E7O0FBRW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvZ2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwLm1qcz81MDRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJpbmRHcm91cCB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBtYXhSZWNvbW1lbmRlZFRleHR1cmVzIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3V0aWxzL21heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBjYWNoZWRHcm91cHMgPSB7fTtcbmZ1bmN0aW9uIGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCh0ZXh0dXJlcywgc2l6ZSkge1xuICBsZXQgdWlkID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICB1aWQgPSB1aWQgKiAzMSArIHRleHR1cmVzW2ldLnVpZCA+Pj4gMDtcbiAgfVxuICByZXR1cm4gY2FjaGVkR3JvdXBzW3VpZF0gfHwgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIHVpZCk7XG59XG5sZXQgbWF4VGV4dHVyZXMgPSAwO1xuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIGtleSkge1xuICBjb25zdCBiaW5kR3JvdXBSZXNvdXJjZXMgPSB7fTtcbiAgbGV0IGJpbmRJbmRleCA9IDA7XG4gIGlmICghbWF4VGV4dHVyZXMpXG4gICAgbWF4VGV4dHVyZXMgPSBtYXhSZWNvbW1lbmRlZFRleHR1cmVzKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgIGNvbnN0IHRleHR1cmUgPSBpIDwgdGV4dHVyZXMubGVuZ3RoID8gdGV4dHVyZXNbaV0gOiBUZXh0dXJlLkVNUFRZLnNvdXJjZTtcbiAgICBiaW5kR3JvdXBSZXNvdXJjZXNbYmluZEluZGV4KytdID0gdGV4dHVyZS5zb3VyY2U7XG4gICAgYmluZEdyb3VwUmVzb3VyY2VzW2JpbmRJbmRleCsrXSA9IHRleHR1cmUuc3R5bGU7XG4gIH1cbiAgY29uc3QgYmluZEdyb3VwID0gbmV3IEJpbmRHcm91cChiaW5kR3JvdXBSZXNvdXJjZXMpO1xuICBjYWNoZWRHcm91cHNba2V5XSA9IGJpbmRHcm91cDtcbiAgcmV0dXJuIGJpbmRHcm91cDtcbn1cblxuZXhwb3J0IHsgZ2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3018\n')},2067:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  m: () => (/* binding */ Batcher)\n});\n\n// UNUSED EXPORTS: Batch\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs\n\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === "number") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case "int8":\n      case "uint8":\n        return 1;\n      case "int16":\n      case "uint16":\n        return 2;\n      case "int32":\n      case "uint32":\n      case "float32":\n        return 4;\n      default:\n        throw new Error(`${type} isn\'t a valid view type`);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ViewableBuffer.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs\nvar fastCopy = __webpack_require__(6633);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs\nvar state_const = __webpack_require__(2475);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs\n\n\n"use strict";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === "no-premultiply-alpha") {\n    return state_const/* BLEND_TO_NPM */.f[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\n\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/maxRecommendedTextures.mjs\nvar maxRecommendedTextures = __webpack_require__(9131);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs\n\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\n\n//# sourceMappingURL=BatchTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs\n\n\n\n\n\n\n\n"use strict";\nclass Batch {\n  constructor() {\n    this.renderPipeId = "batch";\n    this.action = "startBatch";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.blendMode = "normal";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    this.uid = (0,uid/* uid */.h)("batcher");\n    this.dirty = true;\n    this.batchIndex = 0;\n    this.batches = [];\n    // specifics.\n    this._vertexSize = 6;\n    this._elements = [];\n    this._batchPool = [];\n    this._batchPoolIndex = 0;\n    this._textureBatchPool = [];\n    this._textureBatchPoolIndex = 0;\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { vertexSize, indexSize } = options;\n    this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n    this.indexBuffer = new Uint16Array(indexSize);\n    this._maxTextures = (0,maxRecommendedTextures/* maxRecommendedTextures */.I)();\n  }\n  begin() {\n    this.batchIndex = 0;\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    this._batchPoolIndex = 0;\n    this._textureBatchPoolIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject.indexStart = this.indexSize;\n    batchableObject.location = this.attributeSize;\n    batchableObject.batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject.textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    batchableObject.packAttributes(\n      this.attributeBuffer.float32View,\n      this.attributeBuffer.uint32View,\n      batchableObject.location,\n      batchableObject.textureId\n    );\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n    textureBatch.clear();\n    if (!elements[this.elementStart])\n      return;\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const iBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = "startBatch";\n    let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n    const maxTextures = this._maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const blendModeChange = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !blendModeChange) {\n        element.textureId = source._textureBindLocation;\n        size += element.indexSize;\n        element.packAttributes(f32, u32, element.location, element.textureId);\n        element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        element.batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || blendModeChange) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          instructionSet,\n          action\n        );\n        action = "renderBatch";\n        start = size;\n        blendMode = adjustedBlendMode;\n        textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n        textureBatch.clear();\n        batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n        ++BATCH_TICK;\n      }\n      element.textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element.batch = batch;\n      size += element.indexSize;\n      element.packAttributes(f32, u32, element.location, element.textureId);\n      element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    (0,fastCopy/* fastCopy */.T)(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      (0,fastCopy/* fastCopy */.T)(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      this.batches[i].destroy();\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i].batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  vertexSize: 4,\n  indexSize: 6\n};\nlet Batcher = _Batcher;\n\n\n//# sourceMappingURL=Batcher.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDLElBQUksNEJBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU0sNEJBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2RhdGEvVmlld2FibGVCdWZmZXIubWpzP2U2NGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9nZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kLm1qcz85N2ZhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoVGV4dHVyZUFycmF5Lm1qcz9lYWQ3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoZXIubWpzPzc2MTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBWaWV3YWJsZUJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKHNpemVPckJ1ZmZlcikge1xuICAgIGlmICh0eXBlb2Ygc2l6ZU9yQnVmZmVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLnJhd0JpbmFyeURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZU9yQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHNpemVPckJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlci5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy51aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgdGhpcy5mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB0aGlzLnNpemUgPSB0aGlzLnJhd0JpbmFyeURhdGEuYnl0ZUxlbmd0aDtcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYEludDhBcnJheWAuICovXG4gIGdldCBpbnQ4VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDhWaWV3KSB7XG4gICAgICB0aGlzLl9pbnQ4VmlldyA9IG5ldyBJbnQ4QXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDhWaWV3O1xuICB9XG4gIC8qKiBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgVWludDhBcnJheWAuICovXG4gIGdldCB1aW50OFZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl91aW50OFZpZXcpIHtcbiAgICAgIHRoaXMuX3VpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91aW50OFZpZXc7XG4gIH1cbiAgLyoqICBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgSW50MTZBcnJheWAuICovXG4gIGdldCBpbnQxNlZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnQxNlZpZXcpIHtcbiAgICAgIHRoaXMuX2ludDE2VmlldyA9IG5ldyBJbnQxNkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnQxNlZpZXc7XG4gIH1cbiAgLyoqIFZpZXcgb24gdGhlIHJhdyBiaW5hcnkgZGF0YSBhcyBhIGBJbnQzMkFycmF5YC4gKi9cbiAgZ2V0IGludDMyVmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDMyVmlldykge1xuICAgICAgdGhpcy5faW50MzJWaWV3ID0gbmV3IEludDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDMyVmlldztcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYEZsb2F0NjRBcnJheWAuICovXG4gIGdldCBmbG9hdDY0VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2Zsb2F0NjRBcnJheSkge1xuICAgICAgdGhpcy5fZmxvYXQ2NEFycmF5ID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmxvYXQ2NEFycmF5O1xuICB9XG4gIC8qKiBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgQmlnVWludDY0QXJyYXlgLiAqL1xuICBnZXQgYmlnVWludDY0VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2JpZ1VpbnQ2NEFycmF5KSB7XG4gICAgICB0aGlzLl9iaWdVaW50NjRBcnJheSA9IG5ldyBCaWdVaW50NjRBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYmlnVWludDY0QXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZpZXcgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAqIEBwYXJhbSB0eXBlIC0gT25lIG9mIGBpbnQ4YCwgYHVpbnQ4YCwgYGludDE2YCxcbiAgICogICAgYHVpbnQxNmAsIGBpbnQzMmAsIGB1aW50MzJgLCBhbmQgYGZsb2F0MzJgLlxuICAgKiBAcmV0dXJucyAtIHR5cGVkIGFycmF5IG9mIGdpdmVuIHR5cGVcbiAgICovXG4gIHZpZXcodHlwZSkge1xuICAgIHJldHVybiB0aGlzW2Ake3R5cGV9Vmlld2BdO1xuICB9XG4gIC8qKiBEZXN0cm95cyBhbGwgYnVmZmVyIHJlZmVyZW5jZXMuIERvIG5vdCB1c2UgYWZ0ZXIgY2FsbGluZyB0aGlzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IG51bGw7XG4gICAgdGhpcy5faW50OFZpZXcgPSBudWxsO1xuICAgIHRoaXMuX3VpbnQ4VmlldyA9IG51bGw7XG4gICAgdGhpcy5faW50MTZWaWV3ID0gbnVsbDtcbiAgICB0aGlzLnVpbnQxNlZpZXcgPSBudWxsO1xuICAgIHRoaXMuX2ludDMyVmlldyA9IG51bGw7XG4gICAgdGhpcy51aW50MzJWaWV3ID0gbnVsbDtcbiAgICB0aGlzLmZsb2F0MzJWaWV3ID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gdHlwZSBpbiBieXRlcy5cbiAgICogQHBhcmFtIHR5cGUgLSBPbmUgb2YgYGludDhgLCBgdWludDhgLCBgaW50MTZgLFxuICAgKiAgIGB1aW50MTZgLCBgaW50MzJgLCBgdWludDMyYCwgYW5kIGBmbG9hdDMyYC5cbiAgICogQHJldHVybnMgLSBzaXplIG9mIHRoZSB0eXBlIGluIGJ5dGVzXG4gICAqL1xuICBzdGF0aWMgc2l6ZU9mKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGV9IGlzbid0IGEgdmFsaWQgdmlldyB0eXBlYCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFZpZXdhYmxlQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3YWJsZUJ1ZmZlci5tanMubWFwXG4iLCJpbXBvcnQgeyBCTEVORF9UT19OUE0gfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZChibGVuZE1vZGUsIHRleHR1cmVTb3VyY2UpIHtcbiAgaWYgKHRleHR1cmVTb3VyY2UuYWxwaGFNb2RlID09PSBcIm5vLXByZW11bHRpcGx5LWFscGhhXCIpIHtcbiAgICByZXR1cm4gQkxFTkRfVE9fTlBNW2JsZW5kTW9kZV0gfHwgYmxlbmRNb2RlO1xuICB9XG4gIHJldHVybiBibGVuZE1vZGU7XG59XG5cbmV4cG9ydCB7IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCYXRjaFRleHR1cmVBcnJheSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBSZXNwZWN0aXZlIGxvY2F0aW9ucyBmb3IgdGV4dHVyZXMuICovXG4gICAgdGhpcy5pZHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnRleHR1cmVzID0gW107XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cbiAgLyoqIENsZWFyIHRoZSB0ZXh0dXJlcyBhbmQgdGhlaXIgbG9jYXRpb25zLiAqL1xuICBjbGVhcigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdCA9IHRoaXMudGV4dHVyZXNbaV07XG4gICAgICB0aGlzLnRleHR1cmVzW2ldID0gbnVsbDtcbiAgICAgIHRoaXMuaWRzW3QudWlkXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoVGV4dHVyZUFycmF5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFRleHR1cmVBcnJheS5tanMubWFwXG4iLCJpbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgVmlld2FibGVCdWZmZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL1ZpZXdhYmxlQnVmZmVyLm1qcyc7XG5pbXBvcnQgeyBmYXN0Q29weSB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL3V0aWxzL2Zhc3RDb3B5Lm1qcyc7XG5pbXBvcnQgeyBnZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9nZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kLm1qcyc7XG5pbXBvcnQgeyBtYXhSZWNvbW1lbmRlZFRleHR1cmVzIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3V0aWxzL21heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzJztcbmltcG9ydCB7IEJhdGNoVGV4dHVyZUFycmF5IH0gZnJvbSAnLi9CYXRjaFRleHR1cmVBcnJheS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJhdGNoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZW5kZXJQaXBlSWQgPSBcImJhdGNoXCI7XG4gICAgdGhpcy5hY3Rpb24gPSBcInN0YXJ0QmF0Y2hcIjtcbiAgICAvLyBUT0RPIC0gZXZlbnR1YWxseSB0aGlzIGNvdWxkIGJlIHVzZWZ1bCBmb3IgZmxhZ2dpbmcgYmF0Y2hlcyBhcyBkaXJ0eSBhbmQgdGhlbiBvbmx5IHJlYnVpbGRpbmcgdGhvc2Ugb25lc1xuICAgIC8vIHB1YmxpYyBlbGVtZW50U3RhcnQgPSAwO1xuICAgIC8vIHB1YmxpYyBlbGVtZW50U2l6ZSA9IDA7XG4gICAgLy8gZm9yIGRyYXdpbmcuLlxuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBcIm5vcm1hbFwiO1xuICAgIHRoaXMuY2FuQnVuZGxlID0gdHJ1ZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudGV4dHVyZXMgPSBudWxsO1xuICAgIHRoaXMuZ3B1QmluZEdyb3VwID0gbnVsbDtcbiAgICB0aGlzLmJpbmRHcm91cCA9IG51bGw7XG4gICAgdGhpcy5iYXRjaGVyID0gbnVsbDtcbiAgfVxufVxubGV0IEJBVENIX1RJQ0sgPSAwO1xuY29uc3QgX0JhdGNoZXIgPSBjbGFzcyBfQmF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMudWlkID0gdWlkKFwiYmF0Y2hlclwiKTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmJhdGNoSW5kZXggPSAwO1xuICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xuICAgIC8vIHNwZWNpZmljcy5cbiAgICB0aGlzLl92ZXJ0ZXhTaXplID0gNjtcbiAgICB0aGlzLl9lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX2JhdGNoUG9vbCA9IFtdO1xuICAgIHRoaXMuX2JhdGNoUG9vbEluZGV4ID0gMDtcbiAgICB0aGlzLl90ZXh0dXJlQmF0Y2hQb29sID0gW107XG4gICAgdGhpcy5fdGV4dHVyZUJhdGNoUG9vbEluZGV4ID0gMDtcbiAgICBvcHRpb25zID0geyAuLi5fQmF0Y2hlci5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHsgdmVydGV4U2l6ZSwgaW5kZXhTaXplIH0gPSBvcHRpb25zO1xuICAgIHRoaXMuYXR0cmlidXRlQnVmZmVyID0gbmV3IFZpZXdhYmxlQnVmZmVyKHZlcnRleFNpemUgKiB0aGlzLl92ZXJ0ZXhTaXplICogNCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShpbmRleFNpemUpO1xuICAgIHRoaXMuX21heFRleHR1cmVzID0gbWF4UmVjb21tZW5kZWRUZXh0dXJlcygpO1xuICB9XG4gIGJlZ2luKCkge1xuICAgIHRoaXMuYmF0Y2hJbmRleCA9IDA7XG4gICAgdGhpcy5lbGVtZW50U2l6ZSA9IDA7XG4gICAgdGhpcy5lbGVtZW50U3RhcnQgPSAwO1xuICAgIHRoaXMuaW5kZXhTaXplID0gMDtcbiAgICB0aGlzLmF0dHJpYnV0ZVNpemUgPSAwO1xuICAgIHRoaXMuX2JhdGNoUG9vbEluZGV4ID0gMDtcbiAgICB0aGlzLl90ZXh0dXJlQmF0Y2hQb29sSW5kZXggPSAwO1xuICAgIHRoaXMuX2JhdGNoSW5kZXhTdGFydCA9IDA7XG4gICAgdGhpcy5fYmF0Y2hJbmRleFNpemUgPSAwO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIGFkZChiYXRjaGFibGVPYmplY3QpIHtcbiAgICB0aGlzLl9lbGVtZW50c1t0aGlzLmVsZW1lbnRTaXplKytdID0gYmF0Y2hhYmxlT2JqZWN0O1xuICAgIGJhdGNoYWJsZU9iamVjdC5pbmRleFN0YXJ0ID0gdGhpcy5pbmRleFNpemU7XG4gICAgYmF0Y2hhYmxlT2JqZWN0LmxvY2F0aW9uID0gdGhpcy5hdHRyaWJ1dGVTaXplO1xuICAgIGJhdGNoYWJsZU9iamVjdC5iYXRjaGVyID0gdGhpcztcbiAgICB0aGlzLmluZGV4U2l6ZSArPSBiYXRjaGFibGVPYmplY3QuaW5kZXhTaXplO1xuICAgIHRoaXMuYXR0cmlidXRlU2l6ZSArPSBiYXRjaGFibGVPYmplY3QudmVydGV4U2l6ZSAqIHRoaXMuX3ZlcnRleFNpemU7XG4gIH1cbiAgY2hlY2tBbmRVcGRhdGVUZXh0dXJlKGJhdGNoYWJsZU9iamVjdCwgdGV4dHVyZSkge1xuICAgIGNvbnN0IHRleHR1cmVJZCA9IGJhdGNoYWJsZU9iamVjdC5iYXRjaC50ZXh0dXJlcy5pZHNbdGV4dHVyZS5fc291cmNlLnVpZF07XG4gICAgaWYgKCF0ZXh0dXJlSWQgJiYgdGV4dHVyZUlkICE9PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGJhdGNoYWJsZU9iamVjdC50ZXh0dXJlSWQgPSB0ZXh0dXJlSWQ7XG4gICAgYmF0Y2hhYmxlT2JqZWN0LnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnQoYmF0Y2hhYmxlT2JqZWN0KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgYmF0Y2hhYmxlT2JqZWN0LnBhY2tBdHRyaWJ1dGVzKFxuICAgICAgdGhpcy5hdHRyaWJ1dGVCdWZmZXIuZmxvYXQzMlZpZXcsXG4gICAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlci51aW50MzJWaWV3LFxuICAgICAgYmF0Y2hhYmxlT2JqZWN0LmxvY2F0aW9uLFxuICAgICAgYmF0Y2hhYmxlT2JqZWN0LnRleHR1cmVJZFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIGJyZWFrcyB0aGUgYmF0Y2hlci4gVGhpcyBoYXBwZW5zIHdoZW4gYSBiYXRjaCBnZXRzIHRvbyBiaWcsXG4gICAqIG9yIHdlIG5lZWQgdG8gc3dpdGNoIHRvIGEgZGlmZmVyZW50IHR5cGUgb2YgcmVuZGVyaW5nIChhIGZpbHRlciBmb3IgZXhhbXBsZSlcbiAgICogQHBhcmFtIGluc3RydWN0aW9uU2V0XG4gICAqL1xuICBicmVhayhpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHM7XG4gICAgbGV0IHRleHR1cmVCYXRjaCA9IHRoaXMuX3RleHR1cmVCYXRjaFBvb2xbdGhpcy5fdGV4dHVyZUJhdGNoUG9vbEluZGV4KytdIHx8IG5ldyBCYXRjaFRleHR1cmVBcnJheSgpO1xuICAgIHRleHR1cmVCYXRjaC5jbGVhcigpO1xuICAgIGlmICghZWxlbWVudHNbdGhpcy5lbGVtZW50U3RhcnRdKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZpcnN0RWxlbWVudCA9IGVsZW1lbnRzW3RoaXMuZWxlbWVudFN0YXJ0XTtcbiAgICBsZXQgYmxlbmRNb2RlID0gZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZChmaXJzdEVsZW1lbnQuYmxlbmRNb2RlLCBmaXJzdEVsZW1lbnQudGV4dHVyZS5fc291cmNlKTtcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGVTaXplICogNCA+IHRoaXMuYXR0cmlidXRlQnVmZmVyLnNpemUpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUF0dHJpYnV0ZUJ1ZmZlcih0aGlzLmF0dHJpYnV0ZVNpemUgKiA0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5kZXhTaXplID4gdGhpcy5pbmRleEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUluZGV4QnVmZmVyKHRoaXMuaW5kZXhTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZjMyID0gdGhpcy5hdHRyaWJ1dGVCdWZmZXIuZmxvYXQzMlZpZXc7XG4gICAgY29uc3QgdTMyID0gdGhpcy5hdHRyaWJ1dGVCdWZmZXIudWludDMyVmlldztcbiAgICBjb25zdCBpQnVmZmVyID0gdGhpcy5pbmRleEJ1ZmZlcjtcbiAgICBsZXQgc2l6ZSA9IHRoaXMuX2JhdGNoSW5kZXhTaXplO1xuICAgIGxldCBzdGFydCA9IHRoaXMuX2JhdGNoSW5kZXhTdGFydDtcbiAgICBsZXQgYWN0aW9uID0gXCJzdGFydEJhdGNoXCI7XG4gICAgbGV0IGJhdGNoID0gdGhpcy5fYmF0Y2hQb29sW3RoaXMuX2JhdGNoUG9vbEluZGV4KytdIHx8IG5ldyBCYXRjaCgpO1xuICAgIGNvbnN0IG1heFRleHR1cmVzID0gdGhpcy5fbWF4VGV4dHVyZXM7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuZWxlbWVudFN0YXJ0OyBpIDwgdGhpcy5lbGVtZW50U2l6ZTsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBlbGVtZW50c1tpXSA9IG51bGw7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gZWxlbWVudC50ZXh0dXJlO1xuICAgICAgY29uc3Qgc291cmNlID0gdGV4dHVyZS5fc291cmNlO1xuICAgICAgY29uc3QgYWRqdXN0ZWRCbGVuZE1vZGUgPSBnZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kKGVsZW1lbnQuYmxlbmRNb2RlLCBzb3VyY2UpO1xuICAgICAgY29uc3QgYmxlbmRNb2RlQ2hhbmdlID0gYmxlbmRNb2RlICE9PSBhZGp1c3RlZEJsZW5kTW9kZTtcbiAgICAgIGlmIChzb3VyY2UuX2JhdGNoVGljayA9PT0gQkFUQ0hfVElDSyAmJiAhYmxlbmRNb2RlQ2hhbmdlKSB7XG4gICAgICAgIGVsZW1lbnQudGV4dHVyZUlkID0gc291cmNlLl90ZXh0dXJlQmluZExvY2F0aW9uO1xuICAgICAgICBzaXplICs9IGVsZW1lbnQuaW5kZXhTaXplO1xuICAgICAgICBlbGVtZW50LnBhY2tBdHRyaWJ1dGVzKGYzMiwgdTMyLCBlbGVtZW50LmxvY2F0aW9uLCBlbGVtZW50LnRleHR1cmVJZCk7XG4gICAgICAgIGVsZW1lbnQucGFja0luZGV4KGlCdWZmZXIsIGVsZW1lbnQuaW5kZXhTdGFydCwgZWxlbWVudC5sb2NhdGlvbiAvIHRoaXMuX3ZlcnRleFNpemUpO1xuICAgICAgICBlbGVtZW50LmJhdGNoID0gYmF0Y2g7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc291cmNlLl9iYXRjaFRpY2sgPSBCQVRDSF9USUNLO1xuICAgICAgaWYgKHRleHR1cmVCYXRjaC5jb3VudCA+PSBtYXhUZXh0dXJlcyB8fCBibGVuZE1vZGVDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoQmF0Y2goXG4gICAgICAgICAgYmF0Y2gsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgc2l6ZSAtIHN0YXJ0LFxuICAgICAgICAgIHRleHR1cmVCYXRjaCxcbiAgICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgICAgaW5zdHJ1Y3Rpb25TZXQsXG4gICAgICAgICAgYWN0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGFjdGlvbiA9IFwicmVuZGVyQmF0Y2hcIjtcbiAgICAgICAgc3RhcnQgPSBzaXplO1xuICAgICAgICBibGVuZE1vZGUgPSBhZGp1c3RlZEJsZW5kTW9kZTtcbiAgICAgICAgdGV4dHVyZUJhdGNoID0gdGhpcy5fdGV4dHVyZUJhdGNoUG9vbFt0aGlzLl90ZXh0dXJlQmF0Y2hQb29sSW5kZXgrK10gfHwgbmV3IEJhdGNoVGV4dHVyZUFycmF5KCk7XG4gICAgICAgIHRleHR1cmVCYXRjaC5jbGVhcigpO1xuICAgICAgICBiYXRjaCA9IHRoaXMuX2JhdGNoUG9vbFt0aGlzLl9iYXRjaFBvb2xJbmRleCsrXSB8fCBuZXcgQmF0Y2goKTtcbiAgICAgICAgKytCQVRDSF9USUNLO1xuICAgICAgfVxuICAgICAgZWxlbWVudC50ZXh0dXJlSWQgPSBzb3VyY2UuX3RleHR1cmVCaW5kTG9jYXRpb24gPSB0ZXh0dXJlQmF0Y2guY291bnQ7XG4gICAgICB0ZXh0dXJlQmF0Y2guaWRzW3NvdXJjZS51aWRdID0gdGV4dHVyZUJhdGNoLmNvdW50O1xuICAgICAgdGV4dHVyZUJhdGNoLnRleHR1cmVzW3RleHR1cmVCYXRjaC5jb3VudCsrXSA9IHNvdXJjZTtcbiAgICAgIGVsZW1lbnQuYmF0Y2ggPSBiYXRjaDtcbiAgICAgIHNpemUgKz0gZWxlbWVudC5pbmRleFNpemU7XG4gICAgICBlbGVtZW50LnBhY2tBdHRyaWJ1dGVzKGYzMiwgdTMyLCBlbGVtZW50LmxvY2F0aW9uLCBlbGVtZW50LnRleHR1cmVJZCk7XG4gICAgICBlbGVtZW50LnBhY2tJbmRleChpQnVmZmVyLCBlbGVtZW50LmluZGV4U3RhcnQsIGVsZW1lbnQubG9jYXRpb24gLyB0aGlzLl92ZXJ0ZXhTaXplKTtcbiAgICB9XG4gICAgaWYgKHRleHR1cmVCYXRjaC5jb3VudCA+IDApIHtcbiAgICAgIHRoaXMuX2ZpbmlzaEJhdGNoKFxuICAgICAgICBiYXRjaCxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHNpemUgLSBzdGFydCxcbiAgICAgICAgdGV4dHVyZUJhdGNoLFxuICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgIGluc3RydWN0aW9uU2V0LFxuICAgICAgICBhY3Rpb25cbiAgICAgICk7XG4gICAgICBzdGFydCA9IHNpemU7XG4gICAgICArK0JBVENIX1RJQ0s7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudFN0YXJ0ID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB0aGlzLl9iYXRjaEluZGV4U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9iYXRjaEluZGV4U2l6ZSA9IHNpemU7XG4gIH1cbiAgX2ZpbmlzaEJhdGNoKGJhdGNoLCBpbmRleFN0YXJ0LCBpbmRleFNpemUsIHRleHR1cmVCYXRjaCwgYmxlbmRNb2RlLCBpbnN0cnVjdGlvblNldCwgYWN0aW9uKSB7XG4gICAgYmF0Y2guZ3B1QmluZEdyb3VwID0gbnVsbDtcbiAgICBiYXRjaC5hY3Rpb24gPSBhY3Rpb247XG4gICAgYmF0Y2guYmF0Y2hlciA9IHRoaXM7XG4gICAgYmF0Y2gudGV4dHVyZXMgPSB0ZXh0dXJlQmF0Y2g7XG4gICAgYmF0Y2guYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuICAgIGJhdGNoLnN0YXJ0ID0gaW5kZXhTdGFydDtcbiAgICBiYXRjaC5zaXplID0gaW5kZXhTaXplO1xuICAgICsrQkFUQ0hfVElDSztcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoYmF0Y2gpO1xuICB9XG4gIGZpbmlzaChpbnN0cnVjdGlvblNldCkge1xuICAgIHRoaXMuYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBhdHRyaWJ1dGUgYnVmZmVyIHRvIHRoZSBnaXZlbiBzaXplICgxID0gMSBmbG9hdDMyKVxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIGluIHZlcnRpY2VzIHRvIGVuc3VyZSAobm90IGJ5dGVzISlcbiAgICovXG4gIGVuc3VyZUF0dHJpYnV0ZUJ1ZmZlcihzaXplKSB7XG4gICAgaWYgKHNpemUgKiA0IDw9IHRoaXMuYXR0cmlidXRlQnVmZmVyLnNpemUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fcmVzaXplQXR0cmlidXRlQnVmZmVyKHNpemUgKiA0KTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgaW5kZXggYnVmZmVyIHRvIHRoZSBnaXZlbiBzaXplICgxID0gMSBmbG9hdDMyKVxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIGluIHZlcnRpY2VzIHRvIGVuc3VyZSAobm90IGJ5dGVzISlcbiAgICovXG4gIGVuc3VyZUluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA8PSB0aGlzLmluZGV4QnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9yZXNpemVJbmRleEJ1ZmZlcihzaXplKTtcbiAgfVxuICBfcmVzaXplQXR0cmlidXRlQnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCBuZXdTaXplID0gTWF0aC5tYXgoc2l6ZSwgdGhpcy5hdHRyaWJ1dGVCdWZmZXIuc2l6ZSAqIDIpO1xuICAgIGNvbnN0IG5ld0FycmF5QnVmZmVyID0gbmV3IFZpZXdhYmxlQnVmZmVyKG5ld1NpemUpO1xuICAgIGZhc3RDb3B5KHRoaXMuYXR0cmlidXRlQnVmZmVyLnJhd0JpbmFyeURhdGEsIG5ld0FycmF5QnVmZmVyLnJhd0JpbmFyeURhdGEpO1xuICAgIHRoaXMuYXR0cmlidXRlQnVmZmVyID0gbmV3QXJyYXlCdWZmZXI7XG4gIH1cbiAgX3Jlc2l6ZUluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IHRoaXMuaW5kZXhCdWZmZXI7XG4gICAgbGV0IG5ld1NpemUgPSBNYXRoLm1heChzaXplLCBpbmRleEJ1ZmZlci5sZW5ndGggKiAxLjUpO1xuICAgIG5ld1NpemUgKz0gbmV3U2l6ZSAlIDI7XG4gICAgY29uc3QgbmV3SW5kZXhCdWZmZXIgPSBuZXdTaXplID4gNjU1MzUgPyBuZXcgVWludDMyQXJyYXkobmV3U2l6ZSkgOiBuZXcgVWludDE2QXJyYXkobmV3U2l6ZSk7XG4gICAgaWYgKG5ld0luZGV4QnVmZmVyLkJZVEVTX1BFUl9FTEVNRU5UICE9PSBpbmRleEJ1ZmZlci5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdJbmRleEJ1ZmZlcltpXSA9IGluZGV4QnVmZmVyW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmYXN0Q29weShpbmRleEJ1ZmZlci5idWZmZXIsIG5ld0luZGV4QnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBuZXdJbmRleEJ1ZmZlcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmJhdGNoZXNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoZXMgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VsZW1lbnRzW2ldLmJhdGNoID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudHMgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlQnVmZmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlciA9IG51bGw7XG4gIH1cbn07XG5fQmF0Y2hlci5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgdmVydGV4U2l6ZTogNCxcbiAgaW5kZXhTaXplOiA2XG59O1xubGV0IEJhdGNoZXIgPSBfQmF0Y2hlcjtcblxuZXhwb3J0IHsgQmF0Y2gsIEJhdGNoZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2067\n')},2189:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   O: () => (/* binding */ getBatchSamplersUniformGroup)\n/* harmony export */ });\n/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4537);\n\n\n"use strict";\nconst batchSamplersUniformGroupHash = {};\nfunction getBatchSamplersUniformGroup(maxTextures) {\n  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n  if (batchSamplersUniformGroup)\n    return batchSamplersUniformGroup;\n  const sampleValues = new Int32Array(maxTextures);\n  for (let i = 0; i < maxTextures; i++) {\n    sampleValues[i] = i;\n  }\n  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__/* .UniformGroup */ .o({\n    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n  }, { isStatic: true });\n  return batchSamplersUniformGroup;\n}\n\n\n//# sourceMappingURL=getBatchSamplersUniformGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE4OS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLCtFQUErRSxrRkFBWTtBQUMzRixpQkFBaUI7QUFDakIsR0FBRyxJQUFJLGdCQUFnQjtBQUN2QjtBQUNBOztBQUV3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvZ2V0QmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cC5tanM/OGQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXBIYXNoID0ge307XG5mdW5jdGlvbiBnZXRCYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwKG1heFRleHR1cmVzKSB7XG4gIGxldCBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwID0gYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cEhhc2hbbWF4VGV4dHVyZXNdO1xuICBpZiAoYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cClcbiAgICByZXR1cm4gYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cDtcbiAgY29uc3Qgc2FtcGxlVmFsdWVzID0gbmV3IEludDMyQXJyYXkobWF4VGV4dHVyZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICBzYW1wbGVWYWx1ZXNbaV0gPSBpO1xuICB9XG4gIGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgPSBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwSGFzaFttYXhUZXh0dXJlc10gPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICB1VGV4dHVyZXM6IHsgdmFsdWU6IHNhbXBsZVZhbHVlcywgdHlwZTogYGkzMmAsIHNpemU6IG1heFRleHR1cmVzIH1cbiAgfSwgeyBpc1N0YXRpYzogdHJ1ZSB9KTtcbiAgcmV0dXJuIGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXA7XG59XG5cbmV4cG9ydCB7IGdldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2189\n')},8407:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   K: () => (/* binding */ getTestContext)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n\n\n"use strict";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n    context = canvas.getContext("webgl", {});\n  }\n  return context;\n}\n\n\n//# sourceMappingURL=getTestContext.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQwNy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBVTtBQUM3QiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvcHJvZ3JhbS9nZXRUZXN0Q29udGV4dC5tanM/YjJlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCBjb250ZXh0O1xuZnVuY3Rpb24gZ2V0VGVzdENvbnRleHQoKSB7XG4gIGlmICghY29udGV4dCB8fCBjb250ZXh0Py5pc0NvbnRleHRMb3N0KCkpIHtcbiAgICBjb25zdCBjYW52YXMgPSBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcygpO1xuICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHt9KTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZXhwb3J0IHsgZ2V0VGVzdENvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFRlc3RDb250ZXh0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8407\n')},9818:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   v: () => (/* binding */ BindGroup)\n/* harmony export */ });\n\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join("|");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.("change", this.onResourceChange, this);\n    }\n    resource.on?.("change", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to \'touch\' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.("change", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\n\n\n//# sourceMappingURL=BindGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgxOC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3NoYWRlci9CaW5kR3JvdXAubWpzPzM0OTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCaW5kR3JvdXAge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIGVvZiB0aGUgQmluZCBHcm91cC5cbiAgICogQHBhcmFtIHJlc291cmNlcyAtIFRoZSByZXNvdXJjZXMgdGhhdCBhcmUgYm91bmQgdG9nZXRoZXIgZm9yIHVzZSBieSBhIHNoYWRlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc291cmNlcykge1xuICAgIC8qKiBUaGUgcmVzb3VyY2VzIHRoYXQgYXJlIGJvdW5kIHRvZ2V0aGVyIGZvciB1c2UgYnkgYSBzaGFkZXIuICovXG4gICAgdGhpcy5yZXNvdXJjZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGkgaW4gcmVzb3VyY2VzKSB7XG4gICAgICBjb25zdCByZXNvdXJjZSA9IHJlc291cmNlc1tpXTtcbiAgICAgIHRoaXMuc2V0UmVzb3VyY2UocmVzb3VyY2UsIGluZGV4KyspO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVLZXkoKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUga2V5IGlmIGl0cyBmbGFnZ2VkIGFzIGRpcnR5LiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSB0b1xuICAgKiBtYXRjaCB0aGlzIGJpbmQgZ3JvdXAgdG8gYSBXZWJHUFUgQmluZEdyb3VwLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX3VwZGF0ZUtleSgpIHtcbiAgICBpZiAoIXRoaXMuX2RpcnR5KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgY29uc3Qga2V5UGFydHMgPSBbXTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnJlc291cmNlcykge1xuICAgICAga2V5UGFydHNbaW5kZXgrK10gPSB0aGlzLnJlc291cmNlc1tpXS5fcmVzb3VyY2VJZDtcbiAgICB9XG4gICAgdGhpcy5fa2V5ID0ga2V5UGFydHMuam9pbihcInxcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHJlc291cmNlIGF0IGEgZ2l2ZW4gaW5kZXguIHRoaXMgZnVuY3Rpb24gd2lsbFxuICAgKiBlbnN1cmUgdGhhdCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGN1cnJlbnQgcmVzb3VyY2VcbiAgICogYW5kIGFkZGVkIHRvIHRoZSBuZXcgcmVzb3VyY2UuXG4gICAqIEBwYXJhbSByZXNvdXJjZSAtIFRoZSByZXNvdXJjZSB0byBzZXQuXG4gICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB0byBzZXQgdGhlIHJlc291cmNlIGF0LlxuICAgKi9cbiAgc2V0UmVzb3VyY2UocmVzb3VyY2UsIGluZGV4KSB7XG4gICAgY29uc3QgY3VycmVudFJlc291cmNlID0gdGhpcy5yZXNvdXJjZXNbaW5kZXhdO1xuICAgIGlmIChyZXNvdXJjZSA9PT0gY3VycmVudFJlc291cmNlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChjdXJyZW50UmVzb3VyY2UpIHtcbiAgICAgIHJlc291cmNlLm9mZj8uKFwiY2hhbmdlXCIsIHRoaXMub25SZXNvdXJjZUNoYW5nZSwgdGhpcyk7XG4gICAgfVxuICAgIHJlc291cmNlLm9uPy4oXCJjaGFuZ2VcIiwgdGhpcy5vblJlc291cmNlQ2hhbmdlLCB0aGlzKTtcbiAgICB0aGlzLnJlc291cmNlc1tpbmRleF0gPSByZXNvdXJjZTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc291cmNlIGF0IHRoZSBjdXJyZW50IHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSByZXNvdXJjZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIC0gVGhlIHJlc291cmNlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqL1xuICBnZXRSZXNvdXJjZShpbmRleCkge1xuICAgIHJldHVybiB0aGlzLnJlc291cmNlc1tpbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgaW50ZXJuYWxseSB0byAndG91Y2gnIGVhY2ggcmVzb3VyY2UsIHRvIGVuc3VyZSB0aGF0IHRoZSBHQ1xuICAgKiBrbm93cyB0aGF0IGFsbCByZXNvdXJjZXMgaW4gdGhpcyBiaW5kIGdyb3VwIGFyZSBzdGlsbCBiZWluZyB1c2VkLlxuICAgKiBAcGFyYW0gdGljayAtIFRoZSBjdXJyZW50IHRpY2suXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfdG91Y2godGljaykge1xuICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMucmVzb3VyY2VzO1xuICAgIGZvciAoY29uc3QgaSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIHJlc291cmNlc1tpXS5fdG91Y2hlZCA9IHRpY2s7XG4gICAgfVxuICB9XG4gIC8qKiBEZXN0cm95cyB0aGlzIGJpbmQgZ3JvdXAgYW5kIHJlbW92ZXMgYWxsIGxpc3RlbmVycy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCByZXNvdXJjZXMgPSB0aGlzLnJlc291cmNlcztcbiAgICBmb3IgKGNvbnN0IGkgaW4gcmVzb3VyY2VzKSB7XG4gICAgICBjb25zdCByZXNvdXJjZSA9IHJlc291cmNlc1tpXTtcbiAgICAgIHJlc291cmNlLm9mZj8uKFwiY2hhbmdlXCIsIHRoaXMub25SZXNvdXJjZUNoYW5nZSwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMucmVzb3VyY2VzID0gbnVsbDtcbiAgfVxuICBvblJlc291cmNlQ2hhbmdlKHJlc291cmNlKSB7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIGlmIChyZXNvdXJjZS5kZXN0cm95ZWQpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMucmVzb3VyY2VzO1xuICAgICAgZm9yIChjb25zdCBpIGluIHJlc291cmNlcykge1xuICAgICAgICBpZiAocmVzb3VyY2VzW2ldID09PSByZXNvdXJjZSkge1xuICAgICAgICAgIHJlc291cmNlc1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlS2V5KCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEJpbmRHcm91cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmluZEdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9818\n')},7494:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   l: () => (/* binding */ Buffer)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1580);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6258);\n/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5324);\n\n\n\n\n"use strict";\nclass Buffer extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("buffer");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = "buffer";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size = size ?? data?.byteLength;\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & _const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= _const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC;\n    } else {\n      this.descriptor.usage &= ~_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit("update", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    if (oldData.length !== value.length) {\n      if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit("update", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n        this.emit("change", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit("update", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit("update", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.emit("change", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\n\n//# sourceMappingURL=Buffer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ5NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUM7QUFDWTtBQUNYOztBQUUxQztBQUNBLHFCQUFxQiw4REFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDREQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0REFBVztBQUMxQyxNQUFNO0FBQ04sZ0NBQWdDLDREQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwyQkFBMkIsaUVBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvQnVmZmVyLm1qcz9hMTg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgQnVmZmVyVXNhZ2UgfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQnVmZmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQnVmZmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgb3B0aW9ucyBmb3IgdGhlIGJ1ZmZlclxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGxldCB7IGRhdGEsIHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyB1c2FnZSwgbGFiZWwsIHNocmlua1RvRml0IH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogZW1pdHMgd2hlbiB0aGUgdW5kZXJseWluZyBidWZmZXIgaGFzIGNoYW5nZWQgc2hhcGUgKGkuZS4gcmVzaXplZClcbiAgICAgKiBsZXR0aW5nIHRoZSByZW5kZXJlciBrbm93IHRoYXQgaXQgbmVlZHMgdG8gZGlzY2FyZCB0aGUgb2xkIGJ1ZmZlciBvbiB0aGUgR1BVIGFuZCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGVtaXRzIHdoZW4gdGhlIHVuZGVybHlpbmcgYnVmZmVyIGRhdGEgaGFzIGJlZW4gdXBkYXRlZC4gbGV0dGluZyB0aGUgcmVuZGVyZXIga25vd1xuICAgICAqIHRoYXQgaXQgbmVlZHMgdG8gdXBkYXRlIHRoZSBidWZmZXIgb24gdGhlIEdQVVxuICAgICAqIEBldmVudCB1cGRhdGVcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBlbWl0cyB3aGVuIHRoZSBidWZmZXIgaXMgZGVzdHJveWVkLiBsZXR0aW5nIHRoZSByZW5kZXJlciBrbm93IHRoYXQgaXQgbmVlZHMgdG8gZGVzdHJveSB0aGUgYnVmZmVyIG9uIHRoZSBHUFVcbiAgICAgKiBAZXZlbnQgZGVzdHJveVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGEgdW5pcXVlIGlkIGZvciB0aGlzIHVuaWZvcm0gZ3JvdXAgdXNlZCB0aHJvdWdoIHRoZSByZW5kZXJlclxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLnVpZCA9IHVpZChcImJ1ZmZlclwiKTtcbiAgICAvKipcbiAgICAgKiBhIHJlc291cmNlIHR5cGUsIHVzZWQgdG8gaWRlbnRpZnkgaG93IHRvIGhhbmRsZSBpdCB3aGVuIGl0cyBpbiBhIGJpbmQgZ3JvdXAgLyBzaGFkZXIgcmVzb3VyY2VcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fcmVzb3VyY2VUeXBlID0gXCJidWZmZXJcIjtcbiAgICAvKipcbiAgICAgKiB0aGUgcmVzb3VyY2UgaWQgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSByZW5kZXJlciB0byBidWlsZCBiaW5kIGdyb3VwIGtleXNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fcmVzb3VyY2VJZCA9IHVpZChcInJlc291cmNlXCIpO1xuICAgIC8qKlxuICAgICAqIHVzZWQgaW50ZXJuYWxseSB0byBrbm93IGlmIGEgdW5pZm9ybSBncm91cCB3YXMgdXNlZCBpbiB0aGUgbGFzdCByZW5kZXIgcGFzc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl90b3VjaGVkID0gMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fdXBkYXRlSUQgPSAxO1xuICAgIC8qKlxuICAgICAqIHNob3VsZCB0aGUgR1BVIGJ1ZmZlciBiZSBzaHJ1bmsgd2hlbiB0aGUgZGF0YSBiZWNvbWVzIHNtYWxsZXI/XG4gICAgICogY2hhbmdpbmcgdGhpcyB3aWxsIGNhdXNlIHRoZSBidWZmZXIgdG8gYmUgZGVzdHJveWVkIGFuZCBhIG5ldyBvbmUgY3JlYXRlZCBvbiB0aGUgR1BVXG4gICAgICogdGhpcyBjYW4gYmUgZXhwZW5zaXZlLCBlc3BlY2lhbGx5IGlmIHRoZSBidWZmZXIgaXMgYWxyZWFkeSBiaWcgZW5vdWdoIVxuICAgICAqIHNldHRpbmcgdGhpcyB0byBmYWxzZSB3aWxsIHByZXZlbnQgdGhlIGJ1ZmZlciBmcm9tIGJlaW5nIHNocnVuay4gVGhpcyB3aWxsIHlpZWxkIGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAqIGlmIHlvdSBhcmUgY29uc3RhbnRseSBzZXR0aW5nIGRhdGEgdGhhdCBpcyBjaGFuZ2luZyBzaXplIG9mdGVuLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLnNocmlua1RvRml0ID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBIYXMgdGhlIGJ1ZmZlciBiZWVuIGRlc3Ryb3llZD9cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICBzaXplID0gc2l6ZSA/PyBkYXRhPy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IG1hcHBlZEF0Q3JlYXRpb24gPSAhIWRhdGE7XG4gICAgdGhpcy5kZXNjcmlwdG9yID0ge1xuICAgICAgc2l6ZSxcbiAgICAgIHVzYWdlLFxuICAgICAgbWFwcGVkQXRDcmVhdGlvbixcbiAgICAgIGxhYmVsXG4gICAgfTtcbiAgICB0aGlzLnNocmlua1RvRml0ID0gc2hyaW5rVG9GaXQgPz8gdHJ1ZTtcbiAgfVxuICAvKiogdGhlIGRhdGEgaW4gdGhlIGJ1ZmZlciAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0RGF0YVdpdGhTaXplKHZhbHVlLCB2YWx1ZS5sZW5ndGgsIHRydWUpO1xuICB9XG4gIC8qKiB3aGV0aGVyIHRoZSBidWZmZXIgaXMgc3RhdGljIG9yIG5vdCAqL1xuICBnZXQgc3RhdGljKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRlc2NyaXB0b3IudXNhZ2UgJiBCdWZmZXJVc2FnZS5TVEFUSUMpO1xuICB9XG4gIHNldCBzdGF0aWModmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVzY3JpcHRvci51c2FnZSB8PSBCdWZmZXJVc2FnZS5TVEFUSUM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzY3JpcHRvci51c2FnZSAmPSB+QnVmZmVyVXNhZ2UuU1RBVElDO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGF0YSBpbiB0aGUgYnVmZmVyIHRvIHRoZSBnaXZlbiB2YWx1ZS4gVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHVwZGF0ZSB0aGUgYnVmZmVyIG9uIHRoZSBHUFUuXG4gICAqIElmIHlvdSBvbmx5IHdhbnQgdG8gdXBkYXRlIGEgc3Vic2V0IG9mIHRoZSBidWZmZXIsIHlvdSBjYW4gcGFzcyBpbiB0aGUgc2l6ZSBvZiB0aGUgZGF0YS5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIGRhdGEgdG8gc2V0XG4gICAqIEBwYXJhbSBzaXplIC0gdGhlIHNpemUgb2YgdGhlIGRhdGEgaW4gYnl0ZXNcbiAgICogQHBhcmFtIHN5bmNHUFUgLSBzaG91bGQgdGhlIGJ1ZmZlciBiZSB1cGRhdGVkIG9uIHRoZSBHUFUgaW1tZWRpYXRlbHk/XG4gICAqL1xuICBzZXREYXRhV2l0aFNpemUodmFsdWUsIHNpemUsIHN5bmNHUFUpIHtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgIHRoaXMuX3VwZGF0ZVNpemUgPSBzaXplICogdmFsdWUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgaWYgKHRoaXMuX2RhdGEgPT09IHZhbHVlKSB7XG4gICAgICBpZiAoc3luY0dQVSlcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB0aGlzLl9kYXRhID0gdmFsdWU7XG4gICAgaWYgKG9sZERhdGEubGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGlmICghdGhpcy5zaHJpbmtUb0ZpdCAmJiB2YWx1ZS5ieXRlTGVuZ3RoIDwgb2xkRGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGlmIChzeW5jR1BVKVxuICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRvci5zaXplID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VJZCA9IHVpZChcInJlc291cmNlXCIpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzeW5jR1BVKVxuICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiB1cGRhdGVzIHRoZSBidWZmZXIgb24gdGhlIEdQVSB0byByZWZsZWN0IHRoZSBkYXRhIGluIHRoZSBidWZmZXIuXG4gICAqIEJ5IGRlZmF1bHQgaXQgd2lsbCB1cGRhdGUgdGhlIGVudGlyZSBidWZmZXIuIElmIHlvdSBvbmx5IHdhbnQgdG8gdXBkYXRlIGEgc3Vic2V0IG9mIHRoZSBidWZmZXIsXG4gICAqIHlvdSBjYW4gcGFzcyBpbiB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHNpemVJbkJ5dGVzIC0gdGhlIG5ldyBzaXplIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXNcbiAgICovXG4gIHVwZGF0ZShzaXplSW5CeXRlcykge1xuICAgIHRoaXMuX3VwZGF0ZVNpemUgPSBzaXplSW5CeXRlcyA/PyB0aGlzLl91cGRhdGVTaXplO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGUgYnVmZmVyICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIiwgdGhpcyk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHRoaXMpO1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIHRoaXMuZGVzY3JpcHRvciA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxufVxuXG5leHBvcnQgeyBCdWZmZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7494\n')},5324:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   F: () => (/* binding */ BufferUsage)\n/* harmony export */ });\n\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";\n  BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";\n  BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";\n  BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";\n  BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";\n  BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";\n  BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";\n  BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";\n  BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";\n  BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";\n  BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";\n  return BufferUsage2;\n})(BufferUsage || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7O0FBRUc7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci9jb25zdC5tanM/YjZkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBCdWZmZXJVc2FnZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEJ1ZmZlclVzYWdlMikgPT4ge1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiTUFQX1JFQURcIl0gPSAxXSA9IFwiTUFQX1JFQURcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIk1BUF9XUklURVwiXSA9IDJdID0gXCJNQVBfV1JJVEVcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIkNPUFlfU1JDXCJdID0gNF0gPSBcIkNPUFlfU1JDXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJDT1BZX0RTVFwiXSA9IDhdID0gXCJDT1BZX0RTVFwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiSU5ERVhcIl0gPSAxNl0gPSBcIklOREVYXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJWRVJURVhcIl0gPSAzMl0gPSBcIlZFUlRFWFwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiVU5JRk9STVwiXSA9IDY0XSA9IFwiVU5JRk9STVwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiU1RPUkFHRVwiXSA9IDEyOF0gPSBcIlNUT1JBR0VcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIklORElSRUNUXCJdID0gMjU2XSA9IFwiSU5ESVJFQ1RcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIlFVRVJZX1JFU09MVkVcIl0gPSA1MTJdID0gXCJRVUVSWV9SRVNPTFZFXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJTVEFUSUNcIl0gPSAxMDI0XSA9IFwiU1RBVElDXCI7XG4gIHJldHVybiBCdWZmZXJVc2FnZTI7XG59KShCdWZmZXJVc2FnZSB8fCB7fSk7XG5cbmV4cG9ydCB7IEJ1ZmZlclVzYWdlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5324\n')},6633:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ fastCopy)\n/* harmony export */ });\n\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\n\n//# sourceMappingURL=fastCopy.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYzMy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci91dGlscy9mYXN0Q29weS5tanM/ZGQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGZhc3RDb3B5KHNvdXJjZUJ1ZmZlciwgZGVzdGluYXRpb25CdWZmZXIpIHtcbiAgY29uc3QgbGVuZ3RoRG91YmxlID0gc291cmNlQnVmZmVyLmJ5dGVMZW5ndGggLyA4IHwgMDtcbiAgY29uc3Qgc291cmNlRmxvYXQ2NFZpZXcgPSBuZXcgRmxvYXQ2NEFycmF5KHNvdXJjZUJ1ZmZlciwgMCwgbGVuZ3RoRG91YmxlKTtcbiAgY29uc3QgZGVzdGluYXRpb25GbG9hdDY0VmlldyA9IG5ldyBGbG9hdDY0QXJyYXkoZGVzdGluYXRpb25CdWZmZXIsIDAsIGxlbmd0aERvdWJsZSk7XG4gIGRlc3RpbmF0aW9uRmxvYXQ2NFZpZXcuc2V0KHNvdXJjZUZsb2F0NjRWaWV3KTtcbiAgY29uc3QgcmVtYWluaW5nQnl0ZXMgPSBzb3VyY2VCdWZmZXIuYnl0ZUxlbmd0aCAtIGxlbmd0aERvdWJsZSAqIDg7XG4gIGlmIChyZW1haW5pbmdCeXRlcyA+IDApIHtcbiAgICBjb25zdCBzb3VyY2VVaW50OFZpZXcgPSBuZXcgVWludDhBcnJheShzb3VyY2VCdWZmZXIsIGxlbmd0aERvdWJsZSAqIDgsIHJlbWFpbmluZ0J5dGVzKTtcbiAgICBjb25zdCBkZXN0aW5hdGlvblVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KGRlc3RpbmF0aW9uQnVmZmVyLCBsZW5ndGhEb3VibGUgKiA4LCByZW1haW5pbmdCeXRlcyk7XG4gICAgZGVzdGluYXRpb25VaW50OFZpZXcuc2V0KHNvdXJjZVVpbnQ4Vmlldyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgZmFzdENvcHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhc3RDb3B5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6633\n")},1980:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Z: () => (/* binding */ Geometry)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs\nvar Buffer = __webpack_require__(7494);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs\nvar buffer_const = __webpack_require__(5324);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs\n\n\n\n"use strict";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer/* Buffer */.l)) {\n    let usage = index ? buffer_const/* BufferUsage */.F.INDEX : buffer_const/* BufferUsage */.F.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = buffer_const/* BufferUsage */.F.INDEX | buffer_const/* BufferUsage */.F.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = buffer_const/* BufferUsage */.F.VERTEX | buffer_const/* BufferUsage */.F.COPY_DST;\n      }\n    }\n    buffer = new Buffer/* Buffer */.l({\n      data: buffer,\n      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",\n      usage\n    });\n  }\n  return buffer;\n}\n\n\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs\n\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\n\n//# sourceMappingURL=getGeometryBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs\n\n\n\n\n\n\n\n"use strict";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer/* Buffer */.l || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends eventemitter3/* default */.Z {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options) {\n    const { attributes, indexBuffer, topology } = options;\n    super();\n    /** The unique id of the geometry. */\n    this.uid = (0,uid/* uid */.h)("geometry");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._boundsDirty = true;\n    this.attributes = attributes;\n    this.buffers = [];\n    this.instanceCount = options.instanceCount || 1;\n    for (const i in attributes) {\n      const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n      const bufferIndex = this.buffers.indexOf(attribute.buffer);\n      if (bufferIndex === -1) {\n        this.buffers.push(attribute.buffer);\n        attribute.buffer.on("update", this.onBufferUpdate, this);\n        attribute.buffer.on("change", this.onBufferUpdate, this);\n      }\n    }\n    if (indexBuffer) {\n      this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n      this.buffers.push(this.indexBuffer);\n    }\n    this.topology = topology || "triangle-list";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit("update", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, "aPosition", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\n\n//# sourceMappingURL=Geometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNJOztBQUVyRDtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFNO0FBQ2hDLHdCQUF3QiwrQkFBVyxTQUFTLCtCQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBVyxTQUFTLCtCQUFXO0FBQy9DLFFBQVE7QUFDUjtBQUNBLGdCQUFnQiwrQkFBVyxVQUFVLCtCQUFXO0FBQ2hEO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQzFCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCOzs7QUN0Q3lDO0FBQzhCO0FBQ2xCO0FBQ1A7QUFDYztBQUNNOztBQUVsRTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBLGVBQWUsa0JBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvZW5zdXJlSXNCdWZmZXIubWpzPzkwM2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy9nZXRHZW9tZXRyeUJvdW5kcy5tanM/NmJmZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcz8wNDE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uLy4uL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IEJ1ZmZlclVzYWdlIH0gZnJvbSAnLi4vLi4vYnVmZmVyL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZW5zdXJlSXNCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgbGV0IHVzYWdlID0gaW5kZXggPyBCdWZmZXJVc2FnZS5JTkRFWCA6IEJ1ZmZlclVzYWdlLlZFUlRFWDtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGlmIChpbmRleCkge1xuICAgICAgICBidWZmZXIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgdXNhZ2UgPSBCdWZmZXJVc2FnZS5JTkRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICB1c2FnZSA9IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IGJ1ZmZlcixcbiAgICAgIGxhYmVsOiBpbmRleCA/IFwiaW5kZXgtbWVzaC1idWZmZXJcIiA6IFwidmVydGV4LW1lc2gtYnVmZmVyXCIsXG4gICAgICB1c2FnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmV4cG9ydCB7IGVuc3VyZUlzQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnN1cmVJc0J1ZmZlci5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldEdlb21ldHJ5Qm91bmRzKGdlb21ldHJ5LCBhdHRyaWJ1dGVJZCwgYm91bmRzKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVJZCk7XG4gIGlmICghYXR0cmlidXRlKSB7XG4gICAgYm91bmRzLm1pblggPSAwO1xuICAgIGJvdW5kcy5taW5ZID0gMDtcbiAgICBib3VuZHMubWF4WCA9IDA7XG4gICAgYm91bmRzLm1heFkgPSAwO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbiAgY29uc3QgZGF0YSA9IGF0dHJpYnV0ZS5idWZmZXIuZGF0YTtcbiAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgbGV0IG1pblkgPSBJbmZpbml0eTtcbiAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gIGxldCBtYXhZID0gLUluZmluaXR5O1xuICBjb25zdCBieXRlU2l6ZSA9IGRhdGEuQllURVNfUEVSX0VMRU1FTlQ7XG4gIGNvbnN0IG9mZnNldCA9IChhdHRyaWJ1dGUub2Zmc2V0IHx8IDApIC8gYnl0ZVNpemU7XG4gIGNvbnN0IHN0cmlkZSA9IChhdHRyaWJ1dGUuc3RyaWRlIHx8IDIgKiA0KSAvIGJ5dGVTaXplO1xuICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeCA9IGRhdGFbaV07XG4gICAgY29uc3QgeSA9IGRhdGFbaSArIDFdO1xuICAgIGlmICh4ID4gbWF4WClcbiAgICAgIG1heFggPSB4O1xuICAgIGlmICh5ID4gbWF4WSlcbiAgICAgIG1heFkgPSB5O1xuICAgIGlmICh4IDwgbWluWClcbiAgICAgIG1pblggPSB4O1xuICAgIGlmICh5IDwgbWluWSlcbiAgICAgIG1pblkgPSB5O1xuICB9XG4gIGJvdW5kcy5taW5YID0gbWluWDtcbiAgYm91bmRzLm1pblkgPSBtaW5ZO1xuICBib3VuZHMubWF4WCA9IG1heFg7XG4gIGJvdW5kcy5tYXhZID0gbWF4WTtcbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZXhwb3J0IHsgZ2V0R2VvbWV0cnlCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEdlb21ldHJ5Qm91bmRzLm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IGVuc3VyZUlzQnVmZmVyIH0gZnJvbSAnLi91dGlscy9lbnN1cmVJc0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgZ2V0R2VvbWV0cnlCb3VuZHMgfSBmcm9tICcuL3V0aWxzL2dldEdlb21ldHJ5Qm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZW5zdXJlSXNBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gIGlmIChhdHRyaWJ1dGUgaW5zdGFuY2VvZiBCdWZmZXIgfHwgQXJyYXkuaXNBcnJheShhdHRyaWJ1dGUpIHx8IGF0dHJpYnV0ZS5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgIGJ1ZmZlcjogYXR0cmlidXRlXG4gICAgfTtcbiAgfVxuICBhdHRyaWJ1dGUuYnVmZmVyID0gZW5zdXJlSXNCdWZmZXIoYXR0cmlidXRlLmJ1ZmZlciwgZmFsc2UpO1xuICByZXR1cm4gYXR0cmlidXRlO1xufVxuY2xhc3MgR2VvbWV0cnkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgZ2VvbWV0cnlcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGdlb21ldHJ5LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXR0cmlidXRlcywgaW5kZXhCdWZmZXIsIHRvcG9sb2d5IH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIFRoZSB1bmlxdWUgaWQgb2YgdGhlIGdlb21ldHJ5LiAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwiZ2VvbWV0cnlcIik7XG4gICAgLyoqXG4gICAgICogdGhlIGxheW91dCBrZXkgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgV2ViR1BVIGFsbCBnZW9tZXRyaWVzIHRoYXQgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmVcbiAgICAgKiB3aWxsIGhhdmUgdGhlIHNhbWUgbGF5b3V0IGtleS4gVGhpcyBpcyB1c2VkIHRvIGNhY2hlIHRoZSBwaXBlbGluZSBsYXlvdXRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fbGF5b3V0S2V5ID0gMDtcbiAgICAvKiogdGhlIGluc3RhbmNlIGNvdW50IG9mIHRoZSBnZW9tZXRyeSB0byBkcmF3ICovXG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gMTtcbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gb3B0aW9ucy5pbnN0YW5jZUNvdW50IHx8IDE7XG4gICAgZm9yIChjb25zdCBpIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV0gPSBlbnN1cmVJc0F0dHJpYnV0ZShhdHRyaWJ1dGVzW2ldKTtcbiAgICAgIGNvbnN0IGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmluZGV4T2YoYXR0cmlidXRlLmJ1ZmZlcik7XG4gICAgICBpZiAoYnVmZmVySW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGF0dHJpYnV0ZS5idWZmZXIpO1xuICAgICAgICBhdHRyaWJ1dGUuYnVmZmVyLm9uKFwidXBkYXRlXCIsIHRoaXMub25CdWZmZXJVcGRhdGUsIHRoaXMpO1xuICAgICAgICBhdHRyaWJ1dGUuYnVmZmVyLm9uKFwiY2hhbmdlXCIsIHRoaXMub25CdWZmZXJVcGRhdGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5kZXhCdWZmZXIpIHtcbiAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBlbnN1cmVJc0J1ZmZlcihpbmRleEJ1ZmZlciwgdHJ1ZSk7XG4gICAgICB0aGlzLmJ1ZmZlcnMucHVzaCh0aGlzLmluZGV4QnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy50b3BvbG9neSA9IHRvcG9sb2d5IHx8IFwidHJpYW5nbGUtbGlzdFwiO1xuICB9XG4gIG9uQnVmZmVyVXBkYXRlKCkge1xuICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgcmVxdWlyZWRcbiAgICogQHJldHVybnMgLSBUaGUgYXR0cmlidXRlIHJlcXVlc3RlZC5cbiAgICovXG4gIGdldEF0dHJpYnV0ZShpZCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbaWRdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBidWZmZXJcbiAgICogQHJldHVybnMgLSBUaGUgaW5kZXggYnVmZmVyLlxuICAgKi9cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCBidWZmZXIuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBidWZmZXIgcmVxdWlyZWQuXG4gICAqIEByZXR1cm5zIC0gVGhlIGJ1ZmZlciByZXF1ZXN0ZWQuXG4gICAqL1xuICBnZXRCdWZmZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoaWQpLmJ1ZmZlcjtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBmaWd1cmUgb3V0IGhvdyBtYW55IHZlcnRpY2VzIHRoZXJlIGFyZSBpbiB0aGlzIGdlb21ldHJ5XG4gICAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGdlb21ldHJ5XG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1tpXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGF0dHJpYnV0ZS5idWZmZXI7XG4gICAgICByZXR1cm4gYnVmZmVyLmRhdGEubGVuZ3RoIC8gKGF0dHJpYnV0ZS5zdHJpZGUgLyA0IHx8IGF0dHJpYnV0ZS5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgZ2VvbWV0cnkuICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgaWYgKCF0aGlzLl9ib3VuZHNEaXJ0eSlcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSBmYWxzZTtcbiAgICByZXR1cm4gZ2V0R2VvbWV0cnlCb3VuZHModGhpcywgXCJhUG9zaXRpb25cIiwgdGhpcy5fYm91bmRzKTtcbiAgfVxuICAvKipcbiAgICogZGVzdHJveXMgdGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0gZGVzdHJveUJ1ZmZlcnMgLSBkZXN0cm95IHRoZSBidWZmZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGdlb21ldHJ5XG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lCdWZmZXJzID0gZmFsc2UpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgaWYgKGRlc3Ryb3lCdWZmZXJzKSB7XG4gICAgICB0aGlzLmJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiBidWZmZXIuZGVzdHJveSgpKTtcbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1980\n')},2475:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ STENCIL_MODES),\n/* harmony export */   f: () => (/* binding */ BLEND_TO_NPM)\n/* harmony export */ });\n\nconst BLEND_TO_NPM = {\n  normal: "normal-npm",\n  add: "add-npm",\n  screen: "screen-npm"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";\n  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";\n  STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";\n  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";\n  STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3NS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFaUI7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL2NvbnN0Lm1qcz8wNDdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQkxFTkRfVE9fTlBNID0ge1xuICBub3JtYWw6IFwibm9ybWFsLW5wbVwiLFxuICBhZGQ6IFwiYWRkLW5wbVwiLFxuICBzY3JlZW46IFwic2NyZWVuLW5wbVwiXG59O1xudmFyIFNURU5DSUxfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChTVEVOQ0lMX01PREVTMikgPT4ge1xuICBTVEVOQ0lMX01PREVTMltTVEVOQ0lMX01PREVTMltcIkRJU0FCTEVEXCJdID0gMF0gPSBcIkRJU0FCTEVEXCI7XG4gIFNURU5DSUxfTU9ERVMyW1NURU5DSUxfTU9ERVMyW1wiUkVOREVSSU5HX01BU0tfQUREXCJdID0gMV0gPSBcIlJFTkRFUklOR19NQVNLX0FERFwiO1xuICBTVEVOQ0lMX01PREVTMltTVEVOQ0lMX01PREVTMltcIk1BU0tfQUNUSVZFXCJdID0gMl0gPSBcIk1BU0tfQUNUSVZFXCI7XG4gIFNURU5DSUxfTU9ERVMyW1NURU5DSUxfTU9ERVMyW1wiUkVOREVSSU5HX01BU0tfUkVNT1ZFXCJdID0gM10gPSBcIlJFTkRFUklOR19NQVNLX1JFTU9WRVwiO1xuICBTVEVOQ0lMX01PREVTMltTVEVOQ0lMX01PREVTMltcIk5PTkVcIl0gPSA0XSA9IFwiTk9ORVwiO1xuICByZXR1cm4gU1RFTkNJTF9NT0RFUzI7XG59KShTVEVOQ0lMX01PREVTIHx8IHt9KTtcblxuZXhwb3J0IHsgQkxFTkRfVE9fTlBNLCBTVEVOQ0lMX01PREVTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2475\n')},131:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ CanvasPool)\n/* harmony export */ });\n/* unused harmony export CanvasPoolClass */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4181);\n\n\n\n"use strict";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext("2d");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minWidth);\n    minHeight = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .a9)(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const { width, height } = canvasAndContext.canvas;\n    const key = (width << 17) + (height << 1);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\n\n//# sourceMappingURL=CanvasPool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRTtBQUNOOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0VBQVE7QUFDdkIsZ0JBQWdCLHdFQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzPzg3ODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IG5leHRQb3cyIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWlzYy9wb3cyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ2FudmFzUG9vbENsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzT3B0aW9ucykge1xuICAgIHRoaXMuX2NhbnZhc1Bvb2wgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNhbnZhc09wdGlvbnMgPSBjYW52YXNPcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZW5hYmxlRnVsbFNjcmVlbiA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHR1cmUgd2l0aCBwYXJhbXMgdGhhdCB3ZXJlIHNwZWNpZmllZCBpbiBwb29sIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gcGl4ZWxXaWR0aCAtIFdpZHRoIG9mIHRleHR1cmUgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0gcGl4ZWxIZWlnaHQgLSBIZWlnaHQgb2YgdGV4dHVyZSBpbiBwaXhlbHMuXG4gICAqL1xuICBfY3JlYXRlQ2FudmFzQW5kQ29udGV4dChwaXhlbFdpZHRoLCBwaXhlbEhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gcGl4ZWxXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcGl4ZWxIZWlnaHQ7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgcmV0dXJuIHsgY2FudmFzLCBjb250ZXh0IH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBQb3dlci1vZi1Ud28gcmVuZGVyIHRleHR1cmUgb3IgZnVsbFNjcmVlbiB0ZXh0dXJlXG4gICAqIEBwYXJhbSBtaW5XaWR0aCAtIFRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIG1pbkhlaWdodCAtIFRoZSBtaW5pbXVtIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcmV0dXJucyBUaGUgbmV3IHJlbmRlciB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0T3B0aW1hbENhbnZhc0FuZENvbnRleHQobWluV2lkdGgsIG1pbkhlaWdodCwgcmVzb2x1dGlvbiA9IDEpIHtcbiAgICBtaW5XaWR0aCA9IE1hdGguY2VpbChtaW5XaWR0aCAqIHJlc29sdXRpb24gLSAxZS02KTtcbiAgICBtaW5IZWlnaHQgPSBNYXRoLmNlaWwobWluSGVpZ2h0ICogcmVzb2x1dGlvbiAtIDFlLTYpO1xuICAgIG1pbldpZHRoID0gbmV4dFBvdzIobWluV2lkdGgpO1xuICAgIG1pbkhlaWdodCA9IG5leHRQb3cyKG1pbkhlaWdodCk7XG4gICAgY29uc3Qga2V5ID0gKG1pbldpZHRoIDw8IDE3KSArIChtaW5IZWlnaHQgPDwgMSk7XG4gICAgaWYgKCF0aGlzLl9jYW52YXNQb29sW2tleV0pIHtcbiAgICAgIHRoaXMuX2NhbnZhc1Bvb2xba2V5XSA9IFtdO1xuICAgIH1cbiAgICBsZXQgY2FudmFzQW5kQ29udGV4dCA9IHRoaXMuX2NhbnZhc1Bvb2xba2V5XS5wb3AoKTtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQpIHtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQgPSB0aGlzLl9jcmVhdGVDYW52YXNBbmRDb250ZXh0KG1pbldpZHRoLCBtaW5IZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzQW5kQ29udGV4dDtcbiAgfVxuICAvKipcbiAgICogUGxhY2UgYSByZW5kZXIgdGV4dHVyZSBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSBjYW52YXNBbmRDb250ZXh0XG4gICAqL1xuICByZXR1cm5DYW52YXNBbmRDb250ZXh0KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNhbnZhc0FuZENvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IGtleSA9ICh3aWR0aCA8PCAxNykgKyAoaGVpZ2h0IDw8IDEpO1xuICAgIHRoaXMuX2NhbnZhc1Bvb2xba2V5XS5wdXNoKGNhbnZhc0FuZENvbnRleHQpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2NhbnZhc1Bvb2wgPSB7fTtcbiAgfVxufVxuY29uc3QgQ2FudmFzUG9vbCA9IG5ldyBDYW52YXNQb29sQ2xhc3MoKTtcblxuZXhwb3J0IHsgQ2FudmFzUG9vbCwgQ2FudmFzUG9vbENsYXNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNQb29sLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///131\n')},9131:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ maxRecommendedTextures)\n/* harmony export */ });\n/* harmony import */ var _gl_shader_program_getTestContext_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8407);\n\n\n"use strict";\nlet maxRecommendedTexturesCache = null;\nfunction maxRecommendedTextures() {\n  if (maxRecommendedTexturesCache)\n    return maxRecommendedTexturesCache;\n  const gl = (0,_gl_shader_program_getTestContext_mjs__WEBPACK_IMPORTED_MODULE_0__/* .getTestContext */ .K)();\n  maxRecommendedTexturesCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  return maxRecommendedTexturesCache;\n}\n\n\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEzMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQStFOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRWtDO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3V0aWxzL21heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzPzdiNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VGVzdENvbnRleHQgfSBmcm9tICcuLi8uLi8uLi9nbC9zaGFkZXIvcHJvZ3JhbS9nZXRUZXN0Q29udGV4dC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCBtYXhSZWNvbW1lbmRlZFRleHR1cmVzQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gbWF4UmVjb21tZW5kZWRUZXh0dXJlcygpIHtcbiAgaWYgKG1heFJlY29tbWVuZGVkVGV4dHVyZXNDYWNoZSlcbiAgICByZXR1cm4gbWF4UmVjb21tZW5kZWRUZXh0dXJlc0NhY2hlO1xuICBjb25zdCBnbCA9IGdldFRlc3RDb250ZXh0KCk7XG4gIG1heFJlY29tbWVuZGVkVGV4dHVyZXNDYWNoZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gIHJldHVybiBtYXhSZWNvbW1lbmRlZFRleHR1cmVzQ2FjaGU7XG59XG5cbmV4cG9ydCB7IG1heFJlY29tbWVuZGVkVGV4dHVyZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9131\n')},5765:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: () => (/* binding */ RendererType)\n/* harmony export */ });\n\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";\n  RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";\n  RendererType2[RendererType2["BOTH"] = 3] = "BOTH";\n  return RendererType2;\n})(RendererType || {});\n\n\n//# sourceMappingURL=types.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc2NS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFRztBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy90eXBlcy5tanM/MmMyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBSZW5kZXJlclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZW5kZXJlclR5cGUyKSA9PiB7XG4gIFJlbmRlcmVyVHlwZTJbUmVuZGVyZXJUeXBlMltcIldFQkdMXCJdID0gMV0gPSBcIldFQkdMXCI7XG4gIFJlbmRlcmVyVHlwZTJbUmVuZGVyZXJUeXBlMltcIldFQkdQVVwiXSA9IDJdID0gXCJXRUJHUFVcIjtcbiAgUmVuZGVyZXJUeXBlMltSZW5kZXJlclR5cGUyW1wiQk9USFwiXSA9IDNdID0gXCJCT1RIXCI7XG4gIHJldHVybiBSZW5kZXJlclR5cGUyO1xufSkoUmVuZGVyZXJUeXBlIHx8IHt9KTtcblxuZXhwb3J0IHsgUmVuZGVyZXJUeXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5765\n')},9010:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs + 11 modules\nvar GraphicsContextSystem = __webpack_require__(4108);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(6798);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs + 1 modules\nvar BatchableGraphics = __webpack_require__(8859);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs\n\n\n\n\n\n\n"use strict";\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State/* State */.Z.for2d();\n    // batchable graphics list, used to render batches\n    this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics._didGraphicsUpdate) {\n      graphics._didGraphicsUpdate = false;\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const batches = this._graphicsBatchesHash[graphics.uid];\n    if (batches) {\n      for (let i = 0; i < batches.length; i++) {\n        const batch = batches[i];\n        batch.batcher.updateElement(batch);\n      }\n    }\n  }\n  destroyRenderable(graphics) {\n    if (this._graphicsBatchesHash[graphics.uid]) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (wasBatched) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n    if (gpuContext.isBatchable) {\n      this._initBatchesForRenderable(graphics);\n    }\n    graphics.batched = gpuContext.isBatchable;\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getBatchesForRenderable(graphics);\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getBatchesForRenderable(graphics) {\n    return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n  }\n  _initBatchesForRenderable(graphics) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    const batches = gpuContext.batches.map((batch) => {\n      const batchClone = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n    if (this._graphicsBatchesHash[graphics.uid] === void 0) {\n      graphics.on("destroyed", () => {\n        this.destroyRenderable(graphics);\n      });\n    }\n    this._graphicsBatchesHash[graphics.uid] = batches;\n    return batches;\n  }\n  _removeBatchForRenderable(graphicsUid) {\n    this._graphicsBatchesHash[graphicsUid].forEach((batch) => {\n      PoolGroup/* BigPool */.u.return(batch);\n    });\n    this._graphicsBatchesHash[graphicsUid] = null;\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n    for (const i in this._graphicsBatchesHash) {\n      this._removeBatchForRenderable(i);\n    }\n    this._graphicsBatchesHash = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "graphics"\n};\n\n\n//# sourceMappingURL=GraphicsPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(GraphicsPipe);\nExtensions/* extensions */.Rw.add(GraphicsContextSystem/* GraphicsContextSystem */.hJ);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAxMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFtRTtBQUNTO0FBQ2hCO0FBQ0k7QUFDSjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBTyxLQUFLLDBDQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3QkFBTztBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEI7OztBQzlJNkQ7QUFDYztBQUNsQjs7QUFFekQ7QUFDQSw2QkFBVSxLQUFLLFlBQVk7QUFDM0IsNkJBQVUsS0FBSyxtREFBcUI7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljc1BpcGUubWpzPzg1OTAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9pbml0Lm1qcz85N2YyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvU3RhdGUubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSB9IGZyb20gJy4uL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlR3JhcGhpY3MgfSBmcm9tICcuL0JhdGNoYWJsZUdyYXBoaWNzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3JhcGhpY3NQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIsIGFkYXB0b3IpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgICAvLyBiYXRjaGFibGUgZ3JhcGhpY3MgbGlzdCwgdXNlZCB0byByZW5kZXIgYmF0Y2hlc1xuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fYWRhcHRvciA9IGFkYXB0b3I7XG4gICAgdGhpcy5fYWRhcHRvci5pbml0KCk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKGdyYXBoaWNzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmNvbnRleHQ7XG4gICAgY29uc3Qgd2FzQmF0Y2hlZCA9ICEhdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljcy51aWRdO1xuICAgIGNvbnN0IGdwdUNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmdyYXBoaWNzQ29udGV4dC51cGRhdGVHcHVDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChncHVDb250ZXh0LmlzQmF0Y2hhYmxlIHx8IHdhc0JhdGNoZWQgIT09IGdwdUNvbnRleHQuaXNCYXRjaGFibGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZShncmFwaGljcywgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gdGhpcy5yZW5kZXJlci5ncmFwaGljc0NvbnRleHQudXBkYXRlR3B1Q29udGV4dChncmFwaGljcy5jb250ZXh0KTtcbiAgICBpZiAoZ3JhcGhpY3MuX2RpZEdyYXBoaWNzVXBkYXRlKSB7XG4gICAgICBncmFwaGljcy5fZGlkR3JhcGhpY3NVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlYnVpbGQoZ3JhcGhpY3MpO1xuICAgIH1cbiAgICBpZiAoZ3B1Q29udGV4dC5pc0JhdGNoYWJsZSkge1xuICAgICAgdGhpcy5fYWRkVG9CYXRjaGVyKGdyYXBoaWNzLCBpbnN0cnVjdGlvblNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKGdyYXBoaWNzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF07XG4gICAgaWYgKGJhdGNoZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICAgIGJhdGNoLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKGdyYXBoaWNzKSB7XG4gICAgaWYgKHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXSkge1xuICAgICAgdGhpcy5fcmVtb3ZlQmF0Y2hGb3JSZW5kZXJhYmxlKGdyYXBoaWNzLnVpZCk7XG4gICAgfVxuICB9XG4gIGV4ZWN1dGUoZ3JhcGhpY3MpIHtcbiAgICBpZiAoIWdyYXBoaWNzLmlzUmVuZGVyYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmNvbnRleHQ7XG4gICAgY29uc3QgY29udGV4dFN5c3RlbSA9IHJlbmRlcmVyLmdyYXBoaWNzQ29udGV4dDtcbiAgICBpZiAoIWNvbnRleHRTeXN0ZW0uZ2V0R3B1Q29udGV4dChjb250ZXh0KS5iYXRjaGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaGFkZXIgPSBjb250ZXh0LmN1c3RvbVNoYWRlciB8fCB0aGlzLl9hZGFwdG9yLnNoYWRlcjtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IGdyYXBoaWNzLmdyb3VwQmxlbmRNb2RlO1xuICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSBzaGFkZXIucmVzb3VyY2VzLmxvY2FsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgbG9jYWxVbmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4ID0gZ3JhcGhpY3MuZ3JvdXBUcmFuc2Zvcm07XG4gICAgbG9jYWxVbmlmb3Jtcy51Um91bmQgPSByZW5kZXJlci5fcm91bmRQaXhlbHMgfCBncmFwaGljcy5fcm91bmRQaXhlbHM7XG4gICAgY29sb3IzMkJpdFRvVW5pZm9ybShcbiAgICAgIGdyYXBoaWNzLmdyb3VwQ29sb3JBbHBoYSxcbiAgICAgIGxvY2FsVW5pZm9ybXMudUNvbG9yLFxuICAgICAgMFxuICAgICk7XG4gICAgdGhpcy5fYWRhcHRvci5leGVjdXRlKHRoaXMsIGdyYXBoaWNzKTtcbiAgfVxuICBfcmVidWlsZChncmFwaGljcykge1xuICAgIGNvbnN0IHdhc0JhdGNoZWQgPSAhIXRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXTtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gdGhpcy5yZW5kZXJlci5ncmFwaGljc0NvbnRleHQudXBkYXRlR3B1Q29udGV4dChncmFwaGljcy5jb250ZXh0KTtcbiAgICBpZiAod2FzQmF0Y2hlZCkge1xuICAgICAgdGhpcy5fcmVtb3ZlQmF0Y2hGb3JSZW5kZXJhYmxlKGdyYXBoaWNzLnVpZCk7XG4gICAgfVxuICAgIGlmIChncHVDb250ZXh0LmlzQmF0Y2hhYmxlKSB7XG4gICAgICB0aGlzLl9pbml0QmF0Y2hlc0ZvclJlbmRlcmFibGUoZ3JhcGhpY3MpO1xuICAgIH1cbiAgICBncmFwaGljcy5iYXRjaGVkID0gZ3B1Q29udGV4dC5pc0JhdGNoYWJsZTtcbiAgfVxuICBfYWRkVG9CYXRjaGVyKGdyYXBoaWNzLCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGJhdGNoUGlwZSA9IHRoaXMucmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2g7XG4gICAgY29uc3QgYmF0Y2hlcyA9IHRoaXMuX2dldEJhdGNoZXNGb3JSZW5kZXJhYmxlKGdyYXBoaWNzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgIGJhdGNoUGlwZS5hZGRUb0JhdGNoKGJhdGNoLCBpbnN0cnVjdGlvblNldCk7XG4gICAgfVxuICB9XG4gIF9nZXRCYXRjaGVzRm9yUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIHJldHVybiB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF0gfHwgdGhpcy5faW5pdEJhdGNoZXNGb3JSZW5kZXJhYmxlKGdyYXBoaWNzKTtcbiAgfVxuICBfaW5pdEJhdGNoZXNGb3JSZW5kZXJhYmxlKGdyYXBoaWNzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmNvbnRleHQ7XG4gICAgY29uc3QgZ3B1Q29udGV4dCA9IHRoaXMucmVuZGVyZXIuZ3JhcGhpY3NDb250ZXh0LmdldEdwdUNvbnRleHQoY29udGV4dCk7XG4gICAgY29uc3Qgcm91bmRQaXhlbHMgPSB0aGlzLnJlbmRlcmVyLl9yb3VuZFBpeGVscyB8IGdyYXBoaWNzLl9yb3VuZFBpeGVscztcbiAgICBjb25zdCBiYXRjaGVzID0gZ3B1Q29udGV4dC5iYXRjaGVzLm1hcCgoYmF0Y2gpID0+IHtcbiAgICAgIGNvbnN0IGJhdGNoQ2xvbmUgPSBCaWdQb29sLmdldChCYXRjaGFibGVHcmFwaGljcyk7XG4gICAgICBiYXRjaC5jb3B5VG8oYmF0Y2hDbG9uZSk7XG4gICAgICBiYXRjaENsb25lLnJlbmRlcmFibGUgPSBncmFwaGljcztcbiAgICAgIGJhdGNoQ2xvbmUucm91bmRQaXhlbHMgPSByb3VuZFBpeGVscztcbiAgICAgIHJldHVybiBiYXRjaENsb25lO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF0gPT09IHZvaWQgMCkge1xuICAgICAgZ3JhcGhpY3Mub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3lSZW5kZXJhYmxlKGdyYXBoaWNzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF0gPSBiYXRjaGVzO1xuICAgIHJldHVybiBiYXRjaGVzO1xuICB9XG4gIF9yZW1vdmVCYXRjaEZvclJlbmRlcmFibGUoZ3JhcGhpY3NVaWQpIHtcbiAgICB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzVWlkXS5mb3JFYWNoKChiYXRjaCkgPT4ge1xuICAgICAgQmlnUG9vbC5yZXR1cm4oYmF0Y2gpO1xuICAgIH0pO1xuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3NVaWRdID0gbnVsbDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX2FkYXB0b3IuZGVzdHJveSgpO1xuICAgIHRoaXMuX2FkYXB0b3IgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoKSB7XG4gICAgICB0aGlzLl9yZW1vdmVCYXRjaEZvclJlbmRlcmFibGUoaSk7XG4gICAgfVxuICAgIHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2ggPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3JhcGhpY3NQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJncmFwaGljc1wiXG59O1xuXG5leHBvcnQgeyBHcmFwaGljc1BpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfSBmcm9tICcuL3NoYXJlZC9HcmFwaGljc0NvbnRleHRTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdyYXBoaWNzUGlwZSB9IGZyb20gJy4vc2hhcmVkL0dyYXBoaWNzUGlwZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKEdyYXBoaWNzUGlwZSk7XG5leHRlbnNpb25zLmFkZChHcmFwaGljc0NvbnRleHRTeXN0ZW0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9010\n')},8859:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  I: () => (/* binding */ BatchableGraphics)\n});\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs\n\nfunction multiplyHexColors(color1, color2) {\n  if (color1 === 16777215 || !color2)\n    return color2;\n  if (color2 === 16777215 || !color1)\n    return color1;\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 * r2 / 255;\n  const g = g1 * g2 / 255;\n  const b = b1 * b2 / 255;\n  return (r << 16) + (g << 8) + b;\n}\n\n\n//# sourceMappingURL=multiplyHexColors.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs\n\n\n"use strict";\nclass BatchableGraphics {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.applyTransform = true;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    if (this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return "normal";\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometryData.indices;\n    for (let i = 0; i < this.indexSize; i++) {\n      indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const geometry = this.geometryData;\n    const graphics = this.renderable;\n    const positions = geometry.vertices;\n    const uvs = geometry.uvs;\n    const offset = this.vertexOffset * 2;\n    const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n    const rgb = this.color;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    if (this.applyTransform) {\n      const argb = multiplyHexColors(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);\n      const wt = graphics.groupTransform;\n      const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n      const a = wt.a;\n      const b = wt.b;\n      const c = wt.c;\n      const d = wt.d;\n      const tx = wt.tx;\n      const ty = wt.ty;\n      for (let i = offset; i < vertSize; i += 2) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        float32View[index] = a * x + c * y + tx;\n        float32View[index + 1] = b * x + d * y + ty;\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        index += 6;\n      }\n    } else {\n      const argb = bgr + (this.alpha * 255 << 24);\n      for (let i = offset; i < vertSize; i += 2) {\n        float32View[index] = positions[i];\n        float32View[index + 1] = positions[i + 1];\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureId << 16;\n        index += 6;\n      }\n    }\n  }\n  // TODO rename to vertexSize\n  get vertSize() {\n    return this.vertexSize;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.vertexOffset = this.vertexOffset;\n    gpuBuffer.vertexSize = this.vertexSize;\n    gpuBuffer.color = this.color;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n  }\n  reset() {\n    this.applyTransform = true;\n  }\n}\n\n\n//# sourceMappingURL=BatchableGraphics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg1OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDN0I7OztBQ25CZ0Y7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvbXVsdGlwbHlIZXhDb2xvcnMubWpzP2RkM2EiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvQmF0Y2hhYmxlR3JhcGhpY3MubWpzPzgyMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBtdWx0aXBseUhleENvbG9ycyhjb2xvcjEsIGNvbG9yMikge1xuICBpZiAoY29sb3IxID09PSAxNjc3NzIxNSB8fCAhY29sb3IyKVxuICAgIHJldHVybiBjb2xvcjI7XG4gIGlmIChjb2xvcjIgPT09IDE2Nzc3MjE1IHx8ICFjb2xvcjEpXG4gICAgcmV0dXJuIGNvbG9yMTtcbiAgY29uc3QgcjEgPSBjb2xvcjEgPj4gMTYgJiAyNTU7XG4gIGNvbnN0IGcxID0gY29sb3IxID4+IDggJiAyNTU7XG4gIGNvbnN0IGIxID0gY29sb3IxICYgMjU1O1xuICBjb25zdCByMiA9IGNvbG9yMiA+PiAxNiAmIDI1NTtcbiAgY29uc3QgZzIgPSBjb2xvcjIgPj4gOCAmIDI1NTtcbiAgY29uc3QgYjIgPSBjb2xvcjIgJiAyNTU7XG4gIGNvbnN0IHIgPSByMSAqIHIyIC8gMjU1O1xuICBjb25zdCBnID0gZzEgKiBnMiAvIDI1NTtcbiAgY29uc3QgYiA9IGIxICogYjIgLyAyNTU7XG4gIHJldHVybiAociA8PCAxNikgKyAoZyA8PCA4KSArIGI7XG59XG5cbmV4cG9ydCB7IG11bHRpcGx5SGV4Q29sb3JzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBseUhleENvbG9ycy5tanMubWFwXG4iLCJpbXBvcnQgeyBtdWx0aXBseUhleENvbG9ycyB9IGZyb20gJy4uLy4uL2NvbnRhaW5lci91dGlscy9tdWx0aXBseUhleENvbG9ycy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJhdGNoYWJsZUdyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5iYXRjaGVyID0gbnVsbDtcbiAgICB0aGlzLmJhdGNoID0gbnVsbDtcbiAgICB0aGlzLmFwcGx5VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gMDtcbiAgfVxuICBnZXQgYmxlbmRNb2RlKCkge1xuICAgIGlmICh0aGlzLmFwcGx5VHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJhYmxlLmdyb3VwQmxlbmRNb2RlO1xuICAgIH1cbiAgICByZXR1cm4gXCJub3JtYWxcIjtcbiAgfVxuICBwYWNrSW5kZXgoaW5kZXhCdWZmZXIsIGluZGV4LCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuZ2VvbWV0cnlEYXRhLmluZGljZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4U2l6ZTsgaSsrKSB7XG4gICAgICBpbmRleEJ1ZmZlcltpbmRleCsrXSA9IGluZGljZXNbaSArIHRoaXMuaW5kZXhPZmZzZXRdICsgaW5kaWNlc09mZnNldCAtIHRoaXMudmVydGV4T2Zmc2V0O1xuICAgIH1cbiAgfVxuICBwYWNrQXR0cmlidXRlcyhmbG9hdDMyVmlldywgdWludDMyVmlldywgaW5kZXgsIHRleHR1cmVJZCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeURhdGE7XG4gICAgY29uc3QgZ3JhcGhpY3MgPSB0aGlzLnJlbmRlcmFibGU7XG4gICAgY29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgY29uc3QgdXZzID0gZ2VvbWV0cnkudXZzO1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMudmVydGV4T2Zmc2V0ICogMjtcbiAgICBjb25zdCB2ZXJ0U2l6ZSA9ICh0aGlzLnZlcnRleE9mZnNldCArIHRoaXMudmVydGV4U2l6ZSkgKiAyO1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuY29sb3I7XG4gICAgY29uc3QgYmdyID0gcmdiID4+IDE2IHwgcmdiICYgNjUyODAgfCAocmdiICYgMjU1KSA8PCAxNjtcbiAgICBpZiAodGhpcy5hcHBseVRyYW5zZm9ybSkge1xuICAgICAgY29uc3QgYXJnYiA9IG11bHRpcGx5SGV4Q29sb3JzKGJnciwgZ3JhcGhpY3MuZ3JvdXBDb2xvcikgKyAodGhpcy5hbHBoYSAqIGdyYXBoaWNzLmdyb3VwQWxwaGEgKiAyNTUgPDwgMjQpO1xuICAgICAgY29uc3Qgd3QgPSBncmFwaGljcy5ncm91cFRyYW5zZm9ybTtcbiAgICAgIGNvbnN0IHRleHR1cmVJZEFuZFJvdW5kID0gdGV4dHVyZUlkIDw8IDE2IHwgdGhpcy5yb3VuZFBpeGVscyAmIDY1NTM1O1xuICAgICAgY29uc3QgYSA9IHd0LmE7XG4gICAgICBjb25zdCBiID0gd3QuYjtcbiAgICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgICAgY29uc3QgZCA9IHd0LmQ7XG4gICAgICBjb25zdCB0eCA9IHd0LnR4O1xuICAgICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB2ZXJ0U2l6ZTsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb3NpdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IHkgPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICBmbG9hdDMyVmlld1tpbmRleF0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMV0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMl0gPSB1dnNbaV07XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgM10gPSB1dnNbaSArIDFdO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNF0gPSBhcmdiO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNV0gPSB0ZXh0dXJlSWRBbmRSb3VuZDtcbiAgICAgICAgaW5kZXggKz0gNjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXJnYiA9IGJnciArICh0aGlzLmFscGhhICogMjU1IDw8IDI0KTtcbiAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB2ZXJ0U2l6ZTsgaSArPSAyKSB7XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4XSA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxXSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMl0gPSB1dnNbaV07XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgM10gPSB1dnNbaSArIDFdO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNF0gPSBhcmdiO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNV0gPSB0ZXh0dXJlSWQgPDwgMTY7XG4gICAgICAgIGluZGV4ICs9IDY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFRPRE8gcmVuYW1lIHRvIHZlcnRleFNpemVcbiAgZ2V0IHZlcnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnRleFNpemU7XG4gIH1cbiAgY29weVRvKGdwdUJ1ZmZlcikge1xuICAgIGdwdUJ1ZmZlci5pbmRleE9mZnNldCA9IHRoaXMuaW5kZXhPZmZzZXQ7XG4gICAgZ3B1QnVmZmVyLmluZGV4U2l6ZSA9IHRoaXMuaW5kZXhTaXplO1xuICAgIGdwdUJ1ZmZlci52ZXJ0ZXhPZmZzZXQgPSB0aGlzLnZlcnRleE9mZnNldDtcbiAgICBncHVCdWZmZXIudmVydGV4U2l6ZSA9IHRoaXMudmVydGV4U2l6ZTtcbiAgICBncHVCdWZmZXIuY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGdwdUJ1ZmZlci5hbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgZ3B1QnVmZmVyLnRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgZ3B1QnVmZmVyLmdlb21ldHJ5RGF0YSA9IHRoaXMuZ2VvbWV0cnlEYXRhO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoYWJsZUdyYXBoaWNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaGFibGVHcmFwaGljcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8859\n')},6653:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  g: () => (/* binding */ GraphicsContext)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/parse-svg-path/index.js\nvar parse_svg_path = __webpack_require__(1379);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs\n\n\n\n"use strict";\nfunction SVGToGraphicsPath(svgPath, path) {\n  const commands = parse_svg_path(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case "M":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case "m":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case "H":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "h":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "V":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "v":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "L":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case "l":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case "C":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          lastX,\n          lastY\n        );\n        break;\n      case "c":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4],\n          lastX + data[5],\n          lastY + data[6]\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case "S":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case "s":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case "Q":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case "q":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case "T":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case "t":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case "A":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case "a":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case "Z":\n      case "z":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        (0,warn/* warn */.Z)(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== "Z" && type !== "z") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\n\n//# sourceMappingURL=SVGToGraphicsPath.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Circle.mjs\n\n\n"use strict";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'circle\'\n     */\n    this.type = "circle";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  strokeContains(x, y, width) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const r = this.radius;\n    const w2 = width / 2;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < r + w2 && distance > r - w2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=Circle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs\n\n\n"use strict";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'ellipse\'\n     */\n    this.type = "ellipse";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, width) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const halfStrokeWidth = width / 2;\n    const innerA = halfWidth - halfStrokeWidth;\n    const innerB = halfHeight - halfStrokeWidth;\n    const outerA = halfWidth + halfStrokeWidth;\n    const outerB = halfHeight + halfStrokeWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n    const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @returns The framing rectangle\n   */\n  getBounds() {\n    return new Rectangle/* Rectangle */.A(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\n\n//# sourceMappingURL=Ellipse.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs\n\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\n\n//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Polygon.mjs\n\n\n\n"use strict";\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'polygon\'\n     */\n    this.type = "polygon";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== "number") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth) {\n    const halfStrokeWidth = strokeWidth / 2;\n    const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n    const { points } = this;\n    const iterationLength = points.length - (this.closePath ? 0 : 2);\n    for (let i = 0; i < iterationLength; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      if (distanceSqrd <= halfStrokeWidthSqrd) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\n\n//# sourceMappingURL=Polygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs\n\n\n"use strict";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'roundedRectangle\'\n     */\n    this.type = "roundedRectangle";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(pX, pY, strokeWidth) {\n    const { x, y, width, height, radius } = this;\n    const halfStrokeWidth = strokeWidth / 2;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=RoundedRectangle.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs + 11 modules\nvar GraphicsContextSystem = __webpack_require__(4108);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs\n\n\n"use strict";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem/* GraphicsContextSystem */.hJ.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs\n\n\n"use strict";\nconst buildAdaptiveQuadratic_RECURSION_LIMIT = 8;\nconst buildAdaptiveQuadratic_FLT_EPSILON = 11920929e-14;\nconst buildAdaptiveQuadratic_PATH_DISTANCE_EPSILON = 1;\nconst buildAdaptiveQuadratic_curveAngleToleranceEpsilon = 0.01;\nconst buildAdaptiveQuadratic_mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem/* GraphicsContextSystem */.hJ.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (buildAdaptiveQuadratic_PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  buildAdaptiveQuadratic_begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction buildAdaptiveQuadratic_begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  buildAdaptiveQuadratic_recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction buildAdaptiveQuadratic_recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > buildAdaptiveQuadratic_RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > buildAdaptiveQuadratic_FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (buildAdaptiveQuadratic_mAngleTolerance < buildAdaptiveQuadratic_curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < buildAdaptiveQuadratic_mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  buildAdaptiveQuadratic_recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  buildAdaptiveQuadratic_recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs\n\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\n\n//# sourceMappingURL=buildArc.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs\n\n\n"use strict";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\n\n//# sourceMappingURL=buildArcTo.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs\n\n\n"use strict";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\n\n//# sourceMappingURL=buildArcToSvg.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs\n\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\n\n//# sourceMappingURL=roundShape.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempRectangle = new Rectangle/* Rectangle */.A();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc\'s center.\n   * @param y - The y-coordinate of the arc\'s center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse\'s x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc\'s end point.\n   * @param y - The y-coordinate of the arc\'s end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle/* Rectangle */.A(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon\'s vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle\'s corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (!lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\n\n//# sourceMappingURL=ShapePath.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs\n\n\n\n\n\n\n"use strict";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    this.uid = (0,uid/* uid */.h)("graphicsPath");\n    this._dirty = true;\n    if (typeof instructions === "string") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: "addPath", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: "arc", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: "arcTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: "arcToSvg", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: "bezierCurveTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point/* Point */.E.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== "bezierCurveTo") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: "closePath", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: "ellipse", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: "lineTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: "moveTo", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: "quadraticCurveTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point/* Point */.E.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== "quadraticCurveTo") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: "rect", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: "circle", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: "roundRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: "poly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: "regularPoly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: "roundPoly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: "roundShape", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: "filletRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: "chamferRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star\'s points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius = innerRadius || radius / 2;\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path\'s geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation\'s effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path\'s appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case "moveTo":\n        case "lineTo":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case "bezierCurveTo":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case "quadraticCurveTo":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case "arcToSvg":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case "circle":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case "rect":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case "ellipse":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case "roundRect":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case "addPath":\n          data[0].transform(matrix);\n          break;\n        case "poly":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          (0,warn/* warn */.Z)("unknown transform action", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path\'s current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point\'s position is accurately determined regardless of the path\'s complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point\'s coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point\'s coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === "closePath") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case "moveTo":\n      case "lineTo":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case "quadraticCurveTo":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case "bezierCurveTo":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case "arc":\n      case "arcToSvg":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case "addPath":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\n\n//# sourceMappingURL=GraphicsPath.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs\n\n\n\n"use strict";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === "string") {\n    const div = document.createElement("div");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector("svg");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case "path":\n      d = svg.getAttribute("d");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "circle":\n      cx = parseFloatAttribute(svg, "cx", 0);\n      cy = parseFloatAttribute(svg, "cy", 0);\n      r = parseFloatAttribute(svg, "r", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "rect":\n      x = parseFloatAttribute(svg, "x", 0);\n      y = parseFloatAttribute(svg, "y", 0);\n      width = parseFloatAttribute(svg, "width", 0);\n      height = parseFloatAttribute(svg, "height", 0);\n      rx = parseFloatAttribute(svg, "rx", 0);\n      ry = parseFloatAttribute(svg, "ry", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "ellipse":\n      cx = parseFloatAttribute(svg, "cx", 0);\n      cy = parseFloatAttribute(svg, "cy", 0);\n      rx = parseFloatAttribute(svg, "rx", 0);\n      ry = parseFloatAttribute(svg, "ry", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "line":\n      x1 = parseFloatAttribute(svg, "x1", 0);\n      y1 = parseFloatAttribute(svg, "y1", 0);\n      x2 = parseFloatAttribute(svg, "x2", 0);\n      y2 = parseFloatAttribute(svg, "y2", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "polygon":\n      pointsString = svg.getAttribute("points");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "polyline":\n      pointsString = svg.getAttribute("points");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "g":\n    case "svg":\n      break;\n    default: {\n      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute("style");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(";");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(":");\n      switch (key) {\n        case "stroke":\n          if (value !== "none") {\n            strokeStyle.color = Color/* Color */.I.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case "stroke-width":\n          strokeStyle.width = Number(value);\n          break;\n        case "fill":\n          if (value !== "none") {\n            useFill = true;\n            fillStyle.color = Color/* Color */.I.shared.setValue(value).toNumber();\n          }\n          break;\n        case "fill-opacity":\n          fillStyle.alpha = Number(value);\n          break;\n        case "stroke-opacity":\n          strokeStyle.alpha = Number(value);\n          break;\n        case "opacity":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute("stroke");\n    if (stroke && stroke !== "none") {\n      useStroke = true;\n      strokeStyle.color = Color/* Color */.I.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);\n    }\n    const fill = svg.getAttribute("fill");\n    if (fill && fill !== "none") {\n      useFill = true;\n      fillStyle.color = Color/* Color */.I.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\n\n\n//# sourceMappingURL=SVGParser.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs\nvar convertFillInputToFillStyle = __webpack_require__(4915);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tmpPoint = new Point/* Point */.E();\nconst tempMatrix = new Matrix/* Matrix */.y();\nconst _GraphicsContext = class _GraphicsContext extends eventemitter3/* default */.Z {\n  constructor() {\n    super(...arguments);\n    this.uid = (0,uid/* uid */.h)("graphicsContext");\n    this.dirty = true;\n    this.batchMode = "auto";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix/* Matrix */.y();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: "texture",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color/* Color */.I.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === "number") {\n        (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: "fill",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point/* Point */.E.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      this._strokeStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: "stroke",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc\'s center.\n   * @param y - The y-coordinate of the arc\'s center.\n   * @param radius - The arc\'s radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc\'s radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse\'s x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc\'s end point.\n   * @param y - The y-coordinate of the arc\'s end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === "moveTo") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle\'s corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon\'s vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star\'s points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix/* Matrix */.y) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix/* Matrix */.y) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this._activePath.clear();\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit("update", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === "fill") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === "texture") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === "stroke") {\n        const data = instruction.data;\n        const padding = data.style.width / 2;\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - padding,\n          _bounds.minY - padding,\n          _bounds.maxX + padding,\n          _bounds.maxY + padding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it\'s contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === "fill") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture/* Texture */.x.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: "butt",\n  /** The line join style to use. */\n  join: "miter",\n  /** The texture to use for the fill. */\n  texture: Texture/* Texture */.x.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\nlet GraphicsContext = _GraphicsContext;\n\n\n//# sourceMappingURL=GraphicsContext.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRLElBQUksT0FBTyxRQUFRLFlBQVksU0FBUyxhQUFhLFNBQVMsWUFBWTtBQUNqSTtBQUNBOztBQUU0QjtBQUM1Qjs7Ozs7QUM3SXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbURBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0VBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksU0FBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QyxxQkFBcUI7QUFDckIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3N2Zy9TVkdUb0dyYXBoaWNzUGF0aC5tanM/YTdiMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL3NoYXBlcy9DaXJjbGUubWpzPzI4MWEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvRWxsaXBzZS5tanM/NjU3NSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21pc2Mvc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudC5tanM/OTYxOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL3NoYXBlcy9Qb2x5Z29uLm1qcz8yZTI0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvbWF0aHMvc2hhcGVzL1JvdW5kZWRSZWN0YW5nbGUubWpzP2IxZjIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlQmV6aWVyLm1qcz8xNjMwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRBZGFwdGl2ZVF1YWRyYXRpYy5tanM/MDYzZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQXJjLm1qcz82NjUwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRBcmNUby5tanM/ZDc4NiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG9TdmcubWpzPzEyMjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvcGF0aC9yb3VuZFNoYXBlLm1qcz9iY2E4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3BhdGgvU2hhcGVQYXRoLm1qcz9iMDdmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3BhdGgvR3JhcGhpY3NQYXRoLm1qcz9mZTM0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3N2Zy9TVkdQYXJzZXIubWpzPzIwMmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NDb250ZXh0Lm1qcz83MjBjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXJzZSBmcm9tICdwYXJzZS1zdmctcGF0aCc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gU1ZHVG9HcmFwaGljc1BhdGgoc3ZnUGF0aCwgcGF0aCkge1xuICBjb25zdCBjb21tYW5kcyA9IHBhcnNlKHN2Z1BhdGgpO1xuICBjb25zdCBzdWJwYXRocyA9IFtdO1xuICBsZXQgY3VycmVudFN1YlBhdGggPSBudWxsO1xuICBsZXQgbGFzdFggPSAwO1xuICBsZXQgbGFzdFkgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29tbWFuZCA9IGNvbW1hbmRzW2ldO1xuICAgIGNvbnN0IHR5cGUgPSBjb21tYW5kWzBdO1xuICAgIGNvbnN0IGRhdGEgPSBjb21tYW5kO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgbGFzdFggPSBkYXRhWzFdO1xuICAgICAgICBsYXN0WSA9IGRhdGFbMl07XG4gICAgICAgIHBhdGgubW92ZVRvKGxhc3RYLCBsYXN0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgbGFzdFggKz0gZGF0YVsxXTtcbiAgICAgICAgbGFzdFkgKz0gZGF0YVsyXTtcbiAgICAgICAgcGF0aC5tb3ZlVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSFwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbMV07XG4gICAgICAgIHBhdGgubGluZVRvKGxhc3RYLCBsYXN0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgbGFzdFggKz0gZGF0YVsxXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVlwiOlxuICAgICAgICBsYXN0WSA9IGRhdGFbMV07XG4gICAgICAgIHBhdGgubGluZVRvKGxhc3RYLCBsYXN0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgbGFzdFkgKz0gZGF0YVsxXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbMV07XG4gICAgICAgIGxhc3RZID0gZGF0YVsyXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibFwiOlxuICAgICAgICBsYXN0WCArPSBkYXRhWzFdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzJdO1xuICAgICAgICBwYXRoLmxpbmVUbyhsYXN0WCwgbGFzdFkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVs1XTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzZdO1xuICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgZGF0YVsxXSxcbiAgICAgICAgICBkYXRhWzJdLFxuICAgICAgICAgIGRhdGFbM10sXG4gICAgICAgICAgZGF0YVs0XSxcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBsYXN0WCArIGRhdGFbMV0sXG4gICAgICAgICAgbGFzdFkgKyBkYXRhWzJdLFxuICAgICAgICAgIGxhc3RYICsgZGF0YVszXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbNF0sXG4gICAgICAgICAgbGFzdFggKyBkYXRhWzVdLFxuICAgICAgICAgIGxhc3RZICsgZGF0YVs2XVxuICAgICAgICApO1xuICAgICAgICBsYXN0WCArPSBkYXRhWzVdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzZdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVszXTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzRdO1xuICAgICAgICBwYXRoLmJlemllckN1cnZlVG9TaG9ydChcbiAgICAgICAgICBkYXRhWzFdLFxuICAgICAgICAgIGRhdGFbMl0sXG4gICAgICAgICAgbGFzdFgsXG4gICAgICAgICAgbGFzdFlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICBwYXRoLmJlemllckN1cnZlVG9TaG9ydChcbiAgICAgICAgICBsYXN0WCArIGRhdGFbMV0sXG4gICAgICAgICAgbGFzdFkgKyBkYXRhWzJdLFxuICAgICAgICAgIGxhc3RYICsgZGF0YVszXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbNF1cbiAgICAgICAgKTtcbiAgICAgICAgbGFzdFggKz0gZGF0YVszXTtcbiAgICAgICAgbGFzdFkgKz0gZGF0YVs0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUVwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbM107XG4gICAgICAgIGxhc3RZID0gZGF0YVs0XTtcbiAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGRhdGFbMV0sXG4gICAgICAgICAgZGF0YVsyXSxcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBsYXN0WCArIGRhdGFbMV0sXG4gICAgICAgICAgbGFzdFkgKyBkYXRhWzJdLFxuICAgICAgICAgIGxhc3RYICsgZGF0YVszXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbNF1cbiAgICAgICAgKTtcbiAgICAgICAgbGFzdFggKz0gZGF0YVszXTtcbiAgICAgICAgbGFzdFkgKz0gZGF0YVs0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVFwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbMV07XG4gICAgICAgIGxhc3RZID0gZGF0YVsyXTtcbiAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvU2hvcnQoXG4gICAgICAgICAgbGFzdFgsXG4gICAgICAgICAgbGFzdFlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidFwiOlxuICAgICAgICBsYXN0WCArPSBkYXRhWzFdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzJdO1xuICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG9TaG9ydChcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVs2XTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzddO1xuICAgICAgICBwYXRoLmFyY1RvU3ZnKFxuICAgICAgICAgIGRhdGFbMV0sXG4gICAgICAgICAgZGF0YVsyXSxcbiAgICAgICAgICBkYXRhWzNdLFxuICAgICAgICAgIGRhdGFbNF0sXG4gICAgICAgICAgZGF0YVs1XSxcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgIGxhc3RYICs9IGRhdGFbNl07XG4gICAgICAgIGxhc3RZICs9IGRhdGFbN107XG4gICAgICAgIHBhdGguYXJjVG9TdmcoXG4gICAgICAgICAgZGF0YVsxXSxcbiAgICAgICAgICBkYXRhWzJdLFxuICAgICAgICAgIGRhdGFbM10sXG4gICAgICAgICAgZGF0YVs0XSxcbiAgICAgICAgICBkYXRhWzVdLFxuICAgICAgICAgIGxhc3RYLFxuICAgICAgICAgIGxhc3RZXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlpcIjpcbiAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgIGlmIChzdWJwYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudFN1YlBhdGggPSBzdWJwYXRocy5wb3AoKTtcbiAgICAgICAgICBpZiAoY3VycmVudFN1YlBhdGgpIHtcbiAgICAgICAgICAgIGxhc3RYID0gY3VycmVudFN1YlBhdGguc3RhcnRYO1xuICAgICAgICAgICAgbGFzdFkgPSBjdXJyZW50U3ViUGF0aC5zdGFydFk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RYID0gMDtcbiAgICAgICAgICAgIGxhc3RZID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFN1YlBhdGggPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYFVua25vd24gU1ZHIHBhdGggY29tbWFuZDogJHt0eXBlfWApO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPT0gXCJaXCIgJiYgdHlwZSAhPT0gXCJ6XCIpIHtcbiAgICAgIGlmIChjdXJyZW50U3ViUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50U3ViUGF0aCA9IHsgc3RhcnRYOiBsYXN0WCwgc3RhcnRZOiBsYXN0WSB9O1xuICAgICAgICBzdWJwYXRocy5wdXNoKGN1cnJlbnRTdWJQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCB7IFNWR1RvR3JhcGhpY3NQYXRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TVkdUb0dyYXBoaWNzUGF0aC5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENpcmNsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHJhZGl1cyA9IDApIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICogQGRlZmF1bHQgJ2NpcmNsZSdcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcImNpcmNsZVwiO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgQ2lyY2xlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIEEgY29weSBvZiB0aGUgQ2lyY2xlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXG4gICAqL1xuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMucmFkaXVzIDw9IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcjIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuICAgIGxldCBkeCA9IHRoaXMueCAtIHg7XG4gICAgbGV0IGR5ID0gdGhpcy55IC0geTtcbiAgICBkeCAqPSBkeDtcbiAgICBkeSAqPSBkeTtcbiAgICByZXR1cm4gZHggKyBkeSA8PSByMjtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBjaXJjbGUgaW5jbHVkaW5nIHRoZSBzdHJva2UuXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXG4gICAqL1xuICBzdHJva2VDb250YWlucyh4LCB5LCB3aWR0aCkge1xuICAgIGlmICh0aGlzLnJhZGl1cyA9PT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBkeCA9IHRoaXMueCAtIHg7XG4gICAgY29uc3QgZHkgPSB0aGlzLnkgLSB5O1xuICAgIGNvbnN0IHIgPSB0aGlzLnJhZGl1cztcbiAgICBjb25zdCB3MiA9IHdpZHRoIC8gMjtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgcmV0dXJuIGRpc3RhbmNlIDwgciArIHcyICYmIGRpc3RhbmNlID4gciAtIHcyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgY2lyY2xlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgKiBAcGFyYW0gb3V0XG4gICAqIEByZXR1cm5zIFRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgKi9cbiAgZ2V0Qm91bmRzKG91dCkge1xuICAgIG91dCA9IG91dCB8fCBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgb3V0LnggPSB0aGlzLnggLSB0aGlzLnJhZGl1cztcbiAgICBvdXQueSA9IHRoaXMueSAtIHRoaXMucmFkaXVzO1xuICAgIG91dC53aWR0aCA9IHRoaXMucmFkaXVzICogMjtcbiAgICBvdXQuaGVpZ2h0ID0gdGhpcy5yYWRpdXMgKiAyO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhbm90aGVyIGNpcmNsZSB0byB0aGlzIG9uZS5cbiAgICogQHBhcmFtIGNpcmNsZSAtIFRoZSBjaXJjbGUgdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tKGNpcmNsZSkge1xuICAgIHRoaXMueCA9IGNpcmNsZS54O1xuICAgIHRoaXMueSA9IGNpcmNsZS55O1xuICAgIHRoaXMucmFkaXVzID0gY2lyY2xlLnJhZGl1cztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgY2lyY2xlIHRvIGFub3RoZXIgb25lLlxuICAgKiBAcGFyYW0gY2lyY2xlIC0gVGhlIGNpcmNsZSB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhjaXJjbGUpIHtcbiAgICBjaXJjbGUuY29weUZyb20odGhpcyk7XG4gICAgcmV0dXJuIGNpcmNsZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6Q2lyY2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHJhZGl1cz0ke3RoaXMucmFkaXVzfV1gO1xuICB9XG59XG5cbmV4cG9ydCB7IENpcmNsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2lyY2xlLm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4vUmVjdGFuZ2xlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRWxsaXBzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBlbGxpcHNlXG4gICAqIEBwYXJhbSBoYWxmV2lkdGggLSBUaGUgaGFsZiB3aWR0aCBvZiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIGhhbGZIZWlnaHQgLSBUaGUgaGFsZiBoZWlnaHQgb2YgdGhpcyBlbGxpcHNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIGhhbGZXaWR0aCA9IDAsIGhhbGZIZWlnaHQgPSAwKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAqIEBkZWZhdWx0ICdlbGxpcHNlJ1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFwiZWxsaXBzZVwiO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmhhbGZXaWR0aCA9IGhhbGZXaWR0aDtcbiAgICB0aGlzLmhhbGZIZWlnaHQgPSBoYWxmSGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBFbGxpcHNlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtFbGxpcHNlfSBBIGNvcHkgb2YgdGhlIGVsbGlwc2VcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgRWxsaXBzZSh0aGlzLngsIHRoaXMueSwgdGhpcy5oYWxmV2lkdGgsIHRoaXMuaGFsZkhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZHMgYXJlIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy5oYWxmV2lkdGggPD0gMCB8fCB0aGlzLmhhbGZIZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbm9ybXggPSAoeCAtIHRoaXMueCkgLyB0aGlzLmhhbGZXaWR0aDtcbiAgICBsZXQgbm9ybXkgPSAoeSAtIHRoaXMueSkgLyB0aGlzLmhhbGZIZWlnaHQ7XG4gICAgbm9ybXggKj0gbm9ybXg7XG4gICAgbm9ybXkgKj0gbm9ybXk7XG4gICAgcmV0dXJuIG5vcm14ICsgbm9ybXkgPD0gMTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBlbGxpcHNlIGluY2x1ZGluZyBzdHJva2VcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMoeCwgeSwgd2lkdGgpIHtcbiAgICBjb25zdCB7IGhhbGZXaWR0aCwgaGFsZkhlaWdodCB9ID0gdGhpcztcbiAgICBpZiAoaGFsZldpZHRoIDw9IDAgfHwgaGFsZkhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICBjb25zdCBpbm5lckEgPSBoYWxmV2lkdGggLSBoYWxmU3Ryb2tlV2lkdGg7XG4gICAgY29uc3QgaW5uZXJCID0gaGFsZkhlaWdodCAtIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCBvdXRlckEgPSBoYWxmV2lkdGggKyBoYWxmU3Ryb2tlV2lkdGg7XG4gICAgY29uc3Qgb3V0ZXJCID0gaGFsZkhlaWdodCArIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCBub3JtYWxpemVkWCA9IHggLSB0aGlzLng7XG4gICAgY29uc3Qgbm9ybWFsaXplZFkgPSB5IC0gdGhpcy55O1xuICAgIGNvbnN0IGlubmVyRWxsaXBzZSA9IG5vcm1hbGl6ZWRYICogbm9ybWFsaXplZFggLyAoaW5uZXJBICogaW5uZXJBKSArIG5vcm1hbGl6ZWRZICogbm9ybWFsaXplZFkgLyAoaW5uZXJCICogaW5uZXJCKTtcbiAgICBjb25zdCBvdXRlckVsbGlwc2UgPSBub3JtYWxpemVkWCAqIG5vcm1hbGl6ZWRYIC8gKG91dGVyQSAqIG91dGVyQSkgKyBub3JtYWxpemVkWSAqIG5vcm1hbGl6ZWRZIC8gKG91dGVyQiAqIG91dGVyQik7XG4gICAgcmV0dXJuIGlubmVyRWxsaXBzZSA+IDEgJiYgb3V0ZXJFbGxpcHNlIDw9IDE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBlbGxpcHNlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgKiBAcmV0dXJucyBUaGUgZnJhbWluZyByZWN0YW5nbGVcbiAgICovXG4gIGdldEJvdW5kcygpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLmhhbGZXaWR0aCwgdGhpcy55IC0gdGhpcy5oYWxmSGVpZ2h0LCB0aGlzLmhhbGZXaWR0aCAqIDIsIHRoaXMuaGFsZkhlaWdodCAqIDIpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYW5vdGhlciBlbGxpcHNlIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gZWxsaXBzZSAtIFRoZSBlbGxpcHNlIHRvIGNvcHkgZnJvbS5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBjb3B5RnJvbShlbGxpcHNlKSB7XG4gICAgdGhpcy54ID0gZWxsaXBzZS54O1xuICAgIHRoaXMueSA9IGVsbGlwc2UueTtcbiAgICB0aGlzLmhhbGZXaWR0aCA9IGVsbGlwc2UuaGFsZldpZHRoO1xuICAgIHRoaXMuaGFsZkhlaWdodCA9IGVsbGlwc2UuaGFsZkhlaWdodDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgZWxsaXBzZSB0byBhbm90aGVyIG9uZS5cbiAgICogQHBhcmFtIGVsbGlwc2UgLSBUaGUgZWxsaXBzZSB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhlbGxpcHNlKSB7XG4gICAgZWxsaXBzZS5jb3B5RnJvbSh0aGlzKTtcbiAgICByZXR1cm4gZWxsaXBzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6RWxsaXBzZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSBoYWxmV2lkdGg9JHt0aGlzLmhhbGZXaWR0aH0gaGFsZkhlaWdodD0ke3RoaXMuaGFsZkhlaWdodH1dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBFbGxpcHNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBhID0geCAtIHgxO1xuICBjb25zdCBiID0geSAtIHkxO1xuICBjb25zdCBjID0geDIgLSB4MTtcbiAgY29uc3QgZCA9IHkyIC0geTE7XG4gIGNvbnN0IGRvdCA9IGEgKiBjICsgYiAqIGQ7XG4gIGNvbnN0IGxlblNxID0gYyAqIGMgKyBkICogZDtcbiAgbGV0IHBhcmFtID0gLTE7XG4gIGlmIChsZW5TcSAhPT0gMCkge1xuICAgIHBhcmFtID0gZG90IC8gbGVuU3E7XG4gIH1cbiAgbGV0IHh4O1xuICBsZXQgeXk7XG4gIGlmIChwYXJhbSA8IDApIHtcbiAgICB4eCA9IHgxO1xuICAgIHl5ID0geTE7XG4gIH0gZWxzZSBpZiAocGFyYW0gPiAxKSB7XG4gICAgeHggPSB4MjtcbiAgICB5eSA9IHkyO1xuICB9IGVsc2Uge1xuICAgIHh4ID0geDEgKyBwYXJhbSAqIGM7XG4gICAgeXkgPSB5MSArIHBhcmFtICogZDtcbiAgfVxuICBjb25zdCBkeCA9IHggLSB4eDtcbiAgY29uc3QgZHkgPSB5IC0geXk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZXhwb3J0IHsgc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBzcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50IH0gZnJvbSAnLi4vbWlzYy9zcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50Lm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFBvbHlnb24ge1xuICAvKipcbiAgICogQHBhcmFtIHBvaW50cyAtIFRoaXMgY2FuIGJlIGFuIGFycmF5IG9mIFBvaW50c1xuICAgKiAgdGhhdCBmb3JtIHRoZSBwb2x5Z29uLCBhIGZsYXQgYXJyYXkgb2YgbnVtYmVycyB0aGF0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgW3gseSwgeCx5LCAuLi5dLCBvclxuICAgKiAgdGhlIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlIGFsbCB0aGUgcG9pbnRzIG9mIHRoZSBwb2x5Z29uIGUuZy5cbiAgICogIGBuZXcgUG9seWdvbihuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCksIC4uLilgLCBvciB0aGUgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmUgZmxhdFxuICAgKiAgeCx5IHZhbHVlcyBlLmcuIGBuZXcgUG9seWdvbih4LHksIHgseSwgeCx5LCAuLi4pYCB3aGVyZSBgeGAgYW5kIGB5YCBhcmUgTnVtYmVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLnBvaW50cykge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKiBAZGVmYXVsdCAncG9seWdvbidcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcInBvbHlnb25cIjtcbiAgICBsZXQgZmxhdCA9IEFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSA/IHBvaW50c1swXSA6IHBvaW50cztcbiAgICBpZiAodHlwZW9mIGZsYXRbMF0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHAgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGZsYXQubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBwLnB1c2goZmxhdFtpXS54LCBmbGF0W2ldLnkpO1xuICAgICAgfVxuICAgICAgZmxhdCA9IHA7XG4gICAgfVxuICAgIHRoaXMucG9pbnRzID0gZmxhdDtcbiAgICB0aGlzLmNsb3NlUGF0aCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb24uXG4gICAqIEByZXR1cm5zIC0gQSBjb3B5IG9mIHRoZSBwb2x5Z29uLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMuc2xpY2UoKTtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24ocG9pbnRzKTtcbiAgICBwb2x5Z29uLmNsb3NlUGF0aCA9IHRoaXMuY2xvc2VQYXRoO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdC5cbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvbi5cbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICAgIGNvbnN0IHhpID0gdGhpcy5wb2ludHNbaSAqIDJdO1xuICAgICAgY29uc3QgeWkgPSB0aGlzLnBvaW50c1tpICogMiArIDFdO1xuICAgICAgY29uc3QgeGogPSB0aGlzLnBvaW50c1tqICogMl07XG4gICAgICBjb25zdCB5aiA9IHRoaXMucG9pbnRzW2ogKiAyICsgMV07XG4gICAgICBjb25zdCBpbnRlcnNlY3QgPSB5aSA+IHkgIT09IHlqID4geSAmJiB4IDwgKHhqIC0geGkpICogKCh5IC0geWkpIC8gKHlqIC0geWkpKSArIHhpO1xuICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24gaW5jbHVkaW5nIHRoZSBzdHJva2UuXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHN0cm9rZVdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvblxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMoeCwgeSwgc3Ryb2tlV2lkdGgpIHtcbiAgICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3QgaGFsZlN0cm9rZVdpZHRoU3FyZCA9IGhhbGZTdHJva2VXaWR0aCAqIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCB7IHBvaW50cyB9ID0gdGhpcztcbiAgICBjb25zdCBpdGVyYXRpb25MZW5ndGggPSBwb2ludHMubGVuZ3RoIC0gKHRoaXMuY2xvc2VQYXRoID8gMCA6IDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uTGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHgxID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgeTEgPSBwb2ludHNbaSArIDFdO1xuICAgICAgY29uc3QgeDIgPSBwb2ludHNbKGkgKyAyKSAlIHBvaW50cy5sZW5ndGhdO1xuICAgICAgY29uc3QgeTIgPSBwb2ludHNbKGkgKyAzKSAlIHBvaW50cy5sZW5ndGhdO1xuICAgICAgY29uc3QgZGlzdGFuY2VTcXJkID0gc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICBpZiAoZGlzdGFuY2VTcXJkIDw9IGhhbGZTdHJva2VXaWR0aFNxcmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIHBvbHlnb24gYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4gICAqIEBwYXJhbSBvdXQgLSBvcHRpb25hbCByZWN0YW5nbGUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgKiBAcmV0dXJucyBUaGUgZnJhbWluZyByZWN0YW5nbGVcbiAgICovXG4gIGdldEJvdW5kcyhvdXQpIHtcbiAgICBvdXQgPSBvdXQgfHwgbmV3IFJlY3RhbmdsZSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGxldCBtaW5YID0gSW5maW5pdHk7XG4gICAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gICAgbGV0IG1pblkgPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICBjb25zdCB5ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIH1cbiAgICBvdXQueCA9IG1pblg7XG4gICAgb3V0LndpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgb3V0LnkgPSBtaW5ZO1xuICAgIG91dC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYW5vdGhlciBwb2x5Z29uIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcG9seWdvbiAtIFRoZSBwb2x5Z29uIHRvIGNvcHkgZnJvbS5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBjb3B5RnJvbShwb2x5Z29uKSB7XG4gICAgdGhpcy5wb2ludHMgPSBwb2x5Z29uLnBvaW50cy5zbGljZSgpO1xuICAgIHRoaXMuY2xvc2VQYXRoID0gcG9seWdvbi5jbG9zZVBhdGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGlzIHBvbHlnb24gdG8gYW5vdGhlciBvbmUuXG4gICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHBvbHlnb24gdG8gY29weSB0by5cbiAgICogQHJldHVybnMgUmV0dXJucyBnaXZlbiBwYXJhbWV0ZXIuXG4gICAqL1xuICBjb3B5VG8ocG9seWdvbikge1xuICAgIHBvbHlnb24uY29weUZyb20odGhpcyk7XG4gICAgcmV0dXJuIHBvbHlnb247XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbcGl4aS5qcy9tYXRoOlBvbHlnb25jbG9zZVN0cm9rZT0ke3RoaXMuY2xvc2VQYXRofXBvaW50cz0ke3RoaXMucG9pbnRzLnJlZHVjZSgocG9pbnRzRGVzYywgY3VycmVudFBvaW50KSA9PiBgJHtwb2ludHNEZXNjfSwgJHtjdXJyZW50UG9pbnR9YCwgXCJcIil9XWA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb25cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGFzdFgoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDJdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhc3QgWSBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGxhc3RZKCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAxXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb25cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMl07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgWSBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDFdO1xuICB9XG59XG5cbmV4cG9ydCB7IFBvbHlnb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvbHlnb24ubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi9SZWN0YW5nbGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc0Nvcm5lcldpdGhpblN0cm9rZSA9IChwWCwgcFksIGNvcm5lclgsIGNvcm5lclksIHJhZGl1cywgaGFsZlN0cm9rZVdpZHRoKSA9PiB7XG4gIGNvbnN0IGR4ID0gcFggLSBjb3JuZXJYO1xuICBjb25zdCBkeSA9IHBZIC0gY29ybmVyWTtcbiAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICByZXR1cm4gZGlzdGFuY2UgPj0gcmFkaXVzIC0gaGFsZlN0cm9rZVdpZHRoICYmIGRpc3RhbmNlIDw9IHJhZGl1cyArIGhhbGZTdHJva2VXaWR0aDtcbn07XG5jbGFzcyBSb3VuZGVkUmVjdGFuZ2xlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIGhlaWdodCAtIFRoZSBvdmVyYWxsIGhlaWdodCBvZiB0aGlzIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSByYWRpdXMgLSBDb250cm9scyB0aGUgcmFkaXVzIG9mIHRoZSByb3VuZGVkIGNvcm5lcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwLCByYWRpdXMgPSAyMCkge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKiBAZGVmYXVsdCAncm91bmRlZFJlY3RhbmdsZSdcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcInJvdW5kZWRSZWN0YW5nbGVcIjtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4gICAqIEBwYXJhbSBvdXQgLSBvcHRpb25hbCByZWN0YW5nbGUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgKiBAcmV0dXJucyBUaGUgZnJhbWluZyByZWN0YW5nbGVcbiAgICovXG4gIGdldEJvdW5kcyhvdXQpIHtcbiAgICBvdXQgPSBvdXQgfHwgbmV3IFJlY3RhbmdsZSgpO1xuICAgIG91dC54ID0gdGhpcy54O1xuICAgIG91dC55ID0gdGhpcy55O1xuICAgIG91dC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgb3V0LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyAtIEEgY29weSBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJvdW5kZWRSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLnJhZGl1cyk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhbm90aGVyIHJlY3RhbmdsZSB0byB0aGlzIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tKHJlY3RhbmdsZSkge1xuICAgIHRoaXMueCA9IHJlY3RhbmdsZS54O1xuICAgIHRoaXMueSA9IHJlY3RhbmdsZS55O1xuICAgIHRoaXMud2lkdGggPSByZWN0YW5nbGUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSByZWN0YW5nbGUuaGVpZ2h0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgdGhpcyByZWN0YW5nbGUgdG8gYW5vdGhlciBvbmUuXG4gICAqIEBwYXJhbSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGNvcHkgdG8uXG4gICAqIEByZXR1cm5zIFJldHVybnMgZ2l2ZW4gcGFyYW1ldGVyLlxuICAgKi9cbiAgY29weVRvKHJlY3RhbmdsZSkge1xuICAgIHJlY3RhbmdsZS5jb3B5RnJvbSh0aGlzKTtcbiAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdC5cbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgUm91bmRlZCBSZWN0YW5nbGUuXG4gICAqL1xuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGgpIHtcbiAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMucmFkaXVzLCBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyKSk7XG4gICAgICAgIGlmICh5ID49IHRoaXMueSArIHJhZGl1cyAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gcmFkaXVzIHx8IHggPj0gdGhpcy54ICsgcmFkaXVzICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAtIHJhZGl1cykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkeCA9IHggLSAodGhpcy54ICsgcmFkaXVzKTtcbiAgICAgICAgbGV0IGR5ID0geSAtICh0aGlzLnkgKyByYWRpdXMpO1xuICAgICAgICBjb25zdCByYWRpdXMyID0gcmFkaXVzICogcmFkaXVzO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLndpZHRoIC0gcmFkaXVzKTtcbiAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkeSA9IHkgLSAodGhpcy55ICsgdGhpcy5oZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtICh0aGlzLnggKyByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyByZWN0YW5nbGUgaW5jbHVkaW5nIHRoZSBzdHJva2UuXG4gICAqIEBwYXJhbSBwWCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHBZIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gc3Ryb2tlV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGxpbmUgdG8gY2hlY2tcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyByZWN0YW5nbGVcbiAgICovXG4gIHN0cm9rZUNvbnRhaW5zKHBYLCBwWSwgc3Ryb2tlV2lkdGgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyB9ID0gdGhpcztcbiAgICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3QgaW5uZXJYID0geCArIHJhZGl1cztcbiAgICBjb25zdCBpbm5lclkgPSB5ICsgcmFkaXVzO1xuICAgIGNvbnN0IGlubmVyV2lkdGggPSB3aWR0aCAtIHJhZGl1cyAqIDI7XG4gICAgY29uc3QgaW5uZXJIZWlnaHQgPSBoZWlnaHQgLSByYWRpdXMgKiAyO1xuICAgIGNvbnN0IHJpZ2h0Qm91bmQgPSB4ICsgd2lkdGg7XG4gICAgY29uc3QgYm90dG9tQm91bmQgPSB5ICsgaGVpZ2h0O1xuICAgIGlmICgocFggPj0geCAtIGhhbGZTdHJva2VXaWR0aCAmJiBwWCA8PSB4ICsgaGFsZlN0cm9rZVdpZHRoIHx8IHBYID49IHJpZ2h0Qm91bmQgLSBoYWxmU3Ryb2tlV2lkdGggJiYgcFggPD0gcmlnaHRCb3VuZCArIGhhbGZTdHJva2VXaWR0aCkgJiYgcFkgPj0gaW5uZXJZICYmIHBZIDw9IGlubmVyWSArIGlubmVySGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKChwWSA+PSB5IC0gaGFsZlN0cm9rZVdpZHRoICYmIHBZIDw9IHkgKyBoYWxmU3Ryb2tlV2lkdGggfHwgcFkgPj0gYm90dG9tQm91bmQgLSBoYWxmU3Ryb2tlV2lkdGggJiYgcFkgPD0gYm90dG9tQm91bmQgKyBoYWxmU3Ryb2tlV2lkdGgpICYmIHBYID49IGlubmVyWCAmJiBwWCA8PSBpbm5lclggKyBpbm5lcldpZHRoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIFRvcC1sZWZ0XG4gICAgICBwWCA8IGlubmVyWCAmJiBwWSA8IGlubmVyWSAmJiBpc0Nvcm5lcldpdGhpblN0cm9rZShwWCwgcFksIGlubmVyWCwgaW5uZXJZLCByYWRpdXMsIGhhbGZTdHJva2VXaWR0aCkgfHwgcFggPiByaWdodEJvdW5kIC0gcmFkaXVzICYmIHBZIDwgaW5uZXJZICYmIGlzQ29ybmVyV2l0aGluU3Ryb2tlKHBYLCBwWSwgcmlnaHRCb3VuZCAtIHJhZGl1cywgaW5uZXJZLCByYWRpdXMsIGhhbGZTdHJva2VXaWR0aCkgfHwgcFggPiByaWdodEJvdW5kIC0gcmFkaXVzICYmIHBZID4gYm90dG9tQm91bmQgLSByYWRpdXMgJiYgaXNDb3JuZXJXaXRoaW5TdHJva2UocFgsIHBZLCByaWdodEJvdW5kIC0gcmFkaXVzLCBib3R0b21Cb3VuZCAtIHJhZGl1cywgcmFkaXVzLCBoYWxmU3Ryb2tlV2lkdGgpIHx8IHBYIDwgaW5uZXJYICYmIHBZID4gYm90dG9tQm91bmQgLSByYWRpdXMgJiYgaXNDb3JuZXJXaXRoaW5TdHJva2UocFgsIHBZLCBpbm5lclgsIGJvdHRvbUJvdW5kIC0gcmFkaXVzLCByYWRpdXMsIGhhbGZTdHJva2VXaWR0aClcbiAgICApO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW3BpeGkuanMvbWF0aDpSb3VuZGVkUmVjdGFuZ2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9d2lkdGg9JHt0aGlzLndpZHRofSBoZWlnaHQ9JHt0aGlzLmhlaWdodH0gcmFkaXVzPSR7dGhpcy5yYWRpdXN9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgUm91bmRlZFJlY3RhbmdsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um91bmRlZFJlY3RhbmdsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfSBmcm9tICcuLi9HcmFwaGljc0NvbnRleHRTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSA4O1xuY29uc3QgRkxUX0VQU0lMT04gPSAxMTkyMDkyOWUtMTQ7XG5jb25zdCBQQVRIX0RJU1RBTkNFX0VQU0lMT04gPSAxO1xuY29uc3QgY3VydmVBbmdsZVRvbGVyYW5jZUVwc2lsb24gPSAwLjAxO1xuY29uc3QgbUFuZ2xlVG9sZXJhbmNlID0gMDtcbmNvbnN0IG1DdXNwTGltaXQgPSAwO1xuZnVuY3Rpb24gYnVpbGRBZGFwdGl2ZUJlemllcihwb2ludHMsIHNYLCBzWSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgZVgsIGVZLCBzbW9vdGhuZXNzKSB7XG4gIGNvbnN0IHNjYWxlID0gMTtcbiAgY29uc3Qgc21vb3RoaW5nID0gTWF0aC5taW4oXG4gICAgMC45OSxcbiAgICAvLyBhIHZhbHVlIG9mIDEuMCBhY3R1YWxseSBpbnZlcnRzIHNtb290aGluZywgc28gd2UgY2FwIGl0IGF0IDAuOTlcbiAgICBNYXRoLm1heCgwLCBzbW9vdGhuZXNzID8/IEdyYXBoaWNzQ29udGV4dFN5c3RlbS5kZWZhdWx0T3B0aW9ucy5iZXppZXJTbW9vdGhuZXNzKVxuICApO1xuICBsZXQgZGlzdGFuY2VUb2xlcmFuY2UgPSAoUEFUSF9ESVNUQU5DRV9FUFNJTE9OIC0gc21vb3RoaW5nKSAvIHNjYWxlO1xuICBkaXN0YW5jZVRvbGVyYW5jZSAqPSBkaXN0YW5jZVRvbGVyYW5jZTtcbiAgYmVnaW4oc1gsIHNZLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBlWCwgZVksIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UpO1xuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gYmVnaW4oc1gsIHNZLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBlWCwgZVksIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UpIHtcbiAgcmVjdXJzaXZlKHNYLCBzWSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgZVgsIGVZLCBwb2ludHMsIGRpc3RhbmNlVG9sZXJhbmNlLCAwKTtcbiAgcG9pbnRzLnB1c2goZVgsIGVZKTtcbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsKSB7XG4gIGlmIChsZXZlbCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwaSA9IE1hdGguUEk7XG4gIGNvbnN0IHgxMiA9ICh4MSArIHgyKSAvIDI7XG4gIGNvbnN0IHkxMiA9ICh5MSArIHkyKSAvIDI7XG4gIGNvbnN0IHgyMyA9ICh4MiArIHgzKSAvIDI7XG4gIGNvbnN0IHkyMyA9ICh5MiArIHkzKSAvIDI7XG4gIGNvbnN0IHgzNCA9ICh4MyArIHg0KSAvIDI7XG4gIGNvbnN0IHkzNCA9ICh5MyArIHk0KSAvIDI7XG4gIGNvbnN0IHgxMjMgPSAoeDEyICsgeDIzKSAvIDI7XG4gIGNvbnN0IHkxMjMgPSAoeTEyICsgeTIzKSAvIDI7XG4gIGNvbnN0IHgyMzQgPSAoeDIzICsgeDM0KSAvIDI7XG4gIGNvbnN0IHkyMzQgPSAoeTIzICsgeTM0KSAvIDI7XG4gIGNvbnN0IHgxMjM0ID0gKHgxMjMgKyB4MjM0KSAvIDI7XG4gIGNvbnN0IHkxMjM0ID0gKHkxMjMgKyB5MjM0KSAvIDI7XG4gIGlmIChsZXZlbCA+IDApIHtcbiAgICBsZXQgZHggPSB4NCAtIHgxO1xuICAgIGxldCBkeSA9IHk0IC0geTE7XG4gICAgY29uc3QgZDIgPSBNYXRoLmFicygoeDIgLSB4NCkgKiBkeSAtICh5MiAtIHk0KSAqIGR4KTtcbiAgICBjb25zdCBkMyA9IE1hdGguYWJzKCh4MyAtIHg0KSAqIGR5IC0gKHkzIC0geTQpICogZHgpO1xuICAgIGxldCBkYTE7XG4gICAgbGV0IGRhMjtcbiAgICBpZiAoZDIgPiBGTFRfRVBTSUxPTiAmJiBkMyA+IEZMVF9FUFNJTE9OKSB7XG4gICAgICBpZiAoKGQyICsgZDMpICogKGQyICsgZDMpIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuICAgICAgICBpZiAobUFuZ2xlVG9sZXJhbmNlIDwgY3VydmVBbmdsZVRvbGVyYW5jZUVwc2lsb24pIHtcbiAgICAgICAgICBwb2ludHMucHVzaCh4MTIzNCwgeTEyMzQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhMjMgPSBNYXRoLmF0YW4yKHkzIC0geTIsIHgzIC0geDIpO1xuICAgICAgICBkYTEgPSBNYXRoLmFicyhhMjMgLSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpKTtcbiAgICAgICAgZGEyID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5NCAtIHkzLCB4NCAtIHgzKSAtIGEyMyk7XG4gICAgICAgIGlmIChkYTEgPj0gcGkpXG4gICAgICAgICAgZGExID0gMiAqIHBpIC0gZGExO1xuICAgICAgICBpZiAoZGEyID49IHBpKVxuICAgICAgICAgIGRhMiA9IDIgKiBwaSAtIGRhMjtcbiAgICAgICAgaWYgKGRhMSArIGRhMiA8IG1BbmdsZVRvbGVyYW5jZSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgxMjM0LCB5MTIzNCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtQ3VzcExpbWl0ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGRhMSA+IG1DdXNwTGltaXQpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHgyLCB5Mik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYTIgPiBtQ3VzcExpbWl0KSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh4MywgeTMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZDIgPiBGTFRfRVBTSUxPTikge1xuICAgICAgaWYgKGQyICogZDIgPD0gZGlzdGFuY2VUb2xlcmFuY2UgKiAoZHggKiBkeCArIGR5ICogZHkpKSB7XG4gICAgICAgIGlmIChtQW5nbGVUb2xlcmFuY2UgPCBjdXJ2ZUFuZ2xlVG9sZXJhbmNlRXBzaWxvbikge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgxMjM0LCB5MTIzNCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhMSA9IE1hdGguYWJzKE1hdGguYXRhbjIoeTMgLSB5MiwgeDMgLSB4MikgLSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpKTtcbiAgICAgICAgaWYgKGRhMSA+PSBwaSlcbiAgICAgICAgICBkYTEgPSAyICogcGkgLSBkYTE7XG4gICAgICAgIGlmIChkYTEgPCBtQW5nbGVUb2xlcmFuY2UpIHtcbiAgICAgICAgICBwb2ludHMucHVzaCh4MiwgeTIpO1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgzLCB5Myk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtQ3VzcExpbWl0ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGRhMSA+IG1DdXNwTGltaXQpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHgyLCB5Mik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkMyA+IEZMVF9FUFNJTE9OKSB7XG4gICAgICBpZiAoZDMgKiBkMyA8PSBkaXN0YW5jZVRvbGVyYW5jZSAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcbiAgICAgICAgaWYgKG1BbmdsZVRvbGVyYW5jZSA8IGN1cnZlQW5nbGVUb2xlcmFuY2VFcHNpbG9uKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDEyMzQsIHkxMjM0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGExID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5NCAtIHkzLCB4NCAtIHgzKSAtIE1hdGguYXRhbjIoeTMgLSB5MiwgeDMgLSB4MikpO1xuICAgICAgICBpZiAoZGExID49IHBpKVxuICAgICAgICAgIGRhMSA9IDIgKiBwaSAtIGRhMTtcbiAgICAgICAgaWYgKGRhMSA8IG1BbmdsZVRvbGVyYW5jZSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgyLCB5Mik7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDMsIHkzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1DdXNwTGltaXQgIT09IDApIHtcbiAgICAgICAgICBpZiAoZGExID4gbUN1c3BMaW1pdCkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeDMsIHkzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHggPSB4MTIzNCAtICh4MSArIHg0KSAvIDI7XG4gICAgICBkeSA9IHkxMjM0IC0gKHkxICsgeTQpIC8gMjtcbiAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSBkaXN0YW5jZVRvbGVyYW5jZSkge1xuICAgICAgICBwb2ludHMucHVzaCh4MTIzNCwgeTEyMzQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlY3Vyc2l2ZSh4MSwgeTEsIHgxMiwgeTEyLCB4MTIzLCB5MTIzLCB4MTIzNCwgeTEyMzQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsICsgMSk7XG4gIHJlY3Vyc2l2ZSh4MTIzNCwgeTEyMzQsIHgyMzQsIHkyMzQsIHgzNCwgeTM0LCB4NCwgeTQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsICsgMSk7XG59XG5cbmV4cG9ydCB7IGJ1aWxkQWRhcHRpdmVCZXppZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQWRhcHRpdmVCZXppZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgR3JhcGhpY3NDb250ZXh0U3lzdGVtIH0gZnJvbSAnLi4vR3JhcGhpY3NDb250ZXh0U3lzdGVtLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gODtcbmNvbnN0IEZMVF9FUFNJTE9OID0gMTE5MjA5MjllLTE0O1xuY29uc3QgUEFUSF9ESVNUQU5DRV9FUFNJTE9OID0gMTtcbmNvbnN0IGN1cnZlQW5nbGVUb2xlcmFuY2VFcHNpbG9uID0gMC4wMTtcbmNvbnN0IG1BbmdsZVRvbGVyYW5jZSA9IDA7XG5mdW5jdGlvbiBidWlsZEFkYXB0aXZlUXVhZHJhdGljKHBvaW50cywgc1gsIHNZLCBjcDF4LCBjcDF5LCBlWCwgZVksIHNtb290aG5lc3MpIHtcbiAgY29uc3Qgc2NhbGUgPSAxO1xuICBjb25zdCBzbW9vdGhpbmcgPSBNYXRoLm1pbihcbiAgICAwLjk5LFxuICAgIC8vIGEgdmFsdWUgb2YgMS4wIGFjdHVhbGx5IGludmVydHMgc21vb3RoaW5nLCBzbyB3ZSBjYXAgaXQgYXQgMC45OVxuICAgIE1hdGgubWF4KDAsIHNtb290aG5lc3MgPz8gR3JhcGhpY3NDb250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zLmJlemllclNtb290aG5lc3MpXG4gICk7XG4gIGxldCBkaXN0YW5jZVRvbGVyYW5jZSA9IChQQVRIX0RJU1RBTkNFX0VQU0lMT04gLSBzbW9vdGhpbmcpIC8gc2NhbGU7XG4gIGRpc3RhbmNlVG9sZXJhbmNlICo9IGRpc3RhbmNlVG9sZXJhbmNlO1xuICBiZWdpbihzWCwgc1ksIGNwMXgsIGNwMXksIGVYLCBlWSwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5mdW5jdGlvbiBiZWdpbihzWCwgc1ksIGNwMXgsIGNwMXksIGVYLCBlWSwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSkge1xuICByZWN1cnNpdmUocG9pbnRzLCBzWCwgc1ksIGNwMXgsIGNwMXksIGVYLCBlWSwgZGlzdGFuY2VUb2xlcmFuY2UsIDApO1xuICBwb2ludHMucHVzaChlWCwgZVkpO1xufVxuZnVuY3Rpb24gcmVjdXJzaXZlKHBvaW50cywgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsKSB7XG4gIGlmIChsZXZlbCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwaSA9IE1hdGguUEk7XG4gIGNvbnN0IHgxMiA9ICh4MSArIHgyKSAvIDI7XG4gIGNvbnN0IHkxMiA9ICh5MSArIHkyKSAvIDI7XG4gIGNvbnN0IHgyMyA9ICh4MiArIHgzKSAvIDI7XG4gIGNvbnN0IHkyMyA9ICh5MiArIHkzKSAvIDI7XG4gIGNvbnN0IHgxMjMgPSAoeDEyICsgeDIzKSAvIDI7XG4gIGNvbnN0IHkxMjMgPSAoeTEyICsgeTIzKSAvIDI7XG4gIGxldCBkeCA9IHgzIC0geDE7XG4gIGxldCBkeSA9IHkzIC0geTE7XG4gIGNvbnN0IGQgPSBNYXRoLmFicygoeDIgLSB4MykgKiBkeSAtICh5MiAtIHkzKSAqIGR4KTtcbiAgaWYgKGQgPiBGTFRfRVBTSUxPTikge1xuICAgIGlmIChkICogZCA8PSBkaXN0YW5jZVRvbGVyYW5jZSAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcbiAgICAgIGlmIChtQW5nbGVUb2xlcmFuY2UgPCBjdXJ2ZUFuZ2xlVG9sZXJhbmNlRXBzaWxvbikge1xuICAgICAgICBwb2ludHMucHVzaCh4MTIzLCB5MTIzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRhID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5MyAtIHkyLCB4MyAtIHgyKSAtIE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkpO1xuICAgICAgaWYgKGRhID49IHBpKVxuICAgICAgICBkYSA9IDIgKiBwaSAtIGRhO1xuICAgICAgaWYgKGRhIDwgbUFuZ2xlVG9sZXJhbmNlKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHgxMjMsIHkxMjMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGR4ID0geDEyMyAtICh4MSArIHgzKSAvIDI7XG4gICAgZHkgPSB5MTIzIC0gKHkxICsgeTMpIC8gMjtcbiAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gZGlzdGFuY2VUb2xlcmFuY2UpIHtcbiAgICAgIHBvaW50cy5wdXNoKHgxMjMsIHkxMjMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZWN1cnNpdmUocG9pbnRzLCB4MSwgeTEsIHgxMiwgeTEyLCB4MTIzLCB5MTIzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwgKyAxKTtcbiAgcmVjdXJzaXZlKHBvaW50cywgeDEyMywgeTEyMywgeDIzLCB5MjMsIHgzLCB5MywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsICsgMSk7XG59XG5cbmV4cG9ydCB7IGJ1aWxkQWRhcHRpdmVRdWFkcmF0aWMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQWRhcHRpdmVRdWFkcmF0aWMubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBidWlsZEFyYyhwb2ludHMsIHgsIHksIHJhZGl1cywgc3RhcnQsIGVuZCwgY2xvY2t3aXNlLCBzdGVwcykge1xuICBsZXQgZGlzdCA9IE1hdGguYWJzKHN0YXJ0IC0gZW5kKTtcbiAgaWYgKCFjbG9ja3dpc2UgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICBkaXN0ID0gMiAqIE1hdGguUEkgLSBkaXN0O1xuICB9IGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiBlbmQgPiBzdGFydCkge1xuICAgIGRpc3QgPSAyICogTWF0aC5QSSAtIGRpc3Q7XG4gIH1cbiAgc3RlcHMgPSBzdGVwcyB8fCBNYXRoLm1heCg2LCBNYXRoLmZsb29yKDYgKiBNYXRoLnBvdyhyYWRpdXMsIDEgLyAzKSAqIChkaXN0IC8gTWF0aC5QSSkpKTtcbiAgc3RlcHMgPSBNYXRoLm1heChzdGVwcywgMyk7XG4gIGxldCBmID0gZGlzdCAvIHN0ZXBzO1xuICBsZXQgdCA9IHN0YXJ0O1xuICBmICo9IGNsb2Nrd2lzZSA/IC0xIDogMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwcyArIDE7IGkrKykge1xuICAgIGNvbnN0IGNzID0gTWF0aC5jb3ModCk7XG4gICAgY29uc3Qgc24gPSBNYXRoLnNpbih0KTtcbiAgICBjb25zdCBueCA9IHggKyBjcyAqIHJhZGl1cztcbiAgICBjb25zdCBueSA9IHkgKyBzbiAqIHJhZGl1cztcbiAgICBwb2ludHMucHVzaChueCwgbnkpO1xuICAgIHQgKz0gZjtcbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZEFyYyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRBcmMubWpzLm1hcFxuIiwiaW1wb3J0IHsgYnVpbGRBcmMgfSBmcm9tICcuL2J1aWxkQXJjLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYnVpbGRBcmNUbyhwb2ludHMsIHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgY29uc3QgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGExID0gZnJvbVkgLSB5MTtcbiAgY29uc3QgYjEgPSBmcm9tWCAtIHgxO1xuICBjb25zdCBhMiA9IHkyIC0geTE7XG4gIGNvbnN0IGIyID0geDIgLSB4MTtcbiAgY29uc3QgbW0gPSBNYXRoLmFicyhhMSAqIGIyIC0gYjEgKiBhMik7XG4gIGlmIChtbSA8IDFlLTggfHwgcmFkaXVzID09PSAwKSB7XG4gICAgaWYgKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gIT09IHgxIHx8IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gIT09IHkxKSB7XG4gICAgICBwb2ludHMucHVzaCh4MSwgeTEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGQgPSBhMSAqIGExICsgYjEgKiBiMTtcbiAgY29uc3QgY2MgPSBhMiAqIGEyICsgYjIgKiBiMjtcbiAgY29uc3QgdHQgPSBhMSAqIGEyICsgYjEgKiBiMjtcbiAgY29uc3QgazEgPSByYWRpdXMgKiBNYXRoLnNxcnQoZGQpIC8gbW07XG4gIGNvbnN0IGsyID0gcmFkaXVzICogTWF0aC5zcXJ0KGNjKSAvIG1tO1xuICBjb25zdCBqMSA9IGsxICogdHQgLyBkZDtcbiAgY29uc3QgajIgPSBrMiAqIHR0IC8gY2M7XG4gIGNvbnN0IGN4ID0gazEgKiBiMiArIGsyICogYjE7XG4gIGNvbnN0IGN5ID0gazEgKiBhMiArIGsyICogYTE7XG4gIGNvbnN0IHB4ID0gYjEgKiAoazIgKyBqMSk7XG4gIGNvbnN0IHB5ID0gYTEgKiAoazIgKyBqMSk7XG4gIGNvbnN0IHF4ID0gYjIgKiAoazEgKyBqMik7XG4gIGNvbnN0IHF5ID0gYTIgKiAoazEgKyBqMik7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHB5IC0gY3ksIHB4IC0gY3gpO1xuICBjb25zdCBlbmRBbmdsZSA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XG4gIGJ1aWxkQXJjKFxuICAgIHBvaW50cyxcbiAgICBjeCArIHgxLFxuICAgIGN5ICsgeTEsXG4gICAgcmFkaXVzLFxuICAgIHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUsXG4gICAgYjEgKiBhMiA+IGIyICogYTFcbiAgKTtcbn1cblxuZXhwb3J0IHsgYnVpbGRBcmNUbyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRBcmNUby5tanMubWFwXG4iLCJpbXBvcnQgeyBidWlsZEFkYXB0aXZlQmV6aWVyIH0gZnJvbSAnLi9idWlsZEFkYXB0aXZlQmV6aWVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgVEFVID0gTWF0aC5QSSAqIDI7XG5jb25zdCBvdXQgPSB7XG4gIGNlbnRlclg6IDAsXG4gIGNlbnRlclk6IDAsXG4gIGFuZzE6IDAsXG4gIGFuZzI6IDBcbn07XG5jb25zdCBtYXBUb0VsbGlwc2UgPSAoeyB4LCB5IH0sIHJ4LCByeSwgY29zUGhpLCBzaW5QaGksIGNlbnRlclgsIGNlbnRlclksIG91dDIpID0+IHtcbiAgeCAqPSByeDtcbiAgeSAqPSByeTtcbiAgY29uc3QgeHAgPSBjb3NQaGkgKiB4IC0gc2luUGhpICogeTtcbiAgY29uc3QgeXAgPSBzaW5QaGkgKiB4ICsgY29zUGhpICogeTtcbiAgb3V0Mi54ID0geHAgKyBjZW50ZXJYO1xuICBvdXQyLnkgPSB5cCArIGNlbnRlclk7XG4gIHJldHVybiBvdXQyO1xufTtcbmZ1bmN0aW9uIGFwcHJveFVuaXRBcmMoYW5nMSwgYW5nMikge1xuICBjb25zdCBhMSA9IGFuZzIgPT09IC0xLjU3MDc5NjMyNjc5NDg5NjYgPyAtMC41NTE5MTUwMjQ0OTQgOiA0IC8gMyAqIE1hdGgudGFuKGFuZzIgLyA0KTtcbiAgY29uc3QgYSA9IGFuZzIgPT09IDEuNTcwNzk2MzI2Nzk0ODk2NiA/IDAuNTUxOTE1MDI0NDk0IDogYTE7XG4gIGNvbnN0IHgxID0gTWF0aC5jb3MoYW5nMSk7XG4gIGNvbnN0IHkxID0gTWF0aC5zaW4oYW5nMSk7XG4gIGNvbnN0IHgyID0gTWF0aC5jb3MoYW5nMSArIGFuZzIpO1xuICBjb25zdCB5MiA9IE1hdGguc2luKGFuZzEgKyBhbmcyKTtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB4OiB4MSAtIHkxICogYSxcbiAgICAgIHk6IHkxICsgeDEgKiBhXG4gICAgfSxcbiAgICB7XG4gICAgICB4OiB4MiArIHkyICogYSxcbiAgICAgIHk6IHkyIC0geDIgKiBhXG4gICAgfSxcbiAgICB7XG4gICAgICB4OiB4MixcbiAgICAgIHk6IHkyXG4gICAgfVxuICBdO1xufVxuY29uc3QgdmVjdG9yQW5nbGUgPSAodXgsIHV5LCB2eCwgdnkpID0+IHtcbiAgY29uc3Qgc2lnbiA9IHV4ICogdnkgLSB1eSAqIHZ4IDwgMCA/IC0xIDogMTtcbiAgbGV0IGRvdCA9IHV4ICogdnggKyB1eSAqIHZ5O1xuICBpZiAoZG90ID4gMSkge1xuICAgIGRvdCA9IDE7XG4gIH1cbiAgaWYgKGRvdCA8IC0xKSB7XG4gICAgZG90ID0gLTE7XG4gIH1cbiAgcmV0dXJuIHNpZ24gKiBNYXRoLmFjb3MoZG90KTtcbn07XG5jb25zdCBnZXRBcmNDZW50ZXIgPSAocHgsIHB5LCBjeCwgY3ksIHJ4LCByeSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHNpblBoaSwgY29zUGhpLCBweHAsIHB5cCwgb3V0MikgPT4ge1xuICBjb25zdCByeFNxID0gTWF0aC5wb3cocngsIDIpO1xuICBjb25zdCByeVNxID0gTWF0aC5wb3cocnksIDIpO1xuICBjb25zdCBweHBTcSA9IE1hdGgucG93KHB4cCwgMik7XG4gIGNvbnN0IHB5cFNxID0gTWF0aC5wb3cocHlwLCAyKTtcbiAgbGV0IHJhZGljYW50ID0gcnhTcSAqIHJ5U3EgLSByeFNxICogcHlwU3EgLSByeVNxICogcHhwU3E7XG4gIGlmIChyYWRpY2FudCA8IDApIHtcbiAgICByYWRpY2FudCA9IDA7XG4gIH1cbiAgcmFkaWNhbnQgLz0gcnhTcSAqIHB5cFNxICsgcnlTcSAqIHB4cFNxO1xuICByYWRpY2FudCA9IE1hdGguc3FydChyYWRpY2FudCkgKiAobGFyZ2VBcmNGbGFnID09PSBzd2VlcEZsYWcgPyAtMSA6IDEpO1xuICBjb25zdCBjZW50ZXJYcCA9IHJhZGljYW50ICogcnggLyByeSAqIHB5cDtcbiAgY29uc3QgY2VudGVyWXAgPSByYWRpY2FudCAqIC1yeSAvIHJ4ICogcHhwO1xuICBjb25zdCBjZW50ZXJYID0gY29zUGhpICogY2VudGVyWHAgLSBzaW5QaGkgKiBjZW50ZXJZcCArIChweCArIGN4KSAvIDI7XG4gIGNvbnN0IGNlbnRlclkgPSBzaW5QaGkgKiBjZW50ZXJYcCArIGNvc1BoaSAqIGNlbnRlcllwICsgKHB5ICsgY3kpIC8gMjtcbiAgY29uc3QgdngxID0gKHB4cCAtIGNlbnRlclhwKSAvIHJ4O1xuICBjb25zdCB2eTEgPSAocHlwIC0gY2VudGVyWXApIC8gcnk7XG4gIGNvbnN0IHZ4MiA9ICgtcHhwIC0gY2VudGVyWHApIC8gcng7XG4gIGNvbnN0IHZ5MiA9ICgtcHlwIC0gY2VudGVyWXApIC8gcnk7XG4gIGNvbnN0IGFuZzEgPSB2ZWN0b3JBbmdsZSgxLCAwLCB2eDEsIHZ5MSk7XG4gIGxldCBhbmcyID0gdmVjdG9yQW5nbGUodngxLCB2eTEsIHZ4MiwgdnkyKTtcbiAgaWYgKHN3ZWVwRmxhZyA9PT0gMCAmJiBhbmcyID4gMCkge1xuICAgIGFuZzIgLT0gVEFVO1xuICB9XG4gIGlmIChzd2VlcEZsYWcgPT09IDEgJiYgYW5nMiA8IDApIHtcbiAgICBhbmcyICs9IFRBVTtcbiAgfVxuICBvdXQyLmNlbnRlclggPSBjZW50ZXJYO1xuICBvdXQyLmNlbnRlclkgPSBjZW50ZXJZO1xuICBvdXQyLmFuZzEgPSBhbmcxO1xuICBvdXQyLmFuZzIgPSBhbmcyO1xufTtcbmZ1bmN0aW9uIGJ1aWxkQXJjVG9TdmcocG9pbnRzLCBweCwgcHksIGN4LCBjeSwgcngsIHJ5LCB4QXhpc1JvdGF0aW9uID0gMCwgbGFyZ2VBcmNGbGFnID0gMCwgc3dlZXBGbGFnID0gMCkge1xuICBpZiAocnggPT09IDAgfHwgcnkgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2luUGhpID0gTWF0aC5zaW4oeEF4aXNSb3RhdGlvbiAqIFRBVSAvIDM2MCk7XG4gIGNvbnN0IGNvc1BoaSA9IE1hdGguY29zKHhBeGlzUm90YXRpb24gKiBUQVUgLyAzNjApO1xuICBjb25zdCBweHAgPSBjb3NQaGkgKiAocHggLSBjeCkgLyAyICsgc2luUGhpICogKHB5IC0gY3kpIC8gMjtcbiAgY29uc3QgcHlwID0gLXNpblBoaSAqIChweCAtIGN4KSAvIDIgKyBjb3NQaGkgKiAocHkgLSBjeSkgLyAyO1xuICBpZiAocHhwID09PSAwICYmIHB5cCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgcnkgPSBNYXRoLmFicyhyeSk7XG4gIGNvbnN0IGxhbWJkYSA9IE1hdGgucG93KHB4cCwgMikgLyBNYXRoLnBvdyhyeCwgMikgKyBNYXRoLnBvdyhweXAsIDIpIC8gTWF0aC5wb3cocnksIDIpO1xuICBpZiAobGFtYmRhID4gMSkge1xuICAgIHJ4ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICB9XG4gIGdldEFyY0NlbnRlcihcbiAgICBweCxcbiAgICBweSxcbiAgICBjeCxcbiAgICBjeSxcbiAgICByeCxcbiAgICByeSxcbiAgICBsYXJnZUFyY0ZsYWcsXG4gICAgc3dlZXBGbGFnLFxuICAgIHNpblBoaSxcbiAgICBjb3NQaGksXG4gICAgcHhwLFxuICAgIHB5cCxcbiAgICBvdXRcbiAgKTtcbiAgbGV0IHsgYW5nMSwgYW5nMiB9ID0gb3V0O1xuICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclkgfSA9IG91dDtcbiAgbGV0IHJhdGlvID0gTWF0aC5hYnMoYW5nMikgLyAoVEFVIC8gNCk7XG4gIGlmIChNYXRoLmFicygxIC0gcmF0aW8pIDwgMWUtNykge1xuICAgIHJhdGlvID0gMTtcbiAgfVxuICBjb25zdCBzZWdtZW50cyA9IE1hdGgubWF4KE1hdGguY2VpbChyYXRpbyksIDEpO1xuICBhbmcyIC89IHNlZ21lbnRzO1xuICBsZXQgbGFzdFggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICBsZXQgbGFzdFkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICBjb25zdCBvdXRDdXJ2ZVBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgIGNvbnN0IGN1cnZlID0gYXBwcm94VW5pdEFyYyhhbmcxLCBhbmcyKTtcbiAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gbWFwVG9FbGxpcHNlKGN1cnZlWzBdLCByeCwgcnksIGNvc1BoaSwgc2luUGhpLCBjZW50ZXJYLCBjZW50ZXJZLCBvdXRDdXJ2ZVBvaW50KTtcbiAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gbWFwVG9FbGxpcHNlKGN1cnZlWzFdLCByeCwgcnksIGNvc1BoaSwgc2luUGhpLCBjZW50ZXJYLCBjZW50ZXJZLCBvdXRDdXJ2ZVBvaW50KTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFRvRWxsaXBzZShjdXJ2ZVsyXSwgcngsIHJ5LCBjb3NQaGksIHNpblBoaSwgY2VudGVyWCwgY2VudGVyWSwgb3V0Q3VydmVQb2ludCk7XG4gICAgYnVpbGRBZGFwdGl2ZUJlemllcihcbiAgICAgIHBvaW50cyxcbiAgICAgIGxhc3RYLFxuICAgICAgbGFzdFksXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MixcbiAgICAgIHgsXG4gICAgICB5XG4gICAgKTtcbiAgICBsYXN0WCA9IHg7XG4gICAgbGFzdFkgPSB5O1xuICAgIGFuZzEgKz0gYW5nMjtcbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZEFyY1RvU3ZnIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZEFyY1RvU3ZnLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcm91bmRlZFNoYXBlQXJjKGcsIHBvaW50cywgcmFkaXVzKSB7XG4gIGNvbnN0IHZlY0Zyb20gPSAocCwgcHApID0+IHtcbiAgICBjb25zdCB4ID0gcHAueCAtIHAueDtcbiAgICBjb25zdCB5ID0gcHAueSAtIHAueTtcbiAgICBjb25zdCBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgY29uc3QgbnggPSB4IC8gbGVuO1xuICAgIGNvbnN0IG55ID0geSAvIGxlbjtcbiAgICByZXR1cm4geyBsZW4sIG54LCBueSB9O1xuICB9O1xuICBjb25zdCBzaGFycENvcm5lciA9IChpLCBwKSA9PiB7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGcubW92ZVRvKHAueCwgcC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZy5saW5lVG8ocC54LCBwLnkpO1xuICAgIH1cbiAgfTtcbiAgbGV0IHAxID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwMiA9IHBvaW50c1tpICUgcG9pbnRzLmxlbmd0aF07XG4gICAgY29uc3QgcFJhZGl1cyA9IHAyLnJhZGl1cyA/PyByYWRpdXM7XG4gICAgaWYgKHBSYWRpdXMgPD0gMCkge1xuICAgICAgc2hhcnBDb3JuZXIoaSwgcDIpO1xuICAgICAgcDEgPSBwMjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwMyA9IHBvaW50c1soaSArIDEpICUgcG9pbnRzLmxlbmd0aF07XG4gICAgY29uc3QgdjEgPSB2ZWNGcm9tKHAyLCBwMSk7XG4gICAgY29uc3QgdjIgPSB2ZWNGcm9tKHAyLCBwMyk7XG4gICAgaWYgKHYxLmxlbiA8IDFlLTQgfHwgdjIubGVuIDwgMWUtNCkge1xuICAgICAgc2hhcnBDb3JuZXIoaSwgcDIpO1xuICAgICAgcDEgPSBwMjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgYW5nbGUgPSBNYXRoLmFzaW4odjEubnggKiB2Mi5ueSAtIHYxLm55ICogdjIubngpO1xuICAgIGxldCByYWREaXJlY3Rpb24gPSAxO1xuICAgIGxldCBkcmF3RGlyZWN0aW9uID0gZmFsc2U7XG4gICAgaWYgKHYxLm54ICogdjIubnggLSB2MS5ueSAqIC12Mi5ueSA8IDApIHtcbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgYW5nbGUgPSBNYXRoLlBJICsgYW5nbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmdsZSA9IE1hdGguUEkgLSBhbmdsZTtcbiAgICAgICAgcmFkRGlyZWN0aW9uID0gLTE7XG4gICAgICAgIGRyYXdEaXJlY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYW5nbGUgPiAwKSB7XG4gICAgICByYWREaXJlY3Rpb24gPSAtMTtcbiAgICAgIGRyYXdEaXJlY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDI7XG4gICAgbGV0IGNSYWRpdXM7XG4gICAgbGV0IGxlbk91dCA9IE1hdGguYWJzKFxuICAgICAgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIHBSYWRpdXMgLyBNYXRoLnNpbihoYWxmQW5nbGUpXG4gICAgKTtcbiAgICBpZiAobGVuT3V0ID4gTWF0aC5taW4odjEubGVuIC8gMiwgdjIubGVuIC8gMikpIHtcbiAgICAgIGxlbk91dCA9IE1hdGgubWluKHYxLmxlbiAvIDIsIHYyLmxlbiAvIDIpO1xuICAgICAgY1JhZGl1cyA9IE1hdGguYWJzKGxlbk91dCAqIE1hdGguc2luKGhhbGZBbmdsZSkgLyBNYXRoLmNvcyhoYWxmQW5nbGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY1JhZGl1cyA9IHBSYWRpdXM7XG4gICAgfVxuICAgIGNvbnN0IGNYID0gcDIueCArIHYyLm54ICogbGVuT3V0ICsgLXYyLm55ICogY1JhZGl1cyAqIHJhZERpcmVjdGlvbjtcbiAgICBjb25zdCBjWSA9IHAyLnkgKyB2Mi5ueSAqIGxlbk91dCArIHYyLm54ICogY1JhZGl1cyAqIHJhZERpcmVjdGlvbjtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gTWF0aC5hdGFuMih2MS5ueSwgdjEubngpICsgTWF0aC5QSSAvIDIgKiByYWREaXJlY3Rpb247XG4gICAgY29uc3QgZW5kQW5nbGUgPSBNYXRoLmF0YW4yKHYyLm55LCB2Mi5ueCkgLSBNYXRoLlBJIC8gMiAqIHJhZERpcmVjdGlvbjtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgZy5tb3ZlVG8oXG4gICAgICAgIGNYICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiBjUmFkaXVzLFxuICAgICAgICBjWSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogY1JhZGl1c1xuICAgICAgKTtcbiAgICB9XG4gICAgZy5hcmMoY1gsIGNZLCBjUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZHJhd0RpcmVjdGlvbik7XG4gICAgcDEgPSBwMjtcbiAgfVxufVxuZnVuY3Rpb24gcm91bmRlZFNoYXBlUXVhZHJhdGljQ3VydmUoZywgcG9pbnRzLCByYWRpdXMsIHNtb290aG5lc3MpIHtcbiAgY29uc3QgZGlzdGFuY2UgPSAocDEsIHAyKSA9PiBNYXRoLnNxcnQoKHAxLnggLSBwMi54KSAqKiAyICsgKHAxLnkgLSBwMi55KSAqKiAyKTtcbiAgY29uc3QgcG9pbnRMZXJwID0gKHAxLCBwMiwgdCkgPT4gKHtcbiAgICB4OiBwMS54ICsgKHAyLnggLSBwMS54KSAqIHQsXG4gICAgeTogcDEueSArIChwMi55IC0gcDEueSkgKiB0XG4gIH0pO1xuICBjb25zdCBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgY29uc3QgdGhpc1BvaW50ID0gcG9pbnRzWyhpICsgMSkgJSBudW1Qb2ludHNdO1xuICAgIGNvbnN0IHBSYWRpdXMgPSB0aGlzUG9pbnQucmFkaXVzID8/IHJhZGl1cztcbiAgICBpZiAocFJhZGl1cyA8PSAwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBnLm1vdmVUbyh0aGlzUG9pbnQueCwgdGhpc1BvaW50LnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZy5saW5lVG8odGhpc1BvaW50LngsIHRoaXNQb2ludC55KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbaV07XG4gICAgY29uc3QgbmV4dFBvaW50ID0gcG9pbnRzWyhpICsgMikgJSBudW1Qb2ludHNdO1xuICAgIGNvbnN0IGxhc3RFZGdlTGVuZ3RoID0gZGlzdGFuY2UobGFzdFBvaW50LCB0aGlzUG9pbnQpO1xuICAgIGxldCBzdGFydDtcbiAgICBpZiAobGFzdEVkZ2VMZW5ndGggPCAxZS00KSB7XG4gICAgICBzdGFydCA9IHRoaXNQb2ludDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdE9mZnNldERpc3RhbmNlID0gTWF0aC5taW4obGFzdEVkZ2VMZW5ndGggLyAyLCBwUmFkaXVzKTtcbiAgICAgIHN0YXJ0ID0gcG9pbnRMZXJwKFxuICAgICAgICB0aGlzUG9pbnQsXG4gICAgICAgIGxhc3RQb2ludCxcbiAgICAgICAgbGFzdE9mZnNldERpc3RhbmNlIC8gbGFzdEVkZ2VMZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRFZGdlTGVuZ3RoID0gZGlzdGFuY2UobmV4dFBvaW50LCB0aGlzUG9pbnQpO1xuICAgIGxldCBlbmQ7XG4gICAgaWYgKG5leHRFZGdlTGVuZ3RoIDwgMWUtNCkge1xuICAgICAgZW5kID0gdGhpc1BvaW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXh0T2Zmc2V0RGlzdGFuY2UgPSBNYXRoLm1pbihuZXh0RWRnZUxlbmd0aCAvIDIsIHBSYWRpdXMpO1xuICAgICAgZW5kID0gcG9pbnRMZXJwKFxuICAgICAgICB0aGlzUG9pbnQsXG4gICAgICAgIG5leHRQb2ludCxcbiAgICAgICAgbmV4dE9mZnNldERpc3RhbmNlIC8gbmV4dEVkZ2VMZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBnLm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZy5saW5lVG8oc3RhcnQueCwgc3RhcnQueSk7XG4gICAgfVxuICAgIGcucXVhZHJhdGljQ3VydmVUbyh0aGlzUG9pbnQueCwgdGhpc1BvaW50LnksIGVuZC54LCBlbmQueSwgc21vb3RobmVzcyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgcm91bmRlZFNoYXBlQXJjLCByb3VuZGVkU2hhcGVRdWFkcmF0aWNDdXJ2ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91bmRTaGFwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBDaXJjbGUgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvQ2lyY2xlLm1qcyc7XG5pbXBvcnQgeyBFbGxpcHNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL0VsbGlwc2UubWpzJztcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvUG9seWdvbi5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgUm91bmRlZFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgYnVpbGRBZGFwdGl2ZUJlemllciB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRBZGFwdGl2ZUJlemllci5tanMnO1xuaW1wb3J0IHsgYnVpbGRBZGFwdGl2ZVF1YWRyYXRpYyB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRBZGFwdGl2ZVF1YWRyYXRpYy5tanMnO1xuaW1wb3J0IHsgYnVpbGRBcmMgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkQXJjLm1qcyc7XG5pbXBvcnQgeyBidWlsZEFyY1RvIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZEFyY1RvLm1qcyc7XG5pbXBvcnQgeyBidWlsZEFyY1RvU3ZnIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZEFyY1RvU3ZnLm1qcyc7XG5pbXBvcnQgeyByb3VuZGVkU2hhcGVRdWFkcmF0aWNDdXJ2ZSwgcm91bmRlZFNoYXBlQXJjIH0gZnJvbSAnLi9yb3VuZFNoYXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdGVtcFJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoKTtcbmNsYXNzIFNoYXBlUGF0aCB7XG4gIGNvbnN0cnVjdG9yKGdyYXBoaWNzUGF0aDJEKSB7XG4gICAgLyoqIFRoZSBsaXN0IG9mIHNoYXBlIHByaW1pdGl2ZXMgdGhhdCBtYWtlIHVwIHRoZSBwYXRoLiAqL1xuICAgIHRoaXMuc2hhcGVQcmltaXRpdmVzID0gW107XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgICB0aGlzLl9ncmFwaGljc1BhdGgyRCA9IGdyYXBoaWNzUGF0aDJEO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGFydGluZyBwb2ludCBmb3IgYSBuZXcgc3ViLXBhdGguIEFueSBzdWJzZXF1ZW50IGRyYXdpbmcgY29tbWFuZHMgYXJlIGNvbnNpZGVyZWQgcGFydCBvZiB0aGlzIHBhdGguXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBmb3IgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgZm9yIHRoZSBzdGFydGluZyBwb2ludC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBtb3ZlVG8oeCwgeSkge1xuICAgIHRoaXMuc3RhcnRQb2x5KHgsIHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0aGUgY3VycmVudCBwb2ludCB0byBhIG5ldyBwb2ludCB3aXRoIGEgc3RyYWlnaHQgbGluZS4gVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCBwYXRoLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb2ludCB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb2ludCB0byBjb25uZWN0IHRvLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgdGhpcy5fZW5zdXJlUG9seSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cztcbiAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gICAgY29uc3QgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChmcm9tWCAhPT0geCB8fCBmcm9tWSAhPT0geSkge1xuICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFyYyB0byB0aGUgcGF0aC4gVGhlIGFyYyBpcyBjZW50ZXJlZCBhdCAoeCwgeSlcbiAgICogIHBvc2l0aW9uIHdpdGggcmFkaXVzIGByYWRpdXNgIHN0YXJ0aW5nIGF0IGBzdGFydEFuZ2xlYCBhbmQgZW5kaW5nIGF0IGBlbmRBbmdsZWAuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgY2VudGVyLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGNlbnRlci5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGFyYy5cbiAgICogQHBhcmFtIHN0YXJ0QW5nbGUgLSBUaGUgc3RhcnRpbmcgYW5nbGUgb2YgdGhlIGFyYywgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIGVuZEFuZ2xlIC0gVGhlIGVuZGluZyBhbmdsZSBvZiB0aGUgYXJjLCBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0gY291bnRlcmNsb2Nrd2lzZSAtIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBhcmMgc2hvdWxkIGJlIGRyYXduIGluIHRoZSBhbnRpY2xvY2t3aXNlIGRpcmVjdGlvbi4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlcmNsb2Nrd2lzZSkge1xuICAgIHRoaXMuX2Vuc3VyZVBvbHkoZmFsc2UpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cztcbiAgICBidWlsZEFyYyhwb2ludHMsIHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJjbG9ja3dpc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFyYyB0byB0aGUgcGF0aCB3aXRoIHRoZSBhcmMgdGFuZ2VudCB0byB0aGUgbGluZSBqb2luaW5nIHR3byBzcGVjaWZpZWQgcG9pbnRzLlxuICAgKiBUaGUgYXJjIHJhZGl1cyBpcyBzcGVjaWZpZWQgYnkgYHJhZGl1c2AuXG4gICAqIEBwYXJhbSB4MSAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgKiBAcGFyYW0geTEgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICogQHBhcmFtIHgyIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgKiBAcGFyYW0geTIgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBhcmMuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIHRoaXMuX2Vuc3VyZVBvbHkoKTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jdXJyZW50UG9seS5wb2ludHM7XG4gICAgYnVpbGRBcmNUbyhwb2ludHMsIHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIFNWRy1zdHlsZSBhcmMgdG8gdGhlIHBhdGgsIGFsbG93aW5nIGZvciBlbGxpcHRpY2FsIGFyY3MgYmFzZWQgb24gdGhlIFNWRyBzcGVjLlxuICAgKiBAcGFyYW0gcnggLSBUaGUgeC1yYWRpdXMgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSByeSAtIFRoZSB5LXJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHhBeGlzUm90YXRpb24gLSBUaGUgcm90YXRpb24gb2YgdGhlIGVsbGlwc2UncyB4LWF4aXMgcmVsYXRpdmVcbiAgICogdG8gdGhlIHgtYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0sIGluIGRlZ3JlZXMuXG4gICAqIEBwYXJhbSBsYXJnZUFyY0ZsYWcgLSBEZXRlcm1pbmVzIGlmIHRoZSBhcmMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBsZXNzIHRoYW4gMTgwIGRlZ3JlZXMuXG4gICAqIEBwYXJhbSBzd2VlcEZsYWcgLSBEZXRlcm1pbmVzIGlmIHRoZSBhcmMgc2hvdWxkIGJlIHN3ZXB0IGluIGEgcG9zaXRpdmUgYW5nbGUgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBhcmMncyBlbmQgcG9pbnQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYXJjVG9TdmcocngsIHJ5LCB4QXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeSkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cztcbiAgICBidWlsZEFyY1RvU3ZnKFxuICAgICAgcG9pbnRzLFxuICAgICAgdGhpcy5fY3VycmVudFBvbHkubGFzdFgsXG4gICAgICB0aGlzLl9jdXJyZW50UG9seS5sYXN0WSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcngsXG4gICAgICByeSxcbiAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICBsYXJnZUFyY0ZsYWcsXG4gICAgICBzd2VlcEZsYWdcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgY3ViaWMgQmV6aWVyIGN1cnZlIHRvIHRoZSBwYXRoLlxuICAgKiBJdCByZXF1aXJlcyB0aHJlZSBwb2ludHM6IHRoZSBmaXJzdCB0d28gYXJlIGNvbnRyb2wgcG9pbnRzIGFuZCB0aGUgdGhpcmQgb25lIGlzIHRoZSBlbmQgcG9pbnQuXG4gICAqIFRoZSBzdGFydGluZyBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCBpbiB0aGUgY3VycmVudCBwYXRoLlxuICAgKiBAcGFyYW0gY3AxeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDF5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIGNwMnggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIGNwMnkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gc21vb3RobmVzcyAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBhZGp1c3QgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSwgc21vb3RobmVzcykge1xuICAgIHRoaXMuX2Vuc3VyZVBvbHkoKTtcbiAgICBjb25zdCBjdXJyZW50UG9seSA9IHRoaXMuX2N1cnJlbnRQb2x5O1xuICAgIGJ1aWxkQWRhcHRpdmVCZXppZXIoXG4gICAgICB0aGlzLl9jdXJyZW50UG9seS5wb2ludHMsXG4gICAgICBjdXJyZW50UG9seS5sYXN0WCxcbiAgICAgIGN1cnJlbnRQb2x5Lmxhc3RZLFxuICAgICAgY3AxeCxcbiAgICAgIGNwMXksXG4gICAgICBjcDJ4LFxuICAgICAgY3AyeSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgc21vb3RobmVzc1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBxdWFkcmF0aWMgY3VydmUgdG8gdGhlIHBhdGguIEl0IHJlcXVpcmVzIHR3byBwb2ludHM6IHRoZSBjb250cm9sIHBvaW50IGFuZCB0aGUgZW5kIHBvaW50LlxuICAgKiBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgdGhlIGxhc3QgcG9pbnQgaW4gdGhlIGN1cnJlbnQgcGF0aC5cbiAgICogQHBhcmFtIGNwMXggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AxeSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aGluZyAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBhZGp1c3QgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHF1YWRyYXRpY0N1cnZlVG8oY3AxeCwgY3AxeSwgeCwgeSwgc21vb3RoaW5nKSB7XG4gICAgdGhpcy5fZW5zdXJlUG9seSgpO1xuICAgIGNvbnN0IGN1cnJlbnRQb2x5ID0gdGhpcy5fY3VycmVudFBvbHk7XG4gICAgYnVpbGRBZGFwdGl2ZVF1YWRyYXRpYyhcbiAgICAgIHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cyxcbiAgICAgIGN1cnJlbnRQb2x5Lmxhc3RYLFxuICAgICAgY3VycmVudFBvbHkubGFzdFksXG4gICAgICBjcDF4LFxuICAgICAgY3AxeSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgc21vb3RoaW5nXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGggYnkgZHJhd2luZyBhIHN0cmFpZ2h0IGxpbmUgYmFjayB0byB0aGUgc3RhcnQuXG4gICAqIElmIHRoZSBzaGFwZSBpcyBhbHJlYWR5IGNsb3NlZCBvciB0aGVyZSBhcmUgbm8gcG9pbnRzIGluIHRoZSBwYXRoLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgY2xvc2VQYXRoKCkge1xuICAgIHRoaXMuZW5kUG9seSh0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbm90aGVyIHBhdGggdG8gdGhlIGN1cnJlbnQgcGF0aC4gVGhpcyBtZXRob2QgYWxsb3dzIGZvciB0aGUgY29tYmluYXRpb24gb2YgbXVsdGlwbGUgcGF0aHMgaW50byBvbmUuXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIGBHcmFwaGljc1BhdGhgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBhdGggdG8gYWRkLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHBhdGggYmVmb3JlIGFkZGluZyBpdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhZGRQYXRoKHBhdGgsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZW5kUG9seSgpO1xuICAgIGlmICh0cmFuc2Zvcm0gJiYgIXRyYW5zZm9ybS5pc0lkZW50aXR5KCkpIHtcbiAgICAgIHBhdGggPSBwYXRoLmNsb25lKHRydWUpO1xuICAgICAgcGF0aC50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBwYXRoLmluc3RydWN0aW9uc1tpXTtcbiAgICAgIHRoaXNbaW5zdHJ1Y3Rpb24uYWN0aW9uXSguLi5pbnN0cnVjdGlvbi5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmFsaXplcyB0aGUgZHJhd2luZyBvZiB0aGUgY3VycmVudCBwYXRoLiBPcHRpb25hbGx5LCBpdCBjYW4gY2xvc2UgdGhlIHBhdGguXG4gICAqIEBwYXJhbSBjbG9zZVBhdGggLSBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNsb3NlIHRoZSBwYXRoIGFmdGVyIGZpbmlzaGluZy4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICovXG4gIGZpbmlzaChjbG9zZVBhdGggPSBmYWxzZSkge1xuICAgIHRoaXMuZW5kUG9seShjbG9zZVBhdGgpO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlY3RhbmdsZSBzaGFwZS4gVGhpcyBtZXRob2QgYWRkcyBhIG5ldyByZWN0YW5nbGUgcGF0aCB0byB0aGUgY3VycmVudCBkcmF3aW5nLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSByZWN0YW5nbGUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVjdCh4LCB5LCB3LCBoLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRyYXdTaGFwZShuZXcgUmVjdGFuZ2xlKHgsIHksIHcsIGgpLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIGNpcmNsZSBzaGFwZS4gVGhpcyBtZXRob2QgYWRkcyBhIG5ldyBjaXJjbGUgcGF0aCB0byB0aGUgY3VycmVudCBkcmF3aW5nLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGNpcmNsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBjaXJjbGUoeCwgeSwgcmFkaXVzLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRyYXdTaGFwZShuZXcgQ2lyY2xlKHgsIHksIHJhZGl1cyksIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcG9seWdvbiBzaGFwZS4gVGhpcyBtZXRob2QgYWxsb3dzIGZvciB0aGUgY3JlYXRpb24gb2YgY29tcGxleCBwb2x5Z29ucyBieSBzcGVjaWZ5aW5nIGEgc2VxdWVuY2Ugb2YgcG9pbnRzLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gQW4gYXJyYXkgb2YgbnVtYmVycywgb3Igb3IgYW4gYXJyYXkgb2YgUG9pbnREYXRhIG9iamVjdHMgZWcgW3t4LHl9LCB7eCx5fSwge3gseX1dXG4gICAqIHJlcHJlc2VudGluZyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbidzIHZlcnRpY2VzLCBpbiBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIGNsb3NlIC0gQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byBjbG9zZSB0aGUgcG9seWdvbiBwYXRoLiBUcnVlIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBwb2x5KHBvaW50cywgY2xvc2UsIHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seWdvbihwb2ludHMpO1xuICAgIHBvbHlnb24uY2xvc2VQYXRoID0gY2xvc2U7XG4gICAgdGhpcy5kcmF3U2hhcGUocG9seWdvbiwgdHJhbnNmb3JtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSByZWd1bGFyIHBvbHlnb24gd2l0aCBhIHNwZWNpZmllZCBudW1iZXIgb2Ygc2lkZXMuIEFsbCBzaWRlcyBhbmQgYW5nbGVzIGFyZSBlcXVhbC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY3Vtc2NyaWJlZCBjaXJjbGUgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSBzaWRlcyAtIFRoZSBudW1iZXIgb2Ygc2lkZXMgb2YgdGhlIHBvbHlnb24uIE11c3QgYmUgMyBvciBtb3JlLlxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBUaGUgcm90YXRpb24gYW5nbGUgb2YgdGhlIHBvbHlnb24sIGluIHJhZGlhbnMuIFplcm8gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlZ3VsYXJQb2x5KHgsIHksIHJhZGl1cywgc2lkZXMsIHJvdGF0aW9uID0gMCwgdHJhbnNmb3JtKSB7XG4gICAgc2lkZXMgPSBNYXRoLm1heChzaWRlcyB8IDAsIDMpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSAtMSAqIE1hdGguUEkgLyAyICsgcm90YXRpb247XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLlBJICogMiAvIHNpZGVzO1xuICAgIGNvbnN0IHBvbHlnb24gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGFuZ2xlID0gaSAqIGRlbHRhICsgc3RhcnRBbmdsZTtcbiAgICAgIHBvbHlnb24ucHVzaChcbiAgICAgICAgeCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wb2x5KHBvbHlnb24sIHRydWUsIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcG9seWdvbiB3aXRoIHJvdW5kZWQgY29ybmVycy5cbiAgICogU2ltaWxhciB0byBgcmVndWxhclBvbHlgIGJ1dCB3aXRoIHRoZSBhYmlsaXR5IHRvIHJvdW5kIHRoZSBjb3JuZXJzIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjdW1zY3JpYmVkIGNpcmNsZSBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHNpZGVzIC0gVGhlIG51bWJlciBvZiBzaWRlcyBvZiB0aGUgcG9seWdvbi4gTXVzdCBiZSAzIG9yIG1vcmUuXG4gICAqIEBwYXJhbSBjb3JuZXIgLSBUaGUgcmFkaXVzIG9mIHRoZSByb3VuZGluZyBvZiB0aGUgY29ybmVycy5cbiAgICogQHBhcmFtIHJvdGF0aW9uIC0gVGhlIHJvdGF0aW9uIGFuZ2xlIG9mIHRoZSBwb2x5Z29uLCBpbiByYWRpYW5zLiBaZXJvIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGFkanVzdCB0aGUgc21vb3RobmVzcyBvZiB0aGUgcm91bmRpbmcuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcm91bmRQb2x5KHgsIHksIHJhZGl1cywgc2lkZXMsIGNvcm5lciwgcm90YXRpb24gPSAwLCBzbW9vdGhuZXNzKSB7XG4gICAgc2lkZXMgPSBNYXRoLm1heChzaWRlcyB8IDAsIDMpO1xuICAgIGlmIChjb3JuZXIgPD0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVndWxhclBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgcm90YXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBzaWRlTGVuZ3RoID0gcmFkaXVzICogTWF0aC5zaW4oTWF0aC5QSSAvIHNpZGVzKSAtIDFlLTM7XG4gICAgY29ybmVyID0gTWF0aC5taW4oY29ybmVyLCBzaWRlTGVuZ3RoKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gLTEgKiBNYXRoLlBJIC8gMiArIHJvdGF0aW9uO1xuICAgIGNvbnN0IGRlbHRhID0gTWF0aC5QSSAqIDIgLyBzaWRlcztcbiAgICBjb25zdCBpbnRlcm5hbEFuZ2xlID0gKHNpZGVzIC0gMikgKiBNYXRoLlBJIC8gc2lkZXMgLyAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgY29uc3QgYW5nbGUgPSBpICogZGVsdGEgKyBzdGFydEFuZ2xlO1xuICAgICAgY29uc3QgeDAgPSB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgY29uc3QgeTAgPSB5ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgY29uc3QgYTEgPSBhbmdsZSArIE1hdGguUEkgKyBpbnRlcm5hbEFuZ2xlO1xuICAgICAgY29uc3QgYTIgPSBhbmdsZSAtIE1hdGguUEkgLSBpbnRlcm5hbEFuZ2xlO1xuICAgICAgY29uc3QgeDEgPSB4MCArIGNvcm5lciAqIE1hdGguY29zKGExKTtcbiAgICAgIGNvbnN0IHkxID0geTAgKyBjb3JuZXIgKiBNYXRoLnNpbihhMSk7XG4gICAgICBjb25zdCB4MyA9IHgwICsgY29ybmVyICogTWF0aC5jb3MoYTIpO1xuICAgICAgY29uc3QgeTMgPSB5MCArIGNvcm5lciAqIE1hdGguc2luKGEyKTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKHgxLCB5MSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpbmVUbyh4MSwgeTEpO1xuICAgICAgfVxuICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKHgwLCB5MCwgeDMsIHkzLCBzbW9vdGhuZXNzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgc2hhcGUgd2l0aCByb3VuZGVkIGNvcm5lcnMuIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY3VzdG9tIHJhZGl1cyBmb3IgZWFjaCBjb3JuZXIgb2YgdGhlIHNoYXBlLlxuICAgKiBPcHRpb25hbGx5LCBjb3JuZXJzIGNhbiBiZSByb3VuZGVkIHVzaW5nIGEgcXVhZHJhdGljIGN1cnZlIGluc3RlYWQgb2YgYW4gYXJjLCBwcm92aWRpbmcgYSBkaWZmZXJlbnQgYWVzdGhldGljLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gQW4gYXJyYXkgb2YgYFJvdW5kZWRQb2ludGAgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIHRoZSBzaGFwZSB0byBkcmF3LlxuICAgKiBBIG1pbmltdW0gb2YgMyBwb2ludHMgaXMgcmVxdWlyZWQuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgZGVmYXVsdCByYWRpdXMgZm9yIHRoZSBjb3JuZXJzLlxuICAgKiBUaGlzIHJhZGl1cyBpcyBhcHBsaWVkIHRvIGFsbCBjb3JuZXJzIHVubGVzcyBvdmVycmlkZGVuIGluIGBwb2ludHNgLlxuICAgKiBAcGFyYW0gdXNlUXVhZHJhdGljIC0gSWYgc2V0IHRvIHRydWUsIHJvdW5kZWQgY29ybmVycyBhcmUgZHJhd24gdXNpbmcgYSBxdWFkcmF0aWNDdXJ2ZVxuICAgKiAgbWV0aG9kIGluc3RlYWQgb2YgYW4gYXJjIG1ldGhvZC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gU3BlY2lmaWVzIHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZSB3aGVuIGB1c2VRdWFkcmF0aWNgIGlzIHRydWUuXG4gICAqIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgY3VydmUgc21vb3RoZXIuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcm91bmRTaGFwZShwb2ludHMsIHJhZGl1cywgdXNlUXVhZHJhdGljID0gZmFsc2UsIHNtb290aG5lc3MpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodXNlUXVhZHJhdGljKSB7XG4gICAgICByb3VuZGVkU2hhcGVRdWFkcmF0aWNDdXJ2ZSh0aGlzLCBwb2ludHMsIHJhZGl1cywgc21vb3RobmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdW5kZWRTaGFwZUFyYyh0aGlzLCBwb2ludHMsIHJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb3NlUGF0aCgpO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3IFJlY3RhbmdsZSB3aXRoIGZpbGxldCBjb3JuZXJzLiBUaGlzIGlzIG11Y2ggbGlrZSByb3VuZGVkIHJlY3RhbmdsZVxuICAgKiBob3dldmVyIGl0IHN1cHBvcnQgbmVnYXRpdmUgbnVtYmVycyBhcyB3ZWxsIGZvciB0aGUgY29ybmVyIHJhZGl1cy5cbiAgICogQHBhcmFtIHggLSBVcHBlciBsZWZ0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB5IC0gVXBwZXIgcmlnaHQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgcmVjdFxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHJlY3RcbiAgICogQHBhcmFtIGZpbGxldCAtIGFjY2VwdCBuZWdhdGl2ZSBvciBwb3NpdGl2ZSB2YWx1ZXNcbiAgICovXG4gIGZpbGxldFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgZmlsbGV0KSB7XG4gICAgaWYgKGZpbGxldCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgbWF4RmlsbGV0ID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyO1xuICAgIGNvbnN0IGluc2V0ID0gTWF0aC5taW4obWF4RmlsbGV0LCBNYXRoLm1heCgtbWF4RmlsbGV0LCBmaWxsZXQpKTtcbiAgICBjb25zdCByaWdodCA9IHggKyB3aWR0aDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgaGVpZ2h0O1xuICAgIGNvbnN0IGRpciA9IGluc2V0IDwgMCA/IC1pbnNldCA6IDA7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKGluc2V0KTtcbiAgICByZXR1cm4gdGhpcy5tb3ZlVG8oeCwgeSArIHNpemUpLmFyY1RvKHggKyBkaXIsIHkgKyBkaXIsIHggKyBzaXplLCB5LCBzaXplKS5saW5lVG8ocmlnaHQgLSBzaXplLCB5KS5hcmNUbyhyaWdodCAtIGRpciwgeSArIGRpciwgcmlnaHQsIHkgKyBzaXplLCBzaXplKS5saW5lVG8ocmlnaHQsIGJvdHRvbSAtIHNpemUpLmFyY1RvKHJpZ2h0IC0gZGlyLCBib3R0b20gLSBkaXIsIHggKyB3aWR0aCAtIHNpemUsIGJvdHRvbSwgc2l6ZSkubGluZVRvKHggKyBzaXplLCBib3R0b20pLmFyY1RvKHggKyBkaXIsIGJvdHRvbSAtIGRpciwgeCwgYm90dG9tIC0gc2l6ZSwgc2l6ZSkuY2xvc2VQYXRoKCk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXcgUmVjdGFuZ2xlIHdpdGggY2hhbWZlciBjb3JuZXJzLiBUaGVzZSBhcmUgYW5nbGVkIGNvcm5lcnMuXG4gICAqIEBwYXJhbSB4IC0gVXBwZXIgbGVmdCBjb3JuZXIgb2YgcmVjdFxuICAgKiBAcGFyYW0geSAtIFVwcGVyIHJpZ2h0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHJlY3RcbiAgICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiByZWN0XG4gICAqIEBwYXJhbSBjaGFtZmVyIC0gbm9uLXplcm8gcmVhbCBudW1iZXIsIHNpemUgb2YgY29ybmVyIGN1dG91dFxuICAgKiBAcGFyYW0gdHJhbnNmb3JtXG4gICAqL1xuICBjaGFtZmVyUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjaGFtZmVyLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoY2hhbWZlciA8PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBpbnNldCA9IE1hdGgubWluKGNoYW1mZXIsIE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMik7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgd2lkdGg7XG4gICAgY29uc3QgYm90dG9tID0geSArIGhlaWdodDtcbiAgICBjb25zdCBwb2ludHMgPSBbXG4gICAgICB4ICsgaW5zZXQsXG4gICAgICB5LFxuICAgICAgcmlnaHQgLSBpbnNldCxcbiAgICAgIHksXG4gICAgICByaWdodCxcbiAgICAgIHkgKyBpbnNldCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tIC0gaW5zZXQsXG4gICAgICByaWdodCAtIGluc2V0LFxuICAgICAgYm90dG9tLFxuICAgICAgeCArIGluc2V0LFxuICAgICAgYm90dG9tLFxuICAgICAgeCxcbiAgICAgIGJvdHRvbSAtIGluc2V0LFxuICAgICAgeCxcbiAgICAgIHkgKyBpbnNldFxuICAgIF07XG4gICAgZm9yIChsZXQgaSA9IHBvaW50cy5sZW5ndGggLSAxOyBpID49IDI7IGkgLT0gMikge1xuICAgICAgaWYgKHBvaW50c1tpXSA9PT0gcG9pbnRzW2kgLSAyXSAmJiBwb2ludHNbaSAtIDFdID09PSBwb2ludHNbaSAtIDNdKSB7XG4gICAgICAgIHBvaW50cy5zcGxpY2UoaSAtIDEsIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb2x5KHBvaW50cywgdHJ1ZSwgdHJhbnNmb3JtKTtcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYW4gZWxsaXBzZSBhdCB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uIGFuZCB3aXRoIHRoZSBnaXZlbiB4IGFuZCB5IHJhZGlpLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCwgYWxsb3dpbmcgZm9yIHJvdGF0aW9uLCBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHJhZGl1c1ggLSBUaGUgaG9yaXpvbnRhbCByYWRpdXMgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSByYWRpdXNZIC0gVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBlbGxpcHNlLiBUaGlzIGNhbiBpbmNsdWRlIHJvdGF0aW9ucy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBlbGxpcHNlKHgsIHksIHJhZGl1c1gsIHJhZGl1c1ksIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBFbGxpcHNlKHgsIHksIHJhZGl1c1gsIHJhZGl1c1kpLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycy5cbiAgICogVGhlIGNvcm5lciByYWRpdXMgY2FuIGJlIHNwZWNpZmllZCB0byBkZXRlcm1pbmUgaG93IHJvdW5kZWQgdGhlIGNvcm5lcnMgc2hvdWxkIGJlLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCwgd2hpY2ggYWxsb3dzIGZvciByb3RhdGlvbiwgc2NhbGluZywgYW5kIHRyYW5zbGF0aW9uIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlJ3MgY29ybmVycy4gSWYgbm90IHNwZWNpZmllZCwgY29ybmVycyB3aWxsIGJlIHNoYXJwLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFJlY3QoeCwgeSwgdywgaCwgcmFkaXVzLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRyYXdTaGFwZShuZXcgUm91bmRlZFJlY3RhbmdsZSh4LCB5LCB3LCBoLCByYWRpdXMpLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIGdpdmVuIHNoYXBlIG9uIHRoZSBjYW52YXMuXG4gICAqIFRoaXMgaXMgYSBnZW5lcmljIG1ldGhvZCB0aGF0IGNhbiBkcmF3IGFueSB0eXBlIG9mIHNoYXBlIHNwZWNpZmllZCBieSB0aGUgYFNoYXBlUHJpbWl0aXZlYCBwYXJhbWV0ZXIuXG4gICAqIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBjYW4gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUsIGFsbG93aW5nIGZvciBjb21wbGV4IHRyYW5zZm9ybWF0aW9ucy5cbiAgICogQHBhcmFtIHNoYXBlIC0gVGhlIHNoYXBlIHRvIGRyYXcsIGRlZmluZWQgYXMgYSBgU2hhcGVQcmltaXRpdmVgIG9iamVjdC5cbiAgICogQHBhcmFtIG1hdHJpeCAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIGZvciB0cmFuc2Zvcm1pbmcgdGhlIHNoYXBlLiBUaGlzIGNhbiBpbmNsdWRlIHJvdGF0aW9ucyxcbiAgICogc2NhbGluZywgYW5kIHRyYW5zbGF0aW9ucy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBkcmF3U2hhcGUoc2hhcGUsIG1hdHJpeCkge1xuICAgIHRoaXMuZW5kUG9seSgpO1xuICAgIHRoaXMuc2hhcGVQcmltaXRpdmVzLnB1c2goeyBzaGFwZSwgdHJhbnNmb3JtOiBtYXRyaXggfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyBhIG5ldyBwb2x5Z29uIHBhdGggZnJvbSB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nIHBvaW50LlxuICAgKiBUaGlzIG1ldGhvZCBpbml0aWFsaXplcyBhIG5ldyBwb2x5Z29uIG9yIGVuZHMgdGhlIGN1cnJlbnQgb25lIGlmIGl0IGV4aXN0cy5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgbmV3IHBvbHlnb24uXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIG5ldyBwb2x5Z29uLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHN0YXJ0UG9seSh4LCB5KSB7XG4gICAgbGV0IGN1cnJlbnRQb2x5ID0gdGhpcy5fY3VycmVudFBvbHk7XG4gICAgaWYgKGN1cnJlbnRQb2x5KSB7XG4gICAgICB0aGlzLmVuZFBvbHkoKTtcbiAgICB9XG4gICAgY3VycmVudFBvbHkgPSBuZXcgUG9seWdvbigpO1xuICAgIGN1cnJlbnRQb2x5LnBvaW50cy5wdXNoKHgsIHkpO1xuICAgIHRoaXMuX2N1cnJlbnRQb2x5ID0gY3VycmVudFBvbHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEVuZHMgdGhlIGN1cnJlbnQgcG9seWdvbiBwYXRoLiBJZiBgY2xvc2VQYXRoYCBpcyBzZXQgdG8gdHJ1ZSxcbiAgICogdGhlIHBhdGggaXMgY2xvc2VkIGJ5IGNvbm5lY3RpbmcgdGhlIGxhc3QgcG9pbnQgdG8gdGhlIGZpcnN0IG9uZS5cbiAgICogVGhpcyBtZXRob2QgZmluYWxpemVzIHRoZSBjdXJyZW50IHBvbHlnb24gYW5kIHByZXBhcmVzIGl0IGZvciBkcmF3aW5nIG9yIGFkZGluZyB0byB0aGUgc2hhcGUgcHJpbWl0aXZlcy5cbiAgICogQHBhcmFtIGNsb3NlUGF0aCAtIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHBvbHlnb24gYnkgY29ubmVjdGluZyB0aGUgbGFzdCBwb2ludFxuICAgKiAgYmFjayB0byB0aGUgc3RhcnRpbmcgcG9pbnQuIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgZW5kUG9seShjbG9zZVBhdGggPSBmYWxzZSkge1xuICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fY3VycmVudFBvbHk7XG4gICAgaWYgKHNoYXBlICYmIHNoYXBlLnBvaW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBzaGFwZS5jbG9zZVBhdGggPSBjbG9zZVBhdGg7XG4gICAgICB0aGlzLnNoYXBlUHJpbWl0aXZlcy5wdXNoKHsgc2hhcGUgfSk7XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnRQb2x5ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfZW5zdXJlUG9seShzdGFydCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5fY3VycmVudFBvbHkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBuZXcgUG9seWdvbigpO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgY29uc3QgbGFzdFNoYXBlID0gdGhpcy5zaGFwZVByaW1pdGl2ZXNbdGhpcy5zaGFwZVByaW1pdGl2ZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdFNoYXBlKSB7XG4gICAgICAgIGxldCBseCA9IGxhc3RTaGFwZS5zaGFwZS54O1xuICAgICAgICBsZXQgbHkgPSBsYXN0U2hhcGUuc2hhcGUueTtcbiAgICAgICAgaWYgKCFsYXN0U2hhcGUudHJhbnNmb3JtLmlzSWRlbnRpdHkoKSkge1xuICAgICAgICAgIGNvbnN0IHQgPSBsYXN0U2hhcGUudHJhbnNmb3JtO1xuICAgICAgICAgIGNvbnN0IHRlbXBYID0gbHg7XG4gICAgICAgICAgbHggPSB0LmEgKiBseCArIHQuYyAqIGx5ICsgdC50eDtcbiAgICAgICAgICBseSA9IHQuYiAqIHRlbXBYICsgdC5kICogbHkgKyB0LnR5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cy5wdXNoKGx4LCBseSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jdXJyZW50UG9seS5wb2ludHMucHVzaCgwLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEJ1aWxkcyB0aGUgcGF0aC4gKi9cbiAgYnVpbGRQYXRoKCkge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLl9ncmFwaGljc1BhdGgyRDtcbiAgICB0aGlzLnNoYXBlUHJpbWl0aXZlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2N1cnJlbnRQb2x5ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGguaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHBhdGguaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgdGhpc1tpbnN0cnVjdGlvbi5hY3Rpb25dKC4uLmluc3RydWN0aW9uLmRhdGEpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaCgpO1xuICB9XG4gIC8qKiBHZXRzIHRoZSBib3VuZHMgb2YgdGhlIHBhdGguICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuICAgIGJvdW5kcy5jbGVhcigpO1xuICAgIGNvbnN0IHNoYXBlUHJpbWl0aXZlcyA9IHRoaXMuc2hhcGVQcmltaXRpdmVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGVQcmltaXRpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzaGFwZVByaW1pdGl2ZSA9IHNoYXBlUHJpbWl0aXZlc1tpXTtcbiAgICAgIGNvbnN0IGJvdW5kc1JlY3QgPSBzaGFwZVByaW1pdGl2ZS5zaGFwZS5nZXRCb3VuZHModGVtcFJlY3RhbmdsZSk7XG4gICAgICBpZiAoc2hhcGVQcmltaXRpdmUudHJhbnNmb3JtKSB7XG4gICAgICAgIGJvdW5kcy5hZGRSZWN0KGJvdW5kc1JlY3QsIHNoYXBlUHJpbWl0aXZlLnRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib3VuZHMuYWRkUmVjdChib3VuZHNSZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxufVxuXG5leHBvcnQgeyBTaGFwZVBhdGggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYXBlUGF0aC5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgU1ZHVG9HcmFwaGljc1BhdGggfSBmcm9tICcuLi9zdmcvU1ZHVG9HcmFwaGljc1BhdGgubWpzJztcbmltcG9ydCB7IFNoYXBlUGF0aCB9IGZyb20gJy4vU2hhcGVQYXRoLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3JhcGhpY3NQYXRoIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBgR3JhcGhpY3NQYXRoYCBpbnN0YW5jZSBvcHRpb25hbGx5IGZyb20gYW4gU1ZHIHBhdGggc3RyaW5nIG9yIGFuIGFycmF5IG9mIGBQYXRoSW5zdHJ1Y3Rpb25gLlxuICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb25zIC0gQW4gU1ZHIHBhdGggc3RyaW5nIG9yIGFuIGFycmF5IG9mIGBQYXRoSW5zdHJ1Y3Rpb25gIG9iamVjdHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpbnN0cnVjdGlvbnMpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgIHRoaXMudWlkID0gdWlkKFwiZ3JhcGhpY3NQYXRoXCIpO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgU1ZHVG9HcmFwaGljc1BhdGgoaW5zdHJ1Y3Rpb25zLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM/LnNsaWNlKCkgPz8gW107XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGludGVybmFsIHNoYXBlIHBhdGgsIGVuc3VyaW5nIGl0IGlzIHVwLXRvLWRhdGUgd2l0aCB0aGUgY3VycmVudCBpbnN0cnVjdGlvbnMuXG4gICAqIEByZXR1cm5zIFRoZSBgU2hhcGVQYXRoYCBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBgR3JhcGhpY3NQYXRoYC5cbiAgICovXG4gIGdldCBzaGFwZVBhdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9zaGFwZVBhdGgpIHtcbiAgICAgIHRoaXMuX3NoYXBlUGF0aCA9IG5ldyBTaGFwZVBhdGgodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NoYXBlUGF0aC5idWlsZFBhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXBlUGF0aDtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbm90aGVyIGBHcmFwaGljc1BhdGhgIHRvIHRoaXMgcGF0aCwgb3B0aW9uYWxseSBhcHBseWluZyBhIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBgR3JhcGhpY3NQYXRoYCB0byBhZGQuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiB0byBhcHBseSB0byB0aGUgYWRkZWQgcGF0aC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhZGRQYXRoKHBhdGgsIHRyYW5zZm9ybSkge1xuICAgIHBhdGggPSBwYXRoLmNsb25lKCk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJhZGRQYXRoXCIsIGRhdGE6IFtwYXRoLCB0cmFuc2Zvcm1dIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhcmMoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiYXJjXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFyY1RvKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcImFyY1RvXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFyY1RvU3ZnKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcImFyY1RvU3ZnXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJlemllckN1cnZlVG8oLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiYmV6aWVyQ3VydmVUb1wiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGN1YmljIEJlemllciBjdXJ2ZSB0byB0aGUgcGF0aC5cbiAgICogSXQgcmVxdWlyZXMgdHdvIHBvaW50czogdGhlIHNlY29uZCBjb250cm9sIHBvaW50IGFuZCB0aGUgZW5kIHBvaW50LiBUaGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlXG4gICAqIFRoZSBzdGFydGluZyBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCBpbiB0aGUgY3VycmVudCBwYXRoLlxuICAgKiBAcGFyYW0gY3AyeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AyeSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGFkanVzdCB0aGUgc21vb3RobmVzcyBvZiB0aGUgY3VydmUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYmV6aWVyQ3VydmVUb1Nob3J0KGNwMngsIGNwMnksIHgsIHksIHNtb290aG5lc3MpIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy5pbnN0cnVjdGlvbnNbdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgbGFzdFBvaW50ID0gdGhpcy5nZXRMYXN0UG9pbnQoUG9pbnQuc2hhcmVkKTtcbiAgICBsZXQgY3AxeCA9IDA7XG4gICAgbGV0IGNwMXkgPSAwO1xuICAgIGlmICghbGFzdCB8fCBsYXN0LmFjdGlvbiAhPT0gXCJiZXppZXJDdXJ2ZVRvXCIpIHtcbiAgICAgIGNwMXggPSBsYXN0UG9pbnQueDtcbiAgICAgIGNwMXkgPSBsYXN0UG9pbnQueTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3AxeCA9IGxhc3QuZGF0YVsyXTtcbiAgICAgIGNwMXkgPSBsYXN0LmRhdGFbM107XG4gICAgICBjb25zdCBjdXJyZW50WCA9IGxhc3RQb2ludC54O1xuICAgICAgY29uc3QgY3VycmVudFkgPSBsYXN0UG9pbnQueTtcbiAgICAgIGNwMXggPSBjdXJyZW50WCArIChjdXJyZW50WCAtIGNwMXgpO1xuICAgICAgY3AxeSA9IGN1cnJlbnRZICsgKGN1cnJlbnRZIC0gY3AxeSk7XG4gICAgfVxuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiYmV6aWVyQ3VydmVUb1wiLCBkYXRhOiBbY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSwgc21vb3RobmVzc10gfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aCBieSBkcmF3aW5nIGEgc3RyYWlnaHQgbGluZSBiYWNrIHRvIHRoZSBzdGFydC5cbiAgICogSWYgdGhlIHNoYXBlIGlzIGFscmVhZHkgY2xvc2VkIG9yIHRoZXJlIGFyZSBubyBwb2ludHMgaW4gdGhlIHBhdGgsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBjbG9zZVBhdGgoKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJjbG9zZVBhdGhcIiwgZGF0YTogW10gfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVsbGlwc2UoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiZWxsaXBzZVwiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaW5lVG8oLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwibGluZVRvXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG1vdmVUbyguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJtb3ZlVG9cIiwgZGF0YTogYXJncyB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBxdWFkcmF0aWNDdXJ2ZVRvKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcInF1YWRyYXRpY0N1cnZlVG9cIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBxdWFkcmF0aWMgY3VydmUgdG8gdGhlIHBhdGguIEl0IHVzZXMgdGhlIHByZXZpb3VzIHBvaW50IGFzIHRoZSBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGFkanVzdCB0aGUgc21vb3RobmVzcyBvZiB0aGUgY3VydmUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcXVhZHJhdGljQ3VydmVUb1Nob3J0KHgsIHksIHNtb290aG5lc3MpIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy5pbnN0cnVjdGlvbnNbdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgbGFzdFBvaW50ID0gdGhpcy5nZXRMYXN0UG9pbnQoUG9pbnQuc2hhcmVkKTtcbiAgICBsZXQgY3B4MSA9IDA7XG4gICAgbGV0IGNweTEgPSAwO1xuICAgIGlmICghbGFzdCB8fCBsYXN0LmFjdGlvbiAhPT0gXCJxdWFkcmF0aWNDdXJ2ZVRvXCIpIHtcbiAgICAgIGNweDEgPSBsYXN0UG9pbnQueDtcbiAgICAgIGNweTEgPSBsYXN0UG9pbnQueTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3B4MSA9IGxhc3QuZGF0YVswXTtcbiAgICAgIGNweTEgPSBsYXN0LmRhdGFbMV07XG4gICAgICBjb25zdCBjdXJyZW50WCA9IGxhc3RQb2ludC54O1xuICAgICAgY29uc3QgY3VycmVudFkgPSBsYXN0UG9pbnQueTtcbiAgICAgIGNweDEgPSBjdXJyZW50WCArIChjdXJyZW50WCAtIGNweDEpO1xuICAgICAgY3B5MSA9IGN1cnJlbnRZICsgKGN1cnJlbnRZIC0gY3B5MSk7XG4gICAgfVxuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicXVhZHJhdGljQ3VydmVUb1wiLCBkYXRhOiBbY3B4MSwgY3B5MSwgeCwgeSwgc21vb3RobmVzc10gfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlY3RhbmdsZSBzaGFwZS4gVGhpcyBtZXRob2QgYWRkcyBhIG5ldyByZWN0YW5nbGUgcGF0aCB0byB0aGUgY3VycmVudCBkcmF3aW5nLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSByZWN0YW5nbGUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVjdCh4LCB5LCB3LCBoLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcInJlY3RcIiwgZGF0YTogW3gsIHksIHcsIGgsIHRyYW5zZm9ybV0gfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIGNpcmNsZSBzaGFwZS4gVGhpcyBtZXRob2QgYWRkcyBhIG5ldyBjaXJjbGUgcGF0aCB0byB0aGUgY3VycmVudCBkcmF3aW5nLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGNpcmNsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBjaXJjbGUoeCwgeSwgcmFkaXVzLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcImNpcmNsZVwiLCBkYXRhOiBbeCwgeSwgcmFkaXVzLCB0cmFuc2Zvcm1dIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByb3VuZFJlY3QoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicm91bmRSZWN0XCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBvbHkoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicG9seVwiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWd1bGFyUG9seSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJyZWd1bGFyUG9seVwiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByb3VuZFBvbHkoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicm91bmRQb2x5XCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdW5kU2hhcGUoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicm91bmRTaGFwZVwiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmaWxsZXRSZWN0KC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcImZpbGxldFJlY3RcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2hhbWZlclJlY3QoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiY2hhbWZlclJlY3RcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgc3RhciBzaGFwZSBjZW50ZXJlZCBhdCBhIHNwZWNpZmllZCBsb2NhdGlvbi4gVGhpcyBtZXRob2QgYWxsb3dzIGZvciB0aGUgY3JlYXRpb25cbiAgICogIG9mIHN0YXJzIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgcG9pbnRzLCBvdXRlciByYWRpdXMsIG9wdGlvbmFsIGlubmVyIHJhZGl1cywgYW5kIHJvdGF0aW9uLlxuICAgKiBUaGUgc3RhciBpcyBkcmF3biBhcyBhIGNsb3NlZCBwb2x5Z29uIHdpdGggYWx0ZXJuYXRpbmcgb3V0ZXIgYW5kIGlubmVyIHZlcnRpY2VzIHRvIGNyZWF0ZSB0aGUgc3RhcidzIHBvaW50cy5cbiAgICogQW4gb3B0aW9uYWwgdHJhbnNmb3JtYXRpb24gY2FuIGJlIGFwcGxpZWQgdG8gc2NhbGUsIHJvdGF0ZSwgb3IgdHJhbnNsYXRlIHRoZSBzdGFyIGFzIG5lZWRlZC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBzdGFyLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gVGhlIG51bWJlciBvZiBwb2ludHMgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzdGFyIChkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgdG8gdGhlIG91dGVyIHBvaW50cykuXG4gICAqIEBwYXJhbSBpbm5lclJhZGl1cyAtIE9wdGlvbmFsLiBUaGUgaW5uZXIgcmFkaXVzIG9mIHRoZSBzdGFyXG4gICAqIChkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgdG8gdGhlIGlubmVyIHBvaW50cyBiZXR3ZWVuIHRoZSBvdXRlciBwb2ludHMpLlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIGhhbGYgb2YgdGhlIGByYWRpdXNgLlxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBPcHRpb25hbC4gVGhlIHJvdGF0aW9uIG9mIHRoZSBzdGFyIGluIHJhZGlhbnMsIHdoZXJlIDAgaXMgYWxpZ25lZCB3aXRoIHRoZSB5LWF4aXMuXG4gICAqIERlZmF1bHRzIHRvIDAsIG1lYW5pbmcgb25lIHBvaW50IGlzIGRpcmVjdGx5IHVwd2FyZC5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBzdGFyLlxuICAgKiBUaGlzIGNhbiBpbmNsdWRlIHJvdGF0aW9ucywgc2NhbGluZywgYW5kIHRyYW5zbGF0aW9ucy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcgZnVydGhlciBkcmF3aW5nIGNvbW1hbmRzLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgc3Rhcih4LCB5LCBwb2ludHMsIHJhZGl1cywgaW5uZXJSYWRpdXMsIHJvdGF0aW9uLCB0cmFuc2Zvcm0pIHtcbiAgICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IHJhZGl1cyAvIDI7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IC0xICogTWF0aC5QSSAvIDIgKyByb3RhdGlvbjtcbiAgICBjb25zdCBsZW4gPSBwb2ludHMgKiAyO1xuICAgIGNvbnN0IGRlbHRhID0gTWF0aC5QSSAqIDIgLyBsZW47XG4gICAgY29uc3QgcG9seWdvbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHIgPSBpICUgMiA/IGlubmVyUmFkaXVzIDogcmFkaXVzO1xuICAgICAgY29uc3QgYW5nbGUgPSBpICogZGVsdGEgKyBzdGFydEFuZ2xlO1xuICAgICAgcG9seWdvbi5wdXNoKFxuICAgICAgICB4ICsgciAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeSArIHIgKiBNYXRoLnNpbihhbmdsZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucG9seShwb2x5Z29uLCB0cnVlLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgY3VycmVudCBgR3JhcGhpY3NQYXRoYCBpbnN0YW5jZS4gVGhpcyBtZXRob2Qgc3VwcG9ydHMgYm90aCBzaGFsbG93IGFuZCBkZWVwIGNsb25pbmcuXG4gICAqIEEgc2hhbGxvdyBjbG9uZSBjb3BpZXMgdGhlIHJlZmVyZW5jZSBvZiB0aGUgaW5zdHJ1Y3Rpb25zIGFycmF5LCB3aGlsZSBhIGRlZXAgY2xvbmUgY3JlYXRlcyBhIG5ldyBhcnJheSBhbmRcbiAgICogY29waWVzIGVhY2ggaW5zdHJ1Y3Rpb24gaW5kaXZpZHVhbGx5LCBlbnN1cmluZyB0aGF0IG1vZGlmaWNhdGlvbnMgdG8gdGhlIGluc3RydWN0aW9ucyBvZiB0aGUgY2xvbmVkIGBHcmFwaGljc1BhdGhgXG4gICAqIGRvIG5vdCBhZmZlY3QgdGhlIG9yaWdpbmFsIGBHcmFwaGljc1BhdGhgIGFuZCB2aWNlIHZlcnNhLlxuICAgKiBAcGFyYW0gZGVlcCAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2xvbmUgc2hvdWxkIGJlIGRlZXAuXG4gICAqIEByZXR1cm5zIEEgbmV3IGBHcmFwaGljc1BhdGhgIGluc3RhbmNlIHRoYXQgaXMgYSBjbG9uZSBvZiB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICovXG4gIGNsb25lKGRlZXAgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5ld0dyYXBoaWNzUGF0aDJEID0gbmV3IEdyYXBoaWNzUGF0aCgpO1xuICAgIGlmICghZGVlcCkge1xuICAgICAgbmV3R3JhcGhpY3NQYXRoMkQuaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnMuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgICBuZXdHcmFwaGljc1BhdGgyRC5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogaW5zdHJ1Y3Rpb24uYWN0aW9uLCBkYXRhOiBpbnN0cnVjdGlvbi5kYXRhLnNsaWNlKCkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdHcmFwaGljc1BhdGgyRDtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBhbGwgZHJhd2luZyBpbnN0cnVjdGlvbnMgd2l0aGluIHRoZSBgR3JhcGhpY3NQYXRoYC5cbiAgICogVGhpcyBtZXRob2QgZW5hYmxlcyB0aGUgbW9kaWZpY2F0aW9uIG9mIHRoZSBwYXRoJ3MgZ2VvbWV0cnkgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZFxuICAgKiB0cmFuc2Zvcm1hdGlvbiBtYXRyaXgsIHdoaWNoIGNhbiBpbmNsdWRlIHRyYW5zbGF0aW9ucywgcm90YXRpb25zLCBzY2FsaW5nLCBhbmQgc2tld2luZy5cbiAgICpcbiAgICogRWFjaCBkcmF3aW5nIGluc3RydWN0aW9uIGluIHRoZSBwYXRoIGlzIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGUgdHJhbnNmb3JtYXRpb24sXG4gICAqIGVuc3VyaW5nIHRoZSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhdGggaXMgY29uc2lzdGVudCB3aXRoIHRoZSBhcHBsaWVkIG1hdHJpeC5cbiAgICpcbiAgICogTm90ZTogVGhlIHRyYW5zZm9ybWF0aW9uIGlzIGFwcGxpZWQgZGlyZWN0bHkgdG8gdGhlIGNvb3JkaW5hdGVzIGFuZCBjb250cm9sIHBvaW50cyBvZiB0aGUgZHJhd2luZyBpbnN0cnVjdGlvbnMsXG4gICAqIG5vdCB0byB0aGUgcGF0aCBhcyBhIHdob2xlLiBUaGlzIG1lYW5zIHRoZSB0cmFuc2Zvcm1hdGlvbidzIGVmZmVjdHMgYXJlIGJha2VkIGludG8gdGhlIGluZGl2aWR1YWwgaW5zdHJ1Y3Rpb25zLFxuICAgKiBhbGxvd2luZyBmb3IgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgcGF0aCdzIGFwcGVhcmFuY2UuXG4gICAqIEBwYXJhbSBtYXRyaXggLSBBIGBNYXRyaXhgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZyBmdXJ0aGVyIG9wZXJhdGlvbnMuXG4gICAqL1xuICB0cmFuc2Zvcm0obWF0cml4KSB7XG4gICAgaWYgKG1hdHJpeC5pc0lkZW50aXR5KCkpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCBhID0gbWF0cml4LmE7XG4gICAgY29uc3QgYiA9IG1hdHJpeC5iO1xuICAgIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgICBjb25zdCBkID0gbWF0cml4LmQ7XG4gICAgY29uc3QgdHggPSBtYXRyaXgudHg7XG4gICAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY3B4MSA9IDA7XG4gICAgbGV0IGNweTEgPSAwO1xuICAgIGxldCBjcHgyID0gMDtcbiAgICBsZXQgY3B5MiA9IDA7XG4gICAgbGV0IHJ4ID0gMDtcbiAgICBsZXQgcnkgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbaV07XG4gICAgICBjb25zdCBkYXRhID0gaW5zdHJ1Y3Rpb24uZGF0YTtcbiAgICAgIHN3aXRjaCAoaW5zdHJ1Y3Rpb24uYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJtb3ZlVG9cIjpcbiAgICAgICAgY2FzZSBcImxpbmVUb1wiOlxuICAgICAgICAgIHggPSBkYXRhWzBdO1xuICAgICAgICAgIHkgPSBkYXRhWzFdO1xuICAgICAgICAgIGRhdGFbMF0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICAgICAgZGF0YVsxXSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJlemllckN1cnZlVG9cIjpcbiAgICAgICAgICBjcHgxID0gZGF0YVswXTtcbiAgICAgICAgICBjcHkxID0gZGF0YVsxXTtcbiAgICAgICAgICBjcHgyID0gZGF0YVsyXTtcbiAgICAgICAgICBjcHkyID0gZGF0YVszXTtcbiAgICAgICAgICB4ID0gZGF0YVs0XTtcbiAgICAgICAgICB5ID0gZGF0YVs1XTtcbiAgICAgICAgICBkYXRhWzBdID0gYSAqIGNweDEgKyBjICogY3B5MSArIHR4O1xuICAgICAgICAgIGRhdGFbMV0gPSBiICogY3B4MSArIGQgKiBjcHkxICsgdHk7XG4gICAgICAgICAgZGF0YVsyXSA9IGEgKiBjcHgyICsgYyAqIGNweTIgKyB0eDtcbiAgICAgICAgICBkYXRhWzNdID0gYiAqIGNweDIgKyBkICogY3B5MiArIHR5O1xuICAgICAgICAgIGRhdGFbNF0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICAgICAgZGF0YVs1XSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInF1YWRyYXRpY0N1cnZlVG9cIjpcbiAgICAgICAgICBjcHgxID0gZGF0YVswXTtcbiAgICAgICAgICBjcHkxID0gZGF0YVsxXTtcbiAgICAgICAgICB4ID0gZGF0YVsyXTtcbiAgICAgICAgICB5ID0gZGF0YVszXTtcbiAgICAgICAgICBkYXRhWzBdID0gYSAqIGNweDEgKyBjICogY3B5MSArIHR4O1xuICAgICAgICAgIGRhdGFbMV0gPSBiICogY3B4MSArIGQgKiBjcHkxICsgdHk7XG4gICAgICAgICAgZGF0YVsyXSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICAgICAgICBkYXRhWzNdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXJjVG9TdmdcIjpcbiAgICAgICAgICB4ID0gZGF0YVs1XTtcbiAgICAgICAgICB5ID0gZGF0YVs2XTtcbiAgICAgICAgICByeCA9IGRhdGFbMF07XG4gICAgICAgICAgcnkgPSBkYXRhWzFdO1xuICAgICAgICAgIGRhdGFbMF0gPSBhICogcnggKyBjICogcnk7XG4gICAgICAgICAgZGF0YVsxXSA9IGIgKiByeCArIGQgKiByeTtcbiAgICAgICAgICBkYXRhWzVdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgICAgICAgIGRhdGFbNl0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjaXJjbGVcIjpcbiAgICAgICAgICBkYXRhWzRdID0gYWRqdXN0VHJhbnNmb3JtKGRhdGFbM10sIG1hdHJpeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWN0XCI6XG4gICAgICAgICAgZGF0YVs0XSA9IGFkanVzdFRyYW5zZm9ybShkYXRhWzRdLCBtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgIGRhdGFbOF0gPSBhZGp1c3RUcmFuc2Zvcm0oZGF0YVs4XSwgbWF0cml4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJvdW5kUmVjdFwiOlxuICAgICAgICAgIGRhdGFbNV0gPSBhZGp1c3RUcmFuc2Zvcm0oZGF0YVs1XSwgbWF0cml4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFkZFBhdGhcIjpcbiAgICAgICAgICBkYXRhWzBdLnRyYW5zZm9ybShtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicG9seVwiOlxuICAgICAgICAgIGRhdGFbMl0gPSBhZGp1c3RUcmFuc2Zvcm0oZGF0YVsyXSwgbWF0cml4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB3YXJuKFwidW5rbm93biB0cmFuc2Zvcm0gYWN0aW9uXCIsIGluc3RydWN0aW9uLmFjdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQgYm91bmRzKCkge1xuICAgIHJldHVybiB0aGlzLnNoYXBlUGF0aC5ib3VuZHM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbGFzdCBwb2ludCBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgaW5zdHJ1Y3Rpb25zIGluIHRoZSBgR3JhcGhpY3NQYXRoYC5cbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciBvcGVyYXRpb25zIHRoYXQgZGVwZW5kIG9uIHRoZSBwYXRoJ3MgY3VycmVudCBlbmRwb2ludCxcbiAgICogc3VjaCBhcyBjb25uZWN0aW5nIHN1YnNlcXVlbnQgc2hhcGVzIG9yIHBhdGhzLiBJdCBzdXBwb3J0cyB2YXJpb3VzIGRyYXdpbmcgaW5zdHJ1Y3Rpb25zLFxuICAgKiBlbnN1cmluZyB0aGUgbGFzdCBwb2ludCdzIHBvc2l0aW9uIGlzIGFjY3VyYXRlbHkgZGV0ZXJtaW5lZCByZWdhcmRsZXNzIG9mIHRoZSBwYXRoJ3MgY29tcGxleGl0eS5cbiAgICpcbiAgICogSWYgdGhlIGxhc3QgaW5zdHJ1Y3Rpb24gaXMgYSBgY2xvc2VQYXRoYCwgdGhlIG1ldGhvZCBpdGVyYXRlcyBiYWNrd2FyZCB0aHJvdWdoIHRoZSBpbnN0cnVjdGlvbnNcbiAgICogIHVudGlsIGl0IGZpbmRzIGFuIGFjdGlvbmFibGUgaW5zdHJ1Y3Rpb24gdGhhdCBkZWZpbmVzIGEgcG9pbnQgKGUuZy4sIGBtb3ZlVG9gLCBgbGluZVRvYCxcbiAgICogYHF1YWRyYXRpY0N1cnZlVG9gLCBldGMuKS4gRm9yIGNvbXBvdW5kIHBhdGhzIGFkZGVkIHZpYSBgYWRkUGF0aGAsIGl0IHJlY3Vyc2l2ZWx5IHJldHJpZXZlc1xuICAgKiB0aGUgbGFzdCBwb2ludCBmcm9tIHRoZSBuZXN0ZWQgcGF0aC5cbiAgICogQHBhcmFtIG91dCAtIEEgYFBvaW50YCBvYmplY3Qgd2hlcmUgdGhlIGxhc3QgcG9pbnQncyBjb29yZGluYXRlcyB3aWxsIGJlIHN0b3JlZC5cbiAgICogVGhpcyBvYmplY3QgaXMgbW9kaWZpZWQgZGlyZWN0bHkgdG8gY29udGFpbiB0aGUgcmVzdWx0LlxuICAgKiBAcmV0dXJucyBUaGUgYFBvaW50YCBvYmplY3QgY29udGFpbmluZyB0aGUgbGFzdCBwb2ludCdzIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgZ2V0TGFzdFBvaW50KG91dCkge1xuICAgIGxldCBpbmRleCA9IHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDE7XG4gICAgbGV0IGxhc3RJbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25zW2luZGV4XTtcbiAgICBpZiAoIWxhc3RJbnN0cnVjdGlvbikge1xuICAgICAgb3V0LnggPSAwO1xuICAgICAgb3V0LnkgPSAwO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgd2hpbGUgKGxhc3RJbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwiY2xvc2VQYXRoXCIpIHtcbiAgICAgIGluZGV4LS07XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIG91dC54ID0gMDtcbiAgICAgICAgb3V0LnkgPSAwO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgICAgbGFzdEluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbaW5kZXhdO1xuICAgIH1cbiAgICBzd2l0Y2ggKGxhc3RJbnN0cnVjdGlvbi5hY3Rpb24pIHtcbiAgICAgIGNhc2UgXCJtb3ZlVG9cIjpcbiAgICAgIGNhc2UgXCJsaW5lVG9cIjpcbiAgICAgICAgb3V0LnggPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVswXTtcbiAgICAgICAgb3V0LnkgPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicXVhZHJhdGljQ3VydmVUb1wiOlxuICAgICAgICBvdXQueCA9IGxhc3RJbnN0cnVjdGlvbi5kYXRhWzJdO1xuICAgICAgICBvdXQueSA9IGxhc3RJbnN0cnVjdGlvbi5kYXRhWzNdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiZXppZXJDdXJ2ZVRvXCI6XG4gICAgICAgIG91dC54ID0gbGFzdEluc3RydWN0aW9uLmRhdGFbNF07XG4gICAgICAgIG91dC55ID0gbGFzdEluc3RydWN0aW9uLmRhdGFbNV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFyY1wiOlxuICAgICAgY2FzZSBcImFyY1RvU3ZnXCI6XG4gICAgICAgIG91dC54ID0gbGFzdEluc3RydWN0aW9uLmRhdGFbNV07XG4gICAgICAgIG91dC55ID0gbGFzdEluc3RydWN0aW9uLmRhdGFbNl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFkZFBhdGhcIjpcbiAgICAgICAgbGFzdEluc3RydWN0aW9uLmRhdGFbMF0uZ2V0TGFzdFBvaW50KG91dCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG5mdW5jdGlvbiBhZGp1c3RUcmFuc2Zvcm0oY3VycmVudE1hdHJpeCwgdHJhbnNmb3JtKSB7XG4gIGlmIChjdXJyZW50TWF0cml4KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRNYXRyaXgucHJlcGVuZCh0cmFuc2Zvcm0pO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm0uY2xvbmUoKTtcbn1cblxuZXhwb3J0IHsgR3JhcGhpY3NQYXRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljc1BhdGgubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NQYXRoIH0gZnJvbSAnLi4vcGF0aC9HcmFwaGljc1BhdGgubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBTVkdQYXJzZXIoc3ZnLCBncmFwaGljc0NvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiBzdmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5pbm5lckhUTUwgPSBzdmcudHJpbSgpO1xuICAgIHN2ZyA9IGRpdi5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpO1xuICB9XG4gIGNvbnN0IHNlc3Npb24gPSB7XG4gICAgY29udGV4dDogZ3JhcGhpY3NDb250ZXh0LFxuICAgIHBhdGg6IG5ldyBHcmFwaGljc1BhdGgoKVxuICB9O1xuICByZW5kZXJDaGlsZHJlbihzdmcsIHNlc3Npb24sIG51bGwsIG51bGwpO1xuICByZXR1cm4gZ3JhcGhpY3NDb250ZXh0O1xufVxuZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oc3ZnLCBzZXNzaW9uLCBmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gc3ZnLmNoaWxkcmVuO1xuICBjb25zdCB7IGZpbGxTdHlsZTogZjEsIHN0cm9rZVN0eWxlOiBzMSB9ID0gcGFyc2VTdHlsZShzdmcpO1xuICBpZiAoZjEgJiYgZmlsbFN0eWxlKSB7XG4gICAgZmlsbFN0eWxlID0geyAuLi5maWxsU3R5bGUsIC4uLmYxIH07XG4gIH0gZWxzZSBpZiAoZjEpIHtcbiAgICBmaWxsU3R5bGUgPSBmMTtcbiAgfVxuICBpZiAoczEgJiYgc3Ryb2tlU3R5bGUpIHtcbiAgICBzdHJva2VTdHlsZSA9IHsgLi4uc3Ryb2tlU3R5bGUsIC4uLnMxIH07XG4gIH0gZWxzZSBpZiAoczEpIHtcbiAgICBzdHJva2VTdHlsZSA9IHMxO1xuICB9XG4gIHNlc3Npb24uY29udGV4dC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gIHNlc3Npb24uY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICBsZXQgeDtcbiAgbGV0IHk7XG4gIGxldCB4MTtcbiAgbGV0IHkxO1xuICBsZXQgeDI7XG4gIGxldCB5MjtcbiAgbGV0IGN4O1xuICBsZXQgY3k7XG4gIGxldCByO1xuICBsZXQgcng7XG4gIGxldCByeTtcbiAgbGV0IHBvaW50cztcbiAgbGV0IHBvaW50c1N0cmluZztcbiAgbGV0IGQ7XG4gIGxldCBncmFwaGljc1BhdGg7XG4gIGxldCB3aWR0aDtcbiAgbGV0IGhlaWdodDtcbiAgc3dpdGNoIChzdmcubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICBkID0gc3ZnLmdldEF0dHJpYnV0ZShcImRcIik7XG4gICAgICBncmFwaGljc1BhdGggPSBuZXcgR3JhcGhpY3NQYXRoKGQpO1xuICAgICAgc2Vzc2lvbi5jb250ZXh0LnBhdGgoZ3JhcGhpY3NQYXRoKTtcbiAgICAgIGlmIChmaWxsU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5maWxsKCk7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5zdHJva2UoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjaXJjbGVcIjpcbiAgICAgIGN4ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiY3hcIiwgMCk7XG4gICAgICBjeSA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcImN5XCIsIDApO1xuICAgICAgciA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInJcIiwgMCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQuZWxsaXBzZShjeCwgY3ksIHIsIHIpO1xuICAgICAgaWYgKGZpbGxTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LmZpbGwoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJlY3RcIjpcbiAgICAgIHggPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJ4XCIsIDApO1xuICAgICAgeSA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInlcIiwgMCk7XG4gICAgICB3aWR0aCA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcIndpZHRoXCIsIDApO1xuICAgICAgaGVpZ2h0ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiaGVpZ2h0XCIsIDApO1xuICAgICAgcnggPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJyeFwiLCAwKTtcbiAgICAgIHJ5ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwicnlcIiwgMCk7XG4gICAgICBpZiAocnggfHwgcnkpIHtcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnJvdW5kUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByeCB8fCByeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXNzaW9uLmNvbnRleHQucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5maWxsKCk7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5zdHJva2UoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICBjeCA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcImN4XCIsIDApO1xuICAgICAgY3kgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJjeVwiLCAwKTtcbiAgICAgIHJ4ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwicnhcIiwgMCk7XG4gICAgICByeSA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInJ5XCIsIDApO1xuICAgICAgc2Vzc2lvbi5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgc2Vzc2lvbi5jb250ZXh0LmVsbGlwc2UoY3gsIGN5LCByeCwgcnkpO1xuICAgICAgaWYgKGZpbGxTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LmZpbGwoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImxpbmVcIjpcbiAgICAgIHgxID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwieDFcIiwgMCk7XG4gICAgICB5MSA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInkxXCIsIDApO1xuICAgICAgeDIgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJ4MlwiLCAwKTtcbiAgICAgIHkyID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwieTJcIiwgMCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQubW92ZVRvKHgxLCB5MSk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQubGluZVRvKHgyLCB5Mik7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5zdHJva2UoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwb2x5Z29uXCI6XG4gICAgICBwb2ludHNTdHJpbmcgPSBzdmcuZ2V0QXR0cmlidXRlKFwicG9pbnRzXCIpO1xuICAgICAgcG9pbnRzID0gcG9pbnRzU3RyaW5nLm1hdGNoKC9cXGQrL2cpLm1hcCgobikgPT4gcGFyc2VJbnQobiwgMTApKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5wb2x5KHBvaW50cywgdHJ1ZSk7XG4gICAgICBpZiAoZmlsbFN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuZmlsbCgpO1xuICAgICAgaWYgKHN0cm9rZVN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicG9seWxpbmVcIjpcbiAgICAgIHBvaW50c1N0cmluZyA9IHN2Zy5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIik7XG4gICAgICBwb2ludHMgPSBwb2ludHNTdHJpbmcubWF0Y2goL1xcZCsvZykubWFwKChuKSA9PiBwYXJzZUludChuLCAxMCkpO1xuICAgICAgc2Vzc2lvbi5jb250ZXh0LnBvbHkocG9pbnRzLCBmYWxzZSk7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5zdHJva2UoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInN2Z1wiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc29sZS5pbmZvKGBbU1ZHIHBhcnNlcl0gPCR7c3ZnLm5vZGVOYW1lfT4gZWxlbWVudHMgdW5zdXBwb3J0ZWRgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVuZGVyQ2hpbGRyZW4oY2hpbGRyZW5baV0sIHNlc3Npb24sIGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgaWQsIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCB2YWx1ZSA9IHN2Zy5nZXRBdHRyaWJ1dGUoaWQpO1xuICByZXR1cm4gdmFsdWUgPyBOdW1iZXIodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gcGFyc2VTdHlsZShzdmcpIHtcbiAgY29uc3Qgc3R5bGUgPSBzdmcuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIGNvbnN0IHN0cm9rZVN0eWxlID0ge307XG4gIGNvbnN0IGZpbGxTdHlsZSA9IHt9O1xuICBsZXQgdXNlRmlsbCA9IGZhbHNlO1xuICBsZXQgdXNlU3Ryb2tlID0gZmFsc2U7XG4gIGlmIChzdHlsZSkge1xuICAgIGNvbnN0IHN0eWxlUGFydHMgPSBzdHlsZS5zcGxpdChcIjtcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdHlsZVBhcnQgPSBzdHlsZVBhcnRzW2ldO1xuICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gc3R5bGVQYXJ0LnNwbGl0KFwiOlwiKTtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJzdHJva2VcIjpcbiAgICAgICAgICBpZiAodmFsdWUgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICBzdHJva2VTdHlsZS5jb2xvciA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZSh2YWx1ZSkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIHVzZVN0cm9rZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3Ryb2tlLXdpZHRoXCI6XG4gICAgICAgICAgc3Ryb2tlU3R5bGUud2lkdGggPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmlsbFwiOlxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHVzZUZpbGwgPSB0cnVlO1xuICAgICAgICAgICAgZmlsbFN0eWxlLmNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHZhbHVlKS50b051bWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZpbGwtb3BhY2l0eVwiOlxuICAgICAgICAgIGZpbGxTdHlsZS5hbHBoYSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJva2Utb3BhY2l0eVwiOlxuICAgICAgICAgIHN0cm9rZVN0eWxlLmFscGhhID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9wYWNpdHlcIjpcbiAgICAgICAgICBmaWxsU3R5bGUuYWxwaGEgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIHN0cm9rZVN0eWxlLmFscGhhID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3Ryb2tlID0gc3ZnLmdldEF0dHJpYnV0ZShcInN0cm9rZVwiKTtcbiAgICBpZiAoc3Ryb2tlICYmIHN0cm9rZSAhPT0gXCJub25lXCIpIHtcbiAgICAgIHVzZVN0cm9rZSA9IHRydWU7XG4gICAgICBzdHJva2VTdHlsZS5jb2xvciA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShzdHJva2UpLnRvTnVtYmVyKCk7XG4gICAgICBzdHJva2VTdHlsZS53aWR0aCA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInN0cm9rZS13aWR0aFwiLCAxKTtcbiAgICB9XG4gICAgY29uc3QgZmlsbCA9IHN2Zy5nZXRBdHRyaWJ1dGUoXCJmaWxsXCIpO1xuICAgIGlmIChmaWxsICYmIGZpbGwgIT09IFwibm9uZVwiKSB7XG4gICAgICB1c2VGaWxsID0gdHJ1ZTtcbiAgICAgIGZpbGxTdHlsZS5jb2xvciA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShmaWxsKS50b051bWJlcigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHN0cm9rZVN0eWxlOiB1c2VTdHJva2UgPyBzdHJva2VTdHlsZSA6IG51bGwsXG4gICAgZmlsbFN0eWxlOiB1c2VGaWxsID8gZmlsbFN0eWxlIDogbnVsbFxuICB9O1xufVxuXG5leHBvcnQgeyBTVkdQYXJzZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNWR1BhcnNlci5tanMubWFwXG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi8uLi9tYXRocy9wb2ludC9Qb2ludC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NQYXRoIH0gZnJvbSAnLi9wYXRoL0dyYXBoaWNzUGF0aC5tanMnO1xuaW1wb3J0IHsgU1ZHUGFyc2VyIH0gZnJvbSAnLi9zdmcvU1ZHUGFyc2VyLm1qcyc7XG5pbXBvcnQgeyBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUgfSBmcm9tICcuL3V0aWxzL2NvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRtcFBvaW50ID0gbmV3IFBvaW50KCk7XG5jb25zdCB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuY29uc3QgX0dyYXBoaWNzQ29udGV4dCA9IGNsYXNzIF9HcmFwaGljc0NvbnRleHQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudWlkID0gdWlkKFwiZ3JhcGhpY3NDb250ZXh0XCIpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuYmF0Y2hNb2RlID0gXCJhdXRvXCI7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoID0gbmV3IEdyYXBoaWNzUGF0aCgpO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLl9maWxsU3R5bGUgPSB7IC4uLl9HcmFwaGljc0NvbnRleHQuZGVmYXVsdEZpbGxTdHlsZSB9O1xuICAgIHRoaXMuX3N0cm9rZVN0eWxlID0geyAuLi5fR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRTdHJva2VTdHlsZSB9O1xuICAgIHRoaXMuX3N0YXRlU3RhY2sgPSBbXTtcbiAgICB0aGlzLl90aWNrID0gMDtcbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEdyYXBoaWNzQ29udGV4dCBvYmplY3QgdGhhdCBpcyBhIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UsIGNvcHlpbmcgYWxsIHByb3BlcnRpZXMsXG4gICAqIGluY2x1ZGluZyB0aGUgY3VycmVudCBkcmF3aW5nIHN0YXRlLCB0cmFuc2Zvcm1hdGlvbnMsIHN0eWxlcywgYW5kIGluc3RydWN0aW9ucy5cbiAgICogQHJldHVybnMgQSBuZXcgR3JhcGhpY3NDb250ZXh0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBhbmQgc3RhdGUgYXMgdGhpcyBvbmUuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBfR3JhcGhpY3NDb250ZXh0KCk7XG4gICAgY2xvbmUuYmF0Y2hNb2RlID0gdGhpcy5iYXRjaE1vZGU7XG4gICAgY2xvbmUuaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnMuc2xpY2UoKTtcbiAgICBjbG9uZS5fYWN0aXZlUGF0aCA9IHRoaXMuX2FjdGl2ZVBhdGguY2xvbmUoKTtcbiAgICBjbG9uZS5fdHJhbnNmb3JtID0gdGhpcy5fdHJhbnNmb3JtLmNsb25lKCk7XG4gICAgY2xvbmUuX2ZpbGxTdHlsZSA9IHsgLi4udGhpcy5fZmlsbFN0eWxlIH07XG4gICAgY2xvbmUuX3N0cm9rZVN0eWxlID0geyAuLi50aGlzLl9zdHJva2VTdHlsZSB9O1xuICAgIGNsb25lLl9zdGF0ZVN0YWNrID0gdGhpcy5fc3RhdGVTdGFjay5zbGljZSgpO1xuICAgIGNsb25lLl9ib3VuZHMgPSB0aGlzLl9ib3VuZHMuY2xvbmUoKTtcbiAgICBjbG9uZS5fYm91bmRzRGlydHkgPSB0cnVlO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgZmlsbCBzdHlsZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC4gVGhpcyBjYW4gYmUgYSBjb2xvciwgZ3JhZGllbnQsIHBhdHRlcm4sIG9yIGEgbW9yZSBjb21wbGV4IHN0eWxlIGRlZmluZWQgYnkgYSBGaWxsU3R5bGUgb2JqZWN0LlxuICAgKi9cbiAgZ2V0IGZpbGxTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbFN0eWxlO1xuICB9XG4gIHNldCBmaWxsU3R5bGUodmFsdWUpIHtcbiAgICB0aGlzLl9maWxsU3R5bGUgPSBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUodmFsdWUsIF9HcmFwaGljc0NvbnRleHQuZGVmYXVsdEZpbGxTdHlsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC4gU2ltaWxhciB0byBmaWxsIHN0eWxlcywgc3Ryb2tlIHN0eWxlcyBjYW4gZW5jb21wYXNzIGNvbG9ycywgZ3JhZGllbnRzLCBwYXR0ZXJucywgb3IgbW9yZSBkZXRhaWxlZCBjb25maWd1cmF0aW9ucyB2aWEgYSBTdHJva2VTdHlsZSBvYmplY3QuXG4gICAqL1xuICBnZXQgc3Ryb2tlU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cm9rZVN0eWxlO1xuICB9XG4gIHNldCBzdHJva2VTdHlsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3N0cm9rZVN0eWxlID0gY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlKHZhbHVlLCBfR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRTdHJva2VTdHlsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgZmlsbCBzdHlsZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC4gVGhlIGZpbGwgc3R5bGUgY2FuIGJlIGEgY29sb3IsIGdyYWRpZW50LFxuICAgKiBwYXR0ZXJuLCBvciBhIG1vcmUgY29tcGxleCBzdHlsZSBkZWZpbmVkIGJ5IGEgRmlsbFN0eWxlIG9iamVjdC5cbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIGZpbGwgc3R5bGUgdG8gYXBwbHkuIFRoaXMgY2FuIGJlIGEgc2ltcGxlIGNvbG9yLCBhIGdyYWRpZW50IG9yIHBhdHRlcm4gb2JqZWN0LFxuICAgKiAgICAgICAgICAgICAgICBvciBhIEZpbGxTdHlsZSBvciBDb252ZXJ0ZWRGaWxsU3R5bGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBzZXRGaWxsU3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLl9maWxsU3R5bGUgPSBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUoc3R5bGUsIF9HcmFwaGljc0NvbnRleHQuZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgc3Ryb2tlIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBTaW1pbGFyIHRvIGZpbGwgc3R5bGVzLCBzdHJva2Ugc3R5bGVzIGNhblxuICAgKiBlbmNvbXBhc3MgY29sb3JzLCBncmFkaWVudHMsIHBhdHRlcm5zLCBvciBtb3JlIGRldGFpbGVkIGNvbmZpZ3VyYXRpb25zIHZpYSBhIFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0cm9rZSBzdHlsZSB0byBhcHBseS4gQ2FuIGJlIGRlZmluZWQgYXMgYSBjb2xvciwgYSBncmFkaWVudCBvciBwYXR0ZXJuLFxuICAgKiAgICAgICAgICAgICAgICBvciBhIFN0cm9rZVN0eWxlIG9yIENvbnZlcnRlZFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc2V0U3Ryb2tlU3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLl9zdHJva2VTdHlsZSA9IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZShzdHlsZSwgX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRleHR1cmUodGV4dHVyZSwgdGludCwgZHgsIGR5LCBkdywgZGgpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgIGFjdGlvbjogXCJ0ZXh0dXJlXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGltYWdlOiB0ZXh0dXJlLFxuICAgICAgICBkeDogZHggfHwgMCxcbiAgICAgICAgZHk6IGR5IHx8IDAsXG4gICAgICAgIGR3OiBkdyB8fCB0ZXh0dXJlLmZyYW1lLndpZHRoLFxuICAgICAgICBkaDogZGggfHwgdGV4dHVyZS5mcmFtZS5oZWlnaHQsXG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5fdHJhbnNmb3JtLmNsb25lKCksXG4gICAgICAgIGFscGhhOiB0aGlzLl9maWxsU3R5bGUuYWxwaGEsXG4gICAgICAgIHN0eWxlOiB0aW50ID8gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRpbnQpLnRvTnVtYmVyKCkgOiAxNjc3NzIxNVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBjdXJyZW50IHBhdGguIEFueSBwcmV2aW91cyBwYXRoIGFuZCBpdHMgY29tbWFuZHMgYXJlIGRpc2NhcmRlZCBhbmQgYSBuZXcgcGF0aCBpc1xuICAgKiBzdGFydGVkLiBUaGlzIGlzIHR5cGljYWxseSBjYWxsZWQgYmVmb3JlIGJlZ2lubmluZyBhIG5ldyBzaGFwZSBvciBzZXJpZXMgb2YgZHJhd2luZyBjb21tYW5kcy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgYmVnaW5QYXRoKCkge1xuICAgIHRoaXMuX2FjdGl2ZVBhdGggPSBuZXcgR3JhcGhpY3NQYXRoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZmlsbChzdHlsZSwgYWxwaGEpIHtcbiAgICBsZXQgcGF0aDtcbiAgICBjb25zdCBsYXN0SW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGhpcy5fdGljayA9PT0gMCAmJiBsYXN0SW5zdHJ1Y3Rpb24gJiYgbGFzdEluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJzdHJva2VcIikge1xuICAgICAgcGF0aCA9IGxhc3RJbnN0cnVjdGlvbi5kYXRhLnBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSB0aGlzLl9hY3RpdmVQYXRoLmNsb25lKCk7XG4gICAgfVxuICAgIGlmICghcGF0aClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmIChzdHlsZSAhPSBudWxsKSB7XG4gICAgICBpZiAoYWxwaGEgIT09IHZvaWQgMCAmJiB0eXBlb2Ygc3R5bGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzQ29udGV4dC5maWxsKGNvbG9yLCBhbHBoYSkgaXMgZGVwcmVjYXRlZCwgdXNlIEdyYXBoaWNzQ29udGV4dC5maWxsKHsgY29sb3IsIGFscGhhIH0pIGluc3RlYWRcIik7XG4gICAgICAgIHN0eWxlID0geyBjb2xvcjogc3R5bGUsIGFscGhhIH07XG4gICAgICB9XG4gICAgICB0aGlzLl9maWxsU3R5bGUgPSBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUoc3R5bGUsIF9HcmFwaGljc0NvbnRleHQuZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgfVxuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgYWN0aW9uOiBcImZpbGxcIixcbiAgICAgIC8vIFRPRE8gY29weSBmaWxsIHN0eWxlIVxuICAgICAgZGF0YTogeyBzdHlsZTogdGhpcy5maWxsU3R5bGUsIHBhdGggfVxuICAgIH0pO1xuICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICB0aGlzLl9pbml0TmV4dFBhdGhMb2NhdGlvbigpO1xuICAgIHRoaXMuX3RpY2sgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9pbml0TmV4dFBhdGhMb2NhdGlvbigpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuX2FjdGl2ZVBhdGguZ2V0TGFzdFBvaW50KFBvaW50LnNoYXJlZCk7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5jbGVhcigpO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgubW92ZVRvKHgsIHkpO1xuICB9XG4gIC8qKlxuICAgKiBTdHJva2VzIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUuIFRoaXMgbWV0aG9kIGNhbiB0YWtlIGFuIG9wdGlvbmFsXG4gICAqIEZpbGxTdHlsZUlucHV0cyBwYXJhbWV0ZXIgdG8gZGVmaW5lIHRoZSBzdHJva2UncyBhcHBlYXJhbmNlLCBpbmNsdWRpbmcgaXRzIGNvbG9yLCB3aWR0aCwgYW5kIG90aGVyIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBzdHlsZSAtIChPcHRpb25hbCkgVGhlIHN0cm9rZSBzdHlsZSB0byBhcHBseS4gQ2FuIGJlIGRlZmluZWQgYXMgYSBzaW1wbGUgY29sb3Igb3IgYSBtb3JlIGNvbXBsZXggc3R5bGUgb2JqZWN0LiBJZiBvbWl0dGVkLCB1c2VzIHRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc3Ryb2tlKHN0eWxlKSB7XG4gICAgbGV0IHBhdGg7XG4gICAgY29uc3QgbGFzdEluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRoaXMuX3RpY2sgPT09IDAgJiYgbGFzdEluc3RydWN0aW9uICYmIGxhc3RJbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICBwYXRoID0gbGFzdEluc3RydWN0aW9uLmRhdGEucGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHRoaXMuX2FjdGl2ZVBhdGguY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKCFwYXRoKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHN0eWxlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3N0cm9rZVN0eWxlID0gY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlKHN0eWxlLCBfR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRTdHJva2VTdHlsZSk7XG4gICAgfVxuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgYWN0aW9uOiBcInN0cm9rZVwiLFxuICAgICAgLy8gVE9ETyBjb3B5IGZpbGwgc3R5bGUhXG4gICAgICBkYXRhOiB7IHN0eWxlOiB0aGlzLnN0cm9rZVN0eWxlLCBwYXRoIH1cbiAgICB9KTtcbiAgICB0aGlzLm9uVXBkYXRlKCk7XG4gICAgdGhpcy5faW5pdE5leHRQYXRoTG9jYXRpb24oKTtcbiAgICB0aGlzLl90aWNrID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIGN1dG91dCB0byB0aGUgbGFzdCBkcmF3biBzaGFwZS4gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBob2xlcyBvciBjb21wbGV4IHNoYXBlcyBieVxuICAgKiBzdWJ0cmFjdGluZyBhIHBhdGggZnJvbSB0aGUgcHJldmlvdXNseSBkcmF3biBwYXRoLiBJZiBhIGhvbGUgaXMgbm90IGNvbXBsZXRlbHkgaW4gYSBzaGFwZSwgaXQgd2lsbFxuICAgKiBmYWlsIHRvIGN1dCBjb3JyZWN0bHkhXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIGN1dCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgY29uc3QgbGFzdEluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgY29uc3QgaG9sZVBhdGggPSB0aGlzLl9hY3RpdmVQYXRoLmNsb25lKCk7XG4gICAgICBpZiAobGFzdEluc3RydWN0aW9uKSB7XG4gICAgICAgIGlmIChsYXN0SW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInN0cm9rZVwiIHx8IGxhc3RJbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICAgICAgaWYgKGxhc3RJbnN0cnVjdGlvbi5kYXRhLmhvbGUpIHtcbiAgICAgICAgICAgIGxhc3RJbnN0cnVjdGlvbi5kYXRhLmhvbGUuYWRkUGF0aChob2xlUGF0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RJbnN0cnVjdGlvbi5kYXRhLmhvbGUgPSBob2xlUGF0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pbml0TmV4dFBhdGhMb2NhdGlvbigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFyYyB0byB0aGUgY3VycmVudCBwYXRoLCB3aGljaCBpcyBjZW50ZXJlZCBhdCAoeCwgeSkgd2l0aCB0aGUgc3BlY2lmaWVkIHJhZGl1cyxcbiAgICogc3RhcnRpbmcgYW5kIGVuZGluZyBhbmdsZXMsIGFuZCBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgY2VudGVyLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGNlbnRlci5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBhcmMncyByYWRpdXMuXG4gICAqIEBwYXJhbSBzdGFydEFuZ2xlIC0gVGhlIHN0YXJ0aW5nIGFuZ2xlLCBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0gZW5kQW5nbGUgLSBUaGUgZW5kaW5nIGFuZ2xlLCBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0gY291bnRlcmNsb2Nrd2lzZSAtIChPcHRpb25hbCkgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGFyYyBpcyBkcmF3biBjb3VudGVyY2xvY2t3aXNlICh0cnVlKSBvciBjbG9ja3dpc2UgKGZhbHNlKS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIGFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyY2xvY2t3aXNlKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIGNvbnN0IHQgPSB0aGlzLl90cmFuc2Zvcm07XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5hcmMoXG4gICAgICB0LmEgKiB4ICsgdC5jICogeSArIHQudHgsXG4gICAgICB0LmIgKiB4ICsgdC5kICogeSArIHQudHksXG4gICAgICByYWRpdXMsXG4gICAgICBzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUsXG4gICAgICBjb3VudGVyY2xvY2t3aXNlXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBhcmMgdG8gdGhlIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBnaXZlbiBjb250cm9sIHBvaW50cyBhbmQgcmFkaXVzLCBjb25uZWN0ZWQgdG8gdGhlIHByZXZpb3VzIHBvaW50XG4gICAqIGJ5IGEgc3RyYWlnaHQgbGluZSBpZiBuZWNlc3NhcnkuXG4gICAqIEBwYXJhbSB4MSAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB5MSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4MiAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geTIgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBhcmMncyByYWRpdXMuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIGFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmFyY1RvKFxuICAgICAgdC5hICogeDEgKyB0LmMgKiB5MSArIHQudHgsXG4gICAgICB0LmIgKiB4MSArIHQuZCAqIHkxICsgdC50eSxcbiAgICAgIHQuYSAqIHgyICsgdC5jICogeTIgKyB0LnR4LFxuICAgICAgdC5iICogeDIgKyB0LmQgKiB5MiArIHQudHksXG4gICAgICByYWRpdXNcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIFNWRy1zdHlsZSBhcmMgdG8gdGhlIHBhdGgsIGFsbG93aW5nIGZvciBlbGxpcHRpY2FsIGFyY3MgYmFzZWQgb24gdGhlIFNWRyBzcGVjLlxuICAgKiBAcGFyYW0gcnggLSBUaGUgeC1yYWRpdXMgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSByeSAtIFRoZSB5LXJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHhBeGlzUm90YXRpb24gLSBUaGUgcm90YXRpb24gb2YgdGhlIGVsbGlwc2UncyB4LWF4aXMgcmVsYXRpdmVcbiAgICogdG8gdGhlIHgtYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0sIGluIGRlZ3JlZXMuXG4gICAqIEBwYXJhbSBsYXJnZUFyY0ZsYWcgLSBEZXRlcm1pbmVzIGlmIHRoZSBhcmMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBsZXNzIHRoYW4gMTgwIGRlZ3JlZXMuXG4gICAqIEBwYXJhbSBzd2VlcEZsYWcgLSBEZXRlcm1pbmVzIGlmIHRoZSBhcmMgc2hvdWxkIGJlIHN3ZXB0IGluIGEgcG9zaXRpdmUgYW5nbGUgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBhcmMncyBlbmQgcG9pbnQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYXJjVG9TdmcocngsIHJ5LCB4QXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBjb25zdCB0ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguYXJjVG9TdmcoXG4gICAgICByeCxcbiAgICAgIHJ5LFxuICAgICAgeEF4aXNSb3RhdGlvbixcbiAgICAgIC8vIHNob3VsZCB3ZSByb3RhdGUgdGhpcyB3aXRoIHRyYW5zZm9ybT8/XG4gICAgICBsYXJnZUFyY0ZsYWcsXG4gICAgICBzd2VlcEZsYWcsXG4gICAgICB0LmEgKiB4ICsgdC5jICogeSArIHQudHgsXG4gICAgICB0LmIgKiB4ICsgdC5kICogeSArIHQudHlcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgY3ViaWMgQmV6aWVyIGN1cnZlIHRvIHRoZSBwYXRoLlxuICAgKiBJdCByZXF1aXJlcyB0aHJlZSBwb2ludHM6IHRoZSBmaXJzdCB0d28gYXJlIGNvbnRyb2wgcG9pbnRzIGFuZCB0aGUgdGhpcmQgb25lIGlzIHRoZSBlbmQgcG9pbnQuXG4gICAqIFRoZSBzdGFydGluZyBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCBpbiB0aGUgY3VycmVudCBwYXRoLlxuICAgKiBAcGFyYW0gY3AxeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDF5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIGNwMnggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIGNwMnkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gc21vb3RobmVzcyAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBhZGp1c3QgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSwgc21vb3RobmVzcykge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBjb25zdCB0ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgIHQuYSAqIGNwMXggKyB0LmMgKiBjcDF5ICsgdC50eCxcbiAgICAgIHQuYiAqIGNwMXggKyB0LmQgKiBjcDF5ICsgdC50eSxcbiAgICAgIHQuYSAqIGNwMnggKyB0LmMgKiBjcDJ5ICsgdC50eCxcbiAgICAgIHQuYiAqIGNwMnggKyB0LmQgKiBjcDJ5ICsgdC50eSxcbiAgICAgIHQuYSAqIHggKyB0LmMgKiB5ICsgdC50eCxcbiAgICAgIHQuYiAqIHggKyB0LmQgKiB5ICsgdC50eSxcbiAgICAgIHNtb290aG5lc3NcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aCBieSBkcmF3aW5nIGEgc3RyYWlnaHQgbGluZSBiYWNrIHRvIHRoZSBzdGFydC5cbiAgICogSWYgdGhlIHNoYXBlIGlzIGFscmVhZHkgY2xvc2VkIG9yIHRoZXJlIGFyZSBubyBwb2ludHMgaW4gdGhlIHBhdGgsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBjbG9zZVBhdGgoKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGg/LmNsb3NlUGF0aCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhbiBlbGxpcHNlIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24gYW5kIHdpdGggdGhlIGdpdmVuIHggYW5kIHkgcmFkaWkuXG4gICAqIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGNhbiBiZSBhcHBsaWVkLCBhbGxvd2luZyBmb3Igcm90YXRpb24sIHNjYWxpbmcsIGFuZCB0cmFuc2xhdGlvbi5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0gcmFkaXVzWCAtIFRoZSBob3Jpem9udGFsIHJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHJhZGl1c1kgLSBUaGUgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGVsbGlwc2UoeCwgeSwgcmFkaXVzWCwgcmFkaXVzWSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmVsbGlwc2UoeCwgeSwgcmFkaXVzWCwgcmFkaXVzWSwgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIGNpcmNsZSBzaGFwZS4gVGhpcyBtZXRob2QgYWRkcyBhIG5ldyBjaXJjbGUgcGF0aCB0byB0aGUgY3VycmVudCBkcmF3aW5nLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNpcmNsZSh4LCB5LCByYWRpdXMpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5jaXJjbGUoeCwgeSwgcmFkaXVzLCB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW5vdGhlciBgR3JhcGhpY3NQYXRoYCB0byB0aGlzIHBhdGgsIG9wdGlvbmFsbHkgYXBwbHlpbmcgYSB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgYEdyYXBoaWNzUGF0aGAgdG8gYWRkLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHBhdGgocGF0aCkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmFkZFBhdGgocGF0aCwgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0aGUgY3VycmVudCBwb2ludCB0byBhIG5ldyBwb2ludCB3aXRoIGEgc3RyYWlnaHQgbGluZS4gVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCBwYXRoLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb2ludCB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb2ludCB0byBjb25uZWN0IHRvLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIGNvbnN0IHQgPSB0aGlzLl90cmFuc2Zvcm07XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5saW5lVG8oXG4gICAgICB0LmEgKiB4ICsgdC5jICogeSArIHQudHgsXG4gICAgICB0LmIgKiB4ICsgdC5kICogeSArIHQudHlcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGFydGluZyBwb2ludCBmb3IgYSBuZXcgc3ViLXBhdGguIEFueSBzdWJzZXF1ZW50IGRyYXdpbmcgY29tbWFuZHMgYXJlIGNvbnNpZGVyZWQgcGFydCBvZiB0aGlzIHBhdGguXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBmb3IgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgZm9yIHRoZSBzdGFydGluZyBwb2ludC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBtb3ZlVG8oeCwgeSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBjb25zdCB0ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMuX2FjdGl2ZVBhdGguaW5zdHJ1Y3Rpb25zO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkWCA9IHQuYSAqIHggKyB0LmMgKiB5ICsgdC50eDtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFkgPSB0LmIgKiB4ICsgdC5kICogeSArIHQudHk7XG4gICAgaWYgKGluc3RydWN0aW9ucy5sZW5ndGggPT09IDEgJiYgaW5zdHJ1Y3Rpb25zWzBdLmFjdGlvbiA9PT0gXCJtb3ZlVG9cIikge1xuICAgICAgaW5zdHJ1Y3Rpb25zWzBdLmRhdGFbMF0gPSB0cmFuc2Zvcm1lZFg7XG4gICAgICBpbnN0cnVjdGlvbnNbMF0uZGF0YVsxXSA9IHRyYW5zZm9ybWVkWTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmVQYXRoLm1vdmVUbyhcbiAgICAgIHRyYW5zZm9ybWVkWCxcbiAgICAgIHRyYW5zZm9ybWVkWVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBxdWFkcmF0aWMgY3VydmUgdG8gdGhlIHBhdGguIEl0IHJlcXVpcmVzIHR3byBwb2ludHM6IHRoZSBjb250cm9sIHBvaW50IGFuZCB0aGUgZW5kIHBvaW50LlxuICAgKiBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgdGhlIGxhc3QgcG9pbnQgaW4gdGhlIGN1cnJlbnQgcGF0aC5cbiAgICogQHBhcmFtIGNweCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGFkanVzdCB0aGUgc21vb3RobmVzcyBvZiB0aGUgY3VydmUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcXVhZHJhdGljQ3VydmVUbyhjcHgsIGNweSwgeCwgeSwgc21vb3RobmVzcykge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBjb25zdCB0ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgIHQuYSAqIGNweCArIHQuYyAqIGNweSArIHQudHgsXG4gICAgICB0LmIgKiBjcHggKyB0LmQgKiBjcHkgKyB0LnR5LFxuICAgICAgdC5hICogeCArIHQuYyAqIHkgKyB0LnR4LFxuICAgICAgdC5iICogeCArIHQuZCAqIHkgKyB0LnR5LFxuICAgICAgc21vb3RobmVzc1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVjdGFuZ2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IHJlY3RhbmdsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlY3QoeCwgeSwgdywgaCkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnJlY3QoeCwgeSwgdywgaCwgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycy5cbiAgICogVGhlIGNvcm5lciByYWRpdXMgY2FuIGJlIHNwZWNpZmllZCB0byBkZXRlcm1pbmUgaG93IHJvdW5kZWQgdGhlIGNvcm5lcnMgc2hvdWxkIGJlLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCwgd2hpY2ggYWxsb3dzIGZvciByb3RhdGlvbiwgc2NhbGluZywgYW5kIHRyYW5zbGF0aW9uIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgcmVjdGFuZ2xlJ3MgY29ybmVycy4gSWYgbm90IHNwZWNpZmllZCwgY29ybmVycyB3aWxsIGJlIHNoYXJwLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJvdW5kUmVjdCh4LCB5LCB3LCBoLCByYWRpdXMpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5yb3VuZFJlY3QoeCwgeSwgdywgaCwgcmFkaXVzLCB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcG9seWdvbiBzaGFwZSBieSBzcGVjaWZ5aW5nIGEgc2VxdWVuY2Ugb2YgcG9pbnRzLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHRoZSBjcmVhdGlvbiBvZiBjb21wbGV4IHBvbHlnb25zLFxuICAgKiB3aGljaCBjYW4gYmUgYm90aCBvcGVuIGFuZCBjbG9zZWQuIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGNhbiBiZSBhcHBsaWVkLCBlbmFibGluZyB0aGUgcG9seWdvbiB0byBiZSBzY2FsZWQsXG4gICAqIHJvdGF0ZWQsIG9yIHRyYW5zbGF0ZWQgYXMgbmVlZGVkLlxuICAgKiBAcGFyYW0gcG9pbnRzIC0gQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgYW4gYXJyYXkgb2YgUG9pbnREYXRhIG9iamVjdHMgZWcgW3t4LHl9LCB7eCx5fSwge3gseX1dXG4gICAqIHJlcHJlc2VudGluZyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcywgb2YgdGhlIHBvbHlnb24ncyB2ZXJ0aWNlcywgaW4gc2VxdWVuY2UuXG4gICAqIEBwYXJhbSBjbG9zZSAtIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHBvbHlnb24gcGF0aC4gVHJ1ZSBieSBkZWZhdWx0LlxuICAgKi9cbiAgcG9seShwb2ludHMsIGNsb3NlKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgucG9seShwb2ludHMsIGNsb3NlLCB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVndWxhciBwb2x5Z29uIHdpdGggYSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNpZGVzLiBBbGwgc2lkZXMgYW5kIGFuZ2xlcyBhcmUgZXF1YWwuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmN1bXNjcmliZWQgY2lyY2xlIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0gc2lkZXMgLSBUaGUgbnVtYmVyIG9mIHNpZGVzIG9mIHRoZSBwb2x5Z29uLiBNdXN0IGJlIDMgb3IgbW9yZS5cbiAgICogQHBhcmFtIHJvdGF0aW9uIC0gVGhlIHJvdGF0aW9uIGFuZ2xlIG9mIHRoZSBwb2x5Z29uLCBpbiByYWRpYW5zLiBaZXJvIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWd1bGFyUG9seSh4LCB5LCByYWRpdXMsIHNpZGVzLCByb3RhdGlvbiA9IDAsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnJlZ3VsYXJQb2x5KHgsIHksIHJhZGl1cywgc2lkZXMsIHJvdGF0aW9uLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHBvbHlnb24gd2l0aCByb3VuZGVkIGNvcm5lcnMuXG4gICAqIFNpbWlsYXIgdG8gYHJlZ3VsYXJQb2x5YCBidXQgd2l0aCB0aGUgYWJpbGl0eSB0byByb3VuZCB0aGUgY29ybmVycyBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY3Vtc2NyaWJlZCBjaXJjbGUgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSBzaWRlcyAtIFRoZSBudW1iZXIgb2Ygc2lkZXMgb2YgdGhlIHBvbHlnb24uIE11c3QgYmUgMyBvciBtb3JlLlxuICAgKiBAcGFyYW0gY29ybmVyIC0gVGhlIHJhZGl1cyBvZiB0aGUgcm91bmRpbmcgb2YgdGhlIGNvcm5lcnMuXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBhbmdsZSBvZiB0aGUgcG9seWdvbiwgaW4gcmFkaWFucy4gWmVybyBieSBkZWZhdWx0LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJvdW5kUG9seSh4LCB5LCByYWRpdXMsIHNpZGVzLCBjb3JuZXIsIHJvdGF0aW9uKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgucm91bmRQb2x5KHgsIHksIHJhZGl1cywgc2lkZXMsIGNvcm5lciwgcm90YXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHNoYXBlIHdpdGggcm91bmRlZCBjb3JuZXJzLiBUaGlzIGZ1bmN0aW9uIHN1cHBvcnRzIGN1c3RvbSByYWRpdXMgZm9yIGVhY2ggY29ybmVyIG9mIHRoZSBzaGFwZS5cbiAgICogT3B0aW9uYWxseSwgY29ybmVycyBjYW4gYmUgcm91bmRlZCB1c2luZyBhIHF1YWRyYXRpYyBjdXJ2ZSBpbnN0ZWFkIG9mIGFuIGFyYywgcHJvdmlkaW5nIGEgZGlmZmVyZW50IGFlc3RoZXRpYy5cbiAgICogQHBhcmFtIHBvaW50cyAtIEFuIGFycmF5IG9mIGBSb3VuZGVkUG9pbnRgIHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiB0aGUgc2hhcGUgdG8gZHJhdy5cbiAgICogQSBtaW5pbXVtIG9mIDMgcG9pbnRzIGlzIHJlcXVpcmVkLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIGRlZmF1bHQgcmFkaXVzIGZvciB0aGUgY29ybmVycy5cbiAgICogVGhpcyByYWRpdXMgaXMgYXBwbGllZCB0byBhbGwgY29ybmVycyB1bmxlc3Mgb3ZlcnJpZGRlbiBpbiBgcG9pbnRzYC5cbiAgICogQHBhcmFtIHVzZVF1YWRyYXRpYyAtIElmIHNldCB0byB0cnVlLCByb3VuZGVkIGNvcm5lcnMgYXJlIGRyYXduIHVzaW5nIGEgcXVhZHJhdGljQ3VydmVcbiAgICogIG1ldGhvZCBpbnN0ZWFkIG9mIGFuIGFyYyBtZXRob2QuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAcGFyYW0gc21vb3RobmVzcyAtIFNwZWNpZmllcyB0aGUgc21vb3RobmVzcyBvZiB0aGUgY3VydmUgd2hlbiBgdXNlUXVhZHJhdGljYCBpcyB0cnVlLlxuICAgKiBIaWdoZXIgdmFsdWVzIG1ha2UgdGhlIGN1cnZlIHNtb290aGVyLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJvdW5kU2hhcGUocG9pbnRzLCByYWRpdXMsIHVzZVF1YWRyYXRpYywgc21vb3RobmVzcykge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnJvdW5kU2hhcGUocG9pbnRzLCByYWRpdXMsIHVzZVF1YWRyYXRpYywgc21vb3RobmVzcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXcgUmVjdGFuZ2xlIHdpdGggZmlsbGV0IGNvcm5lcnMuIFRoaXMgaXMgbXVjaCBsaWtlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAqIGhvd2V2ZXIgaXQgc3VwcG9ydCBuZWdhdGl2ZSBudW1iZXJzIGFzIHdlbGwgZm9yIHRoZSBjb3JuZXIgcmFkaXVzLlxuICAgKiBAcGFyYW0geCAtIFVwcGVyIGxlZnQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHkgLSBVcHBlciByaWdodCBjb3JuZXIgb2YgcmVjdFxuICAgKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiByZWN0XG4gICAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgcmVjdFxuICAgKiBAcGFyYW0gZmlsbGV0IC0gYWNjZXB0IG5lZ2F0aXZlIG9yIHBvc2l0aXZlIHZhbHVlc1xuICAgKi9cbiAgZmlsbGV0UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsZXQpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5maWxsZXRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGZpbGxldCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXcgUmVjdGFuZ2xlIHdpdGggY2hhbWZlciBjb3JuZXJzLiBUaGVzZSBhcmUgYW5nbGVkIGNvcm5lcnMuXG4gICAqIEBwYXJhbSB4IC0gVXBwZXIgbGVmdCBjb3JuZXIgb2YgcmVjdFxuICAgKiBAcGFyYW0geSAtIFVwcGVyIHJpZ2h0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHJlY3RcbiAgICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiByZWN0XG4gICAqIEBwYXJhbSBjaGFtZmVyIC0gbm9uLXplcm8gcmVhbCBudW1iZXIsIHNpemUgb2YgY29ybmVyIGN1dG91dFxuICAgKiBAcGFyYW0gdHJhbnNmb3JtXG4gICAqL1xuICBjaGFtZmVyUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjaGFtZmVyLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5jaGFtZmVyUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjaGFtZmVyLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHN0YXIgc2hhcGUgY2VudGVyZWQgYXQgYSBzcGVjaWZpZWQgbG9jYXRpb24uIFRoaXMgbWV0aG9kIGFsbG93cyBmb3IgdGhlIGNyZWF0aW9uXG4gICAqICBvZiBzdGFycyB3aXRoIGEgdmFyaWFibGUgbnVtYmVyIG9mIHBvaW50cywgb3V0ZXIgcmFkaXVzLCBvcHRpb25hbCBpbm5lciByYWRpdXMsIGFuZCByb3RhdGlvbi5cbiAgICogVGhlIHN0YXIgaXMgZHJhd24gYXMgYSBjbG9zZWQgcG9seWdvbiB3aXRoIGFsdGVybmF0aW5nIG91dGVyIGFuZCBpbm5lciB2ZXJ0aWNlcyB0byBjcmVhdGUgdGhlIHN0YXIncyBwb2ludHMuXG4gICAqIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGNhbiBiZSBhcHBsaWVkIHRvIHNjYWxlLCByb3RhdGUsIG9yIHRyYW5zbGF0ZSB0aGUgc3RhciBhcyBuZWVkZWQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBzdGFyLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHBvaW50cyAtIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9mIHRoZSBzdGFyLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgc3RhciAoZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHRvIHRoZSBvdXRlciBwb2ludHMpLlxuICAgKiBAcGFyYW0gaW5uZXJSYWRpdXMgLSBPcHRpb25hbC4gVGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgc3RhclxuICAgKiAoZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHRvIHRoZSBpbm5lciBwb2ludHMgYmV0d2VlbiB0aGUgb3V0ZXIgcG9pbnRzKS5cbiAgICogSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBoYWxmIG9mIHRoZSBgcmFkaXVzYC5cbiAgICogQHBhcmFtIHJvdGF0aW9uIC0gT3B0aW9uYWwuIFRoZSByb3RhdGlvbiBvZiB0aGUgc3RhciBpbiByYWRpYW5zLCB3aGVyZSAwIGlzIGFsaWduZWQgd2l0aCB0aGUgeS1heGlzLlxuICAgKiBEZWZhdWx0cyB0byAwLCBtZWFuaW5nIG9uZSBwb2ludCBpcyBkaXJlY3RseSB1cHdhcmQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nIGZ1cnRoZXIgZHJhd2luZyBjb21tYW5kcy5cbiAgICovXG4gIHN0YXIoeCwgeSwgcG9pbnRzLCByYWRpdXMsIGlubmVyUmFkaXVzID0gMCwgcm90YXRpb24gPSAwKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguc3Rhcih4LCB5LCBwb2ludHMsIHJhZGl1cywgaW5uZXJSYWRpdXMsIHJvdGF0aW9uLCB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgcmVuZGVycyBhbiBTVkcgc3RyaW5nIGludG8gdGhlIGdyYXBoaWNzIGNvbnRleHQuIFRoaXMgYWxsb3dzIGZvciBjb21wbGV4IHNoYXBlcyBhbmQgcGF0aHNcbiAgICogZGVmaW5lZCBpbiBTVkcgZm9ybWF0IHRvIGJlIGRyYXduIHdpdGhpbiB0aGUgZ3JhcGhpY3MgY29udGV4dC5cbiAgICogQHBhcmFtIHN2ZyAtIFRoZSBTVkcgc3RyaW5nIHRvIGJlIHBhcnNlZCBhbmQgcmVuZGVyZWQuXG4gICAqL1xuICBzdmcoc3ZnKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIFNWR1BhcnNlcihzdmcsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXN0b3JlcyB0aGUgbW9zdCByZWNlbnRseSBzYXZlZCBncmFwaGljcyBzdGF0ZSBieSBwb3BwaW5nIHRoZSB0b3Agb2YgdGhlIGdyYXBoaWNzIHN0YXRlIHN0YWNrLlxuICAgKiBUaGlzIGluY2x1ZGVzIHRyYW5zZm9ybWF0aW9ucywgZmlsbCBzdHlsZXMsIGFuZCBzdHJva2Ugc3R5bGVzLlxuICAgKi9cbiAgcmVzdG9yZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm0gPSBzdGF0ZS50cmFuc2Zvcm07XG4gICAgICB0aGlzLl9maWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgICB0aGlzLl9zdHJva2VTdHlsZSA9IHN0YXRlLnN0cm9rZVN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogU2F2ZXMgdGhlIGN1cnJlbnQgZ3JhcGhpY3Mgc3RhdGUsIGluY2x1ZGluZyB0cmFuc2Zvcm1hdGlvbnMsIGZpbGwgc3R5bGVzLCBhbmQgc3Ryb2tlIHN0eWxlcywgb250byBhIHN0YWNrLiAqL1xuICBzYXZlKCkge1xuICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaCh7XG4gICAgICB0cmFuc2Zvcm06IHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpLFxuICAgICAgZmlsbFN0eWxlOiB7IC4uLnRoaXMuX2ZpbGxTdHlsZSB9LFxuICAgICAgc3Ryb2tlU3R5bGU6IHsgLi4udGhpcy5fc3Ryb2tlU3R5bGUgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC5cbiAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKi9cbiAgZ2V0VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm07XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gdGhlIGlkZW50aXR5IG1hdHJpeCwgZWZmZWN0aXZlbHkgcmVtb3ZpbmcgYW55IHRyYW5zZm9ybWF0aW9ucyAocm90YXRpb24sIHNjYWxpbmcsIHRyYW5zbGF0aW9uKSBwcmV2aW91c2x5IGFwcGxpZWQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHJlc2V0VHJhbnNmb3JtKCkge1xuICAgIHRoaXMuX3RyYW5zZm9ybS5pZGVudGl0eSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gdGhlIGdyYXBoaWNzIGNvbnRleHQgYXJvdW5kIHRoZSBjdXJyZW50IG9yaWdpbi5cbiAgICogQHBhcmFtIGFuZ2xlIC0gVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnMuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHJvdGF0ZShhbmdsZSkge1xuICAgIHRoaXMuX3RyYW5zZm9ybS5yb3RhdGUoYW5nbGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgc2NhbGluZyB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgZ3JhcGhpY3MgY29udGV4dCwgc2NhbGluZyBkcmF3aW5ncyBieSB4IGhvcml6b250YWxseSBhbmQgYnkgeSB2ZXJ0aWNhbGx5LlxuICAgKiBAcGFyYW0geCAtIFRoZSBzY2FsZSBmYWN0b3IgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0geSAtIChPcHRpb25hbCkgVGhlIHNjYWxlIGZhY3RvciBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgeCB2YWx1ZSBpcyB1c2VkIGZvciBib3RoIGRpcmVjdGlvbnMuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHNjYWxlKHgsIHkgPSB4KSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtLnNjYWxlKHgsIHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBkeCwgZHkpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtLnNldChhLmEsIGEuYiwgYS5jLCBhLmQsIGEudHgsIGEudHkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zZm9ybS5zZXQoYSwgYiwgYywgZCwgZHgsIGR5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0cmFuc2Zvcm0oYSwgYiwgYywgZCwgZHgsIGR5KSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybS5hcHBlbmQoYSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGVtcE1hdHJpeC5zZXQoYSwgYiwgYywgZCwgZHgsIGR5KTtcbiAgICB0aGlzLl90cmFuc2Zvcm0uYXBwZW5kKHRlbXBNYXRyaXgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgdHJhbnNsYXRpb24gdHJhbnNmb3JtYXRpb24gdG8gdGhlIGdyYXBoaWNzIGNvbnRleHQsIG1vdmluZyB0aGUgb3JpZ2luIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50cy5cbiAgICogQHBhcmFtIHggLSBUaGUgYW1vdW50IHRvIHRyYW5zbGF0ZSBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB5IC0gKE9wdGlvbmFsKSBUaGUgYW1vdW50IHRvIHRyYW5zbGF0ZSBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgeCB2YWx1ZSBpcyB1c2VkIGZvciBib3RoIGRpcmVjdGlvbnMuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHRyYW5zbGF0ZSh4LCB5ID0geCkge1xuICAgIHRoaXMuX3RyYW5zZm9ybS50cmFuc2xhdGUoeCwgeSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgZHJhd2luZyBjb21tYW5kcyBmcm9tIHRoZSBncmFwaGljcyBjb250ZXh0LCBlZmZlY3RpdmVseSByZXNldHRpbmcgaXQuIFRoaXMgaW5jbHVkZXMgY2xlYXJpbmcgdGhlIHBhdGgsXG4gICAqIGFuZCBvcHRpb25hbGx5IHJlc2V0dGluZyB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5jbGVhcigpO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5yZXNldFRyYW5zZm9ybSgpO1xuICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvblVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcywgMTYpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKiogVGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBzaGFwZS4gKi9cbiAgZ2V0IGJvdW5kcygpIHtcbiAgICBpZiAoIXRoaXMuX2JvdW5kc0RpcnR5KVxuICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgYm91bmRzLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1tpXTtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGluc3RydWN0aW9uLmFjdGlvbjtcbiAgICAgIGlmIChhY3Rpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgICBib3VuZHMuYWRkQm91bmRzKGRhdGEucGF0aC5ib3VuZHMpO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwidGV4dHVyZVwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgICBib3VuZHMuYWRkRnJhbWUoZGF0YS5keCwgZGF0YS5keSwgZGF0YS5keCArIGRhdGEuZHcsIGRhdGEuZHkgKyBkYXRhLmRoLCBkYXRhLnRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9uID09PSBcInN0cm9rZVwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gZGF0YS5zdHlsZS53aWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IF9ib3VuZHMgPSBkYXRhLnBhdGguYm91bmRzO1xuICAgICAgICBib3VuZHMuYWRkRnJhbWUoXG4gICAgICAgICAgX2JvdW5kcy5taW5YIC0gcGFkZGluZyxcbiAgICAgICAgICBfYm91bmRzLm1pblkgLSBwYWRkaW5nLFxuICAgICAgICAgIF9ib3VuZHMubWF4WCArIHBhZGRpbmcsXG4gICAgICAgICAgX2JvdW5kcy5tYXhZICsgcGFkZGluZ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgYSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSBwb2ludCAtIFBvaW50IHRvIGNoZWNrIGlmIGl0J3MgY29udGFpbmVkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGdlb21ldHJ5LlxuICAgKi9cbiAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgIGlmICghdGhpcy5ib3VuZHMuY29udGFpbnNQb2ludChwb2ludC54LCBwb2ludC55KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICBsZXQgaGFzSGl0ID0gZmFsc2U7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2tdO1xuICAgICAgY29uc3QgZGF0YSA9IGluc3RydWN0aW9uLmRhdGE7XG4gICAgICBjb25zdCBwYXRoID0gZGF0YS5wYXRoO1xuICAgICAgaWYgKCFpbnN0cnVjdGlvbi5hY3Rpb24gfHwgIXBhdGgpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgICAgY29uc3Qgc2hhcGVzID0gcGF0aC5zaGFwZVBhdGguc2hhcGVQcmltaXRpdmVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBzaGFwZXNbaV0uc2hhcGU7XG4gICAgICAgIGlmICghc3R5bGUgfHwgIXNoYXBlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzaGFwZXNbaV0udHJhbnNmb3JtO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBvaW50ID0gdHJhbnNmb3JtID8gdHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdG1wUG9pbnQpIDogcG9pbnQ7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICAgICAgaGFzSGl0ID0gc2hhcGUuY29udGFpbnModHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc0hpdCA9IHNoYXBlLnN0cm9rZUNvbnRhaW5zKHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBzdHlsZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9sZXMgPSBkYXRhLmhvbGU7XG4gICAgICAgIGlmIChob2xlcykge1xuICAgICAgICAgIGNvbnN0IGhvbGVTaGFwZXMgPSBob2xlcy5zaGFwZVBhdGg/LnNoYXBlUHJpbWl0aXZlcztcbiAgICAgICAgICBpZiAoaG9sZVNoYXBlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBob2xlU2hhcGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChob2xlU2hhcGVzW2pdLnNoYXBlLmNvbnRhaW5zKHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55KSkge1xuICAgICAgICAgICAgICAgIGhhc0hpdCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNIaXQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzSGl0O1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgR3JhcGhpY3NEYXRhIG9iamVjdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIGZpbGwvc3Ryb2tlIHN0eWxlP1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmVTb3VyY2U9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgc291cmNlIG9mIHRoZSBmaWxsL3N0cm9rZSBzdHlsZT9cbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fc3RhdGVTdGFjay5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiLCB0aGlzKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIGNvbnN0IGRlc3Ryb3lUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LnRleHR1cmU7XG4gICAgaWYgKGRlc3Ryb3lUZXh0dXJlKSB7XG4gICAgICBjb25zdCBkZXN0cm95VGV4dHVyZVNvdXJjZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy50ZXh0dXJlU291cmNlO1xuICAgICAgaWYgKHRoaXMuX2ZpbGxTdHlsZS50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZS50ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0cm9rZVN0eWxlLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fc3Ryb2tlU3R5bGUudGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lUZXh0dXJlU291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmlsbFN0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9zdHJva2VTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGggPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5fc3RhdGVTdGFjayA9IG51bGw7XG4gICAgdGhpcy5jdXN0b21TaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IG51bGw7XG4gIH1cbn07XG4vKiogVGhlIGRlZmF1bHQgZmlsbCBzdHlsZSB0byB1c2Ugd2hlbiBub25lIGlzIHByb3ZpZGVkLiAqL1xuX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0RmlsbFN0eWxlID0ge1xuICAvKiogVGhlIGNvbG9yIHRvIHVzZSBmb3IgdGhlIGZpbGwuICovXG4gIGNvbG9yOiAxNjc3NzIxNSxcbiAgLyoqIFRoZSBhbHBoYSB2YWx1ZSB0byB1c2UgZm9yIHRoZSBmaWxsLiAqL1xuICBhbHBoYTogMSxcbiAgLyoqIFRoZSB0ZXh0dXJlIHRvIHVzZSBmb3IgdGhlIGZpbGwuICovXG4gIHRleHR1cmU6IFRleHR1cmUuV0hJVEUsXG4gIC8qKiBUaGUgbWF0cml4IHRvIGFwcGx5LiAqL1xuICBtYXRyaXg6IG51bGwsXG4gIC8qKiBUaGUgZmlsbCBwYXR0ZXJuIHRvIHVzZS4gKi9cbiAgZmlsbDogbnVsbFxufTtcbi8qKiBUaGUgZGVmYXVsdCBzdHJva2Ugc3R5bGUgdG8gdXNlIHdoZW4gbm9uZSBpcyBwcm92aWRlZC4gKi9cbl9HcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlID0ge1xuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBzdHJva2UuICovXG4gIHdpZHRoOiAxLFxuICAvKiogVGhlIGNvbG9yIHRvIHVzZSBmb3IgdGhlIHN0cm9rZS4gKi9cbiAgY29sb3I6IDE2Nzc3MjE1LFxuICAvKiogVGhlIGFscGhhIHZhbHVlIHRvIHVzZSBmb3IgdGhlIHN0cm9rZS4gKi9cbiAgYWxwaGE6IDEsXG4gIC8qKiBUaGUgYWxpZ25tZW50IG9mIHRoZSBzdHJva2UuICovXG4gIGFsaWdubWVudDogMC41LFxuICAvKiogVGhlIG1pdGVyIGxpbWl0IHRvIHVzZS4gKi9cbiAgbWl0ZXJMaW1pdDogMTAsXG4gIC8qKiBUaGUgbGluZSBjYXAgc3R5bGUgdG8gdXNlLiAqL1xuICBjYXA6IFwiYnV0dFwiLFxuICAvKiogVGhlIGxpbmUgam9pbiBzdHlsZSB0byB1c2UuICovXG4gIGpvaW46IFwibWl0ZXJcIixcbiAgLyoqIFRoZSB0ZXh0dXJlIHRvIHVzZSBmb3IgdGhlIGZpbGwuICovXG4gIHRleHR1cmU6IFRleHR1cmUuV0hJVEUsXG4gIC8qKiBUaGUgbWF0cml4IHRvIGFwcGx5LiAqL1xuICBtYXRyaXg6IG51bGwsXG4gIC8qKiBUaGUgZmlsbCBwYXR0ZXJuIHRvIHVzZS4gKi9cbiAgZmlsbDogbnVsbFxufTtcbmxldCBHcmFwaGljc0NvbnRleHQgPSBfR3JhcGhpY3NDb250ZXh0O1xuXG5leHBvcnQgeyBHcmFwaGljc0NvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzQ29udGV4dC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6653\n')},4108:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  hJ: () => (/* binding */ GraphicsContextSystem)\n});\n\n// UNUSED EXPORTS: GpuGraphicsContext, GraphicsContextRenderData\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs\nvar BatchGeometry = __webpack_require__(2971);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs\nvar getTextureBatchBindGroup = __webpack_require__(3018);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs + 3 modules\nvar Batcher = __webpack_require__(2067);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs\nvar InstructionSet = __webpack_require__(1854);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs\n\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\n\n//# sourceMappingURL=buildUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs\n\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset = offset || 0;\n  stride = stride || 2;\n  size = size || vertices.length / stride - offset;\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\n\n//# sourceMappingURL=transformVertices.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs + 1 modules\nvar BatchableGraphics = __webpack_require__(8859);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs\n\nconst buildCircle = {\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === "circle") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === "ellipse") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\n\n\n//# sourceMappingURL=buildCircle.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/const.mjs\n\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs\n\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\n\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs\n\n\n\n\n"use strict";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point/* Point */.E(points[0], points[1]);\n  const lastPoint = new Point/* Point */.E(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === "round") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === "square") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === "round") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === "round") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === "round") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === "round") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === "square") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\n\n//# sourceMappingURL=buildLine.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(720);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs\n\n\n"use strict";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\n\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs\n\n\n"use strict";\nconst emptyArray = [];\nconst buildPolygon = {\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\n\n//# sourceMappingURL=buildPolygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs\n\nconst buildRectangle = {\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width >= 0 && height >= 0)) {\n      return points;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\n\n//# sourceMappingURL=buildRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs\n\nconst buildTriangle = {\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\n\n//# sourceMappingURL=buildTriangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst buildMap = {\n  rectangle: buildRectangle,\n  polygon: buildPolygon,\n  triangle: buildTriangle,\n  circle: buildCircle,\n  ellipse: buildCircle,\n  roundedRectangle: buildCircle\n};\nconst tempRect = new Rectangle/* Rectangle */.A();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === "texture") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === "fill" || instruction.action === "stroke") {\n      const isStroke = instruction.action === "stroke";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = buildMap.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.vertexOffset = vertOffset;\n  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.color = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = buildMap[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn("[Pixi Graphics] only the last shape have be cut out");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture/* Texture */.x.WHITE) {\n      const textureMatrix = style.matrix;\n      if (matrix) {\n        textureMatrix.append(matrix.clone().invert());\n      }\n      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape)\n    return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = buildMap[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\n\n\n//# sourceMappingURL=buildContextBatches.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.geometry = new BatchGeometry/* BatchGeometry */.J();\n    this.instructions = new InstructionSet/* InstructionSet */.h();\n  }\n  init() {\n    this.instructions.reset();\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor() {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._activeBatchers = [];\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  prerender() {\n    this._returnActiveBatchers();\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === "no-batch") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === "auto") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _returnActiveBatchers() {\n    for (let i = 0; i < this._activeBatchers.length; i++) {\n      PoolGroup/* BigPool */.u.return(this._activeBatchers[i]);\n    }\n    this._activeBatchers.length = 0;\n  }\n  _initContextRenderData(context) {\n    const graphicsData = PoolGroup/* BigPool */.u.get(GraphicsContextRenderData);\n    const { batches, geometryData } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = PoolGroup/* BigPool */.u.get(Batcher/* Batcher */.m);\n    this._activeBatchers.push(batcher);\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = graphicsData.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = (0,getTextureBatchBindGroup/* getTextureBatchBindGroup */.Q)(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    gpuContext.context = context;\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on("destroy", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off("destroy", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        PoolGroup/* BigPool */.u.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        PoolGroup/* BigPool */.u.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const i in this._gpuContextHash) {\n      if (this._gpuContextHash[i]) {\n        this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n      }\n    }\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "graphicsContext"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\n\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTSxtQkFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRCxNQUFNLHdCQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQU87QUFDaEMsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBLG9CQUFvQix3QkFBTyxLQUFLLHNCQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBLHdCQUF3Qiw0REFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBTztBQUNmLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Y7QUFDaEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L3V0aWxzL2J1aWxkVXZzLm1qcz84MGRiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvdHJhbnNmb3JtVmVydGljZXMubWpzPzQ5YmIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZENpcmNsZS5tanM/MjY4ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9jb25zdC5tanM/NmY1ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC91dGlscy9nZXRPcmllbnRhdGlvbk9mUG9pbnRzLm1qcz9kMGVjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRMaW5lLm1qcz8zZTcwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3V0aWxzL3RyaWFuZ3VsYXRlV2l0aEhvbGVzLm1qcz8xMmEzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRQb2x5Z29uLm1qcz8xYWE1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRSZWN0YW5nbGUubWpzP2ZmMGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZFRyaWFuZ2xlLm1qcz9iZmI4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3V0aWxzL2J1aWxkQ29udGV4dEJhdGNoZXMubWpzPzJlYzciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NDb250ZXh0U3lzdGVtLm1qcz84NTA1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYnVpbGRVdnModmVydGljZXMsIHZlcnRpY2VzU3RyaWRlLCB2ZXJ0aWNlc09mZnNldCwgdXZzLCB1dnNPZmZzZXQsIHV2c1N0cmlkZSwgc2l6ZSwgbWF0cml4ID0gbnVsbCkge1xuICBsZXQgaW5kZXggPSAwO1xuICB2ZXJ0aWNlc09mZnNldCAqPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgdXZzT2Zmc2V0ICo9IHV2c1N0cmlkZTtcbiAgY29uc3QgYSA9IG1hdHJpeC5hO1xuICBjb25zdCBiID0gbWF0cml4LmI7XG4gIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgY29uc3QgZCA9IG1hdHJpeC5kO1xuICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gIHdoaWxlIChpbmRleCA8IHNpemUpIHtcbiAgICBjb25zdCB4ID0gdmVydGljZXNbdmVydGljZXNPZmZzZXRdO1xuICAgIGNvbnN0IHkgPSB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIDFdO1xuICAgIHV2c1t1dnNPZmZzZXRdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIHV2c1t1dnNPZmZzZXQgKyAxXSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICB1dnNPZmZzZXQgKz0gdXZzU3RyaWRlO1xuICAgIHZlcnRpY2VzT2Zmc2V0ICs9IHZlcnRpY2VzU3RyaWRlO1xuICAgIGluZGV4Kys7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkU2ltcGxlVXZzKHV2cywgdXZzT2Zmc2V0LCB1dnNTdHJpZGUsIHNpemUpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgdXZzT2Zmc2V0ICo9IHV2c1N0cmlkZTtcbiAgd2hpbGUgKGluZGV4IDwgc2l6ZSkge1xuICAgIHV2c1t1dnNPZmZzZXRdID0gMDtcbiAgICB1dnNbdXZzT2Zmc2V0ICsgMV0gPSAwO1xuICAgIHV2c09mZnNldCArPSB1dnNTdHJpZGU7XG4gICAgaW5kZXgrKztcbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZFNpbXBsZVV2cywgYnVpbGRVdnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkVXZzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gdHJhbnNmb3JtVmVydGljZXModmVydGljZXMsIG0sIG9mZnNldCwgc3RyaWRlLCBzaXplKSB7XG4gIGNvbnN0IGEgPSBtLmE7XG4gIGNvbnN0IGIgPSBtLmI7XG4gIGNvbnN0IGMgPSBtLmM7XG4gIGNvbnN0IGQgPSBtLmQ7XG4gIGNvbnN0IHR4ID0gbS50eDtcbiAgY29uc3QgdHkgPSBtLnR5O1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgc3RyaWRlID0gc3RyaWRlIHx8IDI7XG4gIHNpemUgPSBzaXplIHx8IHZlcnRpY2VzLmxlbmd0aCAvIHN0cmlkZSAtIG9mZnNldDtcbiAgbGV0IGluZGV4ID0gb2Zmc2V0ICogc3RyaWRlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpbmRleF07XG4gICAgY29uc3QgeSA9IHZlcnRpY2VzW2luZGV4ICsgMV07XG4gICAgdmVydGljZXNbaW5kZXhdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIHZlcnRpY2VzW2luZGV4ICsgMV0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgaW5kZXggKz0gc3RyaWRlO1xuICB9XG59XG5cbmV4cG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1WZXJ0aWNlcy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJ1aWxkQ2lyY2xlID0ge1xuICBidWlsZChzaGFwZSwgcG9pbnRzKSB7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IGR4O1xuICAgIGxldCBkeTtcbiAgICBsZXQgcng7XG4gICAgbGV0IHJ5O1xuICAgIGlmIChzaGFwZS50eXBlID09PSBcImNpcmNsZVwiKSB7XG4gICAgICBjb25zdCBjaXJjbGUgPSBzaGFwZTtcbiAgICAgIHggPSBjaXJjbGUueDtcbiAgICAgIHkgPSBjaXJjbGUueTtcbiAgICAgIHJ4ID0gcnkgPSBjaXJjbGUucmFkaXVzO1xuICAgICAgZHggPSBkeSA9IDA7XG4gICAgfSBlbHNlIGlmIChzaGFwZS50eXBlID09PSBcImVsbGlwc2VcIikge1xuICAgICAgY29uc3QgZWxsaXBzZSA9IHNoYXBlO1xuICAgICAgeCA9IGVsbGlwc2UueDtcbiAgICAgIHkgPSBlbGxpcHNlLnk7XG4gICAgICByeCA9IGVsbGlwc2UuaGFsZldpZHRoO1xuICAgICAgcnkgPSBlbGxpcHNlLmhhbGZIZWlnaHQ7XG4gICAgICBkeCA9IGR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm91bmRlZFJlY3QgPSBzaGFwZTtcbiAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IHJvdW5kZWRSZWN0LndpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGhhbGZIZWlnaHQgPSByb3VuZGVkUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgeCA9IHJvdW5kZWRSZWN0LnggKyBoYWxmV2lkdGg7XG4gICAgICB5ID0gcm91bmRlZFJlY3QueSArIGhhbGZIZWlnaHQ7XG4gICAgICByeCA9IHJ5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocm91bmRlZFJlY3QucmFkaXVzLCBNYXRoLm1pbihoYWxmV2lkdGgsIGhhbGZIZWlnaHQpKSk7XG4gICAgICBkeCA9IGhhbGZXaWR0aCAtIHJ4O1xuICAgICAgZHkgPSBoYWxmSGVpZ2h0IC0gcnk7XG4gICAgfVxuICAgIGlmICghKHJ4ID49IDAgJiYgcnkgPj0gMCAmJiBkeCA+PSAwICYmIGR5ID49IDApKSB7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICBjb25zdCBuID0gTWF0aC5jZWlsKDIuMyAqIE1hdGguc3FydChyeCArIHJ5KSk7XG4gICAgY29uc3QgbSA9IG4gKiA4ICsgKGR4ID8gNCA6IDApICsgKGR5ID8gNCA6IDApO1xuICAgIGlmIChtID09PSAwKSB7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcG9pbnRzWzBdID0gcG9pbnRzWzZdID0geCArIGR4O1xuICAgICAgcG9pbnRzWzFdID0gcG9pbnRzWzNdID0geSArIGR5O1xuICAgICAgcG9pbnRzWzJdID0gcG9pbnRzWzRdID0geCAtIGR4O1xuICAgICAgcG9pbnRzWzVdID0gcG9pbnRzWzddID0geSAtIGR5O1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgbGV0IGoxID0gMDtcbiAgICBsZXQgajIgPSBuICogNCArIChkeCA/IDIgOiAwKSArIDI7XG4gICAgbGV0IGozID0gajI7XG4gICAgbGV0IGo0ID0gbTtcbiAgICBsZXQgeDAgPSBkeCArIHJ4O1xuICAgIGxldCB5MCA9IGR5O1xuICAgIGxldCB4MSA9IHggKyB4MDtcbiAgICBsZXQgeDIgPSB4IC0geDA7XG4gICAgbGV0IHkxID0geSArIHkwO1xuICAgIHBvaW50c1tqMSsrXSA9IHgxO1xuICAgIHBvaW50c1tqMSsrXSA9IHkxO1xuICAgIHBvaW50c1stLWoyXSA9IHkxO1xuICAgIHBvaW50c1stLWoyXSA9IHgyO1xuICAgIGlmIChkeSkge1xuICAgICAgY29uc3QgeTIyID0geSAtIHkwO1xuICAgICAgcG9pbnRzW2ozKytdID0geDI7XG4gICAgICBwb2ludHNbajMrK10gPSB5MjI7XG4gICAgICBwb2ludHNbLS1qNF0gPSB5MjI7XG4gICAgICBwb2ludHNbLS1qNF0gPSB4MTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLlBJIC8gMiAqIChpIC8gbik7XG4gICAgICBjb25zdCB4MDIgPSBkeCArIE1hdGguY29zKGEpICogcng7XG4gICAgICBjb25zdCB5MDIgPSBkeSArIE1hdGguc2luKGEpICogcnk7XG4gICAgICBjb25zdCB4MTIgPSB4ICsgeDAyO1xuICAgICAgY29uc3QgeDIyID0geCAtIHgwMjtcbiAgICAgIGNvbnN0IHkxMiA9IHkgKyB5MDI7XG4gICAgICBjb25zdCB5MjIgPSB5IC0geTAyO1xuICAgICAgcG9pbnRzW2oxKytdID0geDEyO1xuICAgICAgcG9pbnRzW2oxKytdID0geTEyO1xuICAgICAgcG9pbnRzWy0tajJdID0geTEyO1xuICAgICAgcG9pbnRzWy0tajJdID0geDIyO1xuICAgICAgcG9pbnRzW2ozKytdID0geDIyO1xuICAgICAgcG9pbnRzW2ozKytdID0geTIyO1xuICAgICAgcG9pbnRzWy0tajRdID0geTIyO1xuICAgICAgcG9pbnRzWy0tajRdID0geDEyO1xuICAgIH1cbiAgICB4MCA9IGR4O1xuICAgIHkwID0gZHkgKyByeTtcbiAgICB4MSA9IHggKyB4MDtcbiAgICB4MiA9IHggLSB4MDtcbiAgICB5MSA9IHkgKyB5MDtcbiAgICBjb25zdCB5MiA9IHkgLSB5MDtcbiAgICBwb2ludHNbajErK10gPSB4MTtcbiAgICBwb2ludHNbajErK10gPSB5MTtcbiAgICBwb2ludHNbLS1qNF0gPSB5MjtcbiAgICBwb2ludHNbLS1qNF0gPSB4MTtcbiAgICBpZiAoZHgpIHtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHgyO1xuICAgICAgcG9pbnRzW2oxKytdID0geTE7XG4gICAgICBwb2ludHNbLS1qNF0gPSB5MjtcbiAgICAgIHBvaW50c1stLWo0XSA9IHgyO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuICB0cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCB2ZXJ0aWNlc1N0cmlkZSwgdmVydGljZXNPZmZzZXQsIGluZGljZXMsIGluZGljZXNPZmZzZXQpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2VudGVyWCA9IDA7XG4gICAgbGV0IGNlbnRlclkgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjZW50ZXJYICs9IHBvaW50c1tpXTtcbiAgICAgIGNlbnRlclkgKz0gcG9pbnRzW2kgKyAxXTtcbiAgICB9XG4gICAgY2VudGVyWCAvPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICBjZW50ZXJZIC89IHBvaW50cy5sZW5ndGggLyAyO1xuICAgIGxldCBjb3VudCA9IHZlcnRpY2VzT2Zmc2V0O1xuICAgIHZlcnRpY2VzW2NvdW50ICogdmVydGljZXNTdHJpZGVdID0gY2VudGVyWDtcbiAgICB2ZXJ0aWNlc1tjb3VudCAqIHZlcnRpY2VzU3RyaWRlICsgMV0gPSBjZW50ZXJZO1xuICAgIGNvbnN0IGNlbnRlckluZGV4ID0gY291bnQrKztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmVydGljZXNbY291bnQgKiB2ZXJ0aWNlc1N0cmlkZV0gPSBwb2ludHNbaV07XG4gICAgICB2ZXJ0aWNlc1tjb3VudCAqIHZlcnRpY2VzU3RyaWRlICsgMV0gPSBwb2ludHNbaSArIDFdO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNvdW50O1xuICAgICAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSBjZW50ZXJJbmRleDtcbiAgICAgICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gY291bnQgLSAxO1xuICAgICAgfVxuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gY2VudGVySW5kZXggKyAxO1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNlbnRlckluZGV4O1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNvdW50IC0gMTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRDaXJjbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQ2lyY2xlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgY2xvc2VQb2ludEVwcyA9IDFlLTQ7XG5jb25zdCBjdXJ2ZUVwcyA9IDFlLTQ7XG5cbmV4cG9ydCB7IGNsb3NlUG9pbnRFcHMsIGN1cnZlRXBzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldE9yaWVudGF0aW9uT2ZQb2ludHMocG9pbnRzKSB7XG4gIGNvbnN0IG0gPSBwb2ludHMubGVuZ3RoO1xuICBpZiAobSA8IDYpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgYXJlYSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCB4MSA9IHBvaW50c1ttIC0gMl0sIHkxID0gcG9pbnRzW20gLSAxXTsgaSA8IG07IGkgKz0gMikge1xuICAgIGNvbnN0IHgyID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IHkyID0gcG9pbnRzW2kgKyAxXTtcbiAgICBhcmVhICs9ICh4MiAtIHgxKSAqICh5MiArIHkxKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgaWYgKGFyZWEgPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAxO1xufVxuXG5leHBvcnQgeyBnZXRPcmllbnRhdGlvbk9mUG9pbnRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRPcmllbnRhdGlvbk9mUG9pbnRzLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcbmltcG9ydCB7IGNsb3NlUG9pbnRFcHMsIGN1cnZlRXBzIH0gZnJvbSAnLi4vY29uc3QubWpzJztcbmltcG9ydCB7IGdldE9yaWVudGF0aW9uT2ZQb2ludHMgfSBmcm9tICcuLi91dGlscy9nZXRPcmllbnRhdGlvbk9mUG9pbnRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc3F1YXJlKHgsIHksIG54LCBueSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCBjbG9ja3dpc2UsIHZlcnRzKSB7XG4gIGNvbnN0IGl4ID0geCAtIG54ICogaW5uZXJXZWlnaHQ7XG4gIGNvbnN0IGl5ID0geSAtIG55ICogaW5uZXJXZWlnaHQ7XG4gIGNvbnN0IG94ID0geCArIG54ICogb3V0ZXJXZWlnaHQ7XG4gIGNvbnN0IG95ID0geSArIG55ICogb3V0ZXJXZWlnaHQ7XG4gIGxldCBleHg7XG4gIGxldCBleXk7XG4gIGlmIChjbG9ja3dpc2UpIHtcbiAgICBleHggPSBueTtcbiAgICBleXkgPSAtbng7XG4gIH0gZWxzZSB7XG4gICAgZXh4ID0gLW55O1xuICAgIGV5eSA9IG54O1xuICB9XG4gIGNvbnN0IGVpeCA9IGl4ICsgZXh4O1xuICBjb25zdCBlaXkgPSBpeSArIGV5eTtcbiAgY29uc3QgZW94ID0gb3ggKyBleHg7XG4gIGNvbnN0IGVveSA9IG95ICsgZXl5O1xuICB2ZXJ0cy5wdXNoKGVpeCwgZWl5KTtcbiAgdmVydHMucHVzaChlb3gsIGVveSk7XG4gIHJldHVybiAyO1xufVxuZnVuY3Rpb24gcm91bmQoY3gsIGN5LCBzeCwgc3ksIGV4LCBleSwgdmVydHMsIGNsb2Nrd2lzZSkge1xuICBjb25zdCBjeDJwMHggPSBzeCAtIGN4O1xuICBjb25zdCBjeTJwMHkgPSBzeSAtIGN5O1xuICBsZXQgYW5nbGUwID0gTWF0aC5hdGFuMihjeDJwMHgsIGN5MnAweSk7XG4gIGxldCBhbmdsZTEgPSBNYXRoLmF0YW4yKGV4IC0gY3gsIGV5IC0gY3kpO1xuICBpZiAoY2xvY2t3aXNlICYmIGFuZ2xlMCA8IGFuZ2xlMSkge1xuICAgIGFuZ2xlMCArPSBNYXRoLlBJICogMjtcbiAgfSBlbHNlIGlmICghY2xvY2t3aXNlICYmIGFuZ2xlMCA+IGFuZ2xlMSkge1xuICAgIGFuZ2xlMSArPSBNYXRoLlBJICogMjtcbiAgfVxuICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlMDtcbiAgY29uc3QgYW5nbGVEaWZmID0gYW5nbGUxIC0gYW5nbGUwO1xuICBjb25zdCBhYnNBbmdsZURpZmYgPSBNYXRoLmFicyhhbmdsZURpZmYpO1xuICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoY3gycDB4ICogY3gycDB4ICsgY3kycDB5ICogY3kycDB5KTtcbiAgY29uc3Qgc2VnQ291bnQgPSAoMTUgKiBhYnNBbmdsZURpZmYgKiBNYXRoLnNxcnQocmFkaXVzKSAvIE1hdGguUEkgPj4gMCkgKyAxO1xuICBjb25zdCBhbmdsZUluYyA9IGFuZ2xlRGlmZiAvIHNlZ0NvdW50O1xuICBzdGFydEFuZ2xlICs9IGFuZ2xlSW5jO1xuICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIHZlcnRzLnB1c2goc3gsIHN5KTtcbiAgICBmb3IgKGxldCBpID0gMSwgYW5nbGUgPSBzdGFydEFuZ2xlOyBpIDwgc2VnQ291bnQ7IGkrKywgYW5nbGUgKz0gYW5nbGVJbmMpIHtcbiAgICAgIHZlcnRzLnB1c2goY3gsIGN5KTtcbiAgICAgIHZlcnRzLnB1c2goXG4gICAgICAgIGN4ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgICBjeSArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1c1xuICAgICAgKTtcbiAgICB9XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIHZlcnRzLnB1c2goZXgsIGV5KTtcbiAgfSBlbHNlIHtcbiAgICB2ZXJ0cy5wdXNoKHN4LCBzeSk7XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIGZvciAobGV0IGkgPSAxLCBhbmdsZSA9IHN0YXJ0QW5nbGU7IGkgPCBzZWdDb3VudDsgaSsrLCBhbmdsZSArPSBhbmdsZUluYykge1xuICAgICAgdmVydHMucHVzaChcbiAgICAgICAgY3ggKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICAgIGN5ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzXG4gICAgICApO1xuICAgICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIH1cbiAgICB2ZXJ0cy5wdXNoKGV4LCBleSk7XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICB9XG4gIHJldHVybiBzZWdDb3VudCAqIDI7XG59XG5mdW5jdGlvbiBidWlsZExpbmUocG9pbnRzLCBsaW5lU3R5bGUsIGZsaXBBbGlnbm1lbnQsIGNsb3NlZCwgdmVydGljZXMsIF92ZXJ0aWNlc1N0cmlkZSwgX3ZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBfaW5kaWNlc09mZnNldCkge1xuICBjb25zdCBlcHMgPSBjbG9zZVBvaW50RXBzO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdHlsZSA9IGxpbmVTdHlsZTtcbiAgbGV0IGFsaWdubWVudCA9IHN0eWxlLmFsaWdubWVudDtcbiAgaWYgKGxpbmVTdHlsZS5hbGlnbm1lbnQgIT09IDAuNSkge1xuICAgIGxldCBvcmllbnRhdGlvbiA9IGdldE9yaWVudGF0aW9uT2ZQb2ludHMocG9pbnRzKTtcbiAgICBpZiAoZmxpcEFsaWdubWVudClcbiAgICAgIG9yaWVudGF0aW9uICo9IC0xO1xuICAgIGFsaWdubWVudCA9IChhbGlnbm1lbnQgLSAwLjUpICogb3JpZW50YXRpb24gKyAwLjU7XG4gIH1cbiAgY29uc3QgZmlyc3RQb2ludCA9IG5ldyBQb2ludChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gIGNvbnN0IGxhc3RQb2ludCA9IG5ldyBQb2ludChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgY2xvc2VkU2hhcGUgPSBjbG9zZWQ7XG4gIGNvbnN0IGNsb3NlZFBhdGggPSBNYXRoLmFicyhmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgPCBlcHMgJiYgTWF0aC5hYnMoZmlyc3RQb2ludC55IC0gbGFzdFBvaW50LnkpIDwgZXBzO1xuICBpZiAoY2xvc2VkU2hhcGUpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcbiAgICBpZiAoY2xvc2VkUGF0aCkge1xuICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgbGFzdFBvaW50LnNldChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgY29uc3QgbWlkUG9pbnRYID0gKGZpcnN0UG9pbnQueCArIGxhc3RQb2ludC54KSAqIDAuNTtcbiAgICBjb25zdCBtaWRQb2ludFkgPSAobGFzdFBvaW50LnkgKyBmaXJzdFBvaW50LnkpICogMC41O1xuICAgIHBvaW50cy51bnNoaWZ0KG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICBwb2ludHMucHVzaChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gIH1cbiAgY29uc3QgdmVydHMgPSB2ZXJ0aWNlcztcbiAgY29uc3QgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gIGxldCBpbmRleENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gIGNvbnN0IHdpZHRoID0gc3R5bGUud2lkdGggLyAyO1xuICBjb25zdCB3aWR0aFNxdWFyZWQgPSB3aWR0aCAqIHdpZHRoO1xuICBjb25zdCBtaXRlckxpbWl0U3F1YXJlZCA9IHN0eWxlLm1pdGVyTGltaXQgKiBzdHlsZS5taXRlckxpbWl0O1xuICBsZXQgeDAgPSBwb2ludHNbMF07XG4gIGxldCB5MCA9IHBvaW50c1sxXTtcbiAgbGV0IHgxID0gcG9pbnRzWzJdO1xuICBsZXQgeTEgPSBwb2ludHNbM107XG4gIGxldCB4MiA9IDA7XG4gIGxldCB5MiA9IDA7XG4gIGxldCBwZXJwWCA9IC0oeTAgLSB5MSk7XG4gIGxldCBwZXJwWSA9IHgwIC0geDE7XG4gIGxldCBwZXJwMXggPSAwO1xuICBsZXQgcGVycDF5ID0gMDtcbiAgbGV0IGRpc3QgPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICBwZXJwWCAvPSBkaXN0O1xuICBwZXJwWSAvPSBkaXN0O1xuICBwZXJwWCAqPSB3aWR0aDtcbiAgcGVycFkgKj0gd2lkdGg7XG4gIGNvbnN0IHJhdGlvID0gYWxpZ25tZW50O1xuICBjb25zdCBpbm5lcldlaWdodCA9ICgxIC0gcmF0aW8pICogMjtcbiAgY29uc3Qgb3V0ZXJXZWlnaHQgPSByYXRpbyAqIDI7XG4gIGlmICghY2xvc2VkU2hhcGUpIHtcbiAgICBpZiAoc3R5bGUuY2FwID09PSBcInJvdW5kXCIpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgIHgwIC0gcGVycFggKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsXG4gICAgICAgIHkwIC0gcGVycFkgKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsXG4gICAgICAgIHgwIC0gcGVycFggKiBpbm5lcldlaWdodCxcbiAgICAgICAgeTAgLSBwZXJwWSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB4MCArIHBlcnBYICogb3V0ZXJXZWlnaHQsXG4gICAgICAgIHkwICsgcGVycFkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgdmVydHMsXG4gICAgICAgIHRydWVcbiAgICAgICkgKyAyO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY2FwID09PSBcInNxdWFyZVwiKSB7XG4gICAgICBpbmRleENvdW50ICs9IHNxdWFyZSh4MCwgeTAsIHBlcnBYLCBwZXJwWSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCB0cnVlLCB2ZXJ0cyk7XG4gICAgfVxuICB9XG4gIHZlcnRzLnB1c2goXG4gICAgeDAgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgIHkwIC0gcGVycFkgKiBpbm5lcldlaWdodFxuICApO1xuICB2ZXJ0cy5wdXNoKFxuICAgIHgwICsgcGVycFggKiBvdXRlcldlaWdodCxcbiAgICB5MCArIHBlcnBZICogb3V0ZXJXZWlnaHRcbiAgKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGggLSAxOyArK2kpIHtcbiAgICB4MCA9IHBvaW50c1soaSAtIDEpICogMl07XG4gICAgeTAgPSBwb2ludHNbKGkgLSAxKSAqIDIgKyAxXTtcbiAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgeTIgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICBwZXJwWCA9IC0oeTAgLSB5MSk7XG4gICAgcGVycFkgPSB4MCAtIHgxO1xuICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICAgIHBlcnBYIC89IGRpc3Q7XG4gICAgcGVycFkgLz0gZGlzdDtcbiAgICBwZXJwWCAqPSB3aWR0aDtcbiAgICBwZXJwWSAqPSB3aWR0aDtcbiAgICBwZXJwMXggPSAtKHkxIC0geTIpO1xuICAgIHBlcnAxeSA9IHgxIC0geDI7XG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJwMXggKiBwZXJwMXggKyBwZXJwMXkgKiBwZXJwMXkpO1xuICAgIHBlcnAxeCAvPSBkaXN0O1xuICAgIHBlcnAxeSAvPSBkaXN0O1xuICAgIHBlcnAxeCAqPSB3aWR0aDtcbiAgICBwZXJwMXkgKj0gd2lkdGg7XG4gICAgY29uc3QgZHgwID0geDEgLSB4MDtcbiAgICBjb25zdCBkeTAgPSB5MCAtIHkxO1xuICAgIGNvbnN0IGR4MSA9IHgxIC0geDI7XG4gICAgY29uc3QgZHkxID0geTIgLSB5MTtcbiAgICBjb25zdCBkb3QgPSBkeDAgKiBkeDEgKyBkeTAgKiBkeTE7XG4gICAgY29uc3QgY3Jvc3MgPSBkeTAgKiBkeDEgLSBkeTEgKiBkeDA7XG4gICAgY29uc3QgY2xvY2t3aXNlID0gY3Jvc3MgPCAwO1xuICAgIGlmIChNYXRoLmFicyhjcm9zcykgPCAxZS0zICogTWF0aC5hYnMoZG90KSkge1xuICAgICAgdmVydHMucHVzaChcbiAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHRcbiAgICAgICk7XG4gICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICB4MSArIHBlcnBYICogb3V0ZXJXZWlnaHQsXG4gICAgICAgIHkxICsgcGVycFkgKiBvdXRlcldlaWdodFxuICAgICAgKTtcbiAgICAgIGlmIChkb3QgPj0gMCkge1xuICAgICAgICBpZiAoc3R5bGUuam9pbiA9PT0gXCJyb3VuZFwiKSB7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSAtIHBlcnBYICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApICsgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleENvdW50ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdmVydHMucHVzaChcbiAgICAgICAgICB4MSAtIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgIHkxIC0gcGVycDF5ICogb3V0ZXJXZWlnaHRcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHMucHVzaChcbiAgICAgICAgICB4MSArIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgIHkxICsgcGVycDF5ICogaW5uZXJXZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjMSA9ICgtcGVycFggKyB4MCkgKiAoLXBlcnBZICsgeTEpIC0gKC1wZXJwWCArIHgxKSAqICgtcGVycFkgKyB5MCk7XG4gICAgY29uc3QgYzIgPSAoLXBlcnAxeCArIHgyKSAqICgtcGVycDF5ICsgeTEpIC0gKC1wZXJwMXggKyB4MSkgKiAoLXBlcnAxeSArIHkyKTtcbiAgICBjb25zdCBweCA9IChkeDAgKiBjMiAtIGR4MSAqIGMxKSAvIGNyb3NzO1xuICAgIGNvbnN0IHB5ID0gKGR5MSAqIGMxIC0gZHkwICogYzIpIC8gY3Jvc3M7XG4gICAgY29uc3QgcERpc3QgPSAocHggLSB4MSkgKiAocHggLSB4MSkgKyAocHkgLSB5MSkgKiAocHkgLSB5MSk7XG4gICAgY29uc3QgaW14ID0geDEgKyAocHggLSB4MSkgKiBpbm5lcldlaWdodDtcbiAgICBjb25zdCBpbXkgPSB5MSArIChweSAtIHkxKSAqIGlubmVyV2VpZ2h0O1xuICAgIGNvbnN0IG9teCA9IHgxIC0gKHB4IC0geDEpICogb3V0ZXJXZWlnaHQ7XG4gICAgY29uc3Qgb215ID0geTEgLSAocHkgLSB5MSkgKiBvdXRlcldlaWdodDtcbiAgICBjb25zdCBzbWFsbGVySW5zaWRlU2VnbWVudFNxID0gTWF0aC5taW4oZHgwICogZHgwICsgZHkwICogZHkwLCBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpO1xuICAgIGNvbnN0IGluc2lkZVdlaWdodCA9IGNsb2Nrd2lzZSA/IGlubmVyV2VpZ2h0IDogb3V0ZXJXZWlnaHQ7XG4gICAgY29uc3Qgc21hbGxlckluc2lkZURpYWdvbmFsU3EgPSBzbWFsbGVySW5zaWRlU2VnbWVudFNxICsgaW5zaWRlV2VpZ2h0ICogaW5zaWRlV2VpZ2h0ICogd2lkdGhTcXVhcmVkO1xuICAgIGNvbnN0IGluc2lkZU1pdGVyT2sgPSBwRGlzdCA8PSBzbWFsbGVySW5zaWRlRGlhZ29uYWxTcTtcbiAgICBpZiAoaW5zaWRlTWl0ZXJPaykge1xuICAgICAgaWYgKHN0eWxlLmpvaW4gPT09IFwiYmV2ZWxcIiB8fCBwRGlzdCAvIHdpZHRoU3F1YXJlZCA+IG1pdGVyTGltaXRTcXVhcmVkKSB7XG4gICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKHgxICsgcGVycFggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQpO1xuICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCk7XG4gICAgICAgICAgdmVydHMucHVzaChvbXgsIG9teSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhDb3VudCArPSAyO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZS5qb2luID09PSBcInJvdW5kXCIpIHtcbiAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApICsgNDtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQpO1xuICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwWSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKSArIDQ7XG4gICAgICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKG9teCwgb215KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVydHMucHVzaChpbXgsIGlteSk7XG4gICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycFggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwWSAqIGlubmVyV2VpZ2h0KTtcbiAgICAgIHZlcnRzLnB1c2goeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQpO1xuICAgICAgaWYgKHN0eWxlLmpvaW4gPT09IFwicm91bmRcIikge1xuICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSArIHBlcnBYICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICkgKyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwWSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKSArIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUuam9pbiA9PT0gXCJtaXRlclwiICYmIHBEaXN0IC8gd2lkdGhTcXVhcmVkIDw9IG1pdGVyTGltaXRTcXVhcmVkKSB7XG4gICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKG9teCwgb215KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKG9teCwgb215KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleENvdW50ICs9IDI7XG4gICAgICB9XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQpO1xuICAgICAgdmVydHMucHVzaCh4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgIGluZGV4Q291bnQgKz0gMjtcbiAgICB9XG4gIH1cbiAgeDAgPSBwb2ludHNbKGxlbmd0aCAtIDIpICogMl07XG4gIHkwID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDIgKyAxXTtcbiAgeDEgPSBwb2ludHNbKGxlbmd0aCAtIDEpICogMl07XG4gIHkxID0gcG9pbnRzWyhsZW5ndGggLSAxKSAqIDIgKyAxXTtcbiAgcGVycFggPSAtKHkwIC0geTEpO1xuICBwZXJwWSA9IHgwIC0geDE7XG4gIGRpc3QgPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICBwZXJwWCAvPSBkaXN0O1xuICBwZXJwWSAvPSBkaXN0O1xuICBwZXJwWCAqPSB3aWR0aDtcbiAgcGVycFkgKj0gd2lkdGg7XG4gIHZlcnRzLnB1c2goeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQpO1xuICB2ZXJ0cy5wdXNoKHgxICsgcGVycFggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0KTtcbiAgaWYgKCFjbG9zZWRTaGFwZSkge1xuICAgIGlmIChzdHlsZS5jYXAgPT09IFwicm91bmRcIikge1xuICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgeDEgLSBwZXJwWCAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICAgICAgeTEgLSBwZXJwWSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQsXG4gICAgICAgIHgxICsgcGVycFggKiBvdXRlcldlaWdodCxcbiAgICAgICAgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICB2ZXJ0cyxcbiAgICAgICAgZmFsc2VcbiAgICAgICkgKyAyO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY2FwID09PSBcInNxdWFyZVwiKSB7XG4gICAgICBpbmRleENvdW50ICs9IHNxdWFyZSh4MSwgeTEsIHBlcnBYLCBwZXJwWSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCBmYWxzZSwgdmVydHMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBlcHMyID0gY3VydmVFcHMgKiBjdXJ2ZUVwcztcbiAgZm9yIChsZXQgaSA9IGluZGV4U3RhcnQ7IGkgPCBpbmRleENvdW50ICsgaW5kZXhTdGFydCAtIDI7ICsraSkge1xuICAgIHgwID0gdmVydHNbaSAqIDJdO1xuICAgIHkwID0gdmVydHNbaSAqIDIgKyAxXTtcbiAgICB4MSA9IHZlcnRzWyhpICsgMSkgKiAyXTtcbiAgICB5MSA9IHZlcnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgeDIgPSB2ZXJ0c1soaSArIDIpICogMl07XG4gICAgeTIgPSB2ZXJ0c1soaSArIDIpICogMiArIDFdO1xuICAgIGlmIChNYXRoLmFicyh4MCAqICh5MSAtIHkyKSArIHgxICogKHkyIC0geTApICsgeDIgKiAoeTAgLSB5MSkpIDwgZXBzMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChpLCBpICsgMSwgaSArIDIpO1xuICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkTGluZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRMaW5lLm1qcy5tYXBcbiIsImltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiB0cmlhbmd1bGF0ZVdpdGhIb2xlcyhwb2ludHMsIGhvbGVzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gIGNvbnN0IHRyaWFuZ2xlcyA9IGVhcmN1dChwb2ludHMsIGhvbGVzLCAyKTtcbiAgaWYgKCF0cmlhbmdsZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB0cmlhbmdsZXNbaV0gKyB2ZXJ0aWNlc09mZnNldDtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB0cmlhbmdsZXNbaSArIDFdICsgdmVydGljZXNPZmZzZXQ7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdHJpYW5nbGVzW2kgKyAyXSArIHZlcnRpY2VzT2Zmc2V0O1xuICB9XG4gIGxldCBpbmRleCA9IHZlcnRpY2VzT2Zmc2V0ICogdmVydGljZXNTdHJpZGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmVydGljZXNbaW5kZXhdID0gcG9pbnRzW2ldO1xuICAgIHZlcnRpY2VzW2luZGV4ICsgMV0gPSBwb2ludHNbaSArIDFdO1xuICAgIGluZGV4ICs9IHZlcnRpY2VzU3RyaWRlO1xuICB9XG59XG5cbmV4cG9ydCB7IHRyaWFuZ3VsYXRlV2l0aEhvbGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmlhbmd1bGF0ZVdpdGhIb2xlcy5tanMubWFwXG4iLCJpbXBvcnQgeyB0cmlhbmd1bGF0ZVdpdGhIb2xlcyB9IGZyb20gJy4uL3V0aWxzL3RyaWFuZ3VsYXRlV2l0aEhvbGVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgZW1wdHlBcnJheSA9IFtdO1xuY29uc3QgYnVpbGRQb2x5Z29uID0ge1xuICBidWlsZChzaGFwZSwgcG9pbnRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvaW50c1tpXSA9IHNoYXBlLnBvaW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgdHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgdHJpYW5ndWxhdGVXaXRoSG9sZXMocG9pbnRzLCBlbXB0eUFycmF5LCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRQb2x5Z29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZFBvbHlnb24ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBidWlsZFJlY3RhbmdsZSA9IHtcbiAgYnVpbGQoc2hhcGUsIHBvaW50cykge1xuICAgIGNvbnN0IHJlY3REYXRhID0gc2hhcGU7XG4gICAgY29uc3QgeCA9IHJlY3REYXRhLng7XG4gICAgY29uc3QgeSA9IHJlY3REYXRhLnk7XG4gICAgY29uc3Qgd2lkdGggPSByZWN0RGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQ7XG4gICAgaWYgKCEod2lkdGggPj0gMCAmJiBoZWlnaHQgPj0gMCkpIHtcbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIHBvaW50c1swXSA9IHg7XG4gICAgcG9pbnRzWzFdID0geTtcbiAgICBwb2ludHNbMl0gPSB4ICsgd2lkdGg7XG4gICAgcG9pbnRzWzNdID0geTtcbiAgICBwb2ludHNbNF0gPSB4ICsgd2lkdGg7XG4gICAgcG9pbnRzWzVdID0geSArIGhlaWdodDtcbiAgICBwb2ludHNbNl0gPSB4O1xuICAgIHBvaW50c1s3XSA9IHkgKyBoZWlnaHQ7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgdHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB2ZXJ0aWNlc09mZnNldCAqPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1swXTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbMV07XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudF0gPSBwb2ludHNbMl07XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudCArIDFdID0gcG9pbnRzWzNdO1xuICAgIGNvdW50ICs9IHZlcnRpY2VzU3RyaWRlO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnRdID0gcG9pbnRzWzZdO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnQgKyAxXSA9IHBvaW50c1s3XTtcbiAgICBjb3VudCArPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1s0XTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbNV07XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgY29uc3QgdmVydGljZXNJbmRleCA9IHZlcnRpY2VzT2Zmc2V0IC8gdmVydGljZXNTdHJpZGU7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleDtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMTtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMjtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMTtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMztcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMjtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRSZWN0YW5nbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUmVjdGFuZ2xlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgYnVpbGRUcmlhbmdsZSA9IHtcbiAgYnVpbGQoc2hhcGUsIHBvaW50cykge1xuICAgIHBvaW50c1swXSA9IHNoYXBlLng7XG4gICAgcG9pbnRzWzFdID0gc2hhcGUueTtcbiAgICBwb2ludHNbMl0gPSBzaGFwZS54MjtcbiAgICBwb2ludHNbM10gPSBzaGFwZS55MjtcbiAgICBwb2ludHNbNF0gPSBzaGFwZS54MztcbiAgICBwb2ludHNbNV0gPSBzaGFwZS55MztcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuICB0cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCB2ZXJ0aWNlc1N0cmlkZSwgdmVydGljZXNPZmZzZXQsIGluZGljZXMsIGluZGljZXNPZmZzZXQpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHZlcnRpY2VzT2Zmc2V0ICo9IHZlcnRpY2VzU3RyaWRlO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnRdID0gcG9pbnRzWzBdO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnQgKyAxXSA9IHBvaW50c1sxXTtcbiAgICBjb3VudCArPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1syXTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbM107XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudF0gPSBwb2ludHNbNF07XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudCArIDFdID0gcG9pbnRzWzVdO1xuICAgIGNvbnN0IHZlcnRpY2VzSW5kZXggPSB2ZXJ0aWNlc09mZnNldCAvIHZlcnRpY2VzU3RyaWRlO1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IHZlcnRpY2VzSW5kZXg7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleCArIDE7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleCArIDI7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGJ1aWxkVHJpYW5nbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkVHJpYW5nbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRVdnMsIGJ1aWxkU2ltcGxlVXZzIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvYnVpbGRVdnMubWpzJztcbmltcG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvdHJhbnNmb3JtVmVydGljZXMubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlR3JhcGhpY3MgfSBmcm9tICcuLi9CYXRjaGFibGVHcmFwaGljcy5tanMnO1xuaW1wb3J0IHsgYnVpbGRDaXJjbGUgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkQ2lyY2xlLm1qcyc7XG5pbXBvcnQgeyBidWlsZExpbmUgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkTGluZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRQb2x5Z29uIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZFBvbHlnb24ubWpzJztcbmltcG9ydCB7IGJ1aWxkUmVjdGFuZ2xlIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZFJlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRUcmlhbmdsZSB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRUcmlhbmdsZS5tanMnO1xuaW1wb3J0IHsgdHJpYW5ndWxhdGVXaXRoSG9sZXMgfSBmcm9tICcuL3RyaWFuZ3VsYXRlV2l0aEhvbGVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgYnVpbGRNYXAgPSB7XG4gIHJlY3RhbmdsZTogYnVpbGRSZWN0YW5nbGUsXG4gIHBvbHlnb246IGJ1aWxkUG9seWdvbixcbiAgdHJpYW5nbGU6IGJ1aWxkVHJpYW5nbGUsXG4gIGNpcmNsZTogYnVpbGRDaXJjbGUsXG4gIGVsbGlwc2U6IGJ1aWxkQ2lyY2xlLFxuICByb3VuZGVkUmVjdGFuZ2xlOiBidWlsZENpcmNsZVxufTtcbmNvbnN0IHRlbXBSZWN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuZnVuY3Rpb24gYnVpbGRDb250ZXh0QmF0Y2hlcyhjb250ZXh0LCBncHVDb250ZXh0KSB7XG4gIGNvbnN0IHsgZ2VvbWV0cnlEYXRhLCBiYXRjaGVzIH0gPSBncHVDb250ZXh0O1xuICBiYXRjaGVzLmxlbmd0aCA9IDA7XG4gIGdlb21ldHJ5RGF0YS5pbmRpY2VzLmxlbmd0aCA9IDA7XG4gIGdlb21ldHJ5RGF0YS52ZXJ0aWNlcy5sZW5ndGggPSAwO1xuICBnZW9tZXRyeURhdGEudXZzLmxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGV4dC5pbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGNvbnRleHQuaW5zdHJ1Y3Rpb25zW2ldO1xuICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwidGV4dHVyZVwiKSB7XG4gICAgICBhZGRUZXh0dXJlVG9HZW9tZXRyeURhdGEoaW5zdHJ1Y3Rpb24uZGF0YSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKTtcbiAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJmaWxsXCIgfHwgaW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInN0cm9rZVwiKSB7XG4gICAgICBjb25zdCBpc1N0cm9rZSA9IGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJzdHJva2VcIjtcbiAgICAgIGNvbnN0IHNoYXBlUGF0aCA9IGluc3RydWN0aW9uLmRhdGEucGF0aC5zaGFwZVBhdGg7XG4gICAgICBjb25zdCBzdHlsZSA9IGluc3RydWN0aW9uLmRhdGEuc3R5bGU7XG4gICAgICBjb25zdCBob2xlID0gaW5zdHJ1Y3Rpb24uZGF0YS5ob2xlO1xuICAgICAgaWYgKGlzU3Ryb2tlICYmIGhvbGUpIHtcbiAgICAgICAgYWRkU2hhcGVQYXRoVG9HZW9tZXRyeURhdGEoaG9sZS5zaGFwZVBhdGgsIHN0eWxlLCBudWxsLCB0cnVlLCBiYXRjaGVzLCBnZW9tZXRyeURhdGEpO1xuICAgICAgfVxuICAgICAgYWRkU2hhcGVQYXRoVG9HZW9tZXRyeURhdGEoc2hhcGVQYXRoLCBzdHlsZSwgaG9sZSwgaXNTdHJva2UsIGJhdGNoZXMsIGdlb21ldHJ5RGF0YSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRUZXh0dXJlVG9HZW9tZXRyeURhdGEoZGF0YSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKSB7XG4gIGNvbnN0IHsgdmVydGljZXMsIHV2cywgaW5kaWNlcyB9ID0gZ2VvbWV0cnlEYXRhO1xuICBjb25zdCBpbmRleE9mZnNldCA9IGluZGljZXMubGVuZ3RoO1xuICBjb25zdCB2ZXJ0T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMjtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IGJ1aWxkID0gYnVpbGRNYXAucmVjdGFuZ2xlO1xuICBjb25zdCByZWN0ID0gdGVtcFJlY3Q7XG4gIGNvbnN0IHRleHR1cmUgPSBkYXRhLmltYWdlO1xuICByZWN0LnggPSBkYXRhLmR4O1xuICByZWN0LnkgPSBkYXRhLmR5O1xuICByZWN0LndpZHRoID0gZGF0YS5kdztcbiAgcmVjdC5oZWlnaHQgPSBkYXRhLmRoO1xuICBjb25zdCBtYXRyaXggPSBkYXRhLnRyYW5zZm9ybTtcbiAgYnVpbGQuYnVpbGQocmVjdCwgcG9pbnRzKTtcbiAgaWYgKG1hdHJpeCkge1xuICAgIHRyYW5zZm9ybVZlcnRpY2VzKHBvaW50cywgbWF0cml4KTtcbiAgfVxuICBidWlsZC50cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCAyLCB2ZXJ0T2Zmc2V0LCBpbmRpY2VzLCBpbmRleE9mZnNldCk7XG4gIGNvbnN0IHRleHR1cmVVdnMgPSB0ZXh0dXJlLnV2cztcbiAgdXZzLnB1c2goXG4gICAgdGV4dHVyZVV2cy54MCxcbiAgICB0ZXh0dXJlVXZzLnkwLFxuICAgIHRleHR1cmVVdnMueDEsXG4gICAgdGV4dHVyZVV2cy55MSxcbiAgICB0ZXh0dXJlVXZzLngzLFxuICAgIHRleHR1cmVVdnMueTMsXG4gICAgdGV4dHVyZVV2cy54MixcbiAgICB0ZXh0dXJlVXZzLnkyXG4gICk7XG4gIGNvbnN0IGdyYXBoaWNzQmF0Y2ggPSBCaWdQb29sLmdldChCYXRjaGFibGVHcmFwaGljcyk7XG4gIGdyYXBoaWNzQmF0Y2guaW5kZXhPZmZzZXQgPSBpbmRleE9mZnNldDtcbiAgZ3JhcGhpY3NCYXRjaC5pbmRleFNpemUgPSBpbmRpY2VzLmxlbmd0aCAtIGluZGV4T2Zmc2V0O1xuICBncmFwaGljc0JhdGNoLnZlcnRleE9mZnNldCA9IHZlcnRPZmZzZXQ7XG4gIGdyYXBoaWNzQmF0Y2gudmVydGV4U2l6ZSA9IHZlcnRpY2VzLmxlbmd0aCAvIDIgLSB2ZXJ0T2Zmc2V0O1xuICBncmFwaGljc0JhdGNoLmNvbG9yID0gZGF0YS5zdHlsZTtcbiAgZ3JhcGhpY3NCYXRjaC5hbHBoYSA9IGRhdGEuYWxwaGE7XG4gIGdyYXBoaWNzQmF0Y2gudGV4dHVyZSA9IHRleHR1cmU7XG4gIGdyYXBoaWNzQmF0Y2guZ2VvbWV0cnlEYXRhID0gZ2VvbWV0cnlEYXRhO1xuICBiYXRjaGVzLnB1c2goZ3JhcGhpY3NCYXRjaCk7XG59XG5mdW5jdGlvbiBhZGRTaGFwZVBhdGhUb0dlb21ldHJ5RGF0YShzaGFwZVBhdGgsIHN0eWxlLCBob2xlLCBpc1N0cm9rZSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKSB7XG4gIGNvbnN0IHsgdmVydGljZXMsIHV2cywgaW5kaWNlcyB9ID0gZ2VvbWV0cnlEYXRhO1xuICBjb25zdCBsYXN0SW5kZXggPSBzaGFwZVBhdGguc2hhcGVQcmltaXRpdmVzLmxlbmd0aCAtIDE7XG4gIHNoYXBlUGF0aC5zaGFwZVByaW1pdGl2ZXMuZm9yRWFjaCgoeyBzaGFwZSwgdHJhbnNmb3JtOiBtYXRyaXggfSwgaSkgPT4ge1xuICAgIGNvbnN0IGluZGV4T2Zmc2V0ID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3QgdmVydE9mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgY29uc3QgYnVpbGQgPSBidWlsZE1hcFtzaGFwZS50eXBlXTtcbiAgICBidWlsZC5idWlsZChzaGFwZSwgcG9pbnRzKTtcbiAgICBpZiAobWF0cml4KSB7XG4gICAgICB0cmFuc2Zvcm1WZXJ0aWNlcyhwb2ludHMsIG1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghaXNTdHJva2UpIHtcbiAgICAgIGlmIChob2xlICYmIGxhc3RJbmRleCA9PT0gaSkge1xuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW1BpeGkgR3JhcGhpY3NdIG9ubHkgdGhlIGxhc3Qgc2hhcGUgaGF2ZSBiZSBjdXQgb3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvbGVJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IG90aGVyUG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGhvbGVBcnJheXMgPSBnZXRIb2xlQXJyYXlzKGhvbGUuc2hhcGVQYXRoKTtcbiAgICAgICAgaG9sZUFycmF5cy5mb3JFYWNoKChob2xlUG9pbnRzKSA9PiB7XG4gICAgICAgICAgaG9sZUluZGljZXMucHVzaChvdGhlclBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgICAgICBvdGhlclBvaW50cy5wdXNoKC4uLmhvbGVQb2ludHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJpYW5ndWxhdGVXaXRoSG9sZXMob3RoZXJQb2ludHMsIGhvbGVJbmRpY2VzLCB2ZXJ0aWNlcywgMiwgdmVydE9mZnNldCwgaW5kaWNlcywgaW5kZXhPZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVpbGQudHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgMiwgdmVydE9mZnNldCwgaW5kaWNlcywgaW5kZXhPZmZzZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjbG9zZSA9IHNoYXBlLmNsb3NlUGF0aCA/PyB0cnVlO1xuICAgICAgY29uc3QgbGluZVN0eWxlID0gc3R5bGU7XG4gICAgICBidWlsZExpbmUocG9pbnRzLCBsaW5lU3R5bGUsIGZhbHNlLCBjbG9zZSwgdmVydGljZXMsIDIsIHZlcnRPZmZzZXQsIGluZGljZXMsIGluZGV4T2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgdXZzT2Zmc2V0ID0gdXZzLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgdGV4dHVyZSA9IHN0eWxlLnRleHR1cmU7XG4gICAgaWYgKHRleHR1cmUgIT09IFRleHR1cmUuV0hJVEUpIHtcbiAgICAgIGNvbnN0IHRleHR1cmVNYXRyaXggPSBzdHlsZS5tYXRyaXg7XG4gICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgIHRleHR1cmVNYXRyaXguYXBwZW5kKG1hdHJpeC5jbG9uZSgpLmludmVydCgpKTtcbiAgICAgIH1cbiAgICAgIGJ1aWxkVXZzKHZlcnRpY2VzLCAyLCB2ZXJ0T2Zmc2V0LCB1dnMsIHV2c09mZnNldCwgMiwgdmVydGljZXMubGVuZ3RoIC8gMiAtIHZlcnRPZmZzZXQsIHRleHR1cmVNYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWlsZFNpbXBsZVV2cyh1dnMsIHV2c09mZnNldCwgMiwgdmVydGljZXMubGVuZ3RoIC8gMiAtIHZlcnRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBncmFwaGljc0JhdGNoID0gQmlnUG9vbC5nZXQoQmF0Y2hhYmxlR3JhcGhpY3MpO1xuICAgIGdyYXBoaWNzQmF0Y2guaW5kZXhPZmZzZXQgPSBpbmRleE9mZnNldDtcbiAgICBncmFwaGljc0JhdGNoLmluZGV4U2l6ZSA9IGluZGljZXMubGVuZ3RoIC0gaW5kZXhPZmZzZXQ7XG4gICAgZ3JhcGhpY3NCYXRjaC52ZXJ0ZXhPZmZzZXQgPSB2ZXJ0T2Zmc2V0O1xuICAgIGdyYXBoaWNzQmF0Y2gudmVydGV4U2l6ZSA9IHZlcnRpY2VzLmxlbmd0aCAvIDIgLSB2ZXJ0T2Zmc2V0O1xuICAgIGdyYXBoaWNzQmF0Y2guY29sb3IgPSBzdHlsZS5jb2xvcjtcbiAgICBncmFwaGljc0JhdGNoLmFscGhhID0gc3R5bGUuYWxwaGE7XG4gICAgZ3JhcGhpY3NCYXRjaC50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICBncmFwaGljc0JhdGNoLmdlb21ldHJ5RGF0YSA9IGdlb21ldHJ5RGF0YTtcbiAgICBiYXRjaGVzLnB1c2goZ3JhcGhpY3NCYXRjaCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0SG9sZUFycmF5cyhzaGFwZSkge1xuICBpZiAoIXNoYXBlKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgaG9sZVByaW1pdGl2ZXMgPSBzaGFwZS5zaGFwZVByaW1pdGl2ZXM7XG4gIGNvbnN0IGhvbGVBcnJheXMgPSBbXTtcbiAgZm9yIChsZXQgayA9IDA7IGsgPCBob2xlUHJpbWl0aXZlcy5sZW5ndGg7IGsrKykge1xuICAgIGNvbnN0IGhvbGVQcmltaXRpdmUgPSBob2xlUHJpbWl0aXZlc1trXS5zaGFwZTtcbiAgICBjb25zdCBob2xlUG9pbnRzID0gW107XG4gICAgY29uc3QgaG9sZUJ1aWxkZXIgPSBidWlsZE1hcFtob2xlUHJpbWl0aXZlLnR5cGVdO1xuICAgIGhvbGVCdWlsZGVyLmJ1aWxkKGhvbGVQcmltaXRpdmUsIGhvbGVQb2ludHMpO1xuICAgIGhvbGVBcnJheXMucHVzaChob2xlUG9pbnRzKTtcbiAgfVxuICByZXR1cm4gaG9sZUFycmF5cztcbn1cblxuZXhwb3J0IHsgYnVpbGRDb250ZXh0QmF0Y2hlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRDb250ZXh0QmF0Y2hlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBCYXRjaEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L0JhdGNoR2VvbWV0cnkubWpzJztcbmltcG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9iYXRjaGVyL2dwdS9nZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAubWpzJztcbmltcG9ydCB7IEJhdGNoZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hlci5tanMnO1xuaW1wb3J0IHsgSW5zdHJ1Y3Rpb25TZXQgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9pbnN0cnVjdGlvbnMvSW5zdHJ1Y3Rpb25TZXQubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgYnVpbGRDb250ZXh0QmF0Y2hlcyB9IGZyb20gJy4vdXRpbHMvYnVpbGRDb250ZXh0QmF0Y2hlcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdUdyYXBoaWNzQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xuICAgIHRoaXMuZ2VvbWV0cnlEYXRhID0ge1xuICAgICAgdmVydGljZXM6IFtdLFxuICAgICAgdXZzOiBbXSxcbiAgICAgIGluZGljZXM6IFtdXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgR3JhcGhpY3NDb250ZXh0UmVuZGVyRGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgQmF0Y2hHZW9tZXRyeSgpO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gbmV3IEluc3RydWN0aW9uU2V0KCk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5yZXNldCgpO1xuICB9XG59XG5jb25zdCBfR3JhcGhpY3NDb250ZXh0U3lzdGVtID0gY2xhc3MgX0dyYXBoaWNzQ29udGV4dFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIHRoZSByb290IGNvbnRleHQgYmF0Y2hlcywgdXNlZCB0byBlaXRoZXIgbWFrZSBhIGJhdGNoIG9yIGdlb21ldHJ5XG4gICAgLy8gYWxsIGdyYXBoaWNzIHVzZSB0aGlzIGFzIGEgYmFzZVxuICAgIHRoaXMuX2FjdGl2ZUJhdGNoZXJzID0gW107XG4gICAgdGhpcy5fZ3B1Q29udGV4dEhhc2ggPSB7fTtcbiAgICAvLyB1c2VkIGZvciBub24tYmF0Y2hhYmxlIGdyYXBoaWNzXG4gICAgdGhpcy5fZ3JhcGhpY3NEYXRhQ29udGV4dEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICAvKipcbiAgICogUnVubmVyIGluaXQgY2FsbGVkLCB1cGRhdGUgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgKiBAaWdub3JlXG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICBfR3JhcGhpY3NDb250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zLmJlemllclNtb290aG5lc3MgPSBvcHRpb25zPy5iZXppZXJTbW9vdGhuZXNzID8/IF9HcmFwaGljc0NvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMuYmV6aWVyU21vb3RobmVzcztcbiAgfVxuICBwcmVyZW5kZXIoKSB7XG4gICAgdGhpcy5fcmV0dXJuQWN0aXZlQmF0Y2hlcnMoKTtcbiAgfVxuICBnZXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoaWNzRGF0YUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSB8fCB0aGlzLl9pbml0Q29udGV4dFJlbmRlckRhdGEoY29udGV4dCk7XG4gIH1cbiAgLy8gQ29udGV4dCBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuICB1cGRhdGVHcHVDb250ZXh0KGNvbnRleHQpIHtcbiAgICBsZXQgZ3B1Q29udGV4dCA9IHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSB8fCB0aGlzLl9pbml0Q29udGV4dChjb250ZXh0KTtcbiAgICBpZiAoY29udGV4dC5kaXJ0eSkge1xuICAgICAgaWYgKGdwdUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY2xlYW5HcmFwaGljc0NvbnRleHREYXRhKGNvbnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3B1Q29udGV4dCA9IHRoaXMuX2luaXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgYnVpbGRDb250ZXh0QmF0Y2hlcyhjb250ZXh0LCBncHVDb250ZXh0KTtcbiAgICAgIGNvbnN0IGJhdGNoTW9kZSA9IGNvbnRleHQuYmF0Y2hNb2RlO1xuICAgICAgaWYgKGNvbnRleHQuY3VzdG9tU2hhZGVyIHx8IGJhdGNoTW9kZSA9PT0gXCJuby1iYXRjaFwiKSB7XG4gICAgICAgIGdwdUNvbnRleHQuaXNCYXRjaGFibGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoYmF0Y2hNb2RlID09PSBcImF1dG9cIikge1xuICAgICAgICBncHVDb250ZXh0LmlzQmF0Y2hhYmxlID0gZ3B1Q29udGV4dC5nZW9tZXRyeURhdGEudmVydGljZXMubGVuZ3RoIDwgNDAwO1xuICAgICAgfVxuICAgICAgY29udGV4dC5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZ3B1Q29udGV4dDtcbiAgfVxuICBnZXRHcHVDb250ZXh0KGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdIHx8IHRoaXMuX2luaXRDb250ZXh0KGNvbnRleHQpO1xuICB9XG4gIF9yZXR1cm5BY3RpdmVCYXRjaGVycygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FjdGl2ZUJhdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBCaWdQb29sLnJldHVybih0aGlzLl9hY3RpdmVCYXRjaGVyc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZUJhdGNoZXJzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX2luaXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KSB7XG4gICAgY29uc3QgZ3JhcGhpY3NEYXRhID0gQmlnUG9vbC5nZXQoR3JhcGhpY3NDb250ZXh0UmVuZGVyRGF0YSk7XG4gICAgY29uc3QgeyBiYXRjaGVzLCBnZW9tZXRyeURhdGEgfSA9IHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXTtcbiAgICBjb25zdCB2ZXJ0ZXhTaXplID0gZ2VvbWV0cnlEYXRhLnZlcnRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBpbmRleFNpemUgPSBnZW9tZXRyeURhdGEuaW5kaWNlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXRjaGVzW2ldLmFwcGx5VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJhdGNoZXIgPSBCaWdQb29sLmdldChCYXRjaGVyKTtcbiAgICB0aGlzLl9hY3RpdmVCYXRjaGVycy5wdXNoKGJhdGNoZXIpO1xuICAgIGJhdGNoZXIuZW5zdXJlQXR0cmlidXRlQnVmZmVyKHZlcnRleFNpemUpO1xuICAgIGJhdGNoZXIuZW5zdXJlSW5kZXhCdWZmZXIoaW5kZXhTaXplKTtcbiAgICBiYXRjaGVyLmJlZ2luKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICBiYXRjaGVyLmFkZChiYXRjaCk7XG4gICAgfVxuICAgIGJhdGNoZXIuZmluaXNoKGdyYXBoaWNzRGF0YS5pbnN0cnVjdGlvbnMpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gZ3JhcGhpY3NEYXRhLmdlb21ldHJ5O1xuICAgIGdlb21ldHJ5LmluZGV4QnVmZmVyLnNldERhdGFXaXRoU2l6ZShiYXRjaGVyLmluZGV4QnVmZmVyLCBiYXRjaGVyLmluZGV4U2l6ZSwgdHJ1ZSk7XG4gICAgZ2VvbWV0cnkuYnVmZmVyc1swXS5zZXREYXRhV2l0aFNpemUoYmF0Y2hlci5hdHRyaWJ1dGVCdWZmZXIuZmxvYXQzMlZpZXcsIGJhdGNoZXIuYXR0cmlidXRlU2l6ZSwgdHJ1ZSk7XG4gICAgY29uc3QgZHJhd0JhdGNoZXMgPSBiYXRjaGVyLmJhdGNoZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmF3QmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmF0Y2ggPSBkcmF3QmF0Y2hlc1tpXTtcbiAgICAgIGJhdGNoLmJpbmRHcm91cCA9IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cChiYXRjaC50ZXh0dXJlcy50ZXh0dXJlcywgYmF0Y2gudGV4dHVyZXMuY291bnQpO1xuICAgIH1cbiAgICB0aGlzLl9ncmFwaGljc0RhdGFDb250ZXh0SGFzaFtjb250ZXh0LnVpZF0gPSBncmFwaGljc0RhdGE7XG4gICAgcmV0dXJuIGdyYXBoaWNzRGF0YTtcbiAgfVxuICBfaW5pdENvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGdwdUNvbnRleHQgPSBuZXcgR3B1R3JhcGhpY3NDb250ZXh0KCk7XG4gICAgZ3B1Q29udGV4dC5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9ncHVDb250ZXh0SGFzaFtjb250ZXh0LnVpZF0gPSBncHVDb250ZXh0O1xuICAgIGNvbnRleHQub24oXCJkZXN0cm95XCIsIHRoaXMub25HcmFwaGljc0NvbnRleHREZXN0cm95LCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdO1xuICB9XG4gIG9uR3JhcGhpY3NDb250ZXh0RGVzdHJveShjb250ZXh0KSB7XG4gICAgdGhpcy5fY2xlYW5HcmFwaGljc0NvbnRleHREYXRhKGNvbnRleHQpO1xuICAgIGNvbnRleHQub2ZmKFwiZGVzdHJveVwiLCB0aGlzLm9uR3JhcGhpY3NDb250ZXh0RGVzdHJveSwgdGhpcyk7XG4gICAgdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdID0gbnVsbDtcbiAgfVxuICBfY2xlYW5HcmFwaGljc0NvbnRleHREYXRhKGNvbnRleHQpIHtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdO1xuICAgIGlmICghZ3B1Q29udGV4dC5pc0JhdGNoYWJsZSkge1xuICAgICAgaWYgKHRoaXMuX2dyYXBoaWNzRGF0YUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSkge1xuICAgICAgICBCaWdQb29sLnJldHVybih0aGlzLmdldENvbnRleHRSZW5kZXJEYXRhKGNvbnRleHQpKTtcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NEYXRhQ29udGV4dEhhc2hbY29udGV4dC51aWRdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdwdUNvbnRleHQuYmF0Y2hlcykge1xuICAgICAgZ3B1Q29udGV4dC5iYXRjaGVzLmZvckVhY2goKGJhdGNoKSA9PiB7XG4gICAgICAgIEJpZ1Bvb2wucmV0dXJuKGJhdGNoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVDb250ZXh0SGFzaCkge1xuICAgICAgaWYgKHRoaXMuX2dwdUNvbnRleHRIYXNoW2ldKSB7XG4gICAgICAgIHRoaXMub25HcmFwaGljc0NvbnRleHREZXN0cm95KHRoaXMuX2dwdUNvbnRleHRIYXNoW2ldLmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8qKiBAaWdub3JlICovXG5fR3JhcGhpY3NDb250ZXh0U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJncmFwaGljc0NvbnRleHRcIlxufTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgR3JhcGhpY3NDb250ZXh0U3lzdGVtLiAqL1xuX0dyYXBoaWNzQ29udGV4dFN5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIEEgdmFsdWUgZnJvbSAwIHRvIDEgdGhhdCBjb250cm9scyB0aGUgc21vb3RobmVzcyBvZiBiZXppZXIgY3VydmVzICh0aGUgaGlnaGVyIHRoZSBzbW9vdGhlcilcbiAgICogQGRlZmF1bHQgMC41XG4gICAqL1xuICBiZXppZXJTbW9vdGhuZXNzOiAwLjVcbn07XG5sZXQgR3JhcGhpY3NDb250ZXh0U3lzdGVtID0gX0dyYXBoaWNzQ29udGV4dFN5c3RlbTtcblxuZXhwb3J0IHsgR3B1R3JhcGhpY3NDb250ZXh0LCBHcmFwaGljc0NvbnRleHRSZW5kZXJEYXRhLCBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzQ29udGV4dFN5c3RlbS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4108\n')},557:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   f: () => (/* binding */ FillGradient)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8409);\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3646);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9160);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9853);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n\n\n\n\n\n"use strict";\nconst _FillGradient = class _FillGradient {\n  constructor(x0, y0, x1, y1) {\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("fillGradient");\n    this.type = "linear";\n    this.gradientStops = [];\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n  addColorStop(offset, color) {\n    this.gradientStops.push({ offset, color: _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(color).toHex() });\n    return this;\n  }\n  // TODO move to the system!\n  buildLinearGradient() {\n    const defaultSize = _FillGradient.defaultTextureSize;\n    const { gradientStops } = this;\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__/* .DOMAdapter */ .z.get().createCanvas();\n    canvas.width = defaultSize;\n    canvas.height = defaultSize;\n    const ctx = canvas.getContext("2d");\n    const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n    for (let i = 0; i < gradientStops.length; i++) {\n      const stop = gradientStops[i];\n      gradient.addColorStop(stop.offset, stop.color);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Texture */ .x({\n      source: new _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__/* .ImageSource */ .c({\n        resource: canvas,\n        addressModeU: "clamp-to-edge",\n        addressModeV: "repeat"\n      })\n    });\n    const { x0, y0, x1, y1 } = this;\n    const m = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__/* .Matrix */ .y();\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    m.translate(-x0, -y0);\n    m.scale(1 / defaultSize, 1 / defaultSize);\n    m.rotate(-angle);\n    m.scale(256 / dist, 1);\n    this.transform = m;\n  }\n};\n_FillGradient.defaultTextureSize = 256;\nlet FillGradient = _FillGradient;\n\n\n//# sourceMappingURL=FillGradient.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRDtBQUNhO0FBQ0o7QUFDd0M7QUFDaEI7QUFDaEM7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlLDREQUFLLGlDQUFpQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsbUJBQW1CLHlFQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZGQUFPO0FBQzlCLGtCQUFrQiw2R0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLFlBQVksaUJBQWlCO0FBQzdCLGtCQUFrQixxRUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9maWxsL0ZpbGxHcmFkaWVudC5tanM/MTAxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgSW1hZ2VTb3VyY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvSW1hZ2VTb3VyY2UubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IHVpZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX0ZpbGxHcmFkaWVudCA9IGNsYXNzIF9GaWxsR3JhZGllbnQge1xuICBjb25zdHJ1Y3Rvcih4MCwgeTAsIHgxLCB5MSkge1xuICAgIHRoaXMudWlkID0gdWlkKFwiZmlsbEdyYWRpZW50XCIpO1xuICAgIHRoaXMudHlwZSA9IFwibGluZWFyXCI7XG4gICAgdGhpcy5ncmFkaWVudFN0b3BzID0gW107XG4gICAgdGhpcy54MCA9IHgwO1xuICAgIHRoaXMueTAgPSB5MDtcbiAgICB0aGlzLngxID0geDE7XG4gICAgdGhpcy55MSA9IHkxO1xuICB9XG4gIGFkZENvbG9yU3RvcChvZmZzZXQsIGNvbG9yKSB7XG4gICAgdGhpcy5ncmFkaWVudFN0b3BzLnB1c2goeyBvZmZzZXQsIGNvbG9yOiBDb2xvci5zaGFyZWQuc2V0VmFsdWUoY29sb3IpLnRvSGV4KCkgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLy8gVE9ETyBtb3ZlIHRvIHRoZSBzeXN0ZW0hXG4gIGJ1aWxkTGluZWFyR3JhZGllbnQoKSB7XG4gICAgY29uc3QgZGVmYXVsdFNpemUgPSBfRmlsbEdyYWRpZW50LmRlZmF1bHRUZXh0dXJlU2l6ZTtcbiAgICBjb25zdCB7IGdyYWRpZW50U3RvcHMgfSA9IHRoaXM7XG4gICAgY29uc3QgY2FudmFzID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBkZWZhdWx0U2l6ZTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGVmYXVsdFNpemU7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBfRmlsbEdyYWRpZW50LmRlZmF1bHRUZXh0dXJlU2l6ZSwgMSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFkaWVudFN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdG9wID0gZ3JhZGllbnRTdG9wc1tpXTtcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLm9mZnNldCwgc3RvcC5jb2xvcik7XG4gICAgfVxuICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgZGVmYXVsdFNpemUsIGRlZmF1bHRTaXplKTtcbiAgICB0aGlzLnRleHR1cmUgPSBuZXcgVGV4dHVyZSh7XG4gICAgICBzb3VyY2U6IG5ldyBJbWFnZVNvdXJjZSh7XG4gICAgICAgIHJlc291cmNlOiBjYW52YXMsXG4gICAgICAgIGFkZHJlc3NNb2RlVTogXCJjbGFtcC10by1lZGdlXCIsXG4gICAgICAgIGFkZHJlc3NNb2RlVjogXCJyZXBlYXRcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCB7IHgwLCB5MCwgeDEsIHkxIH0gPSB0aGlzO1xuICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4KCk7XG4gICAgY29uc3QgZHggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGR5ID0geTEgLSB5MDtcbiAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICBtLnRyYW5zbGF0ZSgteDAsIC15MCk7XG4gICAgbS5zY2FsZSgxIC8gZGVmYXVsdFNpemUsIDEgLyBkZWZhdWx0U2l6ZSk7XG4gICAgbS5yb3RhdGUoLWFuZ2xlKTtcbiAgICBtLnNjYWxlKDI1NiAvIGRpc3QsIDEpO1xuICAgIHRoaXMudHJhbnNmb3JtID0gbTtcbiAgfVxufTtcbl9GaWxsR3JhZGllbnQuZGVmYXVsdFRleHR1cmVTaXplID0gMjU2O1xubGV0IEZpbGxHcmFkaWVudCA9IF9GaWxsR3JhZGllbnQ7XG5cbmV4cG9ydCB7IEZpbGxHcmFkaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsbEdyYWRpZW50Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///557\n')},1261:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ FillPattern)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5321);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n\n"use strict";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: "repeat",\n    addressModeV: "repeat"\n  },\n  "repeat-x": {\n    addressModeU: "repeat",\n    addressModeV: "clamp-to-edge"\n  },\n  "repeat-y": {\n    addressModeU: "clamp-to-edge",\n    addressModeV: "repeat"\n  },\n  "no-repeat": {\n    addressModeU: "clamp-to-edge",\n    addressModeV: "clamp-to-edge"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("fillPattern");\n    this.transform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y();\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n  }\n}\n\n\n//# sourceMappingURL=FillPattern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RDtBQUNSOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFHO0FBQ2xCLHlCQUF5QixxRUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbFBhdHRlcm4ubWpzPzRkMjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCByZXBldGl0aW9uTWFwID0ge1xuICByZXBlYXQ6IHtcbiAgICBhZGRyZXNzTW9kZVU6IFwicmVwZWF0XCIsXG4gICAgYWRkcmVzc01vZGVWOiBcInJlcGVhdFwiXG4gIH0sXG4gIFwicmVwZWF0LXhcIjoge1xuICAgIGFkZHJlc3NNb2RlVTogXCJyZXBlYXRcIixcbiAgICBhZGRyZXNzTW9kZVY6IFwiY2xhbXAtdG8tZWRnZVwiXG4gIH0sXG4gIFwicmVwZWF0LXlcIjoge1xuICAgIGFkZHJlc3NNb2RlVTogXCJjbGFtcC10by1lZGdlXCIsXG4gICAgYWRkcmVzc01vZGVWOiBcInJlcGVhdFwiXG4gIH0sXG4gIFwibm8tcmVwZWF0XCI6IHtcbiAgICBhZGRyZXNzTW9kZVU6IFwiY2xhbXAtdG8tZWRnZVwiLFxuICAgIGFkZHJlc3NNb2RlVjogXCJjbGFtcC10by1lZGdlXCJcbiAgfVxufTtcbmNsYXNzIEZpbGxQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgcmVwZXRpdGlvbikge1xuICAgIHRoaXMudWlkID0gdWlkKFwiZmlsbFBhdHRlcm5cIik7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLnRyYW5zZm9ybS5zY2FsZShcbiAgICAgIDEgLyB0ZXh0dXJlLmZyYW1lLndpZHRoLFxuICAgICAgMSAvIHRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgKTtcbiAgICBpZiAocmVwZXRpdGlvbikge1xuICAgICAgdGV4dHVyZS5zb3VyY2Uuc3R5bGUuYWRkcmVzc01vZGVVID0gcmVwZXRpdGlvbk1hcFtyZXBldGl0aW9uXS5hZGRyZXNzTW9kZVU7XG4gICAgICB0ZXh0dXJlLnNvdXJjZS5zdHlsZS5hZGRyZXNzTW9kZVYgPSByZXBldGl0aW9uTWFwW3JlcGV0aXRpb25dLmFkZHJlc3NNb2RlVjtcbiAgICB9XG4gIH1cbiAgc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgdGhpcy50cmFuc2Zvcm0uY29weUZyb20odHJhbnNmb3JtKTtcbiAgICB0aGlzLnRyYW5zZm9ybS5pbnZlcnQoKTtcbiAgICB0aGlzLnRyYW5zZm9ybS5zY2FsZShcbiAgICAgIDEgLyB0ZXh0dXJlLmZyYW1lLndpZHRoLFxuICAgICAgMSAvIHRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgeyBGaWxsUGF0dGVybiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsbFBhdHRlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1261\n')},4915:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   w: () => (/* binding */ convertFillInputToFillStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8409);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9853);\n/* harmony import */ var _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(557);\n/* harmony import */ var _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1261);\n\n\n\n\n\n\n"use strict";\nfunction convertFillInputToFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  let fillStyleToParse;\n  let styleToMerge;\n  if (value?.fill) {\n    styleToMerge = value.fill;\n    fillStyleToParse = { ...defaultStyle, ...value };\n  } else {\n    styleToMerge = value;\n    fillStyleToParse = defaultStyle;\n  }\n  if (_color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.isColorLike(styleToMerge)) {\n    const temp = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.shared.setValue(styleToMerge ?? 0);\n    const opts = {\n      ...fillStyleToParse,\n      color: temp.toNumber(),\n      alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,\n      texture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.WHITE\n    };\n    return opts;\n  } else if (styleToMerge instanceof _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_2__/* .FillPattern */ .h) {\n    const pattern = styleToMerge;\n    return {\n      ...fillStyleToParse,\n      color: 16777215,\n      texture: pattern.texture,\n      matrix: pattern.transform,\n      fill: fillStyleToParse.fill ?? null\n    };\n  } else if (styleToMerge instanceof _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_3__/* .FillGradient */ .f) {\n    const gradient = styleToMerge;\n    gradient.buildLinearGradient();\n    return {\n      ...fillStyleToParse,\n      color: 16777215,\n      texture: gradient.texture,\n      matrix: gradient.transform\n    };\n  }\n  const style = { ...defaultStyle, ...value };\n  if (style.texture) {\n    if (style.texture !== _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.WHITE) {\n      const m = style.matrix?.invert() || new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_4__/* .Matrix */ .y();\n      m.scale(\n        1 / style.texture.frame.width,\n        1 / style.texture.frame.height\n      );\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === "clamp-to-edge") {\n      sourceStyle.addressMode = "repeat";\n    }\n  }\n  const color = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\n\n\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkxNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvRDtBQUNTO0FBQ3dCO0FBQzdCO0FBQ0Y7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBSztBQUNYLGlCQUFpQiw0REFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkZBQU87QUFDdEI7QUFDQTtBQUNBLElBQUksaUNBQWlDLHVFQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQyx5RUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwwQkFBMEIsNkZBQU87QUFDakMsOENBQThDLHFFQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUM7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC91dGlscy9jb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUubWpzP2M4NjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgRmlsbEdyYWRpZW50IH0gZnJvbSAnLi4vZmlsbC9GaWxsR3JhZGllbnQubWpzJztcbmltcG9ydCB7IEZpbGxQYXR0ZXJuIH0gZnJvbSAnLi4vZmlsbC9GaWxsUGF0dGVybi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZSh2YWx1ZSwgZGVmYXVsdFN0eWxlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGZpbGxTdHlsZVRvUGFyc2U7XG4gIGxldCBzdHlsZVRvTWVyZ2U7XG4gIGlmICh2YWx1ZT8uZmlsbCkge1xuICAgIHN0eWxlVG9NZXJnZSA9IHZhbHVlLmZpbGw7XG4gICAgZmlsbFN0eWxlVG9QYXJzZSA9IHsgLi4uZGVmYXVsdFN0eWxlLCAuLi52YWx1ZSB9O1xuICB9IGVsc2Uge1xuICAgIHN0eWxlVG9NZXJnZSA9IHZhbHVlO1xuICAgIGZpbGxTdHlsZVRvUGFyc2UgPSBkZWZhdWx0U3R5bGU7XG4gIH1cbiAgaWYgKENvbG9yLmlzQ29sb3JMaWtlKHN0eWxlVG9NZXJnZSkpIHtcbiAgICBjb25zdCB0ZW1wID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0eWxlVG9NZXJnZSA/PyAwKTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgLi4uZmlsbFN0eWxlVG9QYXJzZSxcbiAgICAgIGNvbG9yOiB0ZW1wLnRvTnVtYmVyKCksXG4gICAgICBhbHBoYTogdGVtcC5hbHBoYSA9PT0gMSA/IGZpbGxTdHlsZVRvUGFyc2UuYWxwaGEgOiB0ZW1wLmFscGhhLFxuICAgICAgdGV4dHVyZTogVGV4dHVyZS5XSElURVxuICAgIH07XG4gICAgcmV0dXJuIG9wdHM7XG4gIH0gZWxzZSBpZiAoc3R5bGVUb01lcmdlIGluc3RhbmNlb2YgRmlsbFBhdHRlcm4pIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gc3R5bGVUb01lcmdlO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5maWxsU3R5bGVUb1BhcnNlLFxuICAgICAgY29sb3I6IDE2Nzc3MjE1LFxuICAgICAgdGV4dHVyZTogcGF0dGVybi50ZXh0dXJlLFxuICAgICAgbWF0cml4OiBwYXR0ZXJuLnRyYW5zZm9ybSxcbiAgICAgIGZpbGw6IGZpbGxTdHlsZVRvUGFyc2UuZmlsbCA/PyBudWxsXG4gICAgfTtcbiAgfSBlbHNlIGlmIChzdHlsZVRvTWVyZ2UgaW5zdGFuY2VvZiBGaWxsR3JhZGllbnQpIHtcbiAgICBjb25zdCBncmFkaWVudCA9IHN0eWxlVG9NZXJnZTtcbiAgICBncmFkaWVudC5idWlsZExpbmVhckdyYWRpZW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZpbGxTdHlsZVRvUGFyc2UsXG4gICAgICBjb2xvcjogMTY3NzcyMTUsXG4gICAgICB0ZXh0dXJlOiBncmFkaWVudC50ZXh0dXJlLFxuICAgICAgbWF0cml4OiBncmFkaWVudC50cmFuc2Zvcm1cbiAgICB9O1xuICB9XG4gIGNvbnN0IHN0eWxlID0geyAuLi5kZWZhdWx0U3R5bGUsIC4uLnZhbHVlIH07XG4gIGlmIChzdHlsZS50ZXh0dXJlKSB7XG4gICAgaWYgKHN0eWxlLnRleHR1cmUgIT09IFRleHR1cmUuV0hJVEUpIHtcbiAgICAgIGNvbnN0IG0gPSBzdHlsZS5tYXRyaXg/LmludmVydCgpIHx8IG5ldyBNYXRyaXgoKTtcbiAgICAgIG0uc2NhbGUoXG4gICAgICAgIDEgLyBzdHlsZS50ZXh0dXJlLmZyYW1lLndpZHRoLFxuICAgICAgICAxIC8gc3R5bGUudGV4dHVyZS5mcmFtZS5oZWlnaHRcbiAgICAgICk7XG4gICAgICBzdHlsZS5tYXRyaXggPSBtO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VTdHlsZSA9IHN0eWxlLnRleHR1cmUuc291cmNlLnN0eWxlO1xuICAgIGlmIChzb3VyY2VTdHlsZS5hZGRyZXNzTW9kZSA9PT0gXCJjbGFtcC10by1lZGdlXCIpIHtcbiAgICAgIHNvdXJjZVN0eWxlLmFkZHJlc3NNb2RlID0gXCJyZXBlYXRcIjtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoc3R5bGUuY29sb3IpO1xuICBzdHlsZS5hbHBoYSAqPSBjb2xvci5hbHBoYTtcbiAgc3R5bGUuY29sb3IgPSBjb2xvci50b051bWJlcigpO1xuICBzdHlsZS5tYXRyaXggPSBzdHlsZS5tYXRyaXggPyBzdHlsZS5tYXRyaXguY2xvbmUoKSA6IG51bGw7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuZXhwb3J0IHsgY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4915\n')},8540:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(9818);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(4537);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup/* UniformGroup */.o({\n      uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uRound: { value: 0, type: "f32" }\n    });\n    this.localUniformsBindGroup = new BindGroup/* BindGroup */.v({\n      0: this.localUniforms\n    });\n    this._meshDataHash = /* @__PURE__ */ Object.create(null);\n    this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      const texture = mesh.texture;\n      if (batchableMesh.texture._source !== texture._source) {\n        if (batchableMesh.texture._source !== texture._source) {\n          return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n        }\n      }\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const { batched } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add({\n        renderPipeId: "mesh",\n        mesh\n      });\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  destroyRenderable(mesh) {\n    this._meshDataHash[mesh.uid] = null;\n    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n    if (gpuMesh) {\n      PoolGroup/* BigPool */.u.return(gpuMesh);\n      this._gpuBatchableMeshHash[mesh.uid] = null;\n    }\n  }\n  execute({ mesh }) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = mesh.groupBlendMode;\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    this._meshDataHash[mesh.uid] = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    mesh.on("destroyed", () => {\n      this.destroyRenderable(mesh);\n    });\n    return this._meshDataHash[mesh.uid];\n  }\n  _getBatchableMesh(mesh) {\n    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = PoolGroup/* BigPool */.u.get(BatchableMesh/* BatchableMesh */.X);\n    gpuMesh.mesh = mesh;\n    gpuMesh.texture = mesh._texture;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n    gpuMesh.mesh = mesh;\n    return gpuMesh;\n  }\n  destroy() {\n    for (const i in this._gpuBatchableMeshHash) {\n      if (this._gpuBatchableMeshHash[i]) {\n        PoolGroup/* BigPool */.u.return(this._gpuBatchableMeshHash[i]);\n      }\n    }\n    this._gpuBatchableMeshHash = null;\n    this._meshDataHash = null;\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "mesh"\n};\n\n\n//# sourceMappingURL=MeshPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU0MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ1Q7QUFDd0I7QUFDUztBQUMvQjtBQUNnQjtBQUN4Qjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFZO0FBQ3pDLDBCQUEwQixXQUFXLG9CQUFNLHlCQUF5QjtBQUNwRSxnQkFBZ0IsMERBQTBEO0FBQzFFLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0wsc0NBQXNDLDBCQUFTO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdCQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2Q0FBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQU8sS0FBSyxrQ0FBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUVvQjtBQUNwQjs7O0FDcEo2RDtBQUNaOztBQUVqRDtBQUNBLDZCQUFVLEtBQUssUUFBUTtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvbWVzaC9zaGFyZWQvTWVzaFBpcGUubWpzP2RmMGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoL2luaXQubWpzPzliYzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBjb2xvcjMyQml0VG9Vbmlmb3JtIH0gZnJvbSAnLi4vLi4vZ3JhcGhpY3MvZ3B1L2NvbG9yVG9Vbmlmb3JtLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGFibGVNZXNoIH0gZnJvbSAnLi9CYXRjaGFibGVNZXNoLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgTWVzaFBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgYWRhcHRvcikge1xuICAgIHRoaXMubG9jYWxVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICAgICAgdVRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1Um91bmQ6IHsgdmFsdWU6IDAsIHR5cGU6IFwiZjMyXCIgfVxuICAgIH0pO1xuICAgIHRoaXMubG9jYWxVbmlmb3Jtc0JpbmRHcm91cCA9IG5ldyBCaW5kR3JvdXAoe1xuICAgICAgMDogdGhpcy5sb2NhbFVuaWZvcm1zXG4gICAgfSk7XG4gICAgdGhpcy5fbWVzaERhdGFIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fYWRhcHRvciA9IGFkYXB0b3I7XG4gICAgdGhpcy5fYWRhcHRvci5pbml0KCk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKG1lc2gpIHtcbiAgICBjb25zdCBtZXNoRGF0YSA9IHRoaXMuX2dldE1lc2hEYXRhKG1lc2gpO1xuICAgIGNvbnN0IHdhc0JhdGNoZWQgPSBtZXNoRGF0YS5iYXRjaGVkO1xuICAgIGNvbnN0IGlzQmF0Y2hlZCA9IG1lc2guYmF0Y2hlZDtcbiAgICBtZXNoRGF0YS5iYXRjaGVkID0gaXNCYXRjaGVkO1xuICAgIGlmICh3YXNCYXRjaGVkICE9PSBpc0JhdGNoZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNCYXRjaGVkKSB7XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IG1lc2guX2dlb21ldHJ5O1xuICAgICAgaWYgKGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICE9PSBtZXNoRGF0YS5pbmRleFNpemUgfHwgZ2VvbWV0cnkucG9zaXRpb25zLmxlbmd0aCAhPT0gbWVzaERhdGEudmVydGV4U2l6ZSkge1xuICAgICAgICBtZXNoRGF0YS5pbmRleFNpemUgPSBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgbWVzaERhdGEudmVydGV4U2l6ZSA9IGdlb21ldHJ5LnBvc2l0aW9ucy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgYmF0Y2hhYmxlTWVzaCA9IHRoaXMuX2dldEJhdGNoYWJsZU1lc2gobWVzaCk7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gbWVzaC50ZXh0dXJlO1xuICAgICAgaWYgKGJhdGNoYWJsZU1lc2gudGV4dHVyZS5fc291cmNlICE9PSB0ZXh0dXJlLl9zb3VyY2UpIHtcbiAgICAgICAgaWYgKGJhdGNoYWJsZU1lc2gudGV4dHVyZS5fc291cmNlICE9PSB0ZXh0dXJlLl9zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gIWJhdGNoYWJsZU1lc2guYmF0Y2hlci5jaGVja0FuZFVwZGF0ZVRleHR1cmUoYmF0Y2hhYmxlTWVzaCwgdGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZFJlbmRlcmFibGUobWVzaCwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBiYXRjaGVyID0gdGhpcy5yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaDtcbiAgICBjb25zdCB7IGJhdGNoZWQgfSA9IHRoaXMuX2dldE1lc2hEYXRhKG1lc2gpO1xuICAgIGlmIChiYXRjaGVkKSB7XG4gICAgICBjb25zdCBncHVCYXRjaGFibGVNZXNoID0gdGhpcy5fZ2V0QmF0Y2hhYmxlTWVzaChtZXNoKTtcbiAgICAgIGdwdUJhdGNoYWJsZU1lc2gudGV4dHVyZSA9IG1lc2guX3RleHR1cmU7XG4gICAgICBncHVCYXRjaGFibGVNZXNoLmdlb21ldHJ5ID0gbWVzaC5fZ2VvbWV0cnk7XG4gICAgICBiYXRjaGVyLmFkZFRvQmF0Y2goZ3B1QmF0Y2hhYmxlTWVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhdGNoZXIuYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgICAgcmVuZGVyUGlwZUlkOiBcIm1lc2hcIixcbiAgICAgICAgbWVzaFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUobWVzaCkge1xuICAgIGlmIChtZXNoLmJhdGNoZWQpIHtcbiAgICAgIGNvbnN0IGdwdUJhdGNoYWJsZU1lc2ggPSB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFttZXNoLnVpZF07XG4gICAgICBncHVCYXRjaGFibGVNZXNoLnRleHR1cmUgPSBtZXNoLl90ZXh0dXJlO1xuICAgICAgZ3B1QmF0Y2hhYmxlTWVzaC5nZW9tZXRyeSA9IG1lc2guX2dlb21ldHJ5O1xuICAgICAgZ3B1QmF0Y2hhYmxlTWVzaC5iYXRjaGVyLnVwZGF0ZUVsZW1lbnQoZ3B1QmF0Y2hhYmxlTWVzaCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKG1lc2gpIHtcbiAgICB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdID0gbnVsbDtcbiAgICBjb25zdCBncHVNZXNoID0gdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbbWVzaC51aWRdO1xuICAgIGlmIChncHVNZXNoKSB7XG4gICAgICBCaWdQb29sLnJldHVybihncHVNZXNoKTtcbiAgICAgIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoW21lc2gudWlkXSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGV4ZWN1dGUoeyBtZXNoIH0pIHtcbiAgICBpZiAoIW1lc2guaXNSZW5kZXJhYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIG1lc2guc3RhdGUuYmxlbmRNb2RlID0gbWVzaC5ncm91cEJsZW5kTW9kZTtcbiAgICBjb25zdCBsb2NhbFVuaWZvcm1zID0gdGhpcy5sb2NhbFVuaWZvcm1zO1xuICAgIGxvY2FsVW5pZm9ybXMudW5pZm9ybXMudVRyYW5zZm9ybU1hdHJpeCA9IG1lc2guZ3JvdXBUcmFuc2Zvcm07XG4gICAgbG9jYWxVbmlmb3Jtcy51bmlmb3Jtcy51Um91bmQgPSB0aGlzLnJlbmRlcmVyLl9yb3VuZFBpeGVscyB8IG1lc2guX3JvdW5kUGl4ZWxzO1xuICAgIGxvY2FsVW5pZm9ybXMudXBkYXRlKCk7XG4gICAgY29sb3IzMkJpdFRvVW5pZm9ybShcbiAgICAgIG1lc2guZ3JvdXBDb2xvckFscGhhLFxuICAgICAgbG9jYWxVbmlmb3Jtcy51bmlmb3Jtcy51Q29sb3IsXG4gICAgICAwXG4gICAgKTtcbiAgICB0aGlzLl9hZGFwdG9yLmV4ZWN1dGUodGhpcywgbWVzaCk7XG4gIH1cbiAgX2dldE1lc2hEYXRhKG1lc2gpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVzaERhdGFIYXNoW21lc2gudWlkXSB8fCB0aGlzLl9pbml0TWVzaERhdGEobWVzaCk7XG4gIH1cbiAgX2luaXRNZXNoRGF0YShtZXNoKSB7XG4gICAgdGhpcy5fbWVzaERhdGFIYXNoW21lc2gudWlkXSA9IHtcbiAgICAgIGJhdGNoZWQ6IG1lc2guYmF0Y2hlZCxcbiAgICAgIGluZGV4U2l6ZTogbWVzaC5fZ2VvbWV0cnkuaW5kaWNlcz8ubGVuZ3RoLFxuICAgICAgdmVydGV4U2l6ZTogbWVzaC5fZ2VvbWV0cnkucG9zaXRpb25zPy5sZW5ndGhcbiAgICB9O1xuICAgIG1lc2gub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShtZXNoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fbWVzaERhdGFIYXNoW21lc2gudWlkXTtcbiAgfVxuICBfZ2V0QmF0Y2hhYmxlTWVzaChtZXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoW21lc2gudWlkXSB8fCB0aGlzLl9pbml0QmF0Y2hhYmxlTWVzaChtZXNoKTtcbiAgfVxuICBfaW5pdEJhdGNoYWJsZU1lc2gobWVzaCkge1xuICAgIGNvbnN0IGdwdU1lc2ggPSBCaWdQb29sLmdldChCYXRjaGFibGVNZXNoKTtcbiAgICBncHVNZXNoLm1lc2ggPSBtZXNoO1xuICAgIGdwdU1lc2gudGV4dHVyZSA9IG1lc2guX3RleHR1cmU7XG4gICAgZ3B1TWVzaC5yb3VuZFBpeGVscyA9IHRoaXMucmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgbWVzaC5fcm91bmRQaXhlbHM7XG4gICAgdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbbWVzaC51aWRdID0gZ3B1TWVzaDtcbiAgICBncHVNZXNoLm1lc2ggPSBtZXNoO1xuICAgIHJldHVybiBncHVNZXNoO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoKSB7XG4gICAgICBpZiAodGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbaV0pIHtcbiAgICAgICAgQmlnUG9vbC5yZXR1cm4odGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaCA9IG51bGw7XG4gICAgdGhpcy5fbWVzaERhdGFIYXNoID0gbnVsbDtcbiAgICB0aGlzLmxvY2FsVW5pZm9ybXMgPSBudWxsO1xuICAgIHRoaXMubG9jYWxVbmlmb3Jtc0JpbmRHcm91cCA9IG51bGw7XG4gICAgdGhpcy5fYWRhcHRvci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYWRhcHRvciA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5NZXNoUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwibWVzaFwiXG59O1xuXG5leHBvcnQgeyBNZXNoUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaFBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWVzaFBpcGUgfSBmcm9tICcuL3NoYXJlZC9NZXNoUGlwZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKE1lc2hQaXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8540\n')},2653:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   X: () => (/* binding */ BatchableMesh)\n/* harmony export */ });\n\nclass BatchableMesh {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  get blendMode() {\n    return this.mesh.groupBlendMode;\n  }\n  reset() {\n    this.mesh = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometry.indices;\n    for (let i = 0; i < indices.length; i++) {\n      indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const mesh = this.mesh;\n    const geometry = this.geometry;\n    const wt = mesh.groupTransform;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const positions = geometry.positions;\n    const uvBuffer = geometry.getBuffer("aUV");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    const abgr = mesh.groupColorAlpha;\n    for (let i = 0; i < positions.length; i += 2) {\n      const x = positions[i];\n      const y = positions[i + 1];\n      float32View[index] = a * x + c * y + tx;\n      float32View[index + 1] = b * x + d * y + ty;\n      float32View[index + 2] = transformedUvs[i];\n      float32View[index + 3] = transformedUvs[i + 1];\n      uint32View[index + 4] = abgr;\n      uint32View[index + 5] = textureIdAndRound;\n      index += 6;\n    }\n  }\n  get vertexSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\n\n//# sourceMappingURL=BatchableMesh.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY1My5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvbWVzaC9zaGFyZWQvQmF0Y2hhYmxlTWVzaC5tanM/MzM2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJhdGNoYWJsZU1lc2gge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJhdGNoZXIgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2ggPSBudWxsO1xuICAgIHRoaXMucm91bmRQaXhlbHMgPSAwO1xuICAgIHRoaXMuX3V2VXBkYXRlSWQgPSAtMTtcbiAgICB0aGlzLl90ZXh0dXJlTWF0cml4VXBkYXRlSWQgPSAtMTtcbiAgfVxuICBnZXQgYmxlbmRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm1lc2guZ3JvdXBCbGVuZE1vZGU7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5tZXNoID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hlciA9IG51bGw7XG4gICAgdGhpcy5iYXRjaCA9IG51bGw7XG4gIH1cbiAgcGFja0luZGV4KGluZGV4QnVmZmVyLCBpbmRleCwgaW5kaWNlc09mZnNldCkge1xuICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLmdlb21ldHJ5LmluZGljZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbmRleEJ1ZmZlcltpbmRleCsrXSA9IGluZGljZXNbaV0gKyBpbmRpY2VzT2Zmc2V0O1xuICAgIH1cbiAgfVxuICBwYWNrQXR0cmlidXRlcyhmbG9hdDMyVmlldywgdWludDMyVmlldywgaW5kZXgsIHRleHR1cmVJZCkge1xuICAgIGNvbnN0IG1lc2ggPSB0aGlzLm1lc2g7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IHd0ID0gbWVzaC5ncm91cFRyYW5zZm9ybTtcbiAgICBjb25zdCB0ZXh0dXJlSWRBbmRSb3VuZCA9IHRleHR1cmVJZCA8PCAxNiB8IHRoaXMucm91bmRQaXhlbHMgJiA2NTUzNTtcbiAgICBjb25zdCBhID0gd3QuYTtcbiAgICBjb25zdCBiID0gd3QuYjtcbiAgICBjb25zdCBjID0gd3QuYztcbiAgICBjb25zdCBkID0gd3QuZDtcbiAgICBjb25zdCB0eCA9IHd0LnR4O1xuICAgIGNvbnN0IHR5ID0gd3QudHk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkucG9zaXRpb25zO1xuICAgIGNvbnN0IHV2QnVmZmVyID0gZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVVWXCIpO1xuICAgIGNvbnN0IHV2cyA9IHV2QnVmZmVyLmRhdGE7XG4gICAgbGV0IHRyYW5zZm9ybWVkVXZzID0gdXZzO1xuICAgIGNvbnN0IHRleHR1cmVNYXRyaXggPSB0aGlzLnRleHR1cmUudGV4dHVyZU1hdHJpeDtcbiAgICBpZiAoIXRleHR1cmVNYXRyaXguaXNTaW1wbGUpIHtcbiAgICAgIHRyYW5zZm9ybWVkVXZzID0gdGhpcy5fdHJhbnNmb3JtZWRVdnM7XG4gICAgICBpZiAodGhpcy5fdGV4dHVyZU1hdHJpeFVwZGF0ZUlkICE9PSB0ZXh0dXJlTWF0cml4Ll91cGRhdGVJRCB8fCB0aGlzLl91dlVwZGF0ZUlkICE9PSB1dkJ1ZmZlci5fdXBkYXRlSUQpIHtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1lZFV2cyB8fCB0cmFuc2Zvcm1lZFV2cy5sZW5ndGggPCB1dnMubGVuZ3RoKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWRVdnMgPSB0aGlzLl90cmFuc2Zvcm1lZFV2cyA9IG5ldyBGbG9hdDMyQXJyYXkodXZzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGV4dHVyZU1hdHJpeFVwZGF0ZUlkID0gdGV4dHVyZU1hdHJpeC5fdXBkYXRlSUQ7XG4gICAgICAgIHRoaXMuX3V2VXBkYXRlSWQgPSB1dkJ1ZmZlci5fdXBkYXRlSUQ7XG4gICAgICAgIHRleHR1cmVNYXRyaXgubXVsdGlwbHlVdnModXZzLCB0cmFuc2Zvcm1lZFV2cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFiZ3IgPSBtZXNoLmdyb3VwQ29sb3JBbHBoYTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgIGNvbnN0IHkgPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgZmxvYXQzMlZpZXdbaW5kZXhdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxXSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMl0gPSB0cmFuc2Zvcm1lZFV2c1tpXTtcbiAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgM10gPSB0cmFuc2Zvcm1lZFV2c1tpICsgMV07XG4gICAgICB1aW50MzJWaWV3W2luZGV4ICsgNF0gPSBhYmdyO1xuICAgICAgdWludDMyVmlld1tpbmRleCArIDVdID0gdGV4dHVyZUlkQW5kUm91bmQ7XG4gICAgICBpbmRleCArPSA2O1xuICAgIH1cbiAgfVxuICBnZXQgdmVydGV4U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5wb3NpdGlvbnMubGVuZ3RoIC8gMjtcbiAgfVxuICBnZXQgaW5kZXhTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmluZGljZXMubGVuZ3RoO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoYWJsZU1lc2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoYWJsZU1lc2gubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2653\n')},4428:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   x: () => (/* binding */ MeshGeometry)\n/* harmony export */ });\n/* harmony import */ var _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7494);\n/* harmony import */ var _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5324);\n/* harmony import */ var _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1980);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(156);\n\n\n\n\n\n"use strict";\nconst _MeshGeometry = class _MeshGeometry extends _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .Z {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .v8_0_0 */ .P, "use new MeshGeometry({ positions, uvs, indices }) instead");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: positions,\n      label: "attribute-mesh-positions",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    const uvBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: uvs,\n      label: "attribute-mesh-uvs",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    const indexBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .l({\n      data: indices,\n      label: "index-mesh-buffer",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.INDEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .F.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: "float32x2",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: "float32x2",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = "auto";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: "triangle-list",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\n\n//# sourceMappingURL=MeshGeometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStFO0FBQ0k7QUFDRTtBQUNSOztBQUU3RTtBQUNBLGtEQUFrRCxnR0FBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9GQUFXLENBQUMsMkVBQU0sMEJBQTBCLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEZBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxVQUFVLDhGQUFXO0FBQzdDLEtBQUs7QUFDTCx5QkFBeUIsMEZBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxVQUFVLDhGQUFXO0FBQzdDLEtBQUs7QUFDTCw0QkFBNEIsMEZBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxTQUFTLDhGQUFXO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvbWVzaC9zaGFyZWQvTWVzaEdlb21ldHJ5Lm1qcz82Y2Q5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IEJ1ZmZlclVzYWdlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9NZXNoR2VvbWV0cnkgPSBjbGFzcyBfTWVzaEdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmdzWzBdID8/IHt9O1xuICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwidXNlIG5ldyBNZXNoR2VvbWV0cnkoeyBwb3NpdGlvbnMsIHV2cywgaW5kaWNlcyB9KSBpbnN0ZWFkXCIpO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcG9zaXRpb25zOiBvcHRpb25zLFxuICAgICAgICB1dnM6IGFyZ3NbMV0sXG4gICAgICAgIGluZGljZXM6IGFyZ3NbMl1cbiAgICAgIH07XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7IC4uLl9NZXNoR2VvbWV0cnkuZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBvcHRpb25zLnBvc2l0aW9ucyB8fCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSk7XG4gICAgY29uc3QgdXZzID0gb3B0aW9ucy51dnMgfHwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pO1xuICAgIGNvbnN0IGluZGljZXMgPSBvcHRpb25zLmluZGljZXMgfHwgbmV3IFVpbnQzMkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSk7XG4gICAgY29uc3Qgc2hyaW5rVG9GaXQgPSBvcHRpb25zLnNocmlua0J1ZmZlcnNUb0ZpdDtcbiAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogcG9zaXRpb25zLFxuICAgICAgbGFiZWw6IFwiYXR0cmlidXRlLW1lc2gtcG9zaXRpb25zXCIsXG4gICAgICBzaHJpbmtUb0ZpdCxcbiAgICAgIHVzYWdlOiBCdWZmZXJVc2FnZS5WRVJURVggfCBCdWZmZXJVc2FnZS5DT1BZX0RTVFxuICAgIH0pO1xuICAgIGNvbnN0IHV2QnVmZmVyID0gbmV3IEJ1ZmZlcih7XG4gICAgICBkYXRhOiB1dnMsXG4gICAgICBsYWJlbDogXCJhdHRyaWJ1dGUtbWVzaC11dnNcIixcbiAgICAgIHNocmlua1RvRml0LFxuICAgICAgdXNhZ2U6IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgfSk7XG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IGluZGljZXMsXG4gICAgICBsYWJlbDogXCJpbmRleC1tZXNoLWJ1ZmZlclwiLFxuICAgICAgc2hyaW5rVG9GaXQsXG4gICAgICB1c2FnZTogQnVmZmVyVXNhZ2UuSU5ERVggfCBCdWZmZXJVc2FnZS5DT1BZX0RTVFxuICAgIH0pO1xuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgYVBvc2l0aW9uOiB7XG4gICAgICAgICAgYnVmZmVyOiBwb3NpdGlvbkJ1ZmZlcixcbiAgICAgICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICAgICAgc3RyaWRlOiAyICogNCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgYVVWOiB7XG4gICAgICAgICAgYnVmZmVyOiB1dkJ1ZmZlcixcbiAgICAgICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICAgICAgc3RyaWRlOiAyICogNCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluZGV4QnVmZmVyLFxuICAgICAgdG9wb2xvZ3k6IG9wdGlvbnMudG9wb2xvZ3lcbiAgICB9KTtcbiAgICB0aGlzLmJhdGNoTW9kZSA9IFwiYXV0b1wiO1xuICB9XG4gIC8qKiBUaGUgcG9zaXRpb25zIG9mIHRoZSBtZXNoLiAqL1xuICBnZXQgcG9zaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuYVBvc2l0aW9uLmJ1ZmZlci5kYXRhO1xuICB9XG4gIHNldCBwb3NpdGlvbnModmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXMuYVBvc2l0aW9uLmJ1ZmZlci5kYXRhID0gdmFsdWU7XG4gIH1cbiAgLyoqIFRoZSBVVnMgb2YgdGhlIG1lc2guICovXG4gIGdldCB1dnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5hVVYuYnVmZmVyLmRhdGE7XG4gIH1cbiAgc2V0IHV2cyh2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlcy5hVVYuYnVmZmVyLmRhdGEgPSB2YWx1ZTtcbiAgfVxuICAvKiogVGhlIGluZGljZXMgb2YgdGhlIG1lc2guICovXG4gIGdldCBpbmRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4QnVmZmVyLmRhdGE7XG4gIH1cbiAgc2V0IGluZGljZXModmFsdWUpIHtcbiAgICB0aGlzLmluZGV4QnVmZmVyLmRhdGEgPSB2YWx1ZTtcbiAgfVxufTtcbl9NZXNoR2VvbWV0cnkuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHRvcG9sb2d5OiBcInRyaWFuZ2xlLWxpc3RcIixcbiAgc2hyaW5rQnVmZmVyc1RvRml0OiBmYWxzZVxufTtcbmxldCBNZXNoR2VvbWV0cnkgPSBfTWVzaEdlb21ldHJ5O1xuXG5leHBvcnQgeyBNZXNoR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hHZW9tZXRyeS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4428\n')},2092:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs\nvar MeshGeometry = __webpack_require__(4428);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs\n\n\n\n"use strict";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry/* MeshGeometry */.x {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === "number") {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\n\n//# sourceMappingURL=PlaneGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs\n\n\n"use strict";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const positions = this.positions;\n    const w = this._leftWidth + this._rightWidth;\n    const scaleW = this.width > w ? 1 : this.width / w;\n    const h = this._topHeight + this._bottomHeight;\n    const scaleH = this.height > h ? 1 : this.height / h;\n    const scale = Math.min(scaleW, scaleH);\n    positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n    positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;\n    positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n    positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n    positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;\n    positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n    this.getBuffer("aPosition").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer("aUV").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\n\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs\n\n\n\n\n\n"use strict";\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, _instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite.batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const texture = sprite._texture;\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (gpuSprite.texture._source !== texture._source) {\n      return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n    }\n    return false;\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    PoolGroup/* BigPool */.u.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    sprite._didSpriteUpdate = false;\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableMesh = new BatchableMesh/* BatchableMesh */.X();\n    batchableMesh.geometry = new NineSliceGeometry();\n    batchableMesh.mesh = sprite;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableMesh;\n    sprite.on("destroyed", () => {\n      this.destroyRenderable(sprite);\n    });\n    return batchableMesh;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      const batchableMesh = this._gpuSpriteHash[i];\n      batchableMesh.geometry.destroy();\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "nineSliceSprite"\n};\n\n\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMEU7QUFDWDs7QUFFL0Q7QUFDQSxvREFBb0QsZ0NBQVk7QUFDaEU7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLE1BQU0sa0NBQVcsQ0FBQyx5QkFBTSxrREFBa0Qsc0NBQXNDO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QjtBQUN6Qjs7O0FDN0VnRTs7QUFFaEU7QUFDQSw0REFBNEQsYUFBYTtBQUN6RSwwQkFBMEI7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCOzs7QUNwRmdFO0FBQ1A7QUFDUTtBQUNMOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFhO0FBQzNDLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRStCO0FBQy9COzs7QUM1RTZEO0FBQ0c7O0FBRWhFO0FBQ0EsNkJBQVUsS0FBSyxtQkFBbUI7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL21lc2gtcGxhbmUvUGxhbmVHZW9tZXRyeS5tanM/N2I3ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS1uaW5lLXNsaWNlL05pbmVTbGljZUdlb21ldHJ5Lm1qcz8wYjJhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvTmluZVNsaWNlU3ByaXRlUGlwZS5tanM/NTBlMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS1uaW5lLXNsaWNlL2luaXQubWpzPzAzNWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IE1lc2hHZW9tZXRyeSB9IGZyb20gJy4uL21lc2gvc2hhcmVkL01lc2hHZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9QbGFuZUdlb21ldHJ5ID0gY2xhc3MgX1BsYW5lR2VvbWV0cnkgZXh0ZW5kcyBNZXNoR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoe30pO1xuICAgIGxldCBvcHRpb25zID0gYXJnc1swXSA/PyB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJQbGFuZUdlb21ldHJ5IGNvbnN0cnVjdG9yIGNoYW5nZWQgcGxlYXNlIHVzZSB7IHdpZHRoLCBoZWlnaHQsIHZlcnRpY2VzWCwgdmVydGljZXNZIH0gaW5zdGVhZFwiKTtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHdpZHRoOiBvcHRpb25zLFxuICAgICAgICBoZWlnaHQ6IGFyZ3NbMV0sXG4gICAgICAgIHZlcnRpY2VzWDogYXJnc1syXSxcbiAgICAgICAgdmVydGljZXNZOiBhcmdzWzNdXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmJ1aWxkKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgcGxhbmUgY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGJlIGFwcGxpZWQgdG8gcGxhbmUgZ2VvbWV0cnlcbiAgICovXG4gIGJ1aWxkKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fUGxhbmVHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMudmVydGljZXNYID0gdGhpcy52ZXJ0aWNlc1ggPz8gb3B0aW9ucy52ZXJ0aWNlc1g7XG4gICAgdGhpcy52ZXJ0aWNlc1kgPSB0aGlzLnZlcnRpY2VzWSA/PyBvcHRpb25zLnZlcnRpY2VzWTtcbiAgICB0aGlzLndpZHRoID0gdGhpcy53aWR0aCA/PyBvcHRpb25zLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgPz8gb3B0aW9ucy5oZWlnaHQ7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLnZlcnRpY2VzWCAqIHRoaXMudmVydGljZXNZO1xuICAgIGNvbnN0IHZlcnRzID0gW107XG4gICAgY29uc3QgdXZzID0gW107XG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IHZlcnRpY2VzWCA9IHRoaXMudmVydGljZXNYIC0gMTtcbiAgICBjb25zdCB2ZXJ0aWNlc1kgPSB0aGlzLnZlcnRpY2VzWSAtIDE7XG4gICAgY29uc3Qgc2l6ZVggPSB0aGlzLndpZHRoIC8gdmVydGljZXNYO1xuICAgIGNvbnN0IHNpemVZID0gdGhpcy5oZWlnaHQgLyB2ZXJ0aWNlc1k7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAlIHRoaXMudmVydGljZXNYO1xuICAgICAgY29uc3QgeSA9IGkgLyB0aGlzLnZlcnRpY2VzWCB8IDA7XG4gICAgICB2ZXJ0cy5wdXNoKHggKiBzaXplWCwgeSAqIHNpemVZKTtcbiAgICAgIHV2cy5wdXNoKHggLyB2ZXJ0aWNlc1gsIHkgLyB2ZXJ0aWNlc1kpO1xuICAgIH1cbiAgICBjb25zdCB0b3RhbFN1YiA9IHZlcnRpY2VzWCAqIHZlcnRpY2VzWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsU3ViOyBpKyspIHtcbiAgICAgIGNvbnN0IHhwb3MgPSBpICUgdmVydGljZXNYO1xuICAgICAgY29uc3QgeXBvcyA9IGkgLyB2ZXJ0aWNlc1ggfCAwO1xuICAgICAgY29uc3QgdmFsdWUgPSB5cG9zICogdGhpcy52ZXJ0aWNlc1ggKyB4cG9zO1xuICAgICAgY29uc3QgdmFsdWUyID0geXBvcyAqIHRoaXMudmVydGljZXNYICsgeHBvcyArIDE7XG4gICAgICBjb25zdCB2YWx1ZTMgPSAoeXBvcyArIDEpICogdGhpcy52ZXJ0aWNlc1ggKyB4cG9zO1xuICAgICAgY29uc3QgdmFsdWU0ID0gKHlwb3MgKyAxKSAqIHRoaXMudmVydGljZXNYICsgeHBvcyArIDE7XG4gICAgICBpbmRpY2VzLnB1c2goXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZTIsXG4gICAgICAgIHZhbHVlMyxcbiAgICAgICAgdmFsdWUyLFxuICAgICAgICB2YWx1ZTQsXG4gICAgICAgIHZhbHVlM1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJzWzBdLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRzKTtcbiAgICB0aGlzLmJ1ZmZlcnNbMV0uZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodXZzKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyLmRhdGEgPSBuZXcgVWludDMyQXJyYXkoaW5kaWNlcyk7XG4gICAgdGhpcy5idWZmZXJzWzBdLnVwZGF0ZSgpO1xuICAgIHRoaXMuYnVmZmVyc1sxXS51cGRhdGUoKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyLnVwZGF0ZSgpO1xuICB9XG59O1xuX1BsYW5lR2VvbWV0cnkuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHdpZHRoOiAxMDAsXG4gIGhlaWdodDogMTAwLFxuICB2ZXJ0aWNlc1g6IDEwLFxuICB2ZXJ0aWNlc1k6IDEwXG59O1xubGV0IFBsYW5lR2VvbWV0cnkgPSBfUGxhbmVHZW9tZXRyeTtcblxuZXhwb3J0IHsgUGxhbmVHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGxhbmVHZW9tZXRyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBQbGFuZUdlb21ldHJ5IH0gZnJvbSAnLi4vbWVzaC1wbGFuZS9QbGFuZUdlb21ldHJ5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX05pbmVTbGljZUdlb21ldHJ5ID0gY2xhc3MgX05pbmVTbGljZUdlb21ldHJ5IGV4dGVuZHMgUGxhbmVHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7IC4uLl9OaW5lU2xpY2VHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHN1cGVyKHtcbiAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoLFxuICAgICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCxcbiAgICAgIHZlcnRpY2VzWDogNCxcbiAgICAgIHZlcnRpY2VzWTogNFxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBOaW5lU2xpY2VHZW9tZXRyeSB3aXRoIHRoZSBvcHRpb25zLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9mIHRoZSBOaW5lU2xpY2VHZW9tZXRyeS5cbiAgICovXG4gIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGggPz8gdGhpcy53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ID8/IHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuX29yaWdpbmFsV2lkdGggPSBvcHRpb25zLm9yaWdpbmFsV2lkdGggPz8gdGhpcy5fb3JpZ2luYWxXaWR0aDtcbiAgICB0aGlzLl9vcmlnaW5hbEhlaWdodCA9IG9wdGlvbnMub3JpZ2luYWxIZWlnaHQgPz8gdGhpcy5fb3JpZ2luYWxIZWlnaHQ7XG4gICAgdGhpcy5fbGVmdFdpZHRoID0gb3B0aW9ucy5sZWZ0V2lkdGggPz8gdGhpcy5fbGVmdFdpZHRoO1xuICAgIHRoaXMuX3JpZ2h0V2lkdGggPSBvcHRpb25zLnJpZ2h0V2lkdGggPz8gdGhpcy5fcmlnaHRXaWR0aDtcbiAgICB0aGlzLl90b3BIZWlnaHQgPSBvcHRpb25zLnRvcEhlaWdodCA/PyB0aGlzLl90b3BIZWlnaHQ7XG4gICAgdGhpcy5fYm90dG9tSGVpZ2h0ID0gb3B0aW9ucy5ib3R0b21IZWlnaHQgPz8gdGhpcy5fYm90dG9tSGVpZ2h0O1xuICAgIHRoaXMudXBkYXRlVXZzKCk7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbnMoKTtcbiAgfVxuICAvKiogVXBkYXRlcyB0aGUgcG9zaXRpb25zIG9mIHRoZSB2ZXJ0aWNlcy4gKi9cbiAgdXBkYXRlUG9zaXRpb25zKCkge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMucG9zaXRpb25zO1xuICAgIGNvbnN0IHcgPSB0aGlzLl9sZWZ0V2lkdGggKyB0aGlzLl9yaWdodFdpZHRoO1xuICAgIGNvbnN0IHNjYWxlVyA9IHRoaXMud2lkdGggPiB3ID8gMSA6IHRoaXMud2lkdGggLyB3O1xuICAgIGNvbnN0IGggPSB0aGlzLl90b3BIZWlnaHQgKyB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVIID0gdGhpcy5oZWlnaHQgPiBoID8gMSA6IHRoaXMuaGVpZ2h0IC8gaDtcbiAgICBjb25zdCBzY2FsZSA9IE1hdGgubWluKHNjYWxlVywgc2NhbGVIKTtcbiAgICBwb3NpdGlvbnNbOV0gPSBwb3NpdGlvbnNbMTFdID0gcG9zaXRpb25zWzEzXSA9IHBvc2l0aW9uc1sxNV0gPSB0aGlzLl90b3BIZWlnaHQgKiBzY2FsZTtcbiAgICBwb3NpdGlvbnNbMTddID0gcG9zaXRpb25zWzE5XSA9IHBvc2l0aW9uc1syMV0gPSBwb3NpdGlvbnNbMjNdID0gdGhpcy5oZWlnaHQgLSB0aGlzLl9ib3R0b21IZWlnaHQgKiBzY2FsZTtcbiAgICBwb3NpdGlvbnNbMjVdID0gcG9zaXRpb25zWzI3XSA9IHBvc2l0aW9uc1syOV0gPSBwb3NpdGlvbnNbMzFdID0gdGhpcy5oZWlnaHQ7XG4gICAgcG9zaXRpb25zWzJdID0gcG9zaXRpb25zWzEwXSA9IHBvc2l0aW9uc1sxOF0gPSBwb3NpdGlvbnNbMjZdID0gdGhpcy5fbGVmdFdpZHRoICogc2NhbGU7XG4gICAgcG9zaXRpb25zWzRdID0gcG9zaXRpb25zWzEyXSA9IHBvc2l0aW9uc1syMF0gPSBwb3NpdGlvbnNbMjhdID0gdGhpcy53aWR0aCAtIHRoaXMuX3JpZ2h0V2lkdGggKiBzY2FsZTtcbiAgICBwb3NpdGlvbnNbNl0gPSBwb3NpdGlvbnNbMTRdID0gcG9zaXRpb25zWzIyXSA9IHBvc2l0aW9uc1szMF0gPSB0aGlzLndpZHRoO1xuICAgIHRoaXMuZ2V0QnVmZmVyKFwiYVBvc2l0aW9uXCIpLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBVVnMgb2YgdGhlIHZlcnRpY2VzLiAqL1xuICB1cGRhdGVVdnMoKSB7XG4gICAgY29uc3QgdXZzID0gdGhpcy51dnM7XG4gICAgdXZzWzBdID0gdXZzWzhdID0gdXZzWzE2XSA9IHV2c1syNF0gPSAwO1xuICAgIHV2c1sxXSA9IHV2c1szXSA9IHV2c1s1XSA9IHV2c1s3XSA9IDA7XG4gICAgdXZzWzZdID0gdXZzWzE0XSA9IHV2c1syMl0gPSB1dnNbMzBdID0gMTtcbiAgICB1dnNbMjVdID0gdXZzWzI3XSA9IHV2c1syOV0gPSB1dnNbMzFdID0gMTtcbiAgICBjb25zdCBfdXZ3ID0gMSAvIHRoaXMuX29yaWdpbmFsV2lkdGg7XG4gICAgY29uc3QgX3V2aCA9IDEgLyB0aGlzLl9vcmlnaW5hbEhlaWdodDtcbiAgICB1dnNbMl0gPSB1dnNbMTBdID0gdXZzWzE4XSA9IHV2c1syNl0gPSBfdXZ3ICogdGhpcy5fbGVmdFdpZHRoO1xuICAgIHV2c1s5XSA9IHV2c1sxMV0gPSB1dnNbMTNdID0gdXZzWzE1XSA9IF91dmggKiB0aGlzLl90b3BIZWlnaHQ7XG4gICAgdXZzWzRdID0gdXZzWzEyXSA9IHV2c1syMF0gPSB1dnNbMjhdID0gMSAtIF91dncgKiB0aGlzLl9yaWdodFdpZHRoO1xuICAgIHV2c1sxN10gPSB1dnNbMTldID0gdXZzWzIxXSA9IHV2c1syM10gPSAxIC0gX3V2aCAqIHRoaXMuX2JvdHRvbUhlaWdodDtcbiAgICB0aGlzLmdldEJ1ZmZlcihcImFVVlwiKS51cGRhdGUoKTtcbiAgfVxufTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgTmluZVNsaWNlR2VvbWV0cnkuICovXG5fTmluZVNsaWNlR2VvbWV0cnkuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIE5pbmVTbGljZVBsYW5lLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHZlcnRpY2VzIGFuZCBVVidzIG9mIHRoaXMgcGxhbmUuICovXG4gIHdpZHRoOiAxMDAsXG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBOaW5lU2xpY2VQbGFuZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSB2ZXJ0aWNlcyBhbmQgVVYncyBvZiB0aGlzIHBsYW5lLiAqL1xuICBoZWlnaHQ6IDEwMCxcbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgbGVmdCBjb2x1bW4uICovXG4gIGxlZnRXaWR0aDogMTAsXG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSB0b3Agcm93LiAqL1xuICB0b3BIZWlnaHQ6IDEwLFxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSByaWdodCBjb2x1bW4uICovXG4gIHJpZ2h0V2lkdGg6IDEwLFxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgYm90dG9tIHJvdy4gKi9cbiAgYm90dG9tSGVpZ2h0OiAxMCxcbiAgLyoqIFRoZSBvcmlnaW5hbCB3aWR0aCBvZiB0aGUgdGV4dHVyZSAqL1xuICBvcmlnaW5hbFdpZHRoOiAxMDAsXG4gIC8qKiBUaGUgb3JpZ2luYWwgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlICovXG4gIG9yaWdpbmFsSGVpZ2h0OiAxMDBcbn07XG5sZXQgTmluZVNsaWNlR2VvbWV0cnkgPSBfTmluZVNsaWNlR2VvbWV0cnk7XG5cbmV4cG9ydCB7IE5pbmVTbGljZUdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OaW5lU2xpY2VHZW9tZXRyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBCaWdQb29sIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9vbC9Qb29sR3JvdXAubWpzJztcbmltcG9ydCB7IEJhdGNoYWJsZU1lc2ggfSBmcm9tICcuLi9tZXNoL3NoYXJlZC9CYXRjaGFibGVNZXNoLm1qcyc7XG5pbXBvcnQgeyBOaW5lU2xpY2VHZW9tZXRyeSB9IGZyb20gJy4vTmluZVNsaWNlR2VvbWV0cnkubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBOaW5lU2xpY2VTcHJpdGVQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBhZGRSZW5kZXJhYmxlKHNwcml0ZSwgX2luc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgZ3B1U3ByaXRlID0gdGhpcy5fZ2V0R3B1U3ByaXRlKHNwcml0ZSk7XG4gICAgaWYgKHNwcml0ZS5fZGlkU3ByaXRlVXBkYXRlKVxuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hhYmxlU3ByaXRlKHNwcml0ZSwgZ3B1U3ByaXRlKTtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5hZGRUb0JhdGNoKGdwdVNwcml0ZSk7XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShzcHJpdGUpIHtcbiAgICBjb25zdCBncHVTcHJpdGUgPSB0aGlzLl9ncHVTcHJpdGVIYXNoW3Nwcml0ZS51aWRdO1xuICAgIGlmIChzcHJpdGUuX2RpZFNwcml0ZVVwZGF0ZSlcbiAgICAgIHRoaXMuX3VwZGF0ZUJhdGNoYWJsZVNwcml0ZShzcHJpdGUsIGdwdVNwcml0ZSk7XG4gICAgZ3B1U3ByaXRlLmJhdGNoZXIudXBkYXRlRWxlbWVudChncHVTcHJpdGUpO1xuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZShzcHJpdGUpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuICAgIGNvbnN0IGdwdVNwcml0ZSA9IHRoaXMuX2dldEdwdVNwcml0ZShzcHJpdGUpO1xuICAgIGlmIChncHVTcHJpdGUudGV4dHVyZS5fc291cmNlICE9PSB0ZXh0dXJlLl9zb3VyY2UpIHtcbiAgICAgIHJldHVybiAhZ3B1U3ByaXRlLmJhdGNoZXIuY2hlY2tBbmRVcGRhdGVUZXh0dXJlKGdwdVNwcml0ZSwgdGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZXN0cm95UmVuZGVyYWJsZShzcHJpdGUpIHtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSB0aGlzLl9ncHVTcHJpdGVIYXNoW3Nwcml0ZS51aWRdO1xuICAgIEJpZ1Bvb2wucmV0dXJuKGJhdGNoYWJsZVNwcml0ZSk7XG4gICAgdGhpcy5fZ3B1U3ByaXRlSGFzaFtzcHJpdGUudWlkXSA9IG51bGw7XG4gIH1cbiAgX3VwZGF0ZUJhdGNoYWJsZVNwcml0ZShzcHJpdGUsIGJhdGNoYWJsZVNwcml0ZSkge1xuICAgIHNwcml0ZS5fZGlkU3ByaXRlVXBkYXRlID0gZmFsc2U7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLmdlb21ldHJ5LnVwZGF0ZShzcHJpdGUpO1xuICAgIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuICB9XG4gIF9nZXRHcHVTcHJpdGUoc3ByaXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF0gfHwgdGhpcy5faW5pdEdQVVNwcml0ZShzcHJpdGUpO1xuICB9XG4gIF9pbml0R1BVU3ByaXRlKHNwcml0ZSkge1xuICAgIGNvbnN0IGJhdGNoYWJsZU1lc2ggPSBuZXcgQmF0Y2hhYmxlTWVzaCgpO1xuICAgIGJhdGNoYWJsZU1lc2guZ2VvbWV0cnkgPSBuZXcgTmluZVNsaWNlR2VvbWV0cnkoKTtcbiAgICBiYXRjaGFibGVNZXNoLm1lc2ggPSBzcHJpdGU7XG4gICAgYmF0Y2hhYmxlTWVzaC50ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuICAgIGJhdGNoYWJsZU1lc2gucm91bmRQaXhlbHMgPSB0aGlzLl9yZW5kZXJlci5fcm91bmRQaXhlbHMgfCBzcHJpdGUuX3JvdW5kUGl4ZWxzO1xuICAgIHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF0gPSBiYXRjaGFibGVNZXNoO1xuICAgIHNwcml0ZS5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3lSZW5kZXJhYmxlKHNwcml0ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJhdGNoYWJsZU1lc2g7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fZ3B1U3ByaXRlSGFzaCkge1xuICAgICAgY29uc3QgYmF0Y2hhYmxlTWVzaCA9IHRoaXMuX2dwdVNwcml0ZUhhc2hbaV07XG4gICAgICBiYXRjaGFibGVNZXNoLmdlb21ldHJ5LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5fZ3B1U3ByaXRlSGFzaCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuTmluZVNsaWNlU3ByaXRlUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwibmluZVNsaWNlU3ByaXRlXCJcbn07XG5cbmV4cG9ydCB7IE5pbmVTbGljZVNwcml0ZVBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5pbmVTbGljZVNwcml0ZVBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTmluZVNsaWNlU3ByaXRlUGlwZSB9IGZyb20gJy4vTmluZVNsaWNlU3ByaXRlUGlwZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKE5pbmVTbGljZVNwcml0ZVBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2092\n')},1015:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(6798);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9989);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2653);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs\nvar MeshGeometry = __webpack_require__(4428);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(8157);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs\nvar localUniformBit = __webpack_require__(8070);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(9637);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(2267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(4537);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs\n\nconst tilingBit = {\n  name: "tiling-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: "tiling-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=tilingBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader/* Shader */.e {\n  constructor() {\n    gpuProgram ?? (gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "tiling-sprite-shader",\n      bits: [\n        localUniformBit/* localUniformBit */.XH,\n        tilingBit,\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    }));\n    glProgram ?? (glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "tiling-sprite-shader",\n      bits: [\n        localUniformBit/* localUniformBitGl */.$g,\n        tilingBitGl,\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    }));\n    const tilingUniforms = new UniformGroup/* UniformGroup */.o({\n      uMapCoord: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },\n      uTextureTransform: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup/* UniformGroup */.o({\n          uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n          uRound: { value: 0, type: "f32" }\n        }),\n        tilingUniforms,\n        uTexture: Texture/* Texture */.x.EMPTY.source,\n        uSampler: Texture/* Texture */.x.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\n\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs\n\n\n"use strict";\nclass QuadGeometry extends MeshGeometry/* MeshGeometry */.x {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\n\n//# sourceMappingURL=QuadGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs\n\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\n\n//# sourceMappingURL=setPositions.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs\n\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\n\n//# sourceMappingURL=applyMatrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs\n\n\n\n"use strict";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite._applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix/* Matrix */.y.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\n\n//# sourceMappingURL=setUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (batchableMesh.texture._source !== renderable.texture._source) {\n        return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n      }\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh/* BatchableMesh */.X());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite._didTilingSpriteUpdate) {\n        tilingSprite._didTilingSpriteUpdate = false;\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.mesh = tilingSprite;\n        batchableMesh.texture = tilingSprite._texture;\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: State/* State */.Z.default2d\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite._didTilingSpriteUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh.batcher.updateElement(batchableMesh);\n    } else if (tilingSprite._didTilingSpriteUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n    tilingSprite._didTilingSpriteUpdate = false;\n  }\n  destroyRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    tilingSpriteData.batchableMesh = null;\n    tilingSpriteData.shader?.destroy();\n    this._tilingSpriteDataHash[tilingSprite.uid] = null;\n  }\n  _getTilingSpriteData(renderable) {\n    return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const geometry = new MeshGeometry/* MeshGeometry */.x({\n      indices: sharedQuad.indices,\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n    this._tilingSpriteDataHash[tilingSprite.uid] = {\n      canBatch: true,\n      renderable: tilingSprite,\n      geometry\n    };\n    tilingSprite.on("destroyed", () => {\n      this.destroyRenderable(tilingSprite);\n    });\n    return this._tilingSpriteDataHash[tilingSprite.uid];\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== "repeat") {\n      style.addressMode = "repeat";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    for (const i in this._tilingSpriteDataHash) {\n      this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n    }\n    this._tilingSpriteDataHash = null;\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === types/* RendererType */.g.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "tilingSprite"\n};\n\n\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUU0QjtBQUM1Qjs7O0FDOUo2RDtBQUNIOztBQUUxRDtBQUNBLDZCQUFVLEtBQUssZ0JBQWdCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL3NoYWRlci90aWxpbmdCaXQubWpzP2I3MzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL3NoYWRlci9UaWxpbmdTcHJpdGVTaGFkZXIubWpzPzgwMmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL1F1YWRHZW9tZXRyeS5tanM/YTcwNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvdXRpbHMvc2V0UG9zaXRpb25zLm1qcz81NGVhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLXRpbGluZy91dGlscy9hcHBseU1hdHJpeC5tanM/OWI5MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvdXRpbHMvc2V0VXZzLm1qcz9iMjhlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLXRpbGluZy9UaWxpbmdTcHJpdGVQaXBlLm1qcz9jN2RlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLXRpbGluZy9pbml0Lm1qcz9kMWY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdGlsaW5nQml0ID0ge1xuICBuYW1lOiBcInRpbGluZy1iaXRcIixcbiAgdmVydGV4OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICBzdHJ1Y3QgVGlsaW5nVW5pZm9ybXMge1xuICAgICAgICAgICAgICAgIHVNYXBDb29yZDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1Q2xhbXBGcmFtZTp2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgdUNsYW1wT2Zmc2V0OnZlYzI8ZjMyPixcbiAgICAgICAgICAgICAgICB1VGV4dHVyZVRyYW5zZm9ybTptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1U2l6ZUFuY2hvcjp2ZWM0PGYzMj5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gdGlsaW5nVW5pZm9ybXM6IFRpbGluZ1VuaWZvcm1zO1xuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdXYgPSAodGlsaW5nVW5pZm9ybXMudVRleHR1cmVUcmFuc2Zvcm0gKiB2ZWMzKHV2LCAxLjApKS54eTtcblxuICAgICAgICAgICAgcG9zaXRpb24gPSAocG9zaXRpb24gLSB0aWxpbmdVbmlmb3Jtcy51U2l6ZUFuY2hvci56dykgKiB0aWxpbmdVbmlmb3Jtcy51U2l6ZUFuY2hvci54eTtcbiAgICAgICAgYFxuICAgIClcbiAgfSxcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHN0cnVjdCBUaWxpbmdVbmlmb3JtcyB7XG4gICAgICAgICAgICAgICAgdU1hcENvb3JkOm1hdDN4MzxmMzI+LFxuICAgICAgICAgICAgICAgIHVDbGFtcEZyYW1lOnZlYzQ8ZjMyPixcbiAgICAgICAgICAgICAgICB1Q2xhbXBPZmZzZXQ6dmVjMjxmMzI+LFxuICAgICAgICAgICAgICAgIHVUZXh0dXJlVHJhbnNmb3JtOm1hdDN4MzxmMzI+LFxuICAgICAgICAgICAgICAgIHVTaXplQW5jaG9yOnZlYzQ8ZjMyPlxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiB0aWxpbmdVbmlmb3JtczogVGlsaW5nVW5pZm9ybXM7XG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47XG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMikgdmFyIHVTYW1wbGVyOiBzYW1wbGVyO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG5cbiAgICAgICAgICAgIHZhciBjb29yZCA9IHZVViArIGNlaWwodGlsaW5nVW5pZm9ybXMudUNsYW1wT2Zmc2V0IC0gdlVWKTtcbiAgICAgICAgICAgIGNvb3JkID0gKHRpbGluZ1VuaWZvcm1zLnVNYXBDb29yZCAqIHZlYzMoY29vcmQsIDEuMCkpLnh5O1xuICAgICAgICAgICAgdmFyIHVuY2xhbXBlZCA9IGNvb3JkO1xuICAgICAgICAgICAgY29vcmQgPSBjbGFtcChjb29yZCwgdGlsaW5nVW5pZm9ybXMudUNsYW1wRnJhbWUueHksIHRpbGluZ1VuaWZvcm1zLnVDbGFtcEZyYW1lLnp3KTtcblxuICAgICAgICAgICAgdmFyIGJpYXMgPSAwLjtcblxuICAgICAgICAgICAgaWYodW5jbGFtcGVkLnggPT0gY29vcmQueCAmJiB1bmNsYW1wZWQueSA9PSBjb29yZC55KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJpYXMgPSAtMzIuO1xuICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgb3V0Q29sb3IgPSB0ZXh0dXJlU2FtcGxlQmlhcyh1VGV4dHVyZSwgdVNhbXBsZXIsIGNvb3JkLCBiaWFzKTtcbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcbmNvbnN0IHRpbGluZ0JpdEdsID0ge1xuICBuYW1lOiBcInRpbGluZy1iaXRcIixcbiAgdmVydGV4OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdVRleHR1cmVUcmFuc2Zvcm07XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgdVNpemVBbmNob3I7XG4gICAgICAgIFxuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB1diA9ICh1VGV4dHVyZVRyYW5zZm9ybSAqIHZlYzMoYVVWLCAxLjApKS54eTtcblxuICAgICAgICAgICAgcG9zaXRpb24gPSAocG9zaXRpb24gLSB1U2l6ZUFuY2hvci56dykgKiB1U2l6ZUFuY2hvci54eTtcbiAgICAgICAgYFxuICAgIClcbiAgfSxcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHVNYXBDb29yZDtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1Q2xhbXBGcmFtZTtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1Q2xhbXBPZmZzZXQ7XG4gICAgICAgIGBcbiAgICApLFxuICAgIG1haW46IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcblxuICAgICAgICB2ZWMyIGNvb3JkID0gdlVWICsgY2VpbCh1Q2xhbXBPZmZzZXQgLSB2VVYpO1xuICAgICAgICBjb29yZCA9ICh1TWFwQ29vcmQgKiB2ZWMzKGNvb3JkLCAxLjApKS54eTtcbiAgICAgICAgdmVjMiB1bmNsYW1wZWQgPSBjb29yZDtcbiAgICAgICAgY29vcmQgPSBjbGFtcChjb29yZCwgdUNsYW1wRnJhbWUueHksIHVDbGFtcEZyYW1lLnp3KTtcbiAgICAgICAgXG4gICAgICAgIG91dENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgY29vcmQsIHVuY2xhbXBlZCA9PSBjb29yZCA/IDAuMCA6IC0zMi4wKTsvLyBsb2QtYmlhcyB2ZXJ5IG5lZ2F0aXZlIHRvIGZvcmNlIGxvZCAwXG4gICAgXG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5cbmV4cG9ydCB7IHRpbGluZ0JpdCwgdGlsaW5nQml0R2wgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGluZ0JpdC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBjb21waWxlSGlnaFNoYWRlckdwdVByb2dyYW0sIGNvbXBpbGVIaWdoU2hhZGVyR2xQcm9ncmFtIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL2NvbXBpbGVIaWdoU2hhZGVyVG9Qcm9ncmFtLm1qcyc7XG5pbXBvcnQgeyBsb2NhbFVuaWZvcm1CaXQsIGxvY2FsVW5pZm9ybUJpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybUJpdC5tanMnO1xuaW1wb3J0IHsgcm91bmRQaXhlbHNCaXQsIHJvdW5kUGl4ZWxzQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvcm91bmRQaXhlbHNCaXQubWpzJztcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9TaGFkZXIubWpzJztcbmltcG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IHRpbGluZ0JpdCwgdGlsaW5nQml0R2wgfSBmcm9tICcuL3RpbGluZ0JpdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCBncHVQcm9ncmFtO1xubGV0IGdsUHJvZ3JhbTtcbmNsYXNzIFRpbGluZ1Nwcml0ZVNoYWRlciBleHRlbmRzIFNoYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGdwdVByb2dyYW0gPz8gKGdwdVByb2dyYW0gPSBjb21waWxlSGlnaFNoYWRlckdwdVByb2dyYW0oe1xuICAgICAgbmFtZTogXCJ0aWxpbmctc3ByaXRlLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBsb2NhbFVuaWZvcm1CaXQsXG4gICAgICAgIHRpbGluZ0JpdCxcbiAgICAgICAgcm91bmRQaXhlbHNCaXRcbiAgICAgIF1cbiAgICB9KSk7XG4gICAgZ2xQcm9ncmFtID8/IChnbFByb2dyYW0gPSBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSh7XG4gICAgICBuYW1lOiBcInRpbGluZy1zcHJpdGUtc2hhZGVyXCIsXG4gICAgICBiaXRzOiBbXG4gICAgICAgIGxvY2FsVW5pZm9ybUJpdEdsLFxuICAgICAgICB0aWxpbmdCaXRHbCxcbiAgICAgICAgcm91bmRQaXhlbHNCaXRHbFxuICAgICAgXVxuICAgIH0pKTtcbiAgICBjb25zdCB0aWxpbmdVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICAgICAgdU1hcENvb3JkOiB7IHZhbHVlOiBuZXcgTWF0cml4KCksIHR5cGU6IFwibWF0M3gzPGYzMj5cIiB9LFxuICAgICAgdUNsYW1wRnJhbWU6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDFdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdUNsYW1wT2Zmc2V0OiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSksIHR5cGU6IFwidmVjMjxmMzI+XCIgfSxcbiAgICAgIHVUZXh0dXJlVHJhbnNmb3JtOiB7IHZhbHVlOiBuZXcgTWF0cml4KCksIHR5cGU6IFwibWF0M3gzPGYzMj5cIiB9LFxuICAgICAgdVNpemVBbmNob3I6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEwMCwgMTAwLCAwLjUsIDAuNV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH1cbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBnbFByb2dyYW0sXG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIGxvY2FsVW5pZm9ybXM6IG5ldyBVbmlmb3JtR3JvdXAoe1xuICAgICAgICAgIHVUcmFuc2Zvcm1NYXRyaXg6IHsgdmFsdWU6IG5ldyBNYXRyaXgoKSwgdHlwZTogXCJtYXQzeDM8ZjMyPlwiIH0sXG4gICAgICAgICAgdUNvbG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgICAgICB1Um91bmQ6IHsgdmFsdWU6IDAsIHR5cGU6IFwiZjMyXCIgfVxuICAgICAgICB9KSxcbiAgICAgICAgdGlsaW5nVW5pZm9ybXMsXG4gICAgICAgIHVUZXh0dXJlOiBUZXh0dXJlLkVNUFRZLnNvdXJjZSxcbiAgICAgICAgdVNhbXBsZXI6IFRleHR1cmUuRU1QVFkuc291cmNlLnN0eWxlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVW5pZm9ybXMod2lkdGgsIGhlaWdodCwgbWF0cml4LCBhbmNob3JYLCBhbmNob3JZLCB0ZXh0dXJlKSB7XG4gICAgY29uc3QgdGlsaW5nVW5pZm9ybXMgPSB0aGlzLnJlc291cmNlcy50aWxpbmdVbmlmb3JtcztcbiAgICBjb25zdCB0ZXh0dXJlV2lkdGggPSB0ZXh0dXJlLndpZHRoO1xuICAgIGNvbnN0IHRleHR1cmVIZWlnaHQgPSB0ZXh0dXJlLmhlaWdodDtcbiAgICBjb25zdCB0ZXh0dXJlTWF0cml4ID0gdGV4dHVyZS50ZXh0dXJlTWF0cml4O1xuICAgIGNvbnN0IHVUZXh0dXJlVHJhbnNmb3JtID0gdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudVRleHR1cmVUcmFuc2Zvcm07XG4gICAgdVRleHR1cmVUcmFuc2Zvcm0uc2V0KFxuICAgICAgbWF0cml4LmEgKiB0ZXh0dXJlV2lkdGggLyB3aWR0aCxcbiAgICAgIG1hdHJpeC5iICogdGV4dHVyZVdpZHRoIC8gaGVpZ2h0LFxuICAgICAgbWF0cml4LmMgKiB0ZXh0dXJlSGVpZ2h0IC8gd2lkdGgsXG4gICAgICBtYXRyaXguZCAqIHRleHR1cmVIZWlnaHQgLyBoZWlnaHQsXG4gICAgICBtYXRyaXgudHggLyB3aWR0aCxcbiAgICAgIG1hdHJpeC50eSAvIGhlaWdodFxuICAgICk7XG4gICAgdVRleHR1cmVUcmFuc2Zvcm0uaW52ZXJ0KCk7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudU1hcENvb3JkID0gdGV4dHVyZU1hdHJpeC5tYXBDb29yZDtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51Q2xhbXBGcmFtZSA9IHRleHR1cmVNYXRyaXgudUNsYW1wRnJhbWU7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudUNsYW1wT2Zmc2V0ID0gdGV4dHVyZU1hdHJpeC51Q2xhbXBPZmZzZXQ7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudVRleHR1cmVUcmFuc2Zvcm0gPSB1VGV4dHVyZVRyYW5zZm9ybTtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51U2l6ZUFuY2hvclswXSA9IHdpZHRoO1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVTaXplQW5jaG9yWzFdID0gaGVpZ2h0O1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVTaXplQW5jaG9yWzJdID0gYW5jaG9yWDtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51U2l6ZUFuY2hvclszXSA9IGFuY2hvclk7XG4gICAgaWYgKHRleHR1cmUpIHtcbiAgICAgIHRoaXMucmVzb3VyY2VzLnVUZXh0dXJlID0gdGV4dHVyZS5zb3VyY2U7XG4gICAgICB0aGlzLnJlc291cmNlcy51U2FtcGxlciA9IHRleHR1cmUuc291cmNlLnN0eWxlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBUaWxpbmdTcHJpdGVTaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGluZ1Nwcml0ZVNoYWRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBNZXNoR2VvbWV0cnkgfSBmcm9tICcuLi8uLi9tZXNoL3NoYXJlZC9NZXNoR2VvbWV0cnkubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBRdWFkR2VvbWV0cnkgZXh0ZW5kcyBNZXNoR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBwb3NpdGlvbnM6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKSxcbiAgICAgIHV2czogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pLFxuICAgICAgaW5kaWNlczogbmV3IFVpbnQzMkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSlcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBRdWFkR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1YWRHZW9tZXRyeS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHNldFBvc2l0aW9ucyh0aWxpbmdTcHJpdGUsIHBvc2l0aW9ucykge1xuICBjb25zdCBhbmNob3JYID0gdGlsaW5nU3ByaXRlLmFuY2hvci54O1xuICBjb25zdCBhbmNob3JZID0gdGlsaW5nU3ByaXRlLmFuY2hvci55O1xuICBwb3NpdGlvbnNbMF0gPSAtYW5jaG9yWCAqIHRpbGluZ1Nwcml0ZS53aWR0aDtcbiAgcG9zaXRpb25zWzFdID0gLWFuY2hvclkgKiB0aWxpbmdTcHJpdGUuaGVpZ2h0O1xuICBwb3NpdGlvbnNbMl0gPSAoMSAtIGFuY2hvclgpICogdGlsaW5nU3ByaXRlLndpZHRoO1xuICBwb3NpdGlvbnNbM10gPSAtYW5jaG9yWSAqIHRpbGluZ1Nwcml0ZS5oZWlnaHQ7XG4gIHBvc2l0aW9uc1s0XSA9ICgxIC0gYW5jaG9yWCkgKiB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHBvc2l0aW9uc1s1XSA9ICgxIC0gYW5jaG9yWSkgKiB0aWxpbmdTcHJpdGUuaGVpZ2h0O1xuICBwb3NpdGlvbnNbNl0gPSAtYW5jaG9yWCAqIHRpbGluZ1Nwcml0ZS53aWR0aDtcbiAgcG9zaXRpb25zWzddID0gKDEgLSBhbmNob3JZKSAqIHRpbGluZ1Nwcml0ZS5oZWlnaHQ7XG59XG5cbmV4cG9ydCB7IHNldFBvc2l0aW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0UG9zaXRpb25zLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYXBwbHlNYXRyaXgoYXJyYXksIHN0cmlkZSwgb2Zmc2V0LCBtYXRyaXgpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3Qgc2l6ZSA9IGFycmF5Lmxlbmd0aCAvIChzdHJpZGUgfHwgMik7XG4gIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgY29uc3QgYiA9IG1hdHJpeC5iO1xuICBjb25zdCBjID0gbWF0cml4LmM7XG4gIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgY29uc3QgdHggPSBtYXRyaXgudHg7XG4gIGNvbnN0IHR5ID0gbWF0cml4LnR5O1xuICBvZmZzZXQgKj0gc3RyaWRlO1xuICB3aGlsZSAoaW5kZXggPCBzaXplKSB7XG4gICAgY29uc3QgeCA9IGFycmF5W29mZnNldF07XG4gICAgY29uc3QgeSA9IGFycmF5W29mZnNldCArIDFdO1xuICAgIGFycmF5W29mZnNldF0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICBpbmRleCsrO1xuICB9XG59XG5cbmV4cG9ydCB7IGFwcGx5TWF0cml4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBseU1hdHJpeC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBhcHBseU1hdHJpeCB9IGZyb20gJy4vYXBwbHlNYXRyaXgubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBzZXRVdnModGlsaW5nU3ByaXRlLCB1dnMpIHtcbiAgY29uc3QgdGV4dHVyZSA9IHRpbGluZ1Nwcml0ZS50ZXh0dXJlO1xuICBjb25zdCB3aWR0aCA9IHRleHR1cmUuZnJhbWUud2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IHRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICBsZXQgYW5jaG9yWCA9IDA7XG4gIGxldCBhbmNob3JZID0gMDtcbiAgaWYgKHRpbGluZ1Nwcml0ZS5fYXBwbHlBbmNob3JUb1RleHR1cmUpIHtcbiAgICBhbmNob3JYID0gdGlsaW5nU3ByaXRlLmFuY2hvci54O1xuICAgIGFuY2hvclkgPSB0aWxpbmdTcHJpdGUuYW5jaG9yLnk7XG4gIH1cbiAgdXZzWzBdID0gdXZzWzZdID0gLWFuY2hvclg7XG4gIHV2c1syXSA9IHV2c1s0XSA9IDEgLSBhbmNob3JYO1xuICB1dnNbMV0gPSB1dnNbM10gPSAtYW5jaG9yWTtcbiAgdXZzWzVdID0gdXZzWzddID0gMSAtIGFuY2hvclk7XG4gIGNvbnN0IHRleHR1cmVNYXRyaXggPSBNYXRyaXguc2hhcmVkO1xuICB0ZXh0dXJlTWF0cml4LmNvcHlGcm9tKHRpbGluZ1Nwcml0ZS5fdGlsZVRyYW5zZm9ybS5tYXRyaXgpO1xuICB0ZXh0dXJlTWF0cml4LnR4IC89IHRpbGluZ1Nwcml0ZS53aWR0aDtcbiAgdGV4dHVyZU1hdHJpeC50eSAvPSB0aWxpbmdTcHJpdGUuaGVpZ2h0O1xuICB0ZXh0dXJlTWF0cml4LmludmVydCgpO1xuICB0ZXh0dXJlTWF0cml4LnNjYWxlKHRpbGluZ1Nwcml0ZS53aWR0aCAvIHdpZHRoLCB0aWxpbmdTcHJpdGUuaGVpZ2h0IC8gaGVpZ2h0KTtcbiAgYXBwbHlNYXRyaXgodXZzLCAyLCAwLCB0ZXh0dXJlTWF0cml4KTtcbn1cblxuZXhwb3J0IHsgc2V0VXZzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXRVdnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9TdGF0ZS5tanMnO1xuaW1wb3J0IHsgUmVuZGVyZXJUeXBlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy90eXBlcy5tanMnO1xuaW1wb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSB9IGZyb20gJy4uL2dyYXBoaWNzL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlTWVzaCB9IGZyb20gJy4uL21lc2gvc2hhcmVkL0JhdGNoYWJsZU1lc2gubWpzJztcbmltcG9ydCB7IE1lc2hHZW9tZXRyeSB9IGZyb20gJy4uL21lc2gvc2hhcmVkL01lc2hHZW9tZXRyeS5tanMnO1xuaW1wb3J0IHsgVGlsaW5nU3ByaXRlU2hhZGVyIH0gZnJvbSAnLi9zaGFkZXIvVGlsaW5nU3ByaXRlU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBRdWFkR2VvbWV0cnkgfSBmcm9tICcuL3V0aWxzL1F1YWRHZW9tZXRyeS5tanMnO1xuaW1wb3J0IHsgc2V0UG9zaXRpb25zIH0gZnJvbSAnLi91dGlscy9zZXRQb3NpdGlvbnMubWpzJztcbmltcG9ydCB7IHNldFV2cyB9IGZyb20gJy4vdXRpbHMvc2V0VXZzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3Qgc2hhcmVkUXVhZCA9IG5ldyBRdWFkR2VvbWV0cnkoKTtcbmNsYXNzIFRpbGluZ1Nwcml0ZVBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICB2YWxpZGF0ZVJlbmRlcmFibGUocmVuZGVyYWJsZSkge1xuICAgIGNvbnN0IHRpbGluZ1Nwcml0ZURhdGEgPSB0aGlzLl9nZXRUaWxpbmdTcHJpdGVEYXRhKHJlbmRlcmFibGUpO1xuICAgIGNvbnN0IGNvdWxkQmF0Y2ggPSB0aWxpbmdTcHJpdGVEYXRhLmNhbkJhdGNoO1xuICAgIHRoaXMuX3VwZGF0ZUNhbkJhdGNoKHJlbmRlcmFibGUpO1xuICAgIGNvbnN0IGNhbkJhdGNoID0gdGlsaW5nU3ByaXRlRGF0YS5jYW5CYXRjaDtcbiAgICBpZiAoY2FuQmF0Y2ggJiYgY2FuQmF0Y2ggPT09IGNvdWxkQmF0Y2gpIHtcbiAgICAgIGNvbnN0IHsgYmF0Y2hhYmxlTWVzaCB9ID0gdGlsaW5nU3ByaXRlRGF0YTtcbiAgICAgIGlmIChiYXRjaGFibGVNZXNoLnRleHR1cmUuX3NvdXJjZSAhPT0gcmVuZGVyYWJsZS50ZXh0dXJlLl9zb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuICFiYXRjaGFibGVNZXNoLmJhdGNoZXIuY2hlY2tBbmRVcGRhdGVUZXh0dXJlKGJhdGNoYWJsZU1lc2gsIHJlbmRlcmFibGUudGV4dHVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VsZEJhdGNoICE9PSBjYW5CYXRjaDtcbiAgfVxuICBhZGRSZW5kZXJhYmxlKHRpbGluZ1Nwcml0ZSwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBiYXRjaGVyID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2g7XG4gICAgdGhpcy5fdXBkYXRlQ2FuQmF0Y2godGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB0aWxpbmdTcHJpdGVEYXRhID0gdGhpcy5fZ2V0VGlsaW5nU3ByaXRlRGF0YSh0aWxpbmdTcHJpdGUpO1xuICAgIGNvbnN0IHsgZ2VvbWV0cnksIGNhbkJhdGNoIH0gPSB0aWxpbmdTcHJpdGVEYXRhO1xuICAgIGlmIChjYW5CYXRjaCkge1xuICAgICAgdGlsaW5nU3ByaXRlRGF0YS5iYXRjaGFibGVNZXNoIHx8ICh0aWxpbmdTcHJpdGVEYXRhLmJhdGNoYWJsZU1lc2ggPSBuZXcgQmF0Y2hhYmxlTWVzaCgpKTtcbiAgICAgIGNvbnN0IGJhdGNoYWJsZU1lc2ggPSB0aWxpbmdTcHJpdGVEYXRhLmJhdGNoYWJsZU1lc2g7XG4gICAgICBpZiAodGlsaW5nU3ByaXRlLl9kaWRUaWxpbmdTcHJpdGVVcGRhdGUpIHtcbiAgICAgICAgdGlsaW5nU3ByaXRlLl9kaWRUaWxpbmdTcHJpdGVVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hhYmxlTWVzaCh0aWxpbmdTcHJpdGUpO1xuICAgICAgICBiYXRjaGFibGVNZXNoLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgIGJhdGNoYWJsZU1lc2gubWVzaCA9IHRpbGluZ1Nwcml0ZTtcbiAgICAgICAgYmF0Y2hhYmxlTWVzaC50ZXh0dXJlID0gdGlsaW5nU3ByaXRlLl90ZXh0dXJlO1xuICAgICAgfVxuICAgICAgYmF0Y2hhYmxlTWVzaC5yb3VuZFBpeGVscyA9IHRoaXMuX3JlbmRlcmVyLl9yb3VuZFBpeGVscyB8IHRpbGluZ1Nwcml0ZS5fcm91bmRQaXhlbHM7XG4gICAgICBiYXRjaGVyLmFkZFRvQmF0Y2goYmF0Y2hhYmxlTWVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhdGNoZXIuYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgICAgdGlsaW5nU3ByaXRlRGF0YS5zaGFkZXIgfHwgKHRpbGluZ1Nwcml0ZURhdGEuc2hhZGVyID0gbmV3IFRpbGluZ1Nwcml0ZVNoYWRlcigpKTtcbiAgICAgIHRoaXMudXBkYXRlUmVuZGVyYWJsZSh0aWxpbmdTcHJpdGUpO1xuICAgICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHRpbGluZ1Nwcml0ZSk7XG4gICAgfVxuICB9XG4gIGV4ZWN1dGUodGlsaW5nU3ByaXRlKSB7XG4gICAgY29uc3QgeyBzaGFkZXIgfSA9IHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoW3RpbGluZ1Nwcml0ZS51aWRdO1xuICAgIHNoYWRlci5ncm91cHNbMF0gPSB0aGlzLl9yZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy5iaW5kR3JvdXA7XG4gICAgY29uc3QgbG9jYWxVbmlmb3JtcyA9IHNoYWRlci5yZXNvdXJjZXMubG9jYWxVbmlmb3Jtcy51bmlmb3JtcztcbiAgICBsb2NhbFVuaWZvcm1zLnVUcmFuc2Zvcm1NYXRyaXggPSB0aWxpbmdTcHJpdGUuZ3JvdXBUcmFuc2Zvcm07XG4gICAgbG9jYWxVbmlmb3Jtcy51Um91bmQgPSB0aGlzLl9yZW5kZXJlci5fcm91bmRQaXhlbHMgfCB0aWxpbmdTcHJpdGUuX3JvdW5kUGl4ZWxzO1xuICAgIGNvbG9yMzJCaXRUb1VuaWZvcm0oXG4gICAgICB0aWxpbmdTcHJpdGUuZ3JvdXBDb2xvckFscGhhLFxuICAgICAgbG9jYWxVbmlmb3Jtcy51Q29sb3IsXG4gICAgICAwXG4gICAgKTtcbiAgICB0aGlzLl9yZW5kZXJlci5lbmNvZGVyLmRyYXcoe1xuICAgICAgZ2VvbWV0cnk6IHNoYXJlZFF1YWQsXG4gICAgICBzaGFkZXIsXG4gICAgICBzdGF0ZTogU3RhdGUuZGVmYXVsdDJkXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZSh0aWxpbmdTcHJpdGUpIHtcbiAgICBjb25zdCB0aWxpbmdTcHJpdGVEYXRhID0gdGhpcy5fZ2V0VGlsaW5nU3ByaXRlRGF0YSh0aWxpbmdTcHJpdGUpO1xuICAgIGNvbnN0IHsgY2FuQmF0Y2ggfSA9IHRpbGluZ1Nwcml0ZURhdGE7XG4gICAgaWYgKGNhbkJhdGNoKSB7XG4gICAgICBjb25zdCB7IGJhdGNoYWJsZU1lc2ggfSA9IHRpbGluZ1Nwcml0ZURhdGE7XG4gICAgICBpZiAodGlsaW5nU3ByaXRlLl9kaWRUaWxpbmdTcHJpdGVVcGRhdGUpXG4gICAgICAgIHRoaXMuX3VwZGF0ZUJhdGNoYWJsZU1lc2godGlsaW5nU3ByaXRlKTtcbiAgICAgIGJhdGNoYWJsZU1lc2guYmF0Y2hlci51cGRhdGVFbGVtZW50KGJhdGNoYWJsZU1lc2gpO1xuICAgIH0gZWxzZSBpZiAodGlsaW5nU3ByaXRlLl9kaWRUaWxpbmdTcHJpdGVVcGRhdGUpIHtcbiAgICAgIGNvbnN0IHsgc2hhZGVyIH0gPSB0aWxpbmdTcHJpdGVEYXRhO1xuICAgICAgc2hhZGVyLnVwZGF0ZVVuaWZvcm1zKFxuICAgICAgICB0aWxpbmdTcHJpdGUud2lkdGgsXG4gICAgICAgIHRpbGluZ1Nwcml0ZS5oZWlnaHQsXG4gICAgICAgIHRpbGluZ1Nwcml0ZS5fdGlsZVRyYW5zZm9ybS5tYXRyaXgsXG4gICAgICAgIHRpbGluZ1Nwcml0ZS5hbmNob3IueCxcbiAgICAgICAgdGlsaW5nU3ByaXRlLmFuY2hvci55LFxuICAgICAgICB0aWxpbmdTcHJpdGUudGV4dHVyZVxuICAgICAgKTtcbiAgICB9XG4gICAgdGlsaW5nU3ByaXRlLl9kaWRUaWxpbmdTcHJpdGVVcGRhdGUgPSBmYWxzZTtcbiAgfVxuICBkZXN0cm95UmVuZGVyYWJsZSh0aWxpbmdTcHJpdGUpIHtcbiAgICBjb25zdCB0aWxpbmdTcHJpdGVEYXRhID0gdGhpcy5fZ2V0VGlsaW5nU3ByaXRlRGF0YSh0aWxpbmdTcHJpdGUpO1xuICAgIHRpbGluZ1Nwcml0ZURhdGEuYmF0Y2hhYmxlTWVzaCA9IG51bGw7XG4gICAgdGlsaW5nU3ByaXRlRGF0YS5zaGFkZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaFt0aWxpbmdTcHJpdGUudWlkXSA9IG51bGw7XG4gIH1cbiAgX2dldFRpbGluZ1Nwcml0ZURhdGEocmVuZGVyYWJsZSkge1xuICAgIHJldHVybiB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaFtyZW5kZXJhYmxlLnVpZF0gfHwgdGhpcy5faW5pdFRpbGluZ1Nwcml0ZURhdGEocmVuZGVyYWJsZSk7XG4gIH1cbiAgX2luaXRUaWxpbmdTcHJpdGVEYXRhKHRpbGluZ1Nwcml0ZSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IE1lc2hHZW9tZXRyeSh7XG4gICAgICBpbmRpY2VzOiBzaGFyZWRRdWFkLmluZGljZXMsXG4gICAgICBwb3NpdGlvbnM6IHNoYXJlZFF1YWQucG9zaXRpb25zLnNsaWNlKCksXG4gICAgICB1dnM6IHNoYXJlZFF1YWQudXZzLnNsaWNlKClcbiAgICB9KTtcbiAgICB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaFt0aWxpbmdTcHJpdGUudWlkXSA9IHtcbiAgICAgIGNhbkJhdGNoOiB0cnVlLFxuICAgICAgcmVuZGVyYWJsZTogdGlsaW5nU3ByaXRlLFxuICAgICAgZ2VvbWV0cnlcbiAgICB9O1xuICAgIHRpbGluZ1Nwcml0ZS5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3lSZW5kZXJhYmxlKHRpbGluZ1Nwcml0ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoW3RpbGluZ1Nwcml0ZS51aWRdO1xuICB9XG4gIF91cGRhdGVCYXRjaGFibGVNZXNoKHRpbGluZ1Nwcml0ZSkge1xuICAgIGNvbnN0IHJlbmRlcmFibGVEYXRhID0gdGhpcy5fZ2V0VGlsaW5nU3ByaXRlRGF0YSh0aWxpbmdTcHJpdGUpO1xuICAgIGNvbnN0IHsgZ2VvbWV0cnkgfSA9IHJlbmRlcmFibGVEYXRhO1xuICAgIGNvbnN0IHN0eWxlID0gdGlsaW5nU3ByaXRlLnRleHR1cmUuc291cmNlLnN0eWxlO1xuICAgIGlmIChzdHlsZS5hZGRyZXNzTW9kZSAhPT0gXCJyZXBlYXRcIikge1xuICAgICAgc3R5bGUuYWRkcmVzc01vZGUgPSBcInJlcGVhdFwiO1xuICAgICAgc3R5bGUudXBkYXRlKCk7XG4gICAgfVxuICAgIHNldFV2cyh0aWxpbmdTcHJpdGUsIGdlb21ldHJ5LnV2cyk7XG4gICAgc2V0UG9zaXRpb25zKHRpbGluZ1Nwcml0ZSwgZ2VvbWV0cnkucG9zaXRpb25zKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaCkge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZSh0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaFtpXS5yZW5kZXJhYmxlKTtcbiAgICB9XG4gICAgdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2ggPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlQ2FuQmF0Y2godGlsaW5nU3ByaXRlKSB7XG4gICAgY29uc3QgcmVuZGVyYWJsZURhdGEgPSB0aGlzLl9nZXRUaWxpbmdTcHJpdGVEYXRhKHRpbGluZ1Nwcml0ZSk7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRpbGluZ1Nwcml0ZS50ZXh0dXJlO1xuICAgIGxldCBfbm9uUG93T2Yyd3JhcHBpbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9yZW5kZXJlci50eXBlID09PSBSZW5kZXJlclR5cGUuV0VCR0wpIHtcbiAgICAgIF9ub25Qb3dPZjJ3cmFwcGluZyA9IHRoaXMuX3JlbmRlcmVyLmNvbnRleHQuc3VwcG9ydHMubm9uUG93T2Yyd3JhcHBpbmc7XG4gICAgfVxuICAgIHJlbmRlcmFibGVEYXRhLmNhbkJhdGNoID0gdGV4dHVyZS50ZXh0dXJlTWF0cml4LmlzU2ltcGxlICYmIChfbm9uUG93T2Yyd3JhcHBpbmcgfHwgdGV4dHVyZS5zb3VyY2UuaXNQb3dlck9mVHdvKTtcbiAgICByZXR1cm4gcmVuZGVyYWJsZURhdGEuY2FuQmF0Y2g7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5UaWxpbmdTcHJpdGVQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJ0aWxpbmdTcHJpdGVcIlxufTtcblxuZXhwb3J0IHsgVGlsaW5nU3ByaXRlUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsaW5nU3ByaXRlUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBUaWxpbmdTcHJpdGVQaXBlIH0gZnJvbSAnLi9UaWxpbmdTcHJpdGVQaXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoVGlsaW5nU3ByaXRlUGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1015\n')},7602:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs\nvar LoaderParser = __webpack_require__(4334);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs\nvar copySearchParams = __webpack_require__(8479);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(1718);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs\n\n\n\n"use strict";\nclass AbstractBitmapFont extends eventemitter3/* default */.Z {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = "";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: "none", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or "none".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");\n    return this.distanceField.type;\n  }\n  destroy(destroyTextures = false) {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture.destroy();\n    }\n    this.chars = null;\n    if (destroyTextures) {\n      this.pages.forEach((page) => page.texture.destroy(true));\n      this.pages = null;\n    }\n  }\n}\n\n\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(4162);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(3779);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(9160);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(13);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(778);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs\n\nfunction resolveCharacters(chars) {\n  if (chars === "") {\n    return [];\n  }\n  if (typeof chars === "string") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error("[BitmapFont]: Invalid character delimiter.");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error("[BitmapFont]: Invalid character range.");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error("[BitmapFont]: Empty set when resolving characters.");\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=resolveCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 4;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = options;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture/* Texture */.x.WHITE;\n      style._fill.fill = null;\n    }\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics/* CanvasTextMetrics */.c.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    const widthScale = style.fontStyle === "italic" ? 2 : 1;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = widthScale * metrics.width * fontScale;\n      const height = metrics.height * fontScale;\n      const paddedWidth = width + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== "\\n" && char !== "\\r" && char !== "\t" && char !== " ") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > 512) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > 512) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle/* Rectangle */.A(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture/* Texture */.x({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(512, 512, textureResolution);\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture/* Texture */.x({\n      source: new ImageSource/* ImageSource */.c({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: "premultiply-alpha-on-upload"\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color/* Color */.I.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = "black";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool/* CanvasPool */.h.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n}\n\n\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs\n\nfunction getBitmapTextLayout(chars, style, font) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    let lastChar = currentLine.chars[index];\n    while (lastChar === " ") {\n      currentLine.width -= font.chars[lastChar].xAdvance;\n      lastChar = currentLine.chars[--index];\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[" "];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === "\\r" || char === "\\n" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === "\\r" || char === "\\n") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === "center") {\n    alignCenter(layoutData);\n  } else if (style.align === "right") {\n    alignRight(layoutData);\n  } else if (style.align === "justify") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\n\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs\n\n\n\n\n\n\n\n"use strict";\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [["a", "z"], ["A", "Z"], " "];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [["0", "9"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[" ", "~"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill) {\n      fontFamilyKey += style._fill.fill.uid;\n      overrideFill = false;\n    }\n    if (!Cache/* Cache */.C.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fnt.once("destroy", () => Cache/* Cache */.C.remove(fontFamilyKey));\n      Cache/* Cache */.C.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache/* Cache */.C.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   */\n  getLayout(text, style) {\n    const bitmapFont = this.getFont(text, style);\n    return getBitmapTextLayout([...text], style, bitmapFont);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   */\n  measureText(text, style) {\n    return this.getLayout(text, style);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === "string") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error("[BitmapFontManager] Property `name` is required.");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle/* TextStyle */.p ? textStyle : new TextStyle/* TextStyle */.p(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(""));\n    Cache/* Cache */.C.set(`${name}-bitmap`, font);\n    font.once("destroy", () => Cache/* Cache */.C.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache/* Cache */.C.get(cacheKey);\n    if (font) {\n      Cache/* Cache */.C.remove(cacheKey);\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\n\n//# sourceMappingURL=BitmapFontManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs\n\n\n\n\n\n"use strict";\nclass BitmapFont extends AbstractBitmapFont {\n  constructor(options, url) {\n    super();\n    const { textures, data } = options;\n    Object.keys(data.pages).forEach((key) => {\n      const pageData = data.pages[parseInt(key, 10)];\n      const texture = textures[pageData.id];\n      this.pages.push({ texture });\n    });\n    Object.keys(data.chars).forEach((key) => {\n      const charData = data.chars[key];\n      const {\n        frame: textureFrame,\n        source: textureSource\n      } = textures[charData.page];\n      const frameReal = new Rectangle/* Rectangle */.A(\n        charData.x + textureFrame.x,\n        charData.y + textureFrame.y,\n        charData.width,\n        charData.height\n      );\n      const texture = new Texture/* Texture */.x({\n        source: textureSource,\n        frame: frameReal\n      });\n      this.chars[key] = {\n        id: key.codePointAt(0),\n        xOffset: charData.xOffset,\n        yOffset: charData.yOffset,\n        xAdvance: charData.xAdvance,\n        kerning: charData.kerning ?? {},\n        texture\n      };\n    });\n    this.baseRenderedFontSize = data.fontSize;\n    this.baseMeasurementFontSize = data.fontSize;\n    this.fontMetrics = {\n      ascent: 0,\n      descent: 0,\n      fontSize: data.fontSize\n    };\n    this.baseLineOffset = data.baseLineOffset;\n    this.lineHeight = data.lineHeight;\n    this.fontFamily = data.fontFamily;\n    this.distanceField = data.distanceField ?? {\n      type: "none",\n      range: 0\n    };\n    this.url = url;\n  }\n  /** Destroys the BitmapFont object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { texture } = this.pages[i];\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n  /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from \'pixi.js\';\n   *\n   * BitmapFont.install(\'TitleFont\', {\n   *     fontFamily: \'Arial\',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: \'purple\',\n   * });\n   *\n   * const title = new BitmapText({ text: \'This is the title\', fontFamily: \'TitleFont\' });\n   */\n  static install(options) {\n    BitmapFontManager.install(options);\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  static uninstall(name) {\n    BitmapFontManager.uninstall(name);\n  }\n}\n\n\n//# sourceMappingURL=BitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs\n\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === "string" && data.startsWith("info face=");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s"\']+|"([^"]*)")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split("=");\n        const key = split[0];\n        const strValue = split[1].replace(/"/gm, "");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: "",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === "space")\n        letter = " ";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontTextParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs\n\nconst bitmapFontXMLParser = {\n  test(data) {\n    const xml = data;\n    return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;\n  },\n  parse(xml) {\n    const data = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: "",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const info = xml.getElementsByTagName("info")[0];\n    const common = xml.getElementsByTagName("common")[0];\n    const distanceField = xml.getElementsByTagName("distanceField")[0];\n    if (distanceField) {\n      data.distanceField = {\n        type: distanceField.getAttribute("fieldType"),\n        range: parseInt(distanceField.getAttribute("distanceRange"), 10)\n      };\n    }\n    const page = xml.getElementsByTagName("page");\n    const char = xml.getElementsByTagName("char");\n    const kerning = xml.getElementsByTagName("kerning");\n    data.fontSize = parseInt(info.getAttribute("size"), 10);\n    data.fontFamily = info.getAttribute("face");\n    data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);\n    for (let i = 0; i < page.length; i++) {\n      data.pages.push({\n        id: parseInt(page[i].getAttribute("id"), 10) || 0,\n        file: page[i].getAttribute("file")\n      });\n    }\n    const map = {};\n    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.getAttribute("id"), 10);\n      let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);\n      if (letter === "space")\n        letter = " ";\n      map[id] = letter;\n      data.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.getAttribute("page"), 10) || 0,\n        x: parseInt(charNode.getAttribute("x"), 10),\n        y: parseInt(charNode.getAttribute("y"), 10),\n        width: parseInt(charNode.getAttribute("width"), 10),\n        height: parseInt(charNode.getAttribute("height"), 10),\n        // render deets..\n        xOffset: parseInt(charNode.getAttribute("xoffset"), 10),\n        yOffset: parseInt(charNode.getAttribute("yoffset"), 10),\n        // + baseLineOffset,\n        xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),\n        kerning: {}\n      };\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].getAttribute("first"), 10);\n      const second = parseInt(kerning[i].getAttribute("second"), 10);\n      const amount = parseInt(kerning[i].getAttribute("amount"), 10);\n      data.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return data;\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontXMLParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs\n\n\n\n"use strict";\nconst bitmapFontXMLStringParser = {\n  test(data) {\n    if (typeof data === "string" && data.includes("<font>")) {\n      return bitmapFontXMLParser.test(adapter/* DOMAdapter */.z.get().parseXML(data));\n    }\n    return false;\n  },\n  parse(data) {\n    return bitmapFontXMLParser.parse(adapter/* DOMAdapter */.z.get().parseXML(data));\n  }\n};\n\n\n//# sourceMappingURL=bitmapFontXMLStringParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst validExtensions = [".xml", ".fnt"];\nconst bitmapFontCachePlugin = {\n  extension: Extensions/* ExtensionType */.nw.CacheParser,\n  test: (asset) => asset instanceof BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach((key) => {\n      out[key] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.LoadParser,\n    priority: LoaderParser/* LoaderParserPriority */.Q.Normal\n  },\n  test(url) {\n    return validExtensions.includes(path/* path */.E.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);\n    const { src } = data;\n    const { pages } = bitmapFontData;\n    const textureUrls = [];\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path/* path */.E.join(path/* path */.E.dirname(src), pageFile);\n      imagePath = (0,copySearchParams/* copySearchParams */.u)(imagePath, src);\n      textureUrls.push(imagePath);\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url]);\n    const bitmapFont = new BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n    return await response.text();\n  },\n  async unload(bitmapFont, _resolvedAsset, loader) {\n    await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n    bitmapFont.destroy();\n  }\n};\n\n\n//# sourceMappingURL=loadBitmapFont.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(8400);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs + 15 modules\nvar GraphicsContext = __webpack_require__(6653);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs\n\n\n\n\n"use strict";\nclass Graphics extends Container/* Container */.W2 {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext/* GraphicsContext */.g) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: "Graphics",\n      ...rest\n    });\n    this.canBundle = true;\n    this.renderPipeId = "graphics";\n    this._roundPixels = 0;\n    if (!context) {\n      this._context = this._ownedContext = new GraphicsContext/* GraphicsContext */.g();\n    } else {\n      this._context = context;\n    }\n    this._context.on("update", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off("update", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on("update", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this._context.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   *  Whether or not to round the x/y position of the graphic.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didGraphicsUpdate = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod("setFillStyle", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod("setStrokeStyle", args);\n  }\n  fill(...args) {\n    return this._callContextMethod("fill", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod("stroke", args);\n  }\n  texture(...args) {\n    return this._callContextMethod("texture", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod("beginPath", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod("cut", []);\n  }\n  arc(...args) {\n    return this._callContextMethod("arc", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod("arcTo", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod("arcToSvg", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod("bezierCurveTo", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod("closePath", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod("ellipse", args);\n  }\n  circle(...args) {\n    return this._callContextMethod("circle", args);\n  }\n  path(...args) {\n    return this._callContextMethod("path", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod("lineTo", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod("moveTo", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod("quadraticCurveTo", args);\n  }\n  rect(...args) {\n    return this._callContextMethod("rect", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod("roundRect", args);\n  }\n  poly(...args) {\n    return this._callContextMethod("poly", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod("regularPoly", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod("roundPoly", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod("roundShape", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod("filletRect", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod("chamferRect", args);\n  }\n  star(...args) {\n    return this._callContextMethod("star", args);\n  }\n  svg(...args) {\n    return this._callContextMethod("svg", args);\n  }\n  restore(...args) {\n    return this._callContextMethod("restore", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod("save", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod("resetTransform", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod("rotate", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod("scale", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod("setTransform", args);\n  }\n  transform(...args) {\n    return this._callContextMethod("transform", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod("translate", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod("clear", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    const fillStyle = {};\n    color && (fillStyle.color = color);\n    alpha && (fillStyle.alpha = alpha);\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext/* GraphicsContext */.g.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext/* GraphicsContext */.g.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext/* GraphicsContext */.g.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Graphics#drawCircle has been renamed to Graphics#circle");\n    return this._callContextMethod("circle", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Graphics#drawEllipse has been renamed to Graphics#ellipse");\n    return this._callContextMethod("ellipse", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Graphics#drawPolygon has been renamed to Graphics#poly");\n    return this._callContextMethod("poly", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Graphics#drawRect has been renamed to Graphics#rect");\n    return this._callContextMethod("rect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");\n    return this._callContextMethod("roundRect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Graphics#drawStar has been renamed to Graphics#star");\n    return this._callContextMethod("star", args);\n  }\n}\n\n\n//# sourceMappingURL=Graphics.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(8157);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs\nvar colorBit = __webpack_require__(2110);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs\nvar generateTextureBatchBit = __webpack_require__(6600);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(9637);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs\nvar getBatchSamplersUniformGroup = __webpack_require__(2189);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(2267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(4537);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/maxRecommendedTextures.mjs\nvar maxRecommendedTextures = __webpack_require__(9131);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs\n\nconst localUniformMSDFBit = {\n  name: "local-uniform-msdf-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: "local-uniform-msdf-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      ` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs\n\nconst mSDFBit = {\n  name: "msdf-bit",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: "msdf-bit",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                return alpha;\n            }\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=mSDFBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass SdfShader extends Shader/* Shader */.e {\n  constructor() {\n    const uniforms = new UniformGroup/* UniformGroup */.o({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uDistance: { value: 4, type: "f32" },\n      uRound: { value: 0, type: "f32" }\n    });\n    const maxTextures = (0,maxRecommendedTextures/* maxRecommendedTextures */.I)();\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.d)({\n      name: "sdf-shader",\n      bits: [\n        colorBit/* colorBit */.M,\n        (0,generateTextureBatchBit/* generateTextureBatchBit */.m)(maxTextures),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit/* roundPixelsBit */.j\n      ]\n    });\n    const glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "sdf-shader",\n      bits: [\n        colorBit/* colorBitGl */.T,\n        (0,generateTextureBatchBit/* generateTextureBatchBitGl */.h)(maxTextures),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: (0,getBatchSamplersUniformGroup/* getBatchSamplersUniformGroup */.O)(maxTextures)\n      }\n    });\n  }\n}\n\n\n//# sourceMappingURL=SdfShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._gpuBitmapText = {};\n    this._renderer = renderer;\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  destroyRenderable(bitmapText) {\n    this._destroyRenderableByUid(bitmapText.uid);\n  }\n  _destroyRenderableByUid(renderableUid) {\n    PoolGroup/* BigPool */.u.return(this._gpuBitmapText[renderableUid]);\n    this._gpuBitmapText[renderableUid] = null;\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== "none") {\n      if (!context.customShader) {\n        if (!this._sdfShader) {\n          this._sdfShader = new SdfShader();\n        }\n        context.customShader = this._sdfShader;\n      }\n    }\n    const chars = Array.from(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = (style._stroke?.width || 0) / 2;\n    currentY += bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n    let index = 0;\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    context.translate(\n      -bitmapText._anchor._x * bitmapTextLayout.width - padding,\n      -bitmapText._anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding\n    ).scale(scale, scale);\n    const tint = style._fill.color;\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = chars[index++];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          context.texture(\n            charData.texture,\n            tint ? tint : "black",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset)\n          );\n        }\n      }\n      currentY += bitmapFont.lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = PoolGroup/* BigPool */.u.get(Graphics);\n    this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    bitmapText.on("destroyed", () => {\n      this.destroyRenderable(bitmapText);\n    });\n    return this._gpuBitmapText[bitmapText.uid];\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache/* Cache */.C.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const resolution = bitmapText.resolution ?? this._renderer.resolution;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    for (const uid in this._gpuBitmapText) {\n      this._destroyRenderableByUid(uid);\n    }\n    this._gpuBitmapText = null;\n    this._sdfShader?.destroy(true);\n    this._sdfShader = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "bitmapText"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\n\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(BitmapTextPipe, loadBitmapFont, bitmapFontCachePlugin);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQkFBK0I7QUFDakU7QUFDQTtBQUNBLElBQUksa0NBQVcsQ0FBQyx5QkFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLElBQUksa0NBQVcsQ0FBQyx5QkFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LDRCQUE0Qix3QkFBTyxLQUFLLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBSyxRQUFRLFdBQVc7QUFDaEQsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCOzs7QUNwSjZEO0FBQ3NCO0FBQzdCOztBQUV0RDtBQUNBLDZCQUFVLEtBQUssY0FBYyxFQUFFLGNBQWMsRUFBRSxxQkFBcUI7QUFDcEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL0Fic3RyYWN0Qml0bWFwRm9udC5tanM/NjRlMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcz83ODk5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvRHluYW1pY0JpdG1hcEZvbnQubWpzPzJkN2YiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC91dGlscy9nZXRCaXRtYXBUZXh0TGF5b3V0Lm1qcz9kZTNlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwRm9udE1hbmFnZXIubWpzP2QyNDIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9CaXRtYXBGb250Lm1qcz85ZDQwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvYXNzZXQvYml0bWFwRm9udFRleHRQYXJzZXIubWpzP2UzZmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250WE1MUGFyc2VyLm1qcz9iN2Y2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvYXNzZXQvYml0bWFwRm9udFhNTFN0cmluZ1BhcnNlci5tanM/NTk5MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL2Fzc2V0L2xvYWRCaXRtYXBGb250Lm1qcz9iZDQxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0dyYXBoaWNzLm1qcz8wOWU3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9zZGZTaGFkZXIvc2hhZGVyLWJpdHMvbG9jYWxVbmlmb3JtTVNERkJpdC5tanM/MmUyZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvc2RmU2hhZGVyL3NoYWRlci1iaXRzL21TREZCaXQubWpzPzYyOTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L3NkZlNoYWRlci9TZGZTaGFkZXIubWpzPzc2ZDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9CaXRtYXBUZXh0UGlwZS5tanM/NDNhMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL2luaXQubWpzPzYwYjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQWJzdHJhY3RCaXRtYXBGb250IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKiogVGhlIG1hcCBvZiBjaGFyYWN0ZXJzIGJ5IGNoYXJhY3RlciBjb2RlLiAqL1xuICAgIHRoaXMuY2hhcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbGluZS1oZWlnaHQgb2YgdGhlIGZvbnQgZmFjZSBpbiBwaXhlbHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVIZWlnaHQgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmb250IGZhY2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwiXCI7XG4gICAgLyoqIFRoZSBtZXRyaWNzIG9mIHRoZSBmb250IGZhY2UuICovXG4gICAgdGhpcy5mb250TWV0cmljcyA9IHsgZm9udFNpemU6IDAsIGFzY2VudDogMCwgZGVzY2VudDogMCB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgb2YgdGhlIGZvbnQgZmFjZSBmcm9tIHRoZSBiYXNlbGluZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZUxpbmVPZmZzZXQgPSAwO1xuICAgIC8qKiBUaGUgcmFuZ2UgYW5kIHR5cGUgb2YgdGhlIGRpc3RhbmNlIGZpZWxkIGZvciB0aGlzIGZvbnQuICovXG4gICAgdGhpcy5kaXN0YW5jZUZpZWxkID0geyB0eXBlOiBcIm5vbmVcIiwgcmFuZ2U6IDAgfTtcbiAgICAvKiogVGhlIG1hcCBvZiBiYXNlIHBhZ2UgdGV4dHVyZXMgKGkuZS4sIHNoZWV0cyBvZiBnbHlwaHMpLiAqL1xuICAgIHRoaXMucGFnZXMgPSBbXTtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIGZvbnQgZmFjZSBpbiBwaXhlbHMuICovXG4gICAgdGhpcy5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZSA9IDEwMDtcbiAgICB0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplID0gMTAwO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZm9udCBmYWNlLlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2UgYGZvbnRGYW1pbHlgIGluc3RlYWQuXG4gICAqL1xuICBnZXQgZm9udCgpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udC5mb250IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5mb250RmFtaWx5IGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmZvbnRGYW1pbHk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXAgb2YgYmFzZSBwYWdlIHRleHR1cmVzIChpLmUuLCBzaGVldHMgb2YgZ2x5cGhzKS5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIGBwYWdlc2AgaW5zdGVhZC5cbiAgICovXG4gIGdldCBwYWdlVGV4dHVyZXMoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQucGFnZVRleHR1cmVzIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5wYWdlcyBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlcztcbiAgfVxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGZvbnQgZmFjZSBpbiBwaXhlbHMuXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSBgZm9udE1ldHJpY3MuZm9udFNpemVgIGluc3RlYWQuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udC5zaXplIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5mb250TWV0cmljcy5mb250U2l6ZSBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5mb250TWV0cmljcy5mb250U2l6ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGtpbmQgb2YgZGlzdGFuY2UgZmllbGQgZm9yIHRoaXMgZm9udCBvciBcIm5vbmVcIi5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIGBkaXN0YW5jZUZpZWxkLnR5cGVgIGluc3RlYWQuXG4gICAqL1xuICBnZXQgZGlzdGFuY2VGaWVsZFJhbmdlKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250LmRpc3RhbmNlRmllbGRSYW5nZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEJpdG1hcEZvbnQuZGlzdGFuY2VGaWVsZC5yYW5nZSBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZUZpZWxkLnJhbmdlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcmFuZ2Ugb2YgdGhlIGRpc3RhbmNlIGZpZWxkIGluIHBpeGVscy5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIGBkaXN0YW5jZUZpZWxkLnJhbmdlYCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGRpc3RhbmNlRmllbGRUeXBlKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250LmRpc3RhbmNlRmllbGRUeXBlIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5kaXN0YW5jZUZpZWxkLnR5cGUgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VGaWVsZC50eXBlO1xuICB9XG4gIGRlc3Ryb3koZGVzdHJveVRleHR1cmVzID0gZmFsc2UpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuY2hhcnMpIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0udGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuY2hhcnMgPSBudWxsO1xuICAgIGlmIChkZXN0cm95VGV4dHVyZXMpIHtcbiAgICAgIHRoaXMucGFnZXMuZm9yRWFjaCgocGFnZSkgPT4gcGFnZS50ZXh0dXJlLmRlc3Ryb3kodHJ1ZSkpO1xuICAgICAgdGhpcy5wYWdlcyA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEFic3RyYWN0Qml0bWFwRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RCaXRtYXBGb250Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcmVzb2x2ZUNoYXJhY3RlcnMoY2hhcnMpIHtcbiAgaWYgKGNoYXJzID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICh0eXBlb2YgY2hhcnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjaGFycyA9IFtjaGFyc107XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBqID0gY2hhcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgY29uc3QgaXRlbSA9IGNoYXJzW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICBpZiAoaXRlbS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlIGxlbmd0aCwgZXhwZWN0aW5nIDIgZ290ICR7aXRlbS5sZW5ndGh9LmApO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMF0ubGVuZ3RoID09PSAwIHx8IGl0ZW1bMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogSW52YWxpZCBjaGFyYWN0ZXIgZGVsaW1pdGVyLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0Q29kZSA9IGl0ZW1bMF0uY2hhckNvZGVBdCgwKTtcbiAgICAgIGNvbnN0IGVuZENvZGUgPSBpdGVtWzFdLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoZW5kQ29kZSA8IHN0YXJ0Q29kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlLlwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkyID0gc3RhcnRDb2RlLCBqMiA9IGVuZENvZGU7IGkyIDw9IGoyOyBpMisrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaTIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goLi4uQXJyYXkuZnJvbShpdGVtKSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0JpdG1hcEZvbnRdOiBFbXB0eSBzZXQgd2hlbiByZXNvbHZpbmcgY2hhcmFjdGVycy5cIik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVDaGFyYWN0ZXJzLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IENhbnZhc1Bvb2wgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzJztcbmltcG9ydCB7IEltYWdlU291cmNlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0ltYWdlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuLi90ZXh0L2NhbnZhcy9DYW52YXNUZXh0TWV0cmljcy5tanMnO1xuaW1wb3J0IHsgZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUgfSBmcm9tICcuLi90ZXh0L2NhbnZhcy91dGlscy9mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMnO1xuaW1wb3J0IHsgZ2V0Q2FudmFzRmlsbFN0eWxlIH0gZnJvbSAnLi4vdGV4dC9jYW52YXMvdXRpbHMvZ2V0Q2FudmFzRmlsbFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdEJpdG1hcEZvbnQgfSBmcm9tICcuL0Fic3RyYWN0Qml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRHluYW1pY0JpdG1hcEZvbnQgZXh0ZW5kcyBBYnN0cmFjdEJpdG1hcEZvbnQge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGR5bmFtaWMgYml0bWFwIGZvbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiB0aGlzIGlzIGEgcmVzb2x1dGlvbiBtb2RpZmllciBmb3IgdGhlIGZvbnQgc2l6ZS4uXG4gICAgICogdGV4dHVyZSByZXNvbHV0aW9uIHdpbGwgYWxzbyBiZSB1c2VkIHRvIHNjYWxlIHRleHR1cmUgYWNjb3JkaW5nIHRvIGl0cyBmb250IHNpemUgYWxzb1xuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG4gICAgLyoqIFRoZSBwYWdlcyBvZiB0aGUgZm9udC4gKi9cbiAgICB0aGlzLnBhZ2VzID0gW107XG4gICAgdGhpcy5fcGFkZGluZyA9IDQ7XG4gICAgdGhpcy5fbWVhc3VyZUNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fY3VycmVudENoYXJzID0gW107XG4gICAgdGhpcy5fY3VycmVudFggPSAwO1xuICAgIHRoaXMuX2N1cnJlbnRZID0gMDtcbiAgICB0aGlzLl9jdXJyZW50UGFnZUluZGV4ID0gLTE7XG4gICAgdGhpcy5fc2tpcEtlcm5pbmcgPSBmYWxzZTtcbiAgICBjb25zdCBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc3R5bGUgPSBkeW5hbWljT3B0aW9ucy5zdHlsZS5jbG9uZSgpO1xuICAgIGlmIChkeW5hbWljT3B0aW9ucy5vdmVycmlkZUZpbGwpIHtcbiAgICAgIHN0eWxlLl9maWxsLmNvbG9yID0gMTY3NzcyMTU7XG4gICAgICBzdHlsZS5fZmlsbC5hbHBoYSA9IDE7XG4gICAgICBzdHlsZS5fZmlsbC50ZXh0dXJlID0gVGV4dHVyZS5XSElURTtcbiAgICAgIHN0eWxlLl9maWxsLmZpbGwgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ZWRGb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xuICAgIHN0eWxlLmZvbnRTaXplID0gdGhpcy5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZTtcbiAgICBjb25zdCBmb250ID0gZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUoc3R5bGUpO1xuICAgIGlmIChkeW5hbWljT3B0aW9ucy5vdmVycmlkZVNpemUpIHtcbiAgICAgIGlmIChzdHlsZS5fc3Ryb2tlKSB7XG4gICAgICAgIHN0eWxlLl9zdHJva2Uud2lkdGggKj0gdGhpcy5iYXNlUmVuZGVyZWRGb250U2l6ZSAvIHJlcXVlc3RlZEZvbnRTaXplO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5mb250U2l6ZSA9IHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgPSByZXF1ZXN0ZWRGb250U2l6ZTtcbiAgICB9XG4gICAgdGhpcy5fc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLl9za2lwS2VybmluZyA9IGR5bmFtaWNPcHRpb25zLnNraXBLZXJuaW5nID8/IGZhbHNlO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IGR5bmFtaWNPcHRpb25zLnJlc29sdXRpb24gPz8gMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gZHluYW1pY09wdGlvbnMucGFkZGluZyA/PyA0O1xuICAgIHRoaXMuZm9udE1ldHJpY3MgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlRm9udChmb250KTtcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IHRoaXMuZm9udE1ldHJpY3MuZm9udFNpemUgfHwgc3R5bGUuZm9udFNpemU7XG4gIH1cbiAgZW5zdXJlQ2hhcmFjdGVycyhjaGFycykge1xuICAgIGNvbnN0IGNoYXJMaXN0ID0gcmVzb2x2ZUNoYXJhY3RlcnMoY2hhcnMpLmZpbHRlcigoY2hhcikgPT4gIXRoaXMuX2N1cnJlbnRDaGFycy5pbmNsdWRlcyhjaGFyKSkuZmlsdGVyKChjaGFyLCBpbmRleCwgc2VsZikgPT4gc2VsZi5pbmRleE9mKGNoYXIpID09PSBpbmRleCk7XG4gICAgaWYgKCFjaGFyTGlzdC5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY3VycmVudENoYXJzID0gWy4uLnRoaXMuX2N1cnJlbnRDaGFycywgLi4uY2hhckxpc3RdO1xuICAgIGxldCBwYWdlRGF0YTtcbiAgICBpZiAodGhpcy5fY3VycmVudFBhZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgIHBhZ2VEYXRhID0gdGhpcy5fbmV4dFBhZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnZURhdGEgPSB0aGlzLnBhZ2VzW3RoaXMuX2N1cnJlbnRQYWdlSW5kZXhdO1xuICAgIH1cbiAgICBsZXQgeyBjYW52YXMsIGNvbnRleHQgfSA9IHBhZ2VEYXRhLmNhbnZhc0FuZENvbnRleHQ7XG4gICAgbGV0IHRleHR1cmVTb3VyY2UgPSBwYWdlRGF0YS50ZXh0dXJlLnNvdXJjZTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgIGxldCBjdXJyZW50WCA9IHRoaXMuX2N1cnJlbnRYO1xuICAgIGxldCBjdXJyZW50WSA9IHRoaXMuX2N1cnJlbnRZO1xuICAgIGNvbnN0IGZvbnRTY2FsZSA9IHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgLyB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nICogZm9udFNjYWxlO1xuICAgIGNvbnN0IHdpZHRoU2NhbGUgPSBzdHlsZS5mb250U3R5bGUgPT09IFwiaXRhbGljXCIgPyAyIDogMTtcbiAgICBsZXQgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgbGV0IHNraXBUZXh0dXJlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJMaXN0W2ldO1xuICAgICAgY29uc3QgbWV0cmljcyA9IENhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVUZXh0KGNoYXIsIHN0eWxlLCBjYW52YXMsIGZhbHNlKTtcbiAgICAgIG1ldHJpY3MubGluZUhlaWdodCA9IG1ldHJpY3MuaGVpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSB3aWR0aFNjYWxlICogbWV0cmljcy53aWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IG1ldHJpY3MuaGVpZ2h0ICogZm9udFNjYWxlO1xuICAgICAgY29uc3QgcGFkZGVkV2lkdGggPSB3aWR0aCArIHBhZGRpbmcgKiAyO1xuICAgICAgY29uc3QgcGFkZGVkSGVpZ2h0ID0gaGVpZ2h0ICsgcGFkZGluZyAqIDI7XG4gICAgICBza2lwVGV4dHVyZSA9IGZhbHNlO1xuICAgICAgaWYgKGNoYXIgIT09IFwiXFxuXCIgJiYgY2hhciAhPT0gXCJcXHJcIiAmJiBjaGFyICE9PSBcIlx0XCIgJiYgY2hhciAhPT0gXCIgXCIpIHtcbiAgICAgICAgc2tpcFRleHR1cmUgPSB0cnVlO1xuICAgICAgICBtYXhDaGFySGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubWF4KHBhZGRlZEhlaWdodCwgbWF4Q2hhckhlaWdodCkpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRYICsgcGFkZGVkV2lkdGggPiA1MTIpIHtcbiAgICAgICAgY3VycmVudFkgKz0gbWF4Q2hhckhlaWdodDtcbiAgICAgICAgbWF4Q2hhckhlaWdodCA9IHBhZGRlZEhlaWdodDtcbiAgICAgICAgY3VycmVudFggPSAwO1xuICAgICAgICBpZiAoY3VycmVudFkgKyBtYXhDaGFySGVpZ2h0ID4gNTEyKSB7XG4gICAgICAgICAgdGV4dHVyZVNvdXJjZS51cGRhdGUoKTtcbiAgICAgICAgICBjb25zdCBwYWdlRGF0YTIgPSB0aGlzLl9uZXh0UGFnZSgpO1xuICAgICAgICAgIGNhbnZhcyA9IHBhZ2VEYXRhMi5jYW52YXNBbmRDb250ZXh0LmNhbnZhcztcbiAgICAgICAgICBjb250ZXh0ID0gcGFnZURhdGEyLmNhbnZhc0FuZENvbnRleHQuY29udGV4dDtcbiAgICAgICAgICB0ZXh0dXJlU291cmNlID0gcGFnZURhdGEyLnRleHR1cmUuc291cmNlO1xuICAgICAgICAgIGN1cnJlbnRZID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgeEFkdmFuY2UgPSB3aWR0aCAvIGZvbnRTY2FsZSAtIChzdHlsZS5kcm9wU2hhZG93Py5kaXN0YW5jZSA/PyAwKSAtIChzdHlsZS5fc3Ryb2tlPy53aWR0aCA/PyAwKTtcbiAgICAgIHRoaXMuY2hhcnNbY2hhcl0gPSB7XG4gICAgICAgIGlkOiBjaGFyLmNvZGVQb2ludEF0KDApLFxuICAgICAgICB4T2Zmc2V0OiAtdGhpcy5fcGFkZGluZyxcbiAgICAgICAgeU9mZnNldDogLXRoaXMuX3BhZGRpbmcsXG4gICAgICAgIHhBZHZhbmNlLFxuICAgICAgICBrZXJuaW5nOiB7fVxuICAgICAgfTtcbiAgICAgIGlmIChza2lwVGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9kcmF3R2x5cGgoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBtZXRyaWNzLFxuICAgICAgICAgIGN1cnJlbnRYICsgcGFkZGluZyxcbiAgICAgICAgICBjdXJyZW50WSArIHBhZGRpbmcsXG4gICAgICAgICAgZm9udFNjYWxlLFxuICAgICAgICAgIHN0eWxlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHB4ID0gdGV4dHVyZVNvdXJjZS53aWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgICAgY29uc3QgcHkgPSB0ZXh0dXJlU291cmNlLmhlaWdodCAqIGZvbnRTY2FsZTtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgIGN1cnJlbnRYIC8gcHggKiB0ZXh0dXJlU291cmNlLndpZHRoLFxuICAgICAgICAgIGN1cnJlbnRZIC8gcHkgKiB0ZXh0dXJlU291cmNlLmhlaWdodCxcbiAgICAgICAgICBwYWRkZWRXaWR0aCAvIHB4ICogdGV4dHVyZVNvdXJjZS53aWR0aCxcbiAgICAgICAgICBwYWRkZWRIZWlnaHQgLyBweSAqIHRleHR1cmVTb3VyY2UuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2hhcnNbY2hhcl0udGV4dHVyZSA9IG5ldyBUZXh0dXJlKHtcbiAgICAgICAgICBzb3VyY2U6IHRleHR1cmVTb3VyY2UsXG4gICAgICAgICAgZnJhbWVcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnRYICs9IE1hdGguY2VpbChwYWRkZWRXaWR0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRleHR1cmVTb3VyY2UudXBkYXRlKCk7XG4gICAgdGhpcy5fY3VycmVudFggPSBjdXJyZW50WDtcbiAgICB0aGlzLl9jdXJyZW50WSA9IGN1cnJlbnRZO1xuICAgIHRoaXMuX3NraXBLZXJuaW5nICYmIHRoaXMuX2FwcGx5S2VybmluZyhjaGFyTGlzdCwgY29udGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wXG4gICAqIFRoZSBtYXAgb2YgYmFzZSBwYWdlIHRleHR1cmVzIChpLmUuLCBzaGVldHMgb2YgZ2x5cGhzKS5cbiAgICovXG4gIGdldCBwYWdlVGV4dHVyZXMoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQucGFnZVRleHR1cmVzIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgQml0bWFwRm9udC5wYWdlcyBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlcztcbiAgfVxuICBfYXBwbHlLZXJuaW5nKG5ld0NoYXJzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbWVhc3VyZUNhY2hlID0gdGhpcy5fbWVhc3VyZUNhY2hlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gbmV3Q2hhcnNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2N1cnJlbnRDaGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBzZWNvbmQgPSB0aGlzLl9jdXJyZW50Q2hhcnNbal07XG4gICAgICAgIGxldCBjMSA9IG1lYXN1cmVDYWNoZVtmaXJzdF07XG4gICAgICAgIGlmICghYzEpXG4gICAgICAgICAgYzEgPSBtZWFzdXJlQ2FjaGVbZmlyc3RdID0gY29udGV4dC5tZWFzdXJlVGV4dChmaXJzdCkud2lkdGg7XG4gICAgICAgIGxldCBjMiA9IG1lYXN1cmVDYWNoZVtzZWNvbmRdO1xuICAgICAgICBpZiAoIWMyKVxuICAgICAgICAgIGMyID0gbWVhc3VyZUNhY2hlW3NlY29uZF0gPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHNlY29uZCkud2lkdGg7XG4gICAgICAgIGxldCB0b3RhbCA9IGNvbnRleHQubWVhc3VyZVRleHQoZmlyc3QgKyBzZWNvbmQpLndpZHRoO1xuICAgICAgICBsZXQgYW1vdW50ID0gdG90YWwgLSAoYzEgKyBjMik7XG4gICAgICAgIGlmIChhbW91bnQpIHtcbiAgICAgICAgICB0aGlzLmNoYXJzW2ZpcnN0XS5rZXJuaW5nW3NlY29uZF0gPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgICAgdG90YWwgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGZpcnN0ICsgc2Vjb25kKS53aWR0aDtcbiAgICAgICAgYW1vdW50ID0gdG90YWwgLSAoYzEgKyBjMik7XG4gICAgICAgIGlmIChhbW91bnQpIHtcbiAgICAgICAgICB0aGlzLmNoYXJzW3NlY29uZF0ua2VybmluZ1tmaXJzdF0gPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX25leHRQYWdlKCkge1xuICAgIHRoaXMuX2N1cnJlbnRQYWdlSW5kZXgrKztcbiAgICBjb25zdCB0ZXh0dXJlUmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gQ2FudmFzUG9vbC5nZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dCg1MTIsIDUxMiwgdGV4dHVyZVJlc29sdXRpb24pO1xuICAgIHRoaXMuX3NldHVwQ29udGV4dChjYW52YXNBbmRDb250ZXh0LmNvbnRleHQsIHRoaXMuX3N0eWxlLCB0ZXh0dXJlUmVzb2x1dGlvbik7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRleHR1cmVSZXNvbHV0aW9uICogKHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgLyB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoe1xuICAgICAgc291cmNlOiBuZXcgSW1hZ2VTb3VyY2Uoe1xuICAgICAgICByZXNvdXJjZTogY2FudmFzQW5kQ29udGV4dC5jYW52YXMsXG4gICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgIGFscGhhTW9kZTogXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCBwYWdlRGF0YSA9IHtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQsXG4gICAgICB0ZXh0dXJlXG4gICAgfTtcbiAgICB0aGlzLnBhZ2VzW3RoaXMuX2N1cnJlbnRQYWdlSW5kZXhdID0gcGFnZURhdGE7XG4gICAgcmV0dXJuIHBhZ2VEYXRhO1xuICB9XG4gIC8vIGNhbnZhcyBzdHlsZSFcbiAgX3NldHVwQ29udGV4dChjb250ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbikge1xuICAgIHN0eWxlLmZvbnRTaXplID0gdGhpcy5iYXNlUmVuZGVyZWRGb250U2l6ZTtcbiAgICBjb250ZXh0LnNjYWxlKHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKTtcbiAgICBzdHlsZS5mb250U2l6ZSA9IHRoaXMuYmFzZU1lYXN1cmVtZW50Rm9udFNpemU7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgY29uc3Qgc3Ryb2tlID0gc3R5bGUuX3N0cm9rZTtcbiAgICBjb25zdCBzdHJva2VUaGlja25lc3MgPSBzdHJva2U/LndpZHRoID8/IDA7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHJva2VUaGlja25lc3M7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gc3Ryb2tlLmpvaW47XG4gICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2UubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNGaWxsU3R5bGUoc3Ryb2tlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHN0eWxlLl9maWxsKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdldENhbnZhc0ZpbGxTdHlsZShzdHlsZS5fZmlsbCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICBjb25zdCBzaGFkb3dPcHRpb25zID0gc3R5bGUuZHJvcFNoYWRvdztcbiAgICAgIGNvbnN0IHJnYiA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShzaGFkb3dPcHRpb25zLmNvbG9yKS50b0FycmF5KCk7XG4gICAgICBjb25zdCBkcm9wU2hhZG93Qmx1ciA9IHNoYWRvd09wdGlvbnMuYmx1ciAqIHJlc29sdXRpb247XG4gICAgICBjb25zdCBkcm9wU2hhZG93RGlzdGFuY2UgPSBzaGFkb3dPcHRpb25zLmRpc3RhbmNlICogcmVzb2x1dGlvbjtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBgcmdiYSgke3JnYlswXSAqIDI1NX0sJHtyZ2JbMV0gKiAyNTV9LCR7cmdiWzJdICogMjU1fSwke3NoYWRvd09wdGlvbnMuYWxwaGF9KWA7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IE1hdGguY29zKHNoYWRvd09wdGlvbnMuYW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc2hhZG93T3B0aW9ucy5hbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgfVxuICB9XG4gIF9kcmF3R2x5cGgoY29udGV4dCwgbWV0cmljcywgeCwgeSwgZm9udFNjYWxlLCBzdHlsZSkge1xuICAgIGNvbnN0IGNoYXIgPSBtZXRyaWNzLnRleHQ7XG4gICAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHN0cm9rZSA9IHN0eWxlLl9zdHJva2U7XG4gICAgY29uc3Qgc3Ryb2tlVGhpY2tuZXNzID0gKHN0cm9rZT8ud2lkdGggPz8gMCkgKiBmb250U2NhbGU7XG4gICAgY29uc3QgdHggPSB4ICsgc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICBjb25zdCB0eSA9IHkgLSBzdHJva2VUaGlja25lc3MgLyAyO1xuICAgIGNvbnN0IGRlc2NlbnQgPSBmb250UHJvcGVydGllcy5kZXNjZW50ICogZm9udFNjYWxlO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBtZXRyaWNzLmxpbmVIZWlnaHQgKiBmb250U2NhbGU7XG4gICAgaWYgKHN0eWxlLnN0cm9rZSAmJiBzdHJva2VUaGlja25lc3MpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChjaGFyLCB0eCwgdHkgKyBsaW5lSGVpZ2h0IC0gZGVzY2VudCk7XG4gICAgfVxuICAgIGlmIChzdHlsZS5fZmlsbCkge1xuICAgICAgY29udGV4dC5maWxsVGV4dChjaGFyLCB0eCwgdHkgKyBsaW5lSGVpZ2h0IC0gZGVzY2VudCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBjYW52YXNBbmRDb250ZXh0LCB0ZXh0dXJlIH0gPSB0aGlzLnBhZ2VzW2ldO1xuICAgICAgQ2FudmFzUG9vbC5yZXR1cm5DYW52YXNBbmRDb250ZXh0KGNhbnZhc0FuZENvbnRleHQpO1xuICAgICAgdGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnBhZ2VzID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBEeW5hbWljQml0bWFwRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHluYW1pY0JpdG1hcEZvbnQubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRCaXRtYXBUZXh0TGF5b3V0KGNoYXJzLCBzdHlsZSwgZm9udCkge1xuICBjb25zdCBsYXlvdXREYXRhID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBvZmZzZXRZOiAwLFxuICAgIHNjYWxlOiBzdHlsZS5mb250U2l6ZSAvIGZvbnQuYmFzZU1lYXN1cmVtZW50Rm9udFNpemUsXG4gICAgbGluZXM6IFt7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGNoYXJQb3NpdGlvbnM6IFtdLFxuICAgICAgc3BhY2VXaWR0aDogMCxcbiAgICAgIHNwYWNlc0luZGV4OiBbXSxcbiAgICAgIGNoYXJzOiBbXVxuICAgIH1dXG4gIH07XG4gIGxheW91dERhdGEub2Zmc2V0WSA9IGZvbnQuYmFzZUxpbmVPZmZzZXQ7XG4gIGxldCBjdXJyZW50TGluZSA9IGxheW91dERhdGEubGluZXNbMF07XG4gIGxldCBwcmV2aW91c0NoYXIgPSBudWxsO1xuICBsZXQgZmlyc3RXb3JkID0gdHJ1ZTtcbiAgY29uc3QgY3VycmVudFdvcmQgPSB7XG4gICAgc3BhY2VXb3JkOiBmYWxzZSxcbiAgICB3aWR0aDogMCxcbiAgICBzdGFydDogMCxcbiAgICBpbmRleDogMCxcbiAgICAvLyB1c2UgaW5kZXggdG8gbm90IG1vZGlmeSB0aGUgYXJyYXkgYXMgd2UgdXNlIGl0IGEgbG90IVxuICAgIHBvc2l0aW9uczogW10sXG4gICAgY2hhcnM6IFtdXG4gIH07XG4gIGNvbnN0IG5leHRXb3JkID0gKHdvcmQpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IGN1cnJlbnRMaW5lLndpZHRoO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VycmVudFdvcmQuaW5kZXg7IGorKykge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB3b3JkLnBvc2l0aW9uc1tqXTtcbiAgICAgIGN1cnJlbnRMaW5lLmNoYXJzLnB1c2god29yZC5jaGFyc1tqXSk7XG4gICAgICBjdXJyZW50TGluZS5jaGFyUG9zaXRpb25zLnB1c2gocG9zaXRpb24gKyBzdGFydCk7XG4gICAgfVxuICAgIGN1cnJlbnRMaW5lLndpZHRoICs9IHdvcmQud2lkdGg7XG4gICAgZmlyc3RXb3JkID0gZmFsc2U7XG4gICAgY3VycmVudFdvcmQud2lkdGggPSAwO1xuICAgIGN1cnJlbnRXb3JkLmluZGV4ID0gMDtcbiAgICBjdXJyZW50V29yZC5jaGFycy5sZW5ndGggPSAwO1xuICB9O1xuICBjb25zdCBuZXh0TGluZSA9ICgpID0+IHtcbiAgICBsZXQgaW5kZXggPSBjdXJyZW50TGluZS5jaGFycy5sZW5ndGggLSAxO1xuICAgIGxldCBsYXN0Q2hhciA9IGN1cnJlbnRMaW5lLmNoYXJzW2luZGV4XTtcbiAgICB3aGlsZSAobGFzdENoYXIgPT09IFwiIFwiKSB7XG4gICAgICBjdXJyZW50TGluZS53aWR0aCAtPSBmb250LmNoYXJzW2xhc3RDaGFyXS54QWR2YW5jZTtcbiAgICAgIGxhc3RDaGFyID0gY3VycmVudExpbmUuY2hhcnNbLS1pbmRleF07XG4gICAgfVxuICAgIGxheW91dERhdGEud2lkdGggPSBNYXRoLm1heChsYXlvdXREYXRhLndpZHRoLCBjdXJyZW50TGluZS53aWR0aCk7XG4gICAgY3VycmVudExpbmUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGNoYXJQb3NpdGlvbnM6IFtdLFxuICAgICAgY2hhcnM6IFtdLFxuICAgICAgc3BhY2VXaWR0aDogMCxcbiAgICAgIHNwYWNlc0luZGV4OiBbXVxuICAgIH07XG4gICAgZmlyc3RXb3JkID0gdHJ1ZTtcbiAgICBsYXlvdXREYXRhLmxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgIGxheW91dERhdGEuaGVpZ2h0ICs9IGZvbnQubGluZUhlaWdodDtcbiAgfTtcbiAgY29uc3Qgc2NhbGUgPSBmb250LmJhc2VNZWFzdXJlbWVudEZvbnRTaXplIC8gc3R5bGUuZm9udFNpemU7XG4gIGNvbnN0IGFkanVzdGVkTGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmcgKiBzY2FsZTtcbiAgY29uc3QgYWRqdXN0ZWRXb3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCAqIHNjYWxlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aCArIDE7IGkrKykge1xuICAgIGxldCBjaGFyO1xuICAgIGNvbnN0IGlzRW5kID0gaSA9PT0gY2hhcnMubGVuZ3RoO1xuICAgIGlmICghaXNFbmQpIHtcbiAgICAgIGNoYXIgPSBjaGFyc1tpXTtcbiAgICB9XG4gICAgY29uc3QgY2hhckRhdGEgPSBmb250LmNoYXJzW2NoYXJdIHx8IGZvbnQuY2hhcnNbXCIgXCJdO1xuICAgIGNvbnN0IGlzU3BhY2UgPSAvKD86XFxzKS8udGVzdChjaGFyKTtcbiAgICBjb25zdCBpc1dvcmRCcmVhayA9IGlzU3BhY2UgfHwgY2hhciA9PT0gXCJcXHJcIiB8fCBjaGFyID09PSBcIlxcblwiIHx8IGlzRW5kO1xuICAgIGlmIChpc1dvcmRCcmVhaykge1xuICAgICAgY29uc3QgYWRkV29yZFRvTmV4dExpbmUgPSAhZmlyc3RXb3JkICYmIHN0eWxlLndvcmRXcmFwICYmIGN1cnJlbnRMaW5lLndpZHRoICsgY3VycmVudFdvcmQud2lkdGggLSBhZGp1c3RlZExldHRlclNwYWNpbmcgPiBhZGp1c3RlZFdvcmRXcmFwV2lkdGg7XG4gICAgICBpZiAoYWRkV29yZFRvTmV4dExpbmUpIHtcbiAgICAgICAgbmV4dExpbmUoKTtcbiAgICAgICAgbmV4dFdvcmQoY3VycmVudFdvcmQpO1xuICAgICAgICBpZiAoIWlzRW5kKSB7XG4gICAgICAgICAgY3VycmVudExpbmUuY2hhclBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50V29yZC5zdGFydCA9IGN1cnJlbnRMaW5lLndpZHRoO1xuICAgICAgICBuZXh0V29yZChjdXJyZW50V29yZCk7XG4gICAgICAgIGlmICghaXNFbmQpIHtcbiAgICAgICAgICBjdXJyZW50TGluZS5jaGFyUG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSBcIlxcclwiIHx8IGNoYXIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgbmV4dExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNFbmQpIHtcbiAgICAgICAgY29uc3Qgc3BhY2VXaWR0aCA9IGNoYXJEYXRhLnhBZHZhbmNlICsgKGNoYXJEYXRhLmtlcm5pbmdbcHJldmlvdXNDaGFyXSB8fCAwKSArIGFkanVzdGVkTGV0dGVyU3BhY2luZztcbiAgICAgICAgY3VycmVudExpbmUud2lkdGggKz0gc3BhY2VXaWR0aDtcbiAgICAgICAgY3VycmVudExpbmUuc3BhY2VXaWR0aCA9IHNwYWNlV2lkdGg7XG4gICAgICAgIGN1cnJlbnRMaW5lLnNwYWNlc0luZGV4LnB1c2goY3VycmVudExpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGgpO1xuICAgICAgICBjdXJyZW50TGluZS5jaGFycy5wdXNoKGNoYXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXJuaW5nID0gY2hhckRhdGEua2VybmluZ1twcmV2aW91c0NoYXJdIHx8IDA7XG4gICAgICBjb25zdCBuZXh0Q2hhcldpZHRoID0gY2hhckRhdGEueEFkdmFuY2UgKyBrZXJuaW5nICsgYWRqdXN0ZWRMZXR0ZXJTcGFjaW5nO1xuICAgICAgY3VycmVudFdvcmQucG9zaXRpb25zW2N1cnJlbnRXb3JkLmluZGV4KytdID0gY3VycmVudFdvcmQud2lkdGggKyBrZXJuaW5nO1xuICAgICAgY3VycmVudFdvcmQuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgIGN1cnJlbnRXb3JkLndpZHRoICs9IG5leHRDaGFyV2lkdGg7XG4gICAgfVxuICAgIHByZXZpb3VzQ2hhciA9IGNoYXI7XG4gIH1cbiAgbmV4dExpbmUoKTtcbiAgaWYgKHN0eWxlLmFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgYWxpZ25DZW50ZXIobGF5b3V0RGF0YSk7XG4gIH0gZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgIGFsaWduUmlnaHQobGF5b3V0RGF0YSk7XG4gIH0gZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09IFwianVzdGlmeVwiKSB7XG4gICAgYWxpZ25KdXN0aWZ5KGxheW91dERhdGEpO1xuICB9XG4gIHJldHVybiBsYXlvdXREYXRhO1xufVxuZnVuY3Rpb24gYWxpZ25DZW50ZXIobWVhc3VyZW1lbnREYXRhKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyZW1lbnREYXRhLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IG1lYXN1cmVtZW50RGF0YS5saW5lc1tpXTtcbiAgICBjb25zdCBvZmZzZXQgPSBtZWFzdXJlbWVudERhdGEud2lkdGggLyAyIC0gbGluZS53aWR0aCAvIDI7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxpbmUuY2hhclBvc2l0aW9uc1tqXSArPSBvZmZzZXQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhbGlnblJpZ2h0KG1lYXN1cmVtZW50RGF0YSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmVtZW50RGF0YS5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBtZWFzdXJlbWVudERhdGEubGluZXNbaV07XG4gICAgY29uc3Qgb2Zmc2V0ID0gbWVhc3VyZW1lbnREYXRhLndpZHRoIC0gbGluZS53aWR0aDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgbGluZS5jaGFyUG9zaXRpb25zW2pdICs9IG9mZnNldDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFsaWduSnVzdGlmeShtZWFzdXJlbWVudERhdGEpIHtcbiAgY29uc3Qgd2lkdGggPSBtZWFzdXJlbWVudERhdGEud2lkdGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyZW1lbnREYXRhLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IG1lYXN1cmVtZW50RGF0YS5saW5lc1tpXTtcbiAgICBsZXQgaW5keSA9IDA7XG4gICAgbGV0IHNwYWNlSW5kZXggPSBsaW5lLnNwYWNlc0luZGV4W2luZHkrK107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgdG90YWxTcGFjZXMgPSBsaW5lLnNwYWNlc0luZGV4Lmxlbmd0aDtcbiAgICBjb25zdCBuZXdTcGFjZVdpZHRoID0gKHdpZHRoIC0gbGluZS53aWR0aCkgLyB0b3RhbFNwYWNlcztcbiAgICBjb25zdCBzcGFjZVdpZHRoID0gbmV3U3BhY2VXaWR0aDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGogPT09IHNwYWNlSW5kZXgpIHtcbiAgICAgICAgc3BhY2VJbmRleCA9IGxpbmUuc3BhY2VzSW5kZXhbaW5keSsrXTtcbiAgICAgICAgb2Zmc2V0ICs9IHNwYWNlV2lkdGg7XG4gICAgICB9XG4gICAgICBsaW5lLmNoYXJQb3NpdGlvbnNbal0gKz0gb2Zmc2V0O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBnZXRCaXRtYXBUZXh0TGF5b3V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRCaXRtYXBUZXh0TGF5b3V0Lm1qcy5tYXBcbiIsImltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi4vLi4vYXNzZXRzL2NhY2hlL0NhY2hlLm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnLi4vdGV4dC9UZXh0U3R5bGUubWpzJztcbmltcG9ydCB7IER5bmFtaWNCaXRtYXBGb250IH0gZnJvbSAnLi9EeW5hbWljQml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgZ2V0Qml0bWFwVGV4dExheW91dCB9IGZyb20gJy4vdXRpbHMvZ2V0Qml0bWFwVGV4dExheW91dC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQml0bWFwRm9udE1hbmFnZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2hhcmFjdGVyIHNldCBpbmNsdWRlcyBhbGwgdGhlIGxldHRlcnMgaW4gdGhlIGFscGhhYmV0IChib3RoIGxvd2VyLSBhbmQgdXBwZXItIGNhc2UpLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXVtdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogQml0bWFwRm9udC5mcm9tKCdFeGFtcGxlRm9udCcsIHN0eWxlLCB7IGNoYXJzOiBCaXRtYXBGb250LkFMUEhBIH0pXG4gICAgICovXG4gICAgdGhpcy5BTFBIQSA9IFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFwiIFwiXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoYXJhY3RlciBzZXQgaW5jbHVkZXMgYWxsIGRlY2ltYWwgZGlnaXRzIChmcm9tIDAgdG8gOSkuXG4gICAgICogQHR5cGUge3N0cmluZ1tdW119XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBCaXRtYXBGb250LmZyb20oJ0V4YW1wbGVGb250Jywgc3R5bGUsIHsgY2hhcnM6IEJpdG1hcEZvbnQuTlVNRVJJQyB9KVxuICAgICAqL1xuICAgIHRoaXMuTlVNRVJJQyA9IFtbXCIwXCIsIFwiOVwiXV07XG4gICAgLyoqXG4gICAgICogVGhpcyBjaGFyYWN0ZXIgc2V0IGlzIHRoZSB1bmlvbiBvZiBgQml0bWFwRm9udC5BTFBIQWAgYW5kIGBCaXRtYXBGb250Lk5VTUVSSUNgLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXVtdfVxuICAgICAqL1xuICAgIHRoaXMuQUxQSEFOVU1FUklDID0gW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl0sIFwiIFwiXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoYXJhY3RlciBzZXQgY29uc2lzdHMgb2YgYWxsIHRoZSBBU0NJSSB0YWJsZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmdbXVtdfVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy5hc2NpaXRhYmxlLmNvbS9cbiAgICAgKi9cbiAgICB0aGlzLkFTQ0lJID0gW1tcIiBcIiwgXCJ+XCJdXTtcbiAgICAvKiogRGVmYXVsdCBvcHRpb25zIGZvciBpbnN0YWxsaW5nIGEgbmV3IEJpdG1hcEZvbnQuICovXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGNoYXJzOiB0aGlzLkFMUEhBTlVNRVJJQyxcbiAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICBwYWRkaW5nOiA0LFxuICAgICAgc2tpcEtlcm5pbmc6IGZhbHNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgZm9udCBmb3IgdGhlIHNwZWNpZmllZCB0ZXh0IGFuZCBzdHlsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBnZXQgdGhlIGZvbnQgZm9yXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSB0byB1c2VcbiAgICovXG4gIGdldEZvbnQodGV4dCwgc3R5bGUpIHtcbiAgICBsZXQgZm9udEZhbWlseUtleSA9IGAke3N0eWxlLmZvbnRGYW1pbHl9LWJpdG1hcGA7XG4gICAgbGV0IG92ZXJyaWRlRmlsbCA9IHRydWU7XG4gICAgaWYgKHN0eWxlLl9maWxsLmZpbGwpIHtcbiAgICAgIGZvbnRGYW1pbHlLZXkgKz0gc3R5bGUuX2ZpbGwuZmlsbC51aWQ7XG4gICAgICBvdmVycmlkZUZpbGwgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFDYWNoZS5oYXMoZm9udEZhbWlseUtleSkpIHtcbiAgICAgIGNvbnN0IGZudCA9IG5ldyBEeW5hbWljQml0bWFwRm9udCh7XG4gICAgICAgIHN0eWxlLFxuICAgICAgICBvdmVycmlkZUZpbGwsXG4gICAgICAgIG92ZXJyaWRlU2l6ZTogdHJ1ZSxcbiAgICAgICAgLi4udGhpcy5kZWZhdWx0T3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBmbnQub25jZShcImRlc3Ryb3lcIiwgKCkgPT4gQ2FjaGUucmVtb3ZlKGZvbnRGYW1pbHlLZXkpKTtcbiAgICAgIENhY2hlLnNldChcbiAgICAgICAgZm9udEZhbWlseUtleSxcbiAgICAgICAgZm50XG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBkeW5hbWljRm9udCA9IENhY2hlLmdldChmb250RmFtaWx5S2V5KTtcbiAgICBkeW5hbWljRm9udC5lbnN1cmVDaGFyYWN0ZXJzPy4odGV4dCk7XG4gICAgcmV0dXJuIGR5bmFtaWNGb250O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheW91dCBvZiBhIHRleHQgZm9yIHRoZSBzcGVjaWZpZWQgc3R5bGUuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHQgdG8gZ2V0IHRoZSBsYXlvdXQgZm9yXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSB0byB1c2VcbiAgICovXG4gIGdldExheW91dCh0ZXh0LCBzdHlsZSkge1xuICAgIGNvbnN0IGJpdG1hcEZvbnQgPSB0aGlzLmdldEZvbnQodGV4dCwgc3R5bGUpO1xuICAgIHJldHVybiBnZXRCaXRtYXBUZXh0TGF5b3V0KFsuLi50ZXh0XSwgc3R5bGUsIGJpdG1hcEZvbnQpO1xuICB9XG4gIC8qKlxuICAgKiBNZWFzdXJlIHRoZSB0ZXh0IHVzaW5nIHRoZSBzcGVjaWZpZWQgc3R5bGUuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHQgdG8gbWVhc3VyZVxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgc3R5bGUgdG8gdXNlXG4gICAqL1xuICBtZWFzdXJlVGV4dCh0ZXh0LCBzdHlsZSkge1xuICAgIHJldHVybiB0aGlzLmdldExheW91dCh0ZXh0LCBzdHlsZSk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgaW5zdGFsbCguLi5hcmdzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmdzWzBdO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgbmFtZTogb3B0aW9ucyxcbiAgICAgICAgc3R5bGU6IGFyZ3NbMV0sXG4gICAgICAgIGNoYXJzOiBhcmdzWzJdPy5jaGFycyxcbiAgICAgICAgcmVzb2x1dGlvbjogYXJnc1syXT8ucmVzb2x1dGlvbixcbiAgICAgICAgcGFkZGluZzogYXJnc1syXT8ucGFkZGluZyxcbiAgICAgICAgc2tpcEtlcm5pbmc6IGFyZ3NbMl0/LnNraXBLZXJuaW5nXG4gICAgICB9O1xuICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnRNYW5hZ2VyLmluc3RhbGwobmFtZSwgc3R5bGUsIG9wdGlvbnMpIGlzIGRlcHJlY2F0ZWQsIHVzZSBCaXRtYXBGb250TWFuYWdlci5pbnN0YWxsKHtuYW1lLCBzdHlsZSwgLi4ub3B0aW9uc30pXCIpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gb3B0aW9ucz8ubmFtZTtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250TWFuYWdlcl0gUHJvcGVydHkgYG5hbWVgIGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4udGhpcy5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHRleHRTdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgY29uc3Qgc3R5bGUgPSB0ZXh0U3R5bGUgaW5zdGFuY2VvZiBUZXh0U3R5bGUgPyB0ZXh0U3R5bGUgOiBuZXcgVGV4dFN0eWxlKHRleHRTdHlsZSk7XG4gICAgY29uc3Qgb3ZlcnJpZGVGaWxsID0gc3R5bGUuX2ZpbGwuZmlsbCAhPT0gbnVsbCAmJiBzdHlsZS5fZmlsbC5maWxsICE9PSB2b2lkIDA7XG4gICAgY29uc3QgZm9udCA9IG5ldyBEeW5hbWljQml0bWFwRm9udCh7XG4gICAgICBzdHlsZSxcbiAgICAgIG92ZXJyaWRlRmlsbCxcbiAgICAgIHNraXBLZXJuaW5nOiBvcHRpb25zLnNraXBLZXJuaW5nLFxuICAgICAgcGFkZGluZzogb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcmVzb2x1dGlvbjogb3B0aW9ucy5yZXNvbHV0aW9uLFxuICAgICAgb3ZlcnJpZGVTaXplOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IGZsYXRDaGFycyA9IHJlc29sdmVDaGFyYWN0ZXJzKG9wdGlvbnMuY2hhcnMpO1xuICAgIGZvbnQuZW5zdXJlQ2hhcmFjdGVycyhmbGF0Q2hhcnMuam9pbihcIlwiKSk7XG4gICAgQ2FjaGUuc2V0KGAke25hbWV9LWJpdG1hcGAsIGZvbnQpO1xuICAgIGZvbnQub25jZShcImRlc3Ryb3lcIiwgKCkgPT4gQ2FjaGUucmVtb3ZlKGAke25hbWV9LWJpdG1hcGApKTtcbiAgICByZXR1cm4gZm9udDtcbiAgfVxuICAvKipcbiAgICogVW5pbnN0YWxscyBhIGJpdG1hcCBmb250IGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaXRtYXAgZm9udCB0byB1bmluc3RhbGwuXG4gICAqL1xuICB1bmluc3RhbGwobmFtZSkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7bmFtZX0tYml0bWFwYDtcbiAgICBjb25zdCBmb250ID0gQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoZm9udCkge1xuICAgICAgQ2FjaGUucmVtb3ZlKGNhY2hlS2V5KTtcbiAgICAgIGZvbnQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgQml0bWFwRm9udE1hbmFnZXIgPSBuZXcgQml0bWFwRm9udE1hbmFnZXJDbGFzcygpO1xuXG5leHBvcnQgeyBCaXRtYXBGb250TWFuYWdlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwRm9udE1hbmFnZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgQWJzdHJhY3RCaXRtYXBGb250IH0gZnJvbSAnLi9BYnN0cmFjdEJpdG1hcEZvbnQubWpzJztcbmltcG9ydCB7IEJpdG1hcEZvbnRNYW5hZ2VyIH0gZnJvbSAnLi9CaXRtYXBGb250TWFuYWdlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJpdG1hcEZvbnQgZXh0ZW5kcyBBYnN0cmFjdEJpdG1hcEZvbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCB1cmwpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHsgdGV4dHVyZXMsIGRhdGEgfSA9IG9wdGlvbnM7XG4gICAgT2JqZWN0LmtleXMoZGF0YS5wYWdlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBwYWdlRGF0YSA9IGRhdGEucGFnZXNbcGFyc2VJbnQoa2V5LCAxMCldO1xuICAgICAgY29uc3QgdGV4dHVyZSA9IHRleHR1cmVzW3BhZ2VEYXRhLmlkXTtcbiAgICAgIHRoaXMucGFnZXMucHVzaCh7IHRleHR1cmUgfSk7XG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMoZGF0YS5jaGFycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBjaGFyRGF0YSA9IGRhdGEuY2hhcnNba2V5XTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZnJhbWU6IHRleHR1cmVGcmFtZSxcbiAgICAgICAgc291cmNlOiB0ZXh0dXJlU291cmNlXG4gICAgICB9ID0gdGV4dHVyZXNbY2hhckRhdGEucGFnZV07XG4gICAgICBjb25zdCBmcmFtZVJlYWwgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICBjaGFyRGF0YS54ICsgdGV4dHVyZUZyYW1lLngsXG4gICAgICAgIGNoYXJEYXRhLnkgKyB0ZXh0dXJlRnJhbWUueSxcbiAgICAgICAgY2hhckRhdGEud2lkdGgsXG4gICAgICAgIGNoYXJEYXRhLmhlaWdodFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSh7XG4gICAgICAgIHNvdXJjZTogdGV4dHVyZVNvdXJjZSxcbiAgICAgICAgZnJhbWU6IGZyYW1lUmVhbFxuICAgICAgfSk7XG4gICAgICB0aGlzLmNoYXJzW2tleV0gPSB7XG4gICAgICAgIGlkOiBrZXkuY29kZVBvaW50QXQoMCksXG4gICAgICAgIHhPZmZzZXQ6IGNoYXJEYXRhLnhPZmZzZXQsXG4gICAgICAgIHlPZmZzZXQ6IGNoYXJEYXRhLnlPZmZzZXQsXG4gICAgICAgIHhBZHZhbmNlOiBjaGFyRGF0YS54QWR2YW5jZSxcbiAgICAgICAga2VybmluZzogY2hhckRhdGEua2VybmluZyA/PyB7fSxcbiAgICAgICAgdGV4dHVyZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICB0aGlzLmJhc2VNZWFzdXJlbWVudEZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICB0aGlzLmZvbnRNZXRyaWNzID0ge1xuICAgICAgYXNjZW50OiAwLFxuICAgICAgZGVzY2VudDogMCxcbiAgICAgIGZvbnRTaXplOiBkYXRhLmZvbnRTaXplXG4gICAgfTtcbiAgICB0aGlzLmJhc2VMaW5lT2Zmc2V0ID0gZGF0YS5iYXNlTGluZU9mZnNldDtcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSBkYXRhLmxpbmVIZWlnaHQ7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gZGF0YS5mb250RmFtaWx5O1xuICAgIHRoaXMuZGlzdGFuY2VGaWVsZCA9IGRhdGEuZGlzdGFuY2VGaWVsZCA/PyB7XG4gICAgICB0eXBlOiBcIm5vbmVcIixcbiAgICAgIHJhbmdlOiAwXG4gICAgfTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIEJpdG1hcEZvbnQgb2JqZWN0LiAqL1xuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgdGV4dHVyZSB9ID0gdGhpcy5wYWdlc1tpXTtcbiAgICAgIHRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5wYWdlcyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGJpdG1hcC1mb250IGZvciB0aGUgZ2l2ZW4gc3R5bGUgYW5kIGNoYXJhY3RlciBzZXRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBTZXR1cCBvcHRpb25zIGZvciBmb250IGdlbmVyYXRpb24uXG4gICAqIEByZXR1cm5zIEZvbnQgZ2VuZXJhdGVkIGJ5IHN0eWxlIG9wdGlvbnMuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IEJpdG1hcEZvbnQsIEJpdG1hcFRleHQgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogQml0bWFwRm9udC5pbnN0YWxsKCdUaXRsZUZvbnQnLCB7XG4gICAqICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgKiAgICAgZm9udFNpemU6IDEyLFxuICAgKiAgICAgc3Ryb2tlVGhpY2tuZXNzOiAyLFxuICAgKiAgICAgZmlsbDogJ3B1cnBsZScsXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCB0aXRsZSA9IG5ldyBCaXRtYXBUZXh0KHsgdGV4dDogJ1RoaXMgaXMgdGhlIHRpdGxlJywgZm9udEZhbWlseTogJ1RpdGxlRm9udCcgfSk7XG4gICAqL1xuICBzdGF0aWMgaW5zdGFsbChvcHRpb25zKSB7XG4gICAgQml0bWFwRm9udE1hbmFnZXIuaW5zdGFsbChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogVW5pbnN0YWxscyBhIGJpdG1hcCBmb250IGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaXRtYXAgZm9udCB0byB1bmluc3RhbGwuXG4gICAqL1xuICBzdGF0aWMgdW5pbnN0YWxsKG5hbWUpIHtcbiAgICBCaXRtYXBGb250TWFuYWdlci51bmluc3RhbGwobmFtZSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQml0bWFwRm9udCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwRm9udC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJpdG1hcEZvbnRUZXh0UGFyc2VyID0ge1xuICB0ZXN0KGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgJiYgZGF0YS5zdGFydHNXaXRoKFwiaW5mbyBmYWNlPVwiKTtcbiAgfSxcbiAgcGFyc2UodHh0KSB7XG4gICAgY29uc3QgaXRlbXMgPSB0eHQubWF0Y2goL15bYS16XStcXHMrLiskL2dtKTtcbiAgICBjb25zdCByYXdEYXRhID0ge1xuICAgICAgaW5mbzogW10sXG4gICAgICBjb21tb246IFtdLFxuICAgICAgcGFnZTogW10sXG4gICAgICBjaGFyOiBbXSxcbiAgICAgIGNoYXJzOiBbXSxcbiAgICAgIGtlcm5pbmc6IFtdLFxuICAgICAga2VybmluZ3M6IFtdLFxuICAgICAgZGlzdGFuY2VGaWVsZDogW11cbiAgICB9O1xuICAgIGZvciAoY29uc3QgaSBpbiBpdGVtcykge1xuICAgICAgY29uc3QgbmFtZSA9IGl0ZW1zW2ldLm1hdGNoKC9eW2Etel0rL2dtKVswXTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUxpc3QgPSBpdGVtc1tpXS5tYXRjaCgvW2EtekEtWl0rPShbXlxcc1wiJ10rfFwiKFteXCJdKilcIikvZ20pO1xuICAgICAgY29uc3QgaXRlbURhdGEgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgaTIgaW4gYXR0cmlidXRlTGlzdCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGF0dHJpYnV0ZUxpc3RbaTJdLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgY29uc3Qga2V5ID0gc3BsaXRbMF07XG4gICAgICAgIGNvbnN0IHN0clZhbHVlID0gc3BsaXRbMV0ucmVwbGFjZSgvXCIvZ20sIFwiXCIpO1xuICAgICAgICBjb25zdCBmbG9hdFZhbHVlID0gcGFyc2VGbG9hdChzdHJWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNOYU4oZmxvYXRWYWx1ZSkgPyBzdHJWYWx1ZSA6IGZsb2F0VmFsdWU7XG4gICAgICAgIGl0ZW1EYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJhd0RhdGFbbmFtZV0ucHVzaChpdGVtRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSB7XG4gICAgICBjaGFyczoge30sXG4gICAgICBwYWdlczogW10sXG4gICAgICBsaW5lSGVpZ2h0OiAwLFxuICAgICAgZm9udFNpemU6IDAsXG4gICAgICBmb250RmFtaWx5OiBcIlwiLFxuICAgICAgZGlzdGFuY2VGaWVsZDogbnVsbCxcbiAgICAgIGJhc2VMaW5lT2Zmc2V0OiAwXG4gICAgfTtcbiAgICBjb25zdCBbaW5mb10gPSByYXdEYXRhLmluZm87XG4gICAgY29uc3QgW2NvbW1vbl0gPSByYXdEYXRhLmNvbW1vbjtcbiAgICBjb25zdCBbZGlzdGFuY2VGaWVsZF0gPSByYXdEYXRhLmRpc3RhbmNlRmllbGQgPz8gW107XG4gICAgaWYgKGRpc3RhbmNlRmllbGQpIHtcbiAgICAgIGZvbnQuZGlzdGFuY2VGaWVsZCA9IHtcbiAgICAgICAgcmFuZ2U6IHBhcnNlSW50KGRpc3RhbmNlRmllbGQuZGlzdGFuY2VSYW5nZSwgMTApLFxuICAgICAgICB0eXBlOiBkaXN0YW5jZUZpZWxkLmZpZWxkVHlwZVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9udC5mb250U2l6ZSA9IHBhcnNlSW50KGluZm8uc2l6ZSwgMTApO1xuICAgIGZvbnQuZm9udEZhbWlseSA9IGluZm8uZmFjZTtcbiAgICBmb250LmxpbmVIZWlnaHQgPSBwYXJzZUludChjb21tb24ubGluZUhlaWdodCwgMTApO1xuICAgIGNvbnN0IHBhZ2UgPSByYXdEYXRhLnBhZ2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb250LnBhZ2VzLnB1c2goe1xuICAgICAgICBpZDogcGFyc2VJbnQocGFnZVtpXS5pZCwgMTApIHx8IDAsXG4gICAgICAgIGZpbGU6IHBhZ2VbaV0uZmlsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIGZvbnQuYmFzZUxpbmVPZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLSBwYXJzZUludChjb21tb24uYmFzZSwgMTApO1xuICAgIGNvbnN0IGNoYXIgPSByYXdEYXRhLmNoYXI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyTm9kZSA9IGNoYXJbaV07XG4gICAgICBjb25zdCBpZCA9IHBhcnNlSW50KGNoYXJOb2RlLmlkLCAxMCk7XG4gICAgICBsZXQgbGV0dGVyID0gY2hhck5vZGUubGV0dGVyID8/IGNoYXJOb2RlLmNoYXIgPz8gU3RyaW5nLmZyb21DaGFyQ29kZShpZCk7XG4gICAgICBpZiAobGV0dGVyID09PSBcInNwYWNlXCIpXG4gICAgICAgIGxldHRlciA9IFwiIFwiO1xuICAgICAgbWFwW2lkXSA9IGxldHRlcjtcbiAgICAgIGZvbnQuY2hhcnNbbGV0dGVyXSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIC8vIHRleHR1cmUgZGVldHMuLlxuICAgICAgICBwYWdlOiBwYXJzZUludChjaGFyTm9kZS5wYWdlLCAxMCkgfHwgMCxcbiAgICAgICAgeDogcGFyc2VJbnQoY2hhck5vZGUueCwgMTApLFxuICAgICAgICB5OiBwYXJzZUludChjaGFyTm9kZS55LCAxMCksXG4gICAgICAgIHdpZHRoOiBwYXJzZUludChjaGFyTm9kZS53aWR0aCwgMTApLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGNoYXJOb2RlLmhlaWdodCwgMTApLFxuICAgICAgICB4T2Zmc2V0OiBwYXJzZUludChjaGFyTm9kZS54b2Zmc2V0LCAxMCksXG4gICAgICAgIHlPZmZzZXQ6IHBhcnNlSW50KGNoYXJOb2RlLnlvZmZzZXQsIDEwKSxcbiAgICAgICAgeEFkdmFuY2U6IHBhcnNlSW50KGNoYXJOb2RlLnhhZHZhbmNlLCAxMCksXG4gICAgICAgIGtlcm5pbmc6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBrZXJuaW5nID0gcmF3RGF0YS5rZXJuaW5nIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlyc3QgPSBwYXJzZUludChrZXJuaW5nW2ldLmZpcnN0LCAxMCk7XG4gICAgICBjb25zdCBzZWNvbmQgPSBwYXJzZUludChrZXJuaW5nW2ldLnNlY29uZCwgMTApO1xuICAgICAgY29uc3QgYW1vdW50ID0gcGFyc2VJbnQoa2VybmluZ1tpXS5hbW91bnQsIDEwKTtcbiAgICAgIGZvbnQuY2hhcnNbbWFwW3NlY29uZF1dLmtlcm5pbmdbbWFwW2ZpcnN0XV0gPSBhbW91bnQ7XG4gICAgfVxuICAgIHJldHVybiBmb250O1xuICB9XG59O1xuXG5leHBvcnQgeyBiaXRtYXBGb250VGV4dFBhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwRm9udFRleHRQYXJzZXIubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBiaXRtYXBGb250WE1MUGFyc2VyID0ge1xuICB0ZXN0KGRhdGEpIHtcbiAgICBjb25zdCB4bWwgPSBkYXRhO1xuICAgIHJldHVybiB0eXBlb2YgeG1sICE9PSBcInN0cmluZ1wiICYmIFwiZ2V0RWxlbWVudHNCeVRhZ05hbWVcIiBpbiB4bWwgJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFnZVwiKS5sZW5ndGggJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5mb1wiKVswXS5nZXRBdHRyaWJ1dGUoXCJmYWNlXCIpICE9PSBudWxsO1xuICB9LFxuICBwYXJzZSh4bWwpIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgY2hhcnM6IHt9LFxuICAgICAgcGFnZXM6IFtdLFxuICAgICAgbGluZUhlaWdodDogMCxcbiAgICAgIGZvbnRTaXplOiAwLFxuICAgICAgZm9udEZhbWlseTogXCJcIixcbiAgICAgIGRpc3RhbmNlRmllbGQ6IG51bGwsXG4gICAgICBiYXNlTGluZU9mZnNldDogMFxuICAgIH07XG4gICAgY29uc3QgaW5mbyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImluZm9cIilbMF07XG4gICAgY29uc3QgY29tbW9uID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY29tbW9uXCIpWzBdO1xuICAgIGNvbnN0IGRpc3RhbmNlRmllbGQgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXN0YW5jZUZpZWxkXCIpWzBdO1xuICAgIGlmIChkaXN0YW5jZUZpZWxkKSB7XG4gICAgICBkYXRhLmRpc3RhbmNlRmllbGQgPSB7XG4gICAgICAgIHR5cGU6IGRpc3RhbmNlRmllbGQuZ2V0QXR0cmlidXRlKFwiZmllbGRUeXBlXCIpLFxuICAgICAgICByYW5nZTogcGFyc2VJbnQoZGlzdGFuY2VGaWVsZC5nZXRBdHRyaWJ1dGUoXCJkaXN0YW5jZVJhbmdlXCIpLCAxMClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBhZ2UgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYWdlXCIpO1xuICAgIGNvbnN0IGNoYXIgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjaGFyXCIpO1xuICAgIGNvbnN0IGtlcm5pbmcgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJrZXJuaW5nXCIpO1xuICAgIGRhdGEuZm9udFNpemUgPSBwYXJzZUludChpbmZvLmdldEF0dHJpYnV0ZShcInNpemVcIiksIDEwKTtcbiAgICBkYXRhLmZvbnRGYW1pbHkgPSBpbmZvLmdldEF0dHJpYnV0ZShcImZhY2VcIik7XG4gICAgZGF0YS5saW5lSGVpZ2h0ID0gcGFyc2VJbnQoY29tbW9uLmdldEF0dHJpYnV0ZShcImxpbmVIZWlnaHRcIiksIDEwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEucGFnZXMucHVzaCh7XG4gICAgICAgIGlkOiBwYXJzZUludChwYWdlW2ldLmdldEF0dHJpYnV0ZShcImlkXCIpLCAxMCkgfHwgMCxcbiAgICAgICAgZmlsZTogcGFnZVtpXS5nZXRBdHRyaWJ1dGUoXCJmaWxlXCIpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWFwID0ge307XG4gICAgZGF0YS5iYXNlTGluZU9mZnNldCA9IGRhdGEubGluZUhlaWdodCAtIHBhcnNlSW50KGNvbW1vbi5nZXRBdHRyaWJ1dGUoXCJiYXNlXCIpLCAxMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyTm9kZSA9IGNoYXJbaV07XG4gICAgICBjb25zdCBpZCA9IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcImlkXCIpLCAxMCk7XG4gICAgICBsZXQgbGV0dGVyID0gY2hhck5vZGUuZ2V0QXR0cmlidXRlKFwibGV0dGVyXCIpID8/IGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcImNoYXJcIikgPz8gU3RyaW5nLmZyb21DaGFyQ29kZShpZCk7XG4gICAgICBpZiAobGV0dGVyID09PSBcInNwYWNlXCIpXG4gICAgICAgIGxldHRlciA9IFwiIFwiO1xuICAgICAgbWFwW2lkXSA9IGxldHRlcjtcbiAgICAgIGRhdGEuY2hhcnNbbGV0dGVyXSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIC8vIHRleHR1cmUgZGVldHMuLlxuICAgICAgICBwYWdlOiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJwYWdlXCIpLCAxMCkgfHwgMCxcbiAgICAgICAgeDogcGFyc2VJbnQoY2hhck5vZGUuZ2V0QXR0cmlidXRlKFwieFwiKSwgMTApLFxuICAgICAgICB5OiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ5XCIpLCAxMCksXG4gICAgICAgIHdpZHRoOiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSwgMTApLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSwgMTApLFxuICAgICAgICAvLyByZW5kZXIgZGVldHMuLlxuICAgICAgICB4T2Zmc2V0OiBwYXJzZUludChjaGFyTm9kZS5nZXRBdHRyaWJ1dGUoXCJ4b2Zmc2V0XCIpLCAxMCksXG4gICAgICAgIHlPZmZzZXQ6IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcInlvZmZzZXRcIiksIDEwKSxcbiAgICAgICAgLy8gKyBiYXNlTGluZU9mZnNldCxcbiAgICAgICAgeEFkdmFuY2U6IHBhcnNlSW50KGNoYXJOb2RlLmdldEF0dHJpYnV0ZShcInhhZHZhbmNlXCIpLCAxMCksXG4gICAgICAgIGtlcm5pbmc6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VJbnQoa2VybmluZ1tpXS5nZXRBdHRyaWJ1dGUoXCJmaXJzdFwiKSwgMTApO1xuICAgICAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQoa2VybmluZ1tpXS5nZXRBdHRyaWJ1dGUoXCJzZWNvbmRcIiksIDEwKTtcbiAgICAgIGNvbnN0IGFtb3VudCA9IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiYW1vdW50XCIpLCAxMCk7XG4gICAgICBkYXRhLmNoYXJzW21hcFtzZWNvbmRdXS5rZXJuaW5nW21hcFtmaXJzdF1dID0gYW1vdW50O1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYml0bWFwRm9udFhNTFBhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwRm9udFhNTFBhcnNlci5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgYml0bWFwRm9udFhNTFBhcnNlciB9IGZyb20gJy4vYml0bWFwRm9udFhNTFBhcnNlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJpdG1hcEZvbnRYTUxTdHJpbmdQYXJzZXIgPSB7XG4gIHRlc3QoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLmluY2x1ZGVzKFwiPGZvbnQ+XCIpKSB7XG4gICAgICByZXR1cm4gYml0bWFwRm9udFhNTFBhcnNlci50ZXN0KERPTUFkYXB0ZXIuZ2V0KCkucGFyc2VYTUwoZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHBhcnNlKGRhdGEpIHtcbiAgICByZXR1cm4gYml0bWFwRm9udFhNTFBhcnNlci5wYXJzZShET01BZGFwdGVyLmdldCgpLnBhcnNlWE1MKGRhdGEpKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYml0bWFwRm9udFhNTFN0cmluZ1BhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwRm9udFhNTFN0cmluZ1BhcnNlci5tanMubWFwXG4iLCJpbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4uLy4uLy4uL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy9Mb2FkZXJQYXJzZXIubWpzJztcbmltcG9ydCB7IGNvcHlTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9hc3NldHMvdXRpbHMvY29weVNlYXJjaFBhcmFtcy5tanMnO1xuaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHBhdGggfSBmcm9tICcuLi8uLi8uLi91dGlscy9wYXRoLm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBGb250IH0gZnJvbSAnLi4vQml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgYml0bWFwRm9udFRleHRQYXJzZXIgfSBmcm9tICcuL2JpdG1hcEZvbnRUZXh0UGFyc2VyLm1qcyc7XG5pbXBvcnQgeyBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyIH0gZnJvbSAnLi9iaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdmFsaWRFeHRlbnNpb25zID0gW1wiLnhtbFwiLCBcIi5mbnRcIl07XG5jb25zdCBiaXRtYXBGb250Q2FjaGVQbHVnaW4gPSB7XG4gIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5DYWNoZVBhcnNlcixcbiAgdGVzdDogKGFzc2V0KSA9PiBhc3NldCBpbnN0YW5jZW9mIEJpdG1hcEZvbnQsXG4gIGdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCBhc3NldCkge1xuICAgIGNvbnN0IG91dCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBvdXRba2V5XSA9IGFzc2V0O1xuICAgIH0pO1xuICAgIG91dFtgJHthc3NldC5mb250RmFtaWx5fS1iaXRtYXBgXSA9IGFzc2V0O1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn07XG5jb25zdCBsb2FkQml0bWFwRm9udCA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5Ob3JtYWxcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gdmFsaWRFeHRlbnNpb25zLmluY2x1ZGVzKHBhdGguZXh0bmFtZSh1cmwpLnRvTG93ZXJDYXNlKCkpO1xuICB9LFxuICBhc3luYyB0ZXN0UGFyc2UoZGF0YSkge1xuICAgIHJldHVybiBiaXRtYXBGb250VGV4dFBhcnNlci50ZXN0KGRhdGEpIHx8IGJpdG1hcEZvbnRYTUxTdHJpbmdQYXJzZXIudGVzdChkYXRhKTtcbiAgfSxcbiAgYXN5bmMgcGFyc2UoYXNzZXQsIGRhdGEsIGxvYWRlcikge1xuICAgIGNvbnN0IGJpdG1hcEZvbnREYXRhID0gYml0bWFwRm9udFRleHRQYXJzZXIudGVzdChhc3NldCkgPyBiaXRtYXBGb250VGV4dFBhcnNlci5wYXJzZShhc3NldCkgOiBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLnBhcnNlKGFzc2V0KTtcbiAgICBjb25zdCB7IHNyYyB9ID0gZGF0YTtcbiAgICBjb25zdCB7IHBhZ2VzIH0gPSBiaXRtYXBGb250RGF0YTtcbiAgICBjb25zdCB0ZXh0dXJlVXJscyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHBhZ2VGaWxlID0gcGFnZXNbaV0uZmlsZTtcbiAgICAgIGxldCBpbWFnZVBhdGggPSBwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKHNyYyksIHBhZ2VGaWxlKTtcbiAgICAgIGltYWdlUGF0aCA9IGNvcHlTZWFyY2hQYXJhbXMoaW1hZ2VQYXRoLCBzcmMpO1xuICAgICAgdGV4dHVyZVVybHMucHVzaChpbWFnZVBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRUZXh0dXJlcyA9IGF3YWl0IGxvYWRlci5sb2FkKHRleHR1cmVVcmxzKTtcbiAgICBjb25zdCB0ZXh0dXJlcyA9IHRleHR1cmVVcmxzLm1hcCgodXJsKSA9PiBsb2FkZWRUZXh0dXJlc1t1cmxdKTtcbiAgICBjb25zdCBiaXRtYXBGb250ID0gbmV3IEJpdG1hcEZvbnQoe1xuICAgICAgZGF0YTogYml0bWFwRm9udERhdGEsXG4gICAgICB0ZXh0dXJlc1xuICAgIH0sIHNyYyk7XG4gICAgcmV0dXJuIGJpdG1hcEZvbnQ7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBfb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgRE9NQWRhcHRlci5nZXQoKS5mZXRjaCh1cmwpO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIH0sXG4gIGFzeW5jIHVubG9hZChiaXRtYXBGb250LCBfcmVzb2x2ZWRBc3NldCwgbG9hZGVyKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoYml0bWFwRm9udC5wYWdlcy5tYXAoKHBhZ2UpID0+IGxvYWRlci51bmxvYWQocGFnZS50ZXh0dXJlLnNvdXJjZS5fc291cmNlT3JpZ2luKSkpO1xuICAgIGJpdG1hcEZvbnQuZGVzdHJveSgpO1xuICB9XG59O1xuXG5leHBvcnQgeyBiaXRtYXBGb250Q2FjaGVQbHVnaW4sIGxvYWRCaXRtYXBGb250IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkQml0bWFwRm9udC5tanMubWFwXG4iLCJpbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NDb250ZXh0IH0gZnJvbSAnLi9HcmFwaGljc0NvbnRleHQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcmFwaGljcyBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBHcmFwaGljcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgb3B0aW9ucyA9IHsgY29udGV4dDogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQsIHJvdW5kUGl4ZWxzLCAuLi5yZXN0IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHN1cGVyKHtcbiAgICAgIGxhYmVsOiBcIkdyYXBoaWNzXCIsXG4gICAgICAuLi5yZXN0XG4gICAgfSk7XG4gICAgdGhpcy5jYW5CdW5kbGUgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyUGlwZUlkID0gXCJncmFwaGljc1wiO1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gMDtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9vd25lZENvbnRleHQgPSBuZXcgR3JhcGhpY3NDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICB0aGlzLl9jb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLmFsbG93Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gcm91bmRQaXhlbHMgPz8gZmFsc2U7XG4gIH1cbiAgc2V0IGNvbnRleHQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB0aGlzLl9jb250ZXh0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvbnRleHQub2ZmKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9jb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLm9uVmlld1VwZGF0ZSgpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbG9jYWwgYm91bmRzIG9mIHRoZSBncmFwaGljLlxuICAgKiBAdHlwZSB7cmVuZGVyaW5nLkJvdW5kc31cbiAgICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuYm91bmRzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBib3VuZHMgb2YgdGhpcyBvYmplY3QgdG8gdGhlIGJvdW5kcyBvYmplY3QuXG4gICAqIEBwYXJhbSBib3VuZHMgLSBUaGUgb3V0cHV0IGJvdW5kcyBvYmplY3QuXG4gICAqL1xuICBhZGRCb3VuZHMoYm91bmRzKSB7XG4gICAgYm91bmRzLmFkZEJvdW5kcyh0aGlzLl9jb250ZXh0LmJvdW5kcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrXG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY29udGFpbnNQb2ludChwb2ludCk7XG4gIH1cbiAgLyoqXG4gICAqICBXaGV0aGVyIG9yIG5vdCB0byByb3VuZCB0aGUgeC95IHBvc2l0aW9uIG9mIHRoZSBncmFwaGljLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gISF0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlID8gMSA6IDA7XG4gIH1cbiAgb25WaWV3VXBkYXRlKCkge1xuICAgIHRoaXMuX2RpZENoYW5nZUlkICs9IDEgPDwgMTI7XG4gICAgdGhpcy5fZGlkR3JhcGhpY3NVcGRhdGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLmRpZFZpZXdVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kaWRWaWV3VXBkYXRlID0gdHJ1ZTtcbiAgICBjb25zdCByZW5kZXJHcm91cCA9IHRoaXMucmVuZGVyR3JvdXAgfHwgdGhpcy5wYXJlbnRSZW5kZXJHcm91cDtcbiAgICBpZiAocmVuZGVyR3JvdXApIHtcbiAgICAgIHJlbmRlckdyb3VwLm9uQ2hpbGRWaWV3VXBkYXRlKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyBncmFwaGljcyByZW5kZXJhYmxlIGFuZCBvcHRpb25hbGx5IGl0cyBjb250ZXh0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICpcbiAgICogSWYgdGhlIGNvbnRleHQgd2FzIGNyZWF0ZWQgYnkgdGhpcyBncmFwaGljcyBhbmQgYGRlc3Ryb3koZmFsc2UpYCBvciBgZGVzdHJveSgpYCBpcyBjYWxsZWRcbiAgICogdGhlbiB0aGUgY29udGV4dCB3aWxsIHN0aWxsIGJlIGRlc3Ryb3llZC5cbiAgICpcbiAgICogSWYgeW91IHdhbnQgdG8gZXhwbGljaXRseSBub3QgZGVzdHJveSB0aGlzIGNvbnRleHQgdGhhdCB0aGlzIGdyYXBoaWNzIGNyZWF0ZWQsXG4gICAqIHRoZW4geW91IHNob3VsZCBwYXNzIGRlc3Ryb3koeyBjb250ZXh0OiBmYWxzZSB9KVxuICAgKlxuICAgKiBJZiB0aGUgY29udGV4dCB3YXMgcGFzc2VkIGluIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjb25zdHJ1Y3RvciB0aGVuIGl0IHdpbGwgbm90IGJlIGRlc3Ryb3llZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGdyYXBoaWNzIGNvbnRleHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlU291cmNlPWZhbHNlXSAtIFNob3VsZCBkZXN0cm95IHRoZSB0ZXh0dXJlIHNvdXJjZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbnRleHQ9ZmFsc2VdIC0gU2hvdWxkIGRlc3Ryb3kgdGhlIGNvbnRleHRcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9vd25lZENvbnRleHQgJiYgIW9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX293bmVkQ29udGV4dC5kZXN0cm95KG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyA9PT0gdHJ1ZSB8fCBvcHRpb25zPy5jb250ZXh0ID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuX293bmVkQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxuICBfY2FsbENvbnRleHRNZXRob2QobWV0aG9kLCBhcmdzKSB7XG4gICAgdGhpcy5jb250ZXh0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEdyYXBoaWNzQ29udGV4dCBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBmaWxsIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBUaGUgZmlsbCBzdHlsZSBjYW4gYmUgYSBjb2xvciwgZ3JhZGllbnQsXG4gICAqIHBhdHRlcm4sIG9yIGEgbW9yZSBjb21wbGV4IHN0eWxlIGRlZmluZWQgYnkgYSBGaWxsU3R5bGUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge0ZpbGxTdHlsZUlucHV0c30gYXJncyAtIFRoZSBmaWxsIHN0eWxlIHRvIGFwcGx5LiBUaGlzIGNhbiBiZSBhIHNpbXBsZSBjb2xvciwgYSBncmFkaWVudCBvclxuICAgKiBwYXR0ZXJuIG9iamVjdCwgb3IgYSBGaWxsU3R5bGUgb3IgQ29udmVydGVkRmlsbFN0eWxlIG9iamVjdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc2V0RmlsbFN0eWxlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzZXRGaWxsU3R5bGVcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgc3Ryb2tlIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBTaW1pbGFyIHRvIGZpbGwgc3R5bGVzLCBzdHJva2Ugc3R5bGVzIGNhblxuICAgKiBlbmNvbXBhc3MgY29sb3JzLCBncmFkaWVudHMsIHBhdHRlcm5zLCBvciBtb3JlIGRldGFpbGVkIGNvbmZpZ3VyYXRpb25zIHZpYSBhIFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICogQHBhcmFtIHtGaWxsU3R5bGVJbnB1dHN9IGFyZ3MgLSBUaGUgc3Ryb2tlIHN0eWxlIHRvIGFwcGx5LiBDYW4gYmUgZGVmaW5lZCBhcyBhIGNvbG9yLCBhIGdyYWRpZW50IG9yIHBhdHRlcm4sXG4gICAqIG9yIGEgU3Ryb2tlU3R5bGUgb3IgQ29udmVydGVkU3Ryb2tlU3R5bGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBzZXRTdHJva2VTdHlsZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic2V0U3Ryb2tlU3R5bGVcIiwgYXJncyk7XG4gIH1cbiAgZmlsbCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiZmlsbFwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogU3Ryb2tlcyB0aGUgY3VycmVudCBwYXRoIHdpdGggdGhlIGN1cnJlbnQgc3Ryb2tlIHN0eWxlLiBUaGlzIG1ldGhvZCBjYW4gdGFrZSBhbiBvcHRpb25hbFxuICAgKiBGaWxsU3R5bGVJbnB1dHMgcGFyYW1ldGVyIHRvIGRlZmluZSB0aGUgc3Ryb2tlJ3MgYXBwZWFyYW5jZSwgaW5jbHVkaW5nIGl0cyBjb2xvciwgd2lkdGgsIGFuZCBvdGhlciBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge0ZpbGxTdHlsZUlucHV0c30gYXJncyAtIChPcHRpb25hbCkgVGhlIHN0cm9rZSBzdHlsZSB0byBhcHBseS4gQ2FuIGJlIGRlZmluZWQgYXMgYSBzaW1wbGUgY29sb3Igb3IgYSBtb3JlXG4gICAqIGNvbXBsZXggc3R5bGUgb2JqZWN0LiBJZiBvbWl0dGVkLCB1c2VzIHRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc3Ryb2tlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzdHJva2VcIiwgYXJncyk7XG4gIH1cbiAgdGV4dHVyZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwidGV4dHVyZVwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBjdXJyZW50IHBhdGguIEFueSBwcmV2aW91cyBwYXRoIGFuZCBpdHMgY29tbWFuZHMgYXJlIGRpc2NhcmRlZCBhbmQgYSBuZXcgcGF0aCBpc1xuICAgKiBzdGFydGVkLiBUaGlzIGlzIHR5cGljYWxseSBjYWxsZWQgYmVmb3JlIGJlZ2lubmluZyBhIG5ldyBzaGFwZSBvciBzZXJpZXMgb2YgZHJhd2luZyBjb21tYW5kcy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgYmVnaW5QYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImJlZ2luUGF0aFwiLCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBjdXRvdXQgdG8gdGhlIGxhc3QgZHJhd24gc2hhcGUuIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgaG9sZXMgb3IgY29tcGxleCBzaGFwZXMgYnlcbiAgICogc3VidHJhY3RpbmcgYSBwYXRoIGZyb20gdGhlIHByZXZpb3VzbHkgZHJhd24gcGF0aC4gSWYgYSBob2xlIGlzIG5vdCBjb21wbGV0ZWx5IGluIGEgc2hhcGUsIGl0IHdpbGxcbiAgICogZmFpbCB0byBjdXQgY29ycmVjdGx5IVxuICAgKi9cbiAgY3V0KCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImN1dFwiLCBbXSk7XG4gIH1cbiAgYXJjKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJhcmNcIiwgYXJncyk7XG4gIH1cbiAgYXJjVG8oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImFyY1RvXCIsIGFyZ3MpO1xuICB9XG4gIGFyY1RvU3ZnKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJhcmNUb1N2Z1wiLCBhcmdzKTtcbiAgfVxuICBiZXppZXJDdXJ2ZVRvKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJiZXppZXJDdXJ2ZVRvXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aCBieSBkcmF3aW5nIGEgc3RyYWlnaHQgbGluZSBiYWNrIHRvIHRoZSBzdGFydC5cbiAgICogSWYgdGhlIHNoYXBlIGlzIGFscmVhZHkgY2xvc2VkIG9yIHRoZXJlIGFyZSBubyBwb2ludHMgaW4gdGhlIHBhdGgsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBjbG9zZVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiY2xvc2VQYXRoXCIsIFtdKTtcbiAgfVxuICBlbGxpcHNlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJlbGxpcHNlXCIsIGFyZ3MpO1xuICB9XG4gIGNpcmNsZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiY2lyY2xlXCIsIGFyZ3MpO1xuICB9XG4gIHBhdGgoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInBhdGhcIiwgYXJncyk7XG4gIH1cbiAgbGluZVRvKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJsaW5lVG9cIiwgYXJncyk7XG4gIH1cbiAgbW92ZVRvKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJtb3ZlVG9cIiwgYXJncyk7XG4gIH1cbiAgcXVhZHJhdGljQ3VydmVUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicXVhZHJhdGljQ3VydmVUb1wiLCBhcmdzKTtcbiAgfVxuICByZWN0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyZWN0XCIsIGFyZ3MpO1xuICB9XG4gIHJvdW5kUmVjdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicm91bmRSZWN0XCIsIGFyZ3MpO1xuICB9XG4gIHBvbHkoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInBvbHlcIiwgYXJncyk7XG4gIH1cbiAgcmVndWxhclBvbHkoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJlZ3VsYXJQb2x5XCIsIGFyZ3MpO1xuICB9XG4gIHJvdW5kUG9seSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicm91bmRQb2x5XCIsIGFyZ3MpO1xuICB9XG4gIHJvdW5kU2hhcGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdW5kU2hhcGVcIiwgYXJncyk7XG4gIH1cbiAgZmlsbGV0UmVjdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiZmlsbGV0UmVjdFwiLCBhcmdzKTtcbiAgfVxuICBjaGFtZmVyUmVjdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiY2hhbWZlclJlY3RcIiwgYXJncyk7XG4gIH1cbiAgc3RhciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic3RhclwiLCBhcmdzKTtcbiAgfVxuICBzdmcoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInN2Z1wiLCBhcmdzKTtcbiAgfVxuICByZXN0b3JlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyZXN0b3JlXCIsIGFyZ3MpO1xuICB9XG4gIC8qKiBTYXZlcyB0aGUgY3VycmVudCBncmFwaGljcyBzdGF0ZSwgaW5jbHVkaW5nIHRyYW5zZm9ybWF0aW9ucywgZmlsbCBzdHlsZXMsIGFuZCBzdHJva2Ugc3R5bGVzLCBvbnRvIGEgc3RhY2suICovXG4gIHNhdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic2F2ZVwiLCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBncmFwaGljcyBjb250ZXh0LlxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAqL1xuICBnZXRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRUcmFuc2Zvcm0oKTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byB0aGUgaWRlbnRpdHkgbWF0cml4LCBlZmZlY3RpdmVseSByZW1vdmluZ1xuICAgKiBhbnkgdHJhbnNmb3JtYXRpb25zIChyb3RhdGlvbiwgc2NhbGluZywgdHJhbnNsYXRpb24pIHByZXZpb3VzbHkgYXBwbGllZC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgcmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicmVzZXRUcmFuc2Zvcm1cIiwgW10pO1xuICB9XG4gIHJvdGF0ZVRyYW5zZm9ybSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicm90YXRlXCIsIGFyZ3MpO1xuICB9XG4gIHNjYWxlVHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzY2FsZVwiLCBhcmdzKTtcbiAgfVxuICBzZXRUcmFuc2Zvcm0oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInNldFRyYW5zZm9ybVwiLCBhcmdzKTtcbiAgfVxuICB0cmFuc2Zvcm0oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInRyYW5zZm9ybVwiLCBhcmdzKTtcbiAgfVxuICB0cmFuc2xhdGVUcmFuc2Zvcm0oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInRyYW5zbGF0ZVwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBkcmF3aW5nIGNvbW1hbmRzIGZyb20gdGhlIGdyYXBoaWNzIGNvbnRleHQsIGVmZmVjdGl2ZWx5IHJlc2V0dGluZyBpdC4gVGhpcyBpbmNsdWRlcyBjbGVhcmluZyB0aGUgcGF0aCxcbiAgICogYW5kIG9wdGlvbmFsbHkgcmVzZXR0aW5nIHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgaWRlbnRpdHkgbWF0cml4LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJjbGVhclwiLCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmaWxsIHN0eWxlIHRvIHVzZS5cbiAgICogQHR5cGUge0NvbnZlcnRlZEZpbGxTdHlsZX1cbiAgICovXG4gIGdldCBmaWxsU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlO1xuICB9XG4gIHNldCBmaWxsU3R5bGUodmFsdWUpIHtcbiAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3Ryb2tlIHN0eWxlIHRvIHVzZS5cbiAgICogQHR5cGUge0NvbnZlcnRlZFN0cm9rZVN0eWxlfVxuICAgKi9cbiAgZ2V0IHN0cm9rZVN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LnN0cm9rZVN0eWxlO1xuICB9XG4gIHNldCBzdHJva2VTdHlsZSh2YWx1ZSkge1xuICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlU3R5bGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljcyBvYmplY3QuXG4gICAqIE5vdGUgdGhhdCBvbmx5IHRoZSBjb250ZXh0IG9mIHRoZSBvYmplY3QgaXMgY2xvbmVkLCBub3QgaXRzIHRyYW5zZm9ybSAocG9zaXRpb24sc2NhbGUsZXRjKVxuICAgKiBAcGFyYW0gZGVlcCAtIFdoZXRoZXIgdG8gY3JlYXRlIGEgZGVlcCBjbG9uZSBvZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0LiBJZiBmYWxzZSwgdGhlIGNvbnRleHRcbiAgICogd2lsbCBiZSBzaGFyZWQgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMgKGRlZmF1bHQgZmFsc2UpLiBJZiB0cnVlLCB0aGUgY29udGV4dCB3aWxsIGJlXG4gICAqIGNsb25lZCAocmVjb21tZW5kZWQgaWYgeW91IG5lZWQgdG8gbW9kaWZ5IHRoZSBjb250ZXh0IGluIGFueSB3YXkpLlxuICAgKiBAcmV0dXJucyAtIEEgY2xvbmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdFxuICAgKi9cbiAgY2xvbmUoZGVlcCA9IGZhbHNlKSB7XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIHJldHVybiBuZXcgR3JhcGhpY3ModGhpcy5fY29udGV4dC5jbG9uZSgpKTtcbiAgICB9XG4gICAgdGhpcy5fb3duZWRDb250ZXh0ID0gbnVsbDtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBHcmFwaGljcyh0aGlzLl9jb250ZXh0KTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgLy8gLS0tLS0tLS0gdjcgZGVwcmVjYXRpb25zIC0tLS0tLS0tLVxuICAvKipcbiAgICogQHBhcmFtIHdpZHRoXG4gICAqIEBwYXJhbSBjb2xvclxuICAgKiBAcGFyYW0gYWxwaGFcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNzZXRTdHJva2VTdHlsZX0gaW5zdGVhZFxuICAgKi9cbiAgbGluZVN0eWxlKHdpZHRoLCBjb2xvciwgYWxwaGEpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjbGluZVN0eWxlIGlzIG5vIGxvbmdlciBuZWVkZWQuIFVzZSBHcmFwaGljcyNzZXRTdHJva2VTdHlsZSB0byBzZXQgdGhlIHN0cm9rZSBzdHlsZS5cIik7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSB7fTtcbiAgICB3aWR0aCAmJiAoc3Ryb2tlU3R5bGUud2lkdGggPSB3aWR0aCk7XG4gICAgY29sb3IgJiYgKHN0cm9rZVN0eWxlLmNvbG9yID0gY29sb3IpO1xuICAgIGFscGhhICYmIChzdHJva2VTdHlsZS5hbHBoYSA9IGFscGhhKTtcbiAgICB0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIGNvbG9yXG4gICAqIEBwYXJhbSBhbHBoYVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI2ZpbGx9IGluc3RlYWRcbiAgICovXG4gIGJlZ2luRmlsbChjb2xvciwgYWxwaGEpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjYmVnaW5GaWxsIGlzIG5vIGxvbmdlciBuZWVkZWQuIFVzZSBHcmFwaGljcyNmaWxsIHRvIGZpbGwgdGhlIHNoYXBlIHdpdGggdGhlIGRlc2lyZWQgc3R5bGUuXCIpO1xuICAgIGNvbnN0IGZpbGxTdHlsZSA9IHt9O1xuICAgIGNvbG9yICYmIChmaWxsU3R5bGUuY29sb3IgPSBjb2xvcik7XG4gICAgYWxwaGEgJiYgKGZpbGxTdHlsZS5hbHBoYSA9IGFscGhhKTtcbiAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI2ZpbGx9IGluc3RlYWRcbiAgICovXG4gIGVuZEZpbGwoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2VuZEZpbGwgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gVXNlIEdyYXBoaWNzI2ZpbGwgdG8gZmlsbCB0aGUgc2hhcGUgd2l0aCB0aGUgZGVzaXJlZCBzdHlsZS5cIik7XG4gICAgdGhpcy5jb250ZXh0LmZpbGwoKTtcbiAgICBjb25zdCBzdHJva2VTdHlsZSA9IHRoaXMuY29udGV4dC5zdHJva2VTdHlsZTtcbiAgICBpZiAoc3Ryb2tlU3R5bGUud2lkdGggIT09IEdyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUud2lkdGggfHwgc3Ryb2tlU3R5bGUuY29sb3IgIT09IEdyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUuY29sb3IgfHwgc3Ryb2tlU3R5bGUuYWxwaGEgIT09IEdyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUuYWxwaGEpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3MjY2lyY2xlfSBpbnN0ZWFkXG4gICAqL1xuICBkcmF3Q2lyY2xlKC4uLmFyZ3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZHJhd0NpcmNsZSBoYXMgYmVlbiByZW5hbWVkIHRvIEdyYXBoaWNzI2NpcmNsZVwiKTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJjaXJjbGVcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3MjZWxsaXBzZX0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd0VsbGlwc2UoLi4uYXJncykge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNkcmF3RWxsaXBzZSBoYXMgYmVlbiByZW5hbWVkIHRvIEdyYXBoaWNzI2VsbGlwc2VcIik7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiZWxsaXBzZVwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNwb2x5fSBpbnN0ZWFkXG4gICAqL1xuICBkcmF3UG9seWdvbiguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdQb2x5Z29uIGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3MjcG9seVwiKTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJwb2x5XCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI3JlY3R9IGluc3RlYWRcbiAgICovXG4gIGRyYXdSZWN0KC4uLmFyZ3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZHJhd1JlY3QgaGFzIGJlZW4gcmVuYW1lZCB0byBHcmFwaGljcyNyZWN0XCIpO1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJlY3RcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3Mjcm91bmRSZWN0fSBpbnN0ZWFkXG4gICAqL1xuICBkcmF3Um91bmRlZFJlY3QoLi4uYXJncykge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNkcmF3Um91bmRlZFJlY3QgaGFzIGJlZW4gcmVuYW1lZCB0byBHcmFwaGljcyNyb3VuZFJlY3RcIik7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicm91bmRSZWN0XCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI3N0YXJ9IGluc3RlYWRcbiAgICovXG4gIGRyYXdTdGFyKC4uLmFyZ3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZHJhd1N0YXIgaGFzIGJlZW4gcmVuYW1lZCB0byBHcmFwaGljcyNzdGFyXCIpO1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInN0YXJcIiwgYXJncyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgR3JhcGhpY3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbG9jYWxVbmlmb3JtTVNERkJpdCA9IHtcbiAgbmFtZTogXCJsb2NhbC11bmlmb3JtLW1zZGYtYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgc3RydWN0IExvY2FsVW5pZm9ybXMge1xuICAgICAgICAgICAgICAgIHVDb2xvcjp2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1RGlzdGFuY2U6IGYzMixcbiAgICAgICAgICAgICAgICB1Um91bmQ6ZjMyLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGxvY2FsVW5pZm9ybXMgOiBMb2NhbFVuaWZvcm1zO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICB2Q29sb3IgKj0gbG9jYWxVbmlmb3Jtcy51Q29sb3I7XG4gICAgICAgICAgICBtb2RlbE1hdHJpeCAqPSBsb2NhbFVuaWZvcm1zLnVUcmFuc2Zvcm1NYXRyaXg7XG4gICAgICAgIGBcbiAgICApLFxuICAgIGVuZDogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgaWYobG9jYWxVbmlmb3Jtcy51Um91bmQgPT0gMSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2UG9zaXRpb24gPSB2ZWM0KHJvdW5kUGl4ZWxzKHZQb3NpdGlvbi54eSwgZ2xvYmFsVW5pZm9ybXMudVJlc29sdXRpb24pLCB2UG9zaXRpb24uencpO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gICAgKVxuICB9LFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgc3RydWN0IExvY2FsVW5pZm9ybXMge1xuICAgICAgICAgICAgICAgIHVDb2xvcjp2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1RGlzdGFuY2U6IGYzMlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGxvY2FsVW5pZm9ybXMgOiBMb2NhbFVuaWZvcm1zO1xuICAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYCBcbiAgICAgICAgICAgIG91dENvbG9yID0gdkNvbG9yICogY2FsY3VsYXRlTVNERkFscGhhKG91dENvbG9yLCBsb2NhbFVuaWZvcm1zLnVEaXN0YW5jZSk7XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5jb25zdCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgPSB7XG4gIG5hbWU6IFwibG9jYWwtdW5pZm9ybS1tc2RmLWJpdFwiLFxuICB2ZXJ0ZXg6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB1VHJhbnNmb3JtTWF0cml4O1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVDb2xvcjtcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdVJvdW5kO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB2Q29sb3IgKj0gdUNvbG9yO1xuICAgICAgICAgICAgbW9kZWxNYXRyaXggKj0gdVRyYW5zZm9ybU1hdHJpeDtcbiAgICAgICAgYFxuICAgICksXG4gICAgZW5kOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICBpZih1Um91bmQgPT0gMS4pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24ueHkgPSByb3VuZFBpeGVscyhnbF9Qb3NpdGlvbi54eSwgdVJlc29sdXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gICAgKVxuICB9LFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1RGlzdGFuY2U7XG4gICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgIFxuICAgICAgICAgICAgb3V0Q29sb3IgPSB2Q29sb3IgKiBjYWxjdWxhdGVNU0RGQWxwaGEob3V0Q29sb3IsIHVEaXN0YW5jZSk7XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5cbmV4cG9ydCB7IGxvY2FsVW5pZm9ybU1TREZCaXQsIGxvY2FsVW5pZm9ybU1TREZCaXRHbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxVbmlmb3JtTVNERkJpdC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG1TREZCaXQgPSB7XG4gIG5hbWU6IFwibXNkZi1iaXRcIixcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIGZuIGNhbGN1bGF0ZU1TREZBbHBoYShtc2RmQ29sb3I6dmVjNDxmMzI+LCBkaXN0YW5jZTpmMzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTVNERlxuICAgICAgICAgICAgICAgIHZhciBtZWRpYW4gPSBtc2RmQ29sb3IuciArIG1zZGZDb2xvci5nICsgbXNkZkNvbG9yLmIgLVxuICAgICAgICAgICAgICAgICAgICBtaW4obXNkZkNvbG9yLnIsIG1pbihtc2RmQ29sb3IuZywgbXNkZkNvbG9yLmIpKSAtXG4gICAgICAgICAgICAgICAgICAgIG1heChtc2RmQ29sb3IuciwgbWF4KG1zZGZDb2xvci5nLCBtc2RmQ29sb3IuYikpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU0RGXG4gICAgICAgICAgICAgICAgbWVkaWFuID0gbWluKG1lZGlhbiwgbXNkZkNvbG9yLmEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNjcmVlblB4RGlzdGFuY2UgPSBkaXN0YW5jZSAqIChtZWRpYW4gLSAwLjUpO1xuICAgICAgICAgICAgICAgIHZhciBhbHBoYSA9IGNsYW1wKHNjcmVlblB4RGlzdGFuY2UgKyAwLjUsIDAuMCwgMS4wKTtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFuIDwgMC4wMSkge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IDAuMDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lZGlhbiA+IDAuOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuY29uc3QgbVNERkJpdEdsID0ge1xuICBuYW1lOiBcIm1zZGYtYml0XCIsXG4gIGZyYWdtZW50OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICBmbG9hdCBjYWxjdWxhdGVNU0RGQWxwaGEodmVjNCBtc2RmQ29sb3IsIGZsb2F0IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTVNERlxuICAgICAgICAgICAgICAgIGZsb2F0IG1lZGlhbiA9IG1zZGZDb2xvci5yICsgbXNkZkNvbG9yLmcgKyBtc2RmQ29sb3IuYiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbihtc2RmQ29sb3IuciwgbWluKG1zZGZDb2xvci5nLCBtc2RmQ29sb3IuYikpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4KG1zZGZDb2xvci5yLCBtYXgobXNkZkNvbG9yLmcsIG1zZGZDb2xvci5iKSk7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBTREZcbiAgICAgICAgICAgICAgICBtZWRpYW4gPSBtaW4obWVkaWFuLCBtc2RmQ29sb3IuYSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmbG9hdCBzY3JlZW5QeERpc3RhbmNlID0gZGlzdGFuY2UgKiAobWVkaWFuIC0gMC41KTtcbiAgICAgICAgICAgICAgICBmbG9hdCBhbHBoYSA9IGNsYW1wKHNjcmVlblB4RGlzdGFuY2UgKyAwLjUsIDAuMCwgMS4wKTtcbiAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhbiA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSAwLjA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZWRpYW4gPiAwLjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gMS4wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcblxuZXhwb3J0IHsgbVNERkJpdCwgbVNERkJpdEdsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tU0RGQml0Lm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSwgY29tcGlsZUhpZ2hTaGFkZXJHbFByb2dyYW0gfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IGNvbG9yQml0LCBjb2xvckJpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2NvbG9yQml0Lm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdCwgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXRHbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9nZW5lcmF0ZVRleHR1cmVCYXRjaEJpdC5tanMnO1xuaW1wb3J0IHsgcm91bmRQaXhlbHNCaXQsIHJvdW5kUGl4ZWxzQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvcm91bmRQaXhlbHNCaXQubWpzJztcbmltcG9ydCB7IGdldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9nZXRCYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBtYXhSZWNvbW1lbmRlZFRleHR1cmVzIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy9tYXhSZWNvbW1lbmRlZFRleHR1cmVzLm1qcyc7XG5pbXBvcnQgeyBsb2NhbFVuaWZvcm1NU0RGQml0LCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgfSBmcm9tICcuL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybU1TREZCaXQubWpzJztcbmltcG9ydCB7IG1TREZCaXQsIG1TREZCaXRHbCB9IGZyb20gJy4vc2hhZGVyLWJpdHMvbVNERkJpdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFNkZlNoYWRlciBleHRlbmRzIFNoYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1Q29sb3I6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdVRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVEaXN0YW5jZTogeyB2YWx1ZTogNCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgdVJvdW5kOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICB9KTtcbiAgICBjb25zdCBtYXhUZXh0dXJlcyA9IG1heFJlY29tbWVuZGVkVGV4dHVyZXMoKTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwic2RmLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBjb2xvckJpdCxcbiAgICAgICAgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQobWF4VGV4dHVyZXMpLFxuICAgICAgICBsb2NhbFVuaWZvcm1NU0RGQml0LFxuICAgICAgICBtU0RGQml0LFxuICAgICAgICByb3VuZFBpeGVsc0JpdFxuICAgICAgXVxuICAgIH0pO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IGNvbXBpbGVIaWdoU2hhZGVyR2xQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwic2RmLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBjb2xvckJpdEdsLFxuICAgICAgICBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdEdsKG1heFRleHR1cmVzKSxcbiAgICAgICAgbG9jYWxVbmlmb3JtTVNERkJpdEdsLFxuICAgICAgICBtU0RGQml0R2wsXG4gICAgICAgIHJvdW5kUGl4ZWxzQml0R2xcbiAgICAgIF1cbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICBnbFByb2dyYW0sXG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIGxvY2FsVW5pZm9ybXM6IHVuaWZvcm1zLFxuICAgICAgICBiYXRjaFNhbXBsZXJzOiBnZXRCYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwKG1heFRleHR1cmVzKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7IFNkZlNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2RmU2hhZGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi4vLi4vYXNzZXRzL2NhY2hlL0NhY2hlLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBCaWdQb29sIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9vbC9Qb29sR3JvdXAubWpzJztcbmltcG9ydCB7IEdyYXBoaWNzIH0gZnJvbSAnLi4vZ3JhcGhpY3Mvc2hhcmVkL0dyYXBoaWNzLm1qcyc7XG5pbXBvcnQgeyBTZGZTaGFkZXIgfSBmcm9tICcuLi90ZXh0L3NkZlNoYWRlci9TZGZTaGFkZXIubWpzJztcbmltcG9ydCB7IEJpdG1hcEZvbnRNYW5hZ2VyIH0gZnJvbSAnLi9CaXRtYXBGb250TWFuYWdlci5tanMnO1xuaW1wb3J0IHsgZ2V0Qml0bWFwVGV4dExheW91dCB9IGZyb20gJy4vdXRpbHMvZ2V0Qml0bWFwVGV4dExheW91dC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJpdG1hcFRleHRQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9ncHVCaXRtYXBUZXh0ID0ge307XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICB2YWxpZGF0ZVJlbmRlcmFibGUoYml0bWFwVGV4dCkge1xuICAgIGNvbnN0IGdyYXBoaWNzUmVuZGVyYWJsZSA9IHRoaXMuX2dldEdwdUJpdG1hcFRleHQoYml0bWFwVGV4dCk7XG4gICAgaWYgKGJpdG1hcFRleHQuX2RpZFRleHRVcGRhdGUpIHtcbiAgICAgIGJpdG1hcFRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNvbnRleHQoYml0bWFwVGV4dCwgZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmdyYXBoaWNzLnZhbGlkYXRlUmVuZGVyYWJsZShncmFwaGljc1JlbmRlcmFibGUpO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoYml0bWFwVGV4dCwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncmFwaGljc1JlbmRlcmFibGUgPSB0aGlzLl9nZXRHcHVCaXRtYXBUZXh0KGJpdG1hcFRleHQpO1xuICAgIHN5bmNXaXRoUHJveHkoYml0bWFwVGV4dCwgZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgICBpZiAoYml0bWFwVGV4dC5fZGlkVGV4dFVwZGF0ZSkge1xuICAgICAgYml0bWFwVGV4dC5fZGlkVGV4dFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGV4dChiaXRtYXBUZXh0LCBncmFwaGljc1JlbmRlcmFibGUpO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5ncmFwaGljcy5hZGRSZW5kZXJhYmxlKGdyYXBoaWNzUmVuZGVyYWJsZSwgaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGlmIChncmFwaGljc1JlbmRlcmFibGUuY29udGV4dC5jdXN0b21TaGFkZXIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlRmllbGQoYml0bWFwVGV4dCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKGJpdG1hcFRleHQpIHtcbiAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5VWlkKGJpdG1hcFRleHQudWlkKTtcbiAgfVxuICBfZGVzdHJveVJlbmRlcmFibGVCeVVpZChyZW5kZXJhYmxlVWlkKSB7XG4gICAgQmlnUG9vbC5yZXR1cm4odGhpcy5fZ3B1Qml0bWFwVGV4dFtyZW5kZXJhYmxlVWlkXSk7XG4gICAgdGhpcy5fZ3B1Qml0bWFwVGV4dFtyZW5kZXJhYmxlVWlkXSA9IG51bGw7XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShiaXRtYXBUZXh0KSB7XG4gICAgY29uc3QgZ3JhcGhpY3NSZW5kZXJhYmxlID0gdGhpcy5fZ2V0R3B1Qml0bWFwVGV4dChiaXRtYXBUZXh0KTtcbiAgICBzeW5jV2l0aFByb3h5KGJpdG1hcFRleHQsIGdyYXBoaWNzUmVuZGVyYWJsZSk7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuZ3JhcGhpY3MudXBkYXRlUmVuZGVyYWJsZShncmFwaGljc1JlbmRlcmFibGUpO1xuICAgIGlmIChncmFwaGljc1JlbmRlcmFibGUuY29udGV4dC5jdXN0b21TaGFkZXIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlRmllbGQoYml0bWFwVGV4dCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVDb250ZXh0KGJpdG1hcFRleHQsIHByb3h5R3JhcGhpY3MpIHtcbiAgICBjb25zdCB7IGNvbnRleHQgfSA9IHByb3h5R3JhcGhpY3M7XG4gICAgY29uc3QgYml0bWFwRm9udCA9IEJpdG1hcEZvbnRNYW5hZ2VyLmdldEZvbnQoYml0bWFwVGV4dC50ZXh0LCBiaXRtYXBUZXh0Ll9zdHlsZSk7XG4gICAgY29udGV4dC5jbGVhcigpO1xuICAgIGlmIChiaXRtYXBGb250LmRpc3RhbmNlRmllbGQudHlwZSAhPT0gXCJub25lXCIpIHtcbiAgICAgIGlmICghY29udGV4dC5jdXN0b21TaGFkZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZGZTaGFkZXIpIHtcbiAgICAgICAgICB0aGlzLl9zZGZTaGFkZXIgPSBuZXcgU2RmU2hhZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jdXN0b21TaGFkZXIgPSB0aGlzLl9zZGZTaGFkZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gQXJyYXkuZnJvbShiaXRtYXBUZXh0LnRleHQpO1xuICAgIGNvbnN0IHN0eWxlID0gYml0bWFwVGV4dC5fc3R5bGU7XG4gICAgbGV0IGN1cnJlbnRZID0gKHN0eWxlLl9zdHJva2U/LndpZHRoIHx8IDApIC8gMjtcbiAgICBjdXJyZW50WSArPSBiaXRtYXBGb250LmJhc2VMaW5lT2Zmc2V0O1xuICAgIGNvbnN0IGJpdG1hcFRleHRMYXlvdXQgPSBnZXRCaXRtYXBUZXh0TGF5b3V0KGNoYXJzLCBzdHlsZSwgYml0bWFwRm9udCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBwYWRkaW5nID0gc3R5bGUucGFkZGluZztcbiAgICBjb25zdCBzY2FsZSA9IGJpdG1hcFRleHRMYXlvdXQuc2NhbGU7XG4gICAgY29udGV4dC50cmFuc2xhdGUoXG4gICAgICAtYml0bWFwVGV4dC5fYW5jaG9yLl94ICogYml0bWFwVGV4dExheW91dC53aWR0aCAtIHBhZGRpbmcsXG4gICAgICAtYml0bWFwVGV4dC5fYW5jaG9yLl95ICogKGJpdG1hcFRleHRMYXlvdXQuaGVpZ2h0ICsgYml0bWFwVGV4dExheW91dC5vZmZzZXRZKSAtIHBhZGRpbmdcbiAgICApLnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgY29uc3QgdGludCA9IHN0eWxlLl9maWxsLmNvbG9yO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0bWFwVGV4dExheW91dC5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGJpdG1hcFRleHRMYXlvdXQubGluZXNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBjaGFyID0gY2hhcnNbaW5kZXgrK107XG4gICAgICAgIGNvbnN0IGNoYXJEYXRhID0gYml0bWFwRm9udC5jaGFyc1tjaGFyXTtcbiAgICAgICAgaWYgKGNoYXJEYXRhPy50ZXh0dXJlKSB7XG4gICAgICAgICAgY29udGV4dC50ZXh0dXJlKFxuICAgICAgICAgICAgY2hhckRhdGEudGV4dHVyZSxcbiAgICAgICAgICAgIHRpbnQgPyB0aW50IDogXCJibGFja1wiLFxuICAgICAgICAgICAgTWF0aC5yb3VuZChsaW5lLmNoYXJQb3NpdGlvbnNbal0gKyBjaGFyRGF0YS54T2Zmc2V0KSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoY3VycmVudFkgKyBjaGFyRGF0YS55T2Zmc2V0KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRZICs9IGJpdG1hcEZvbnQubGluZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgX2dldEdwdUJpdG1hcFRleHQoYml0bWFwVGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9ncHVCaXRtYXBUZXh0W2JpdG1hcFRleHQudWlkXSB8fCB0aGlzLmluaXRHcHVUZXh0KGJpdG1hcFRleHQpO1xuICB9XG4gIGluaXRHcHVUZXh0KGJpdG1hcFRleHQpIHtcbiAgICBjb25zdCBwcm94eVJlbmRlcmFibGUgPSBCaWdQb29sLmdldChHcmFwaGljcyk7XG4gICAgdGhpcy5fZ3B1Qml0bWFwVGV4dFtiaXRtYXBUZXh0LnVpZF0gPSBwcm94eVJlbmRlcmFibGU7XG4gICAgdGhpcy5fdXBkYXRlQ29udGV4dChiaXRtYXBUZXh0LCBwcm94eVJlbmRlcmFibGUpO1xuICAgIGJpdG1hcFRleHQub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShiaXRtYXBUZXh0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Qml0bWFwVGV4dFtiaXRtYXBUZXh0LnVpZF07XG4gIH1cbiAgX3VwZGF0ZURpc3RhbmNlRmllbGQoYml0bWFwVGV4dCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9nZXRHcHVCaXRtYXBUZXh0KGJpdG1hcFRleHQpLmNvbnRleHQ7XG4gICAgY29uc3QgZm9udEZhbWlseSA9IGJpdG1hcFRleHQuX3N0eWxlLmZvbnRGYW1pbHk7XG4gICAgY29uc3QgZHluYW1pY0ZvbnQgPSBDYWNoZS5nZXQoYCR7Zm9udEZhbWlseX0tYml0bWFwYCk7XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSBiaXRtYXBUZXh0Lmdyb3VwVHJhbnNmb3JtO1xuICAgIGNvbnN0IGR4ID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSAoTWF0aC5hYnMoZHgpICsgTWF0aC5hYnMoZHkpKSAvIDI7XG4gICAgY29uc3QgZm9udFNjYWxlID0gZHluYW1pY0ZvbnQuYmFzZVJlbmRlcmVkRm9udFNpemUgLyBiaXRtYXBUZXh0Ll9zdHlsZS5mb250U2l6ZTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gYml0bWFwVGV4dC5yZXNvbHV0aW9uID8/IHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgY29uc3QgZGlzdGFuY2UgPSB3b3JsZFNjYWxlICogZHluYW1pY0ZvbnQuZGlzdGFuY2VGaWVsZC5yYW5nZSAqICgxIC8gZm9udFNjYWxlKSAqIHJlc29sdXRpb247XG4gICAgY29udGV4dC5jdXN0b21TaGFkZXIucmVzb3VyY2VzLmxvY2FsVW5pZm9ybXMudW5pZm9ybXMudURpc3RhbmNlID0gZGlzdGFuY2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IHVpZCBpbiB0aGlzLl9ncHVCaXRtYXBUZXh0KSB7XG4gICAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5VWlkKHVpZCk7XG4gICAgfVxuICAgIHRoaXMuX2dwdUJpdG1hcFRleHQgPSBudWxsO1xuICAgIHRoaXMuX3NkZlNoYWRlcj8uZGVzdHJveSh0cnVlKTtcbiAgICB0aGlzLl9zZGZTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkJpdG1hcFRleHRQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJiaXRtYXBUZXh0XCJcbn07XG5mdW5jdGlvbiBzeW5jV2l0aFByb3h5KGNvbnRhaW5lciwgcHJveHkpIHtcbiAgcHJveHkuZ3JvdXBUcmFuc2Zvcm0gPSBjb250YWluZXIuZ3JvdXBUcmFuc2Zvcm07XG4gIHByb3h5Lmdyb3VwQ29sb3JBbHBoYSA9IGNvbnRhaW5lci5ncm91cENvbG9yQWxwaGE7XG4gIHByb3h5Lmdyb3VwQ29sb3IgPSBjb250YWluZXIuZ3JvdXBDb2xvcjtcbiAgcHJveHkuZ3JvdXBCbGVuZE1vZGUgPSBjb250YWluZXIuZ3JvdXBCbGVuZE1vZGU7XG4gIHByb3h5Lmdsb2JhbERpc3BsYXlTdGF0dXMgPSBjb250YWluZXIuZ2xvYmFsRGlzcGxheVN0YXR1cztcbiAgcHJveHkuZ3JvdXBUcmFuc2Zvcm0gPSBjb250YWluZXIuZ3JvdXBUcmFuc2Zvcm07XG4gIHByb3h5LmxvY2FsRGlzcGxheVN0YXR1cyA9IGNvbnRhaW5lci5sb2NhbERpc3BsYXlTdGF0dXM7XG4gIHByb3h5Lmdyb3VwQWxwaGEgPSBjb250YWluZXIuZ3JvdXBBbHBoYTtcbiAgcHJveHkuX3JvdW5kUGl4ZWxzID0gY29udGFpbmVyLl9yb3VuZFBpeGVscztcbn1cblxuZXhwb3J0IHsgQml0bWFwVGV4dFBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcFRleHRQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IGxvYWRCaXRtYXBGb250LCBiaXRtYXBGb250Q2FjaGVQbHVnaW4gfSBmcm9tICcuL2Fzc2V0L2xvYWRCaXRtYXBGb250Lm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBUZXh0UGlwZSB9IGZyb20gJy4vQml0bWFwVGV4dFBpcGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChCaXRtYXBUZXh0UGlwZSwgbG9hZEJpdG1hcEZvbnQsIGJpdG1hcEZvbnRDYWNoZVBsdWdpbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7602\n')},1709:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs\nvar updateQuadBounds = __webpack_require__(3747);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(900);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs\n\n\n\n\n\n\n"use strict";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText._getKey();\n    if (gpuText.textureNeedsUploading) {\n      gpuText.textureNeedsUploading = false;\n      return true;\n    }\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(htmlText) {\n    this._destroyRenderableById(htmlText.uid);\n  }\n  _destroyRenderableById(htmlTextUid) {\n    const gpuText = this._gpuText[htmlTextUid];\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    PoolGroup/* BigPool */.u.return(gpuText.batchableSprite);\n    this._gpuText[htmlTextUid] = null;\n  }\n  _updateText(htmlText) {\n    const newKey = htmlText._getKey();\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(htmlText).catch((e) => {\n        console.error(e);\n      });\n    }\n    htmlText._didTextUpdate = false;\n    const padding = htmlText._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const gpuText = this._getGpuText(htmlText);\n    if (gpuText.generatingTexture)\n      return;\n    const newKey = htmlText._getKey();\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    gpuText.generatingTexture = true;\n    gpuText.currentKey = newKey;\n    const resolution = htmlText.resolution ?? this._renderer.resolution;\n    const texture = await this._renderer.htmlText.getManagedTexture(\n      htmlText.text,\n      resolution,\n      htmlText._style,\n      htmlText._getKey()\n    );\n    const batchableSprite = gpuText.batchableSprite;\n    batchableSprite.texture = gpuText.texture = texture;\n    gpuText.generatingTexture = false;\n    gpuText.textureNeedsUploading = true;\n    htmlText.onViewUpdate();\n    const padding = htmlText._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  _getGpuText(htmlText) {\n    return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const gpuTextData = {\n      texture: Texture/* Texture */.x.EMPTY,\n      currentKey: "--",\n      batchableSprite: PoolGroup/* BigPool */.u.get(BatchableSprite/* BatchableSprite */.c),\n      textureNeedsUploading: false,\n      generatingTexture: false\n    };\n    const batchableSprite = gpuTextData.batchableSprite;\n    batchableSprite.renderable = htmlText;\n    batchableSprite.texture = Texture/* Texture */.x.EMPTY;\n    batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    this._gpuText[htmlText.uid] = gpuTextData;\n    htmlText.on("destroyed", () => {\n      this.destroyRenderable(htmlText);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "htmlText"\n};\n\n\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isSafari.mjs\n\n\n"use strict";\nfunction isSafari() {\n  const { userAgent } = adapter/* DOMAdapter */.z.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\n\n//# sourceMappingURL=isSafari.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs\nvar getPo2TextureFromSource = __webpack_require__(1647);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs\n\nconst nssvg = "http://www.w3.org/2000/svg";\nconst nsxhtml = "http://www.w3.org/1999/xhtml";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, "svg");\n    this.foreignObject = document.createElementNS(nssvg, "foreignObject");\n    this.domElement = document.createElementNS(nsxhtml, "div");\n    this.styleElement = document.createElementNS(nsxhtml, "style");\n    this.image = new Image();\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute("width", "10000");\n    foreignObject.setAttribute("height", "10000");\n    foreignObject.style.overflow = "hidden";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n  }\n}\n\n\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(3779);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs\nvar generateTextStyleKey = __webpack_require__(740);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs\n\n\n"use strict";\nfunction textStyleToCSS(style) {\n  const stroke = style._stroke;\n  const fill = style._fill;\n  const cssStyleString = [\n    `color: ${Color/* Color */.I.shared.setValue(fill.color).toHex()}`,\n    `font-size: ${style.fontSize}px`,\n    `font-family: ${style.fontFamily}`,\n    `font-weight: ${style.fontWeight}`,\n    `font-style: ${style.fontStyle}`,\n    `font-variant: ${style.fontVariant}`,\n    `letter-spacing: ${style.letterSpacing}px`,\n    `text-align: ${style.align}`,\n    `padding: ${style.padding}px`,\n    `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,\n    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n    ...style.wordWrap ? [\n      `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,\n      `max-width: ${style.wordWrapWidth}px`\n    ] : [],\n    ...stroke ? [strokeToCSS(stroke)] : [],\n    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n    ...style.cssOverrides\n  ].join(";");\n  const cssStyles = [`div { ${cssStyleString} }`];\n  tagStyleToCSS(style.tagStyles, cssStyles);\n  return cssStyles.join(" ");\n}\nfunction dropShadowToCSS(dropShadowStyle) {\n  const color = Color/* Color */.I.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n  const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const position = `${x}px ${y}px`;\n  if (dropShadowStyle.blur > 0) {\n    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n  }\n  return `text-shadow: ${position} ${color}`;\n}\nfunction strokeToCSS(stroke) {\n  return [\n    `-webkit-text-stroke-width: ${stroke.width}px`,\n    `-webkit-text-stroke-color: ${Color/* Color */.I.shared.setValue(stroke.color).toHex()}`,\n    `text-stroke-width: ${stroke.width}px`,\n    `text-stroke-color: ${Color/* Color */.I.shared.setValue(stroke.color).toHex()}`,\n    "paint-order: stroke"\n  ].join(";");\n}\nconst templates = {\n  fontSize: `font-size: {{VALUE}}px`,\n  fontFamily: `font-family: {{VALUE}}`,\n  fontWeight: `font-weight: {{VALUE}}`,\n  fontStyle: `font-style: {{VALUE}}`,\n  fontVariant: `font-variant: {{VALUE}}`,\n  letterSpacing: `letter-spacing: {{VALUE}}px`,\n  align: `text-align: {{VALUE}}`,\n  padding: `padding: {{VALUE}}px`,\n  whiteSpace: `white-space: {{VALUE}}`,\n  lineHeight: `line-height: {{VALUE}}px`,\n  wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst transform = {\n  fill: (value) => `color: ${Color/* Color */.I.shared.setValue(value).toHex()}`,\n  breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,\n  stroke: strokeToCSS,\n  dropShadow: dropShadowToCSS\n};\nfunction tagStyleToCSS(tagStyles, out) {\n  for (const i in tagStyles) {\n    const tagStyle = tagStyles[i];\n    const cssTagStyle = [];\n    for (const j in tagStyle) {\n      if (transform[j]) {\n        cssTagStyle.push(transform[j](tagStyle[j]));\n      } else if (templates[j]) {\n        cssTagStyle.push(templates[j].replace("{{VALUE}}", tagStyle[j]));\n      }\n    }\n    out.push(`${i} { ${cssTagStyle.join(";")} }`);\n  }\n}\n\n\n//# sourceMappingURL=textStyleToCSS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs\n\n\n\n\n\n"use strict";\nclass HTMLTextStyle extends TextStyle/* TextStyle */.p {\n  constructor(options = {}) {\n    super(options);\n    this._cssOverrides = [];\n    this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);\n    this.tagStyles = options.tagStyles ?? {};\n  }\n  /** List of style overrides that will be applied to the HTML text. */\n  set cssOverrides(value) {\n    this._cssOverrides = value instanceof Array ? value : [value];\n    this.update();\n  }\n  get cssOverrides() {\n    return this._cssOverrides;\n  }\n  _generateKey() {\n    this._styleKey = (0,generateTextStyleKey/* generateTextStyleKey */.L)(this) + this._cssOverrides.join("-");\n    return this._styleKey;\n  }\n  update() {\n    this._cssStyle = null;\n    super.update();\n  }\n  /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * @returns New cloned HTMLTextStyle object\n   */\n  clone() {\n    return new HTMLTextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth,\n      cssOverrides: this.cssOverrides\n    });\n  }\n  get cssStyle() {\n    if (!this._cssStyle) {\n      this._cssStyle = textStyleToCSS(this);\n    }\n    return this._cssStyle;\n  }\n  /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride(\'background-color: red\');\n   */\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n    if (toAdd.length > 0) {\n      this.cssOverrides.push(...toAdd);\n      this.update();\n    }\n  }\n  /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride(\'background-color: red\');\n   */\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n    if (toRemove.length > 0) {\n      this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n      this.update();\n    }\n  }\n  set fill(value) {\n    if (typeof value !== "string" && typeof value !== "number") {\n      (0,warn/* warn */.Z)("[HTMLTextStyle] only color fill is not supported by HTMLText");\n    }\n    super.fill = value;\n  }\n  set stroke(value) {\n    if (value && typeof value !== "string" && typeof value !== "number") {\n      (0,warn/* warn */.Z)("[HTMLTextStyle] only color stroke is not supported by HTMLText");\n    }\n    super.stroke = value;\n  }\n}\n\n\n//# sourceMappingURL=HtmlTextStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs\n\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(":")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\n\n//# sourceMappingURL=extractFontFamilies.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(4162);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs\n\n\n"use strict";\nasync function loadFontAsBase64(url) {\n  const response = await adapter/* DOMAdapter */.z.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\n\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs\n\n\n"use strict";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: "${style.fontFamily}";\n        src: url(\'${dataSrc}\');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\n\n//# sourceMappingURL=loadFontCSS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs\n\n\n\n"use strict";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies, style, defaultOptions) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache/* Cache */.C.has(`${fontFamily}-and-url`)).map((fontFamily, i) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { url } = Cache/* Cache */.C.get(`${fontFamily}-and-url`);\n      if (i === 0) {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));\n      } else {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS({\n          fontWeight: defaultOptions.fontWeight,\n          fontStyle: defaultOptions.fontStyle,\n          fontFamily\n        }, url));\n      }\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join("\\n");\n}\n\n\n//# sourceMappingURL=getFontCss.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs\n\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute("width", width.toString());\n  svgRoot.setAttribute("height", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\n\n//# sourceMappingURL=getSVGUrl.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs\n\n\n"use strict";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  CanvasPool/* CanvasPool */.h.returnCanvasAndContext(canvasAndContext);\n  return canvasAndContext.canvas;\n}\n\n\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs\n\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = "anonymous";\n  });\n}\n\n\n//# sourceMappingURL=loadSVGImage.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs\n\n\n\n"use strict";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const descenderPadding = CanvasTextMetrics/* CanvasTextMetrics */.c.measureFont(style.fontStyle).descent;\n  return {\n    width: contentBounds.width,\n    height: contentBounds.height + descenderPadding\n  };\n}\n\n\n//# sourceMappingURL=measureHtmlText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === types/* RendererType */.g.WEBGPU;\n  }\n  getTexture(options) {\n    return this._buildTexturePromise(\n      options.text,\n      options.resolution,\n      options.style\n    );\n  }\n  getManagedTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text, resolution, style).then((texture) => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  async _buildTexturePromise(text, resolution, style) {\n    const htmlTextData = PoolGroup/* BigPool */.u.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(\n      fontFamilies,\n      style,\n      HTMLTextStyle.defaultTextStyle\n    );\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    image.width = width | 0;\n    image.height = height | 0;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    let resource = image;\n    if (this._createCanvas) {\n      resource = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = (0,getPo2TextureFromSource/* getPo2TextureFromSource */.H)(resource, image.width, image.height, resolution);\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n    }\n    PoolGroup/* BigPool */.u.return(htmlTextData);\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture)\n      return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture);\n      } else {\n        activeTexture.promise.then((texture) => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture);\n        }).catch(() => {\n          (0,warn/* warn */.Z)("HTMLTextSystem: Failed to clean texture");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  _cleanUp(activeTexture) {\n    TexturePool/* TexturePool */.z.returnTexture(activeTexture.texture);\n    activeTexture.texture.source.resource = null;\n    activeTexture.texture.source.uploadMethodId = "unknown";\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "htmlText"\n};\nHTMLTextSystem.defaultFontOptions = {\n  fontFamily: "Arial",\n  fontStyle: "normal",\n  fontWeight: "normal"\n};\n\n\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(HTMLTextSystem);\nExtensions/* extensions */.Rw.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxVQUFVLG9CQUFJO0FBQ2QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhCQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQjs7O0FDM0g2RDtBQUNYO0FBQ0k7O0FBRXREO0FBQ0EsNkJBQVUsS0FBSyxjQUFjO0FBQzdCLDZCQUFVLEtBQUssWUFBWTtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0UGlwZS5tanM/MTllYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2Jyb3dzZXIvaXNTYWZhcmkubWpzPzNkZDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvSFRNTFRleHRSZW5kZXJEYXRhLm1qcz82YjM4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL3RleHRTdHlsZVRvQ1NTLm1qcz80ZGY5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL0h0bWxUZXh0U3R5bGUubWpzPzA2MGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZXh0cmFjdEZvbnRGYW1pbGllcy5tanM/MGFhZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkRm9udEFzQmFzZTY0Lm1qcz85Zjc5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2xvYWRGb250Q1NTLm1qcz8xNGZhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2dldEZvbnRDc3MubWpzP2Q5MmQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0U1ZHVXJsLm1qcz8yM2QwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2dldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZS5tanM/OWExZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkU1ZHSW1hZ2UubWpzP2QxYTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvbWVhc3VyZUh0bWxUZXh0Lm1qcz9iNzk2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0U3lzdGVtLm1qcz80ZjBmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL2luaXQubWpzPzFiNjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgdXBkYXRlUXVhZEJvdW5kcyB9IGZyb20gJy4uLy4uL3V0aWxzL2RhdGEvdXBkYXRlUXVhZEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGFibGVTcHJpdGUgfSBmcm9tICcuLi9zcHJpdGUvQmF0Y2hhYmxlU3ByaXRlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgSFRNTFRleHRQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9ncHVUZXh0ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICB2YWxpZGF0ZVJlbmRlcmFibGUoaHRtbFRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgY29uc3QgbmV3S2V5ID0gaHRtbFRleHQuX2dldEtleSgpO1xuICAgIGlmIChncHVUZXh0LnRleHR1cmVOZWVkc1VwbG9hZGluZykge1xuICAgICAgZ3B1VGV4dC50ZXh0dXJlTmVlZHNVcGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ3B1VGV4dC5jdXJyZW50S2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZShodG1sVGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KGh0bWxUZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoaHRtbFRleHQuX2RpZFRleHRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHQoaHRtbFRleHQpO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5hZGRUb0JhdGNoKGJhdGNoYWJsZVNwcml0ZSk7XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShodG1sVGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KGh0bWxUZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoaHRtbFRleHQuX2RpZFRleHRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHQoaHRtbFRleHQpO1xuICAgIH1cbiAgICBiYXRjaGFibGVTcHJpdGUuYmF0Y2hlci51cGRhdGVFbGVtZW50KGJhdGNoYWJsZVNwcml0ZSk7XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUoaHRtbFRleHQpIHtcbiAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5SWQoaHRtbFRleHQudWlkKTtcbiAgfVxuICBfZGVzdHJveVJlbmRlcmFibGVCeUlkKGh0bWxUZXh0VWlkKSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dwdVRleHRbaHRtbFRleHRVaWRdO1xuICAgIHRoaXMuX3JlbmRlcmVyLmh0bWxUZXh0LmRlY3JlYXNlUmVmZXJlbmNlQ291bnQoZ3B1VGV4dC5jdXJyZW50S2V5KTtcbiAgICBCaWdQb29sLnJldHVybihncHVUZXh0LmJhdGNoYWJsZVNwcml0ZSk7XG4gICAgdGhpcy5fZ3B1VGV4dFtodG1sVGV4dFVpZF0gPSBudWxsO1xuICB9XG4gIF91cGRhdGVUZXh0KGh0bWxUZXh0KSB7XG4gICAgY29uc3QgbmV3S2V5ID0gaHRtbFRleHQuX2dldEtleSgpO1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KGh0bWxUZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoZ3B1VGV4dC5jdXJyZW50S2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUdwdVRleHQoaHRtbFRleHQpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaHRtbFRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBwYWRkaW5nID0gaHRtbFRleHQuX3N0eWxlLnBhZGRpbmc7XG4gICAgdXBkYXRlUXVhZEJvdW5kcyhiYXRjaGFibGVTcHJpdGUuYm91bmRzLCBodG1sVGV4dC5fYW5jaG9yLCBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSwgcGFkZGluZyk7XG4gIH1cbiAgYXN5bmMgX3VwZGF0ZUdwdVRleHQoaHRtbFRleHQpIHtcbiAgICBodG1sVGV4dC5fZGlkVGV4dFVwZGF0ZSA9IGZhbHNlO1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KGh0bWxUZXh0KTtcbiAgICBpZiAoZ3B1VGV4dC5nZW5lcmF0aW5nVGV4dHVyZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuZXdLZXkgPSBodG1sVGV4dC5fZ2V0S2V5KCk7XG4gICAgdGhpcy5fcmVuZGVyZXIuaHRtbFRleHQuZGVjcmVhc2VSZWZlcmVuY2VDb3VudChncHVUZXh0LmN1cnJlbnRLZXkpO1xuICAgIGdwdVRleHQuZ2VuZXJhdGluZ1RleHR1cmUgPSB0cnVlO1xuICAgIGdwdVRleHQuY3VycmVudEtleSA9IG5ld0tleTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gaHRtbFRleHQucmVzb2x1dGlvbiA/PyB0aGlzLl9yZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IHRleHR1cmUgPSBhd2FpdCB0aGlzLl9yZW5kZXJlci5odG1sVGV4dC5nZXRNYW5hZ2VkVGV4dHVyZShcbiAgICAgIGh0bWxUZXh0LnRleHQsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgaHRtbFRleHQuX3N0eWxlLFxuICAgICAgaHRtbFRleHQuX2dldEtleSgpXG4gICAgKTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSA9IGdwdVRleHQudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgZ3B1VGV4dC5nZW5lcmF0aW5nVGV4dHVyZSA9IGZhbHNlO1xuICAgIGdwdVRleHQudGV4dHVyZU5lZWRzVXBsb2FkaW5nID0gdHJ1ZTtcbiAgICBodG1sVGV4dC5vblZpZXdVcGRhdGUoKTtcbiAgICBjb25zdCBwYWRkaW5nID0gaHRtbFRleHQuX3N0eWxlLnBhZGRpbmc7XG4gICAgdXBkYXRlUXVhZEJvdW5kcyhiYXRjaGFibGVTcHJpdGUuYm91bmRzLCBodG1sVGV4dC5fYW5jaG9yLCBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSwgcGFkZGluZyk7XG4gIH1cbiAgX2dldEdwdVRleHQoaHRtbFRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1VGV4dFtodG1sVGV4dC51aWRdIHx8IHRoaXMuaW5pdEdwdVRleHQoaHRtbFRleHQpO1xuICB9XG4gIGluaXRHcHVUZXh0KGh0bWxUZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dERhdGEgPSB7XG4gICAgICB0ZXh0dXJlOiBUZXh0dXJlLkVNUFRZLFxuICAgICAgY3VycmVudEtleTogXCItLVwiLFxuICAgICAgYmF0Y2hhYmxlU3ByaXRlOiBCaWdQb29sLmdldChCYXRjaGFibGVTcHJpdGUpLFxuICAgICAgdGV4dHVyZU5lZWRzVXBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIGdlbmVyYXRpbmdUZXh0dXJlOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgYmF0Y2hhYmxlU3ByaXRlID0gZ3B1VGV4dERhdGEuYmF0Y2hhYmxlU3ByaXRlO1xuICAgIGJhdGNoYWJsZVNwcml0ZS5yZW5kZXJhYmxlID0gaHRtbFRleHQ7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUgPSBUZXh0dXJlLkVNUFRZO1xuICAgIGJhdGNoYWJsZVNwcml0ZS5ib3VuZHMgPSB7IG1pblg6IDAsIG1heFg6IDEsIG1pblk6IDAsIG1heFk6IDAgfTtcbiAgICBiYXRjaGFibGVTcHJpdGUucm91bmRQaXhlbHMgPSB0aGlzLl9yZW5kZXJlci5fcm91bmRQaXhlbHMgfCBodG1sVGV4dC5fcm91bmRQaXhlbHM7XG4gICAgdGhpcy5fZ3B1VGV4dFtodG1sVGV4dC51aWRdID0gZ3B1VGV4dERhdGE7XG4gICAgaHRtbFRleHQub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShodG1sVGV4dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdwdVRleHREYXRhO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2dwdVRleHQpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZChpKTtcbiAgICB9XG4gICAgdGhpcy5fZ3B1VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuSFRNTFRleHRQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJodG1sVGV4dFwiXG59O1xuXG5leHBvcnQgeyBIVE1MVGV4dFBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxUZXh0UGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICBjb25zdCB7IHVzZXJBZ2VudCB9ID0gRE9NQWRhcHRlci5nZXQoKS5nZXROYXZpZ2F0b3IoKTtcbiAgcmV0dXJuIC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QodXNlckFnZW50KTtcbn1cblxuZXhwb3J0IHsgaXNTYWZhcmkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2FmYXJpLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbnNzdmcgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jb25zdCBuc3hodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5jbGFzcyBIVE1MVGV4dFJlbmRlckRhdGEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN2Z1Jvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwic3ZnXCIpO1xuICAgIHRoaXMuZm9yZWlnbk9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3N2ZywgXCJmb3JlaWduT2JqZWN0XCIpO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3hodG1sLCBcImRpdlwiKTtcbiAgICB0aGlzLnN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3hodG1sLCBcInN0eWxlXCIpO1xuICAgIHRoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBjb25zdCB7IGZvcmVpZ25PYmplY3QsIHN2Z1Jvb3QsIHN0eWxlRWxlbWVudCwgZG9tRWxlbWVudCB9ID0gdGhpcztcbiAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTAwMDBcIik7XG4gICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIxMDAwMFwiKTtcbiAgICBmb3JlaWduT2JqZWN0LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICBzdmdSb290LmFwcGVuZENoaWxkKGZvcmVpZ25PYmplY3QpO1xuICAgIGZvcmVpZ25PYmplY3QuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICBmb3JlaWduT2JqZWN0LmFwcGVuZENoaWxkKGRvbUVsZW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydCB7IEhUTUxUZXh0UmVuZGVyRGF0YSwgbnNzdmcsIG5zeGh0bWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxUZXh0UmVuZGVyRGF0YS5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gdGV4dFN0eWxlVG9DU1Moc3R5bGUpIHtcbiAgY29uc3Qgc3Ryb2tlID0gc3R5bGUuX3N0cm9rZTtcbiAgY29uc3QgZmlsbCA9IHN0eWxlLl9maWxsO1xuICBjb25zdCBjc3NTdHlsZVN0cmluZyA9IFtcbiAgICBgY29sb3I6ICR7Q29sb3Iuc2hhcmVkLnNldFZhbHVlKGZpbGwuY29sb3IpLnRvSGV4KCl9YCxcbiAgICBgZm9udC1zaXplOiAke3N0eWxlLmZvbnRTaXplfXB4YCxcbiAgICBgZm9udC1mYW1pbHk6ICR7c3R5bGUuZm9udEZhbWlseX1gLFxuICAgIGBmb250LXdlaWdodDogJHtzdHlsZS5mb250V2VpZ2h0fWAsXG4gICAgYGZvbnQtc3R5bGU6ICR7c3R5bGUuZm9udFN0eWxlfWAsXG4gICAgYGZvbnQtdmFyaWFudDogJHtzdHlsZS5mb250VmFyaWFudH1gLFxuICAgIGBsZXR0ZXItc3BhY2luZzogJHtzdHlsZS5sZXR0ZXJTcGFjaW5nfXB4YCxcbiAgICBgdGV4dC1hbGlnbjogJHtzdHlsZS5hbGlnbn1gLFxuICAgIGBwYWRkaW5nOiAke3N0eWxlLnBhZGRpbmd9cHhgLFxuICAgIGB3aGl0ZS1zcGFjZTogJHtzdHlsZS53aGl0ZVNwYWNlID09PSBcInByZVwiICYmIHN0eWxlLndvcmRXcmFwID8gXCJwcmUtd3JhcFwiIDogc3R5bGUud2hpdGVTcGFjZX1gLFxuICAgIC4uLnN0eWxlLmxpbmVIZWlnaHQgPyBbYGxpbmUtaGVpZ2h0OiAke3N0eWxlLmxpbmVIZWlnaHR9cHhgXSA6IFtdLFxuICAgIC4uLnN0eWxlLndvcmRXcmFwID8gW1xuICAgICAgYHdvcmQtd3JhcDogJHtzdHlsZS5icmVha1dvcmRzID8gXCJicmVhay1hbGxcIiA6IFwiYnJlYWstd29yZFwifWAsXG4gICAgICBgbWF4LXdpZHRoOiAke3N0eWxlLndvcmRXcmFwV2lkdGh9cHhgXG4gICAgXSA6IFtdLFxuICAgIC4uLnN0cm9rZSA/IFtzdHJva2VUb0NTUyhzdHJva2UpXSA6IFtdLFxuICAgIC4uLnN0eWxlLmRyb3BTaGFkb3cgPyBbZHJvcFNoYWRvd1RvQ1NTKHN0eWxlLmRyb3BTaGFkb3cpXSA6IFtdLFxuICAgIC4uLnN0eWxlLmNzc092ZXJyaWRlc1xuICBdLmpvaW4oXCI7XCIpO1xuICBjb25zdCBjc3NTdHlsZXMgPSBbYGRpdiB7ICR7Y3NzU3R5bGVTdHJpbmd9IH1gXTtcbiAgdGFnU3R5bGVUb0NTUyhzdHlsZS50YWdTdHlsZXMsIGNzc1N0eWxlcyk7XG4gIHJldHVybiBjc3NTdHlsZXMuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiBkcm9wU2hhZG93VG9DU1MoZHJvcFNoYWRvd1N0eWxlKSB7XG4gIGNvbnN0IGNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGRyb3BTaGFkb3dTdHlsZS5jb2xvcikuc2V0QWxwaGEoZHJvcFNoYWRvd1N0eWxlLmFscGhhKS50b0hleGEoKTtcbiAgY29uc3QgeCA9IE1hdGgucm91bmQoTWF0aC5jb3MoZHJvcFNoYWRvd1N0eWxlLmFuZ2xlKSAqIGRyb3BTaGFkb3dTdHlsZS5kaXN0YW5jZSk7XG4gIGNvbnN0IHkgPSBNYXRoLnJvdW5kKE1hdGguc2luKGRyb3BTaGFkb3dTdHlsZS5hbmdsZSkgKiBkcm9wU2hhZG93U3R5bGUuZGlzdGFuY2UpO1xuICBjb25zdCBwb3NpdGlvbiA9IGAke3h9cHggJHt5fXB4YDtcbiAgaWYgKGRyb3BTaGFkb3dTdHlsZS5ibHVyID4gMCkge1xuICAgIHJldHVybiBgdGV4dC1zaGFkb3c6ICR7cG9zaXRpb259ICR7ZHJvcFNoYWRvd1N0eWxlLmJsdXJ9cHggJHtjb2xvcn1gO1xuICB9XG4gIHJldHVybiBgdGV4dC1zaGFkb3c6ICR7cG9zaXRpb259ICR7Y29sb3J9YDtcbn1cbmZ1bmN0aW9uIHN0cm9rZVRvQ1NTKHN0cm9rZSkge1xuICByZXR1cm4gW1xuICAgIGAtd2Via2l0LXRleHQtc3Ryb2tlLXdpZHRoOiAke3N0cm9rZS53aWR0aH1weGAsXG4gICAgYC13ZWJraXQtdGV4dC1zdHJva2UtY29sb3I6ICR7Q29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0cm9rZS5jb2xvcikudG9IZXgoKX1gLFxuICAgIGB0ZXh0LXN0cm9rZS13aWR0aDogJHtzdHJva2Uud2lkdGh9cHhgLFxuICAgIGB0ZXh0LXN0cm9rZS1jb2xvcjogJHtDb2xvci5zaGFyZWQuc2V0VmFsdWUoc3Ryb2tlLmNvbG9yKS50b0hleCgpfWAsXG4gICAgXCJwYWludC1vcmRlcjogc3Ryb2tlXCJcbiAgXS5qb2luKFwiO1wiKTtcbn1cbmNvbnN0IHRlbXBsYXRlcyA9IHtcbiAgZm9udFNpemU6IGBmb250LXNpemU6IHt7VkFMVUV9fXB4YCxcbiAgZm9udEZhbWlseTogYGZvbnQtZmFtaWx5OiB7e1ZBTFVFfX1gLFxuICBmb250V2VpZ2h0OiBgZm9udC13ZWlnaHQ6IHt7VkFMVUV9fWAsXG4gIGZvbnRTdHlsZTogYGZvbnQtc3R5bGU6IHt7VkFMVUV9fWAsXG4gIGZvbnRWYXJpYW50OiBgZm9udC12YXJpYW50OiB7e1ZBTFVFfX1gLFxuICBsZXR0ZXJTcGFjaW5nOiBgbGV0dGVyLXNwYWNpbmc6IHt7VkFMVUV9fXB4YCxcbiAgYWxpZ246IGB0ZXh0LWFsaWduOiB7e1ZBTFVFfX1gLFxuICBwYWRkaW5nOiBgcGFkZGluZzoge3tWQUxVRX19cHhgLFxuICB3aGl0ZVNwYWNlOiBgd2hpdGUtc3BhY2U6IHt7VkFMVUV9fWAsXG4gIGxpbmVIZWlnaHQ6IGBsaW5lLWhlaWdodDoge3tWQUxVRX19cHhgLFxuICB3b3JkV3JhcFdpZHRoOiBgbWF4LXdpZHRoOiB7e1ZBTFVFfX1weGBcbn07XG5jb25zdCB0cmFuc2Zvcm0gPSB7XG4gIGZpbGw6ICh2YWx1ZSkgPT4gYGNvbG9yOiAke0NvbG9yLnNoYXJlZC5zZXRWYWx1ZSh2YWx1ZSkudG9IZXgoKX1gLFxuICBicmVha1dvcmRzOiAodmFsdWUpID0+IGB3b3JkLXdyYXA6ICR7dmFsdWUgPyBcImJyZWFrLWFsbFwiIDogXCJicmVhay13b3JkXCJ9YCxcbiAgc3Ryb2tlOiBzdHJva2VUb0NTUyxcbiAgZHJvcFNoYWRvdzogZHJvcFNoYWRvd1RvQ1NTXG59O1xuZnVuY3Rpb24gdGFnU3R5bGVUb0NTUyh0YWdTdHlsZXMsIG91dCkge1xuICBmb3IgKGNvbnN0IGkgaW4gdGFnU3R5bGVzKSB7XG4gICAgY29uc3QgdGFnU3R5bGUgPSB0YWdTdHlsZXNbaV07XG4gICAgY29uc3QgY3NzVGFnU3R5bGUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGogaW4gdGFnU3R5bGUpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1bal0pIHtcbiAgICAgICAgY3NzVGFnU3R5bGUucHVzaCh0cmFuc2Zvcm1bal0odGFnU3R5bGVbal0pKTtcbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGVzW2pdKSB7XG4gICAgICAgIGNzc1RhZ1N0eWxlLnB1c2godGVtcGxhdGVzW2pdLnJlcGxhY2UoXCJ7e1ZBTFVFfX1cIiwgdGFnU3R5bGVbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0LnB1c2goYCR7aX0geyAke2Nzc1RhZ1N0eWxlLmpvaW4oXCI7XCIpfSB9YCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgdGV4dFN0eWxlVG9DU1MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHRTdHlsZVRvQ1NTLm1qcy5tYXBcbiIsImltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IFRleHRTdHlsZSB9IGZyb20gJy4uL3RleHQvVGV4dFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVRleHRTdHlsZUtleSB9IGZyb20gJy4uL3RleHQvdXRpbHMvZ2VuZXJhdGVUZXh0U3R5bGVLZXkubWpzJztcbmltcG9ydCB7IHRleHRTdHlsZVRvQ1NTIH0gZnJvbSAnLi91dGlscy90ZXh0U3R5bGVUb0NTUy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEhUTUxUZXh0U3R5bGUgZXh0ZW5kcyBUZXh0U3R5bGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLl9jc3NPdmVycmlkZXMgPSBbXTtcbiAgICB0aGlzLmNzc092ZXJyaWRlcyA/PyAodGhpcy5jc3NPdmVycmlkZXMgPSBvcHRpb25zLmNzc092ZXJyaWRlcyk7XG4gICAgdGhpcy50YWdTdHlsZXMgPSBvcHRpb25zLnRhZ1N0eWxlcyA/PyB7fTtcbiAgfVxuICAvKiogTGlzdCBvZiBzdHlsZSBvdmVycmlkZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIEhUTUwgdGV4dC4gKi9cbiAgc2V0IGNzc092ZXJyaWRlcyh2YWx1ZSkge1xuICAgIHRoaXMuX2Nzc092ZXJyaWRlcyA9IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICBnZXQgY3NzT3ZlcnJpZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jc3NPdmVycmlkZXM7XG4gIH1cbiAgX2dlbmVyYXRlS2V5KCkge1xuICAgIHRoaXMuX3N0eWxlS2V5ID0gZ2VuZXJhdGVUZXh0U3R5bGVLZXkodGhpcykgKyB0aGlzLl9jc3NPdmVycmlkZXMuam9pbihcIi1cIik7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlS2V5O1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9jc3NTdHlsZSA9IG51bGw7XG4gICAgc3VwZXIudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSFRNTFRleHRTdHlsZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIEByZXR1cm5zIE5ldyBjbG9uZWQgSFRNTFRleHRTdHlsZSBvYmplY3RcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgSFRNTFRleHRTdHlsZSh7XG4gICAgICBhbGlnbjogdGhpcy5hbGlnbixcbiAgICAgIGJyZWFrV29yZHM6IHRoaXMuYnJlYWtXb3JkcyxcbiAgICAgIGRyb3BTaGFkb3c6IHRoaXMuZHJvcFNoYWRvdyxcbiAgICAgIGZpbGw6IHRoaXMuX2ZpbGwsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSxcbiAgICAgIGZvbnRTdHlsZTogdGhpcy5mb250U3R5bGUsXG4gICAgICBmb250VmFyaWFudDogdGhpcy5mb250VmFyaWFudCxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCxcbiAgICAgIGxldHRlclNwYWNpbmc6IHRoaXMubGV0dGVyU3BhY2luZyxcbiAgICAgIGxpbmVIZWlnaHQ6IHRoaXMubGluZUhlaWdodCxcbiAgICAgIHBhZGRpbmc6IHRoaXMucGFkZGluZyxcbiAgICAgIHN0cm9rZTogdGhpcy5fc3Ryb2tlLFxuICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgd29yZFdyYXA6IHRoaXMud29yZFdyYXAsXG4gICAgICB3b3JkV3JhcFdpZHRoOiB0aGlzLndvcmRXcmFwV2lkdGgsXG4gICAgICBjc3NPdmVycmlkZXM6IHRoaXMuY3NzT3ZlcnJpZGVzXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGNzc1N0eWxlKCkge1xuICAgIGlmICghdGhpcy5fY3NzU3R5bGUpIHtcbiAgICAgIHRoaXMuX2Nzc1N0eWxlID0gdGV4dFN0eWxlVG9DU1ModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jc3NTdHlsZTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgc3R5bGUgb3ZlcnJpZGUsIHRoaXMgY2FuIGJlIGFueSBDU1MgcHJvcGVydHlcbiAgICogaXQgd2lsbCBvdmVycmlkZSBhbnkgYnVpbHQtaW4gc3R5bGUuIFRoaXMgaXMgdGhlXG4gICAqIHByb3BlcnR5IGFuZCB0aGUgdmFsdWUgYXMgYSBzdHJpbmcgKGUuZy4sIGBjb2xvcjogcmVkYCkuXG4gICAqIFRoaXMgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgaW50ZXJuYWwgc3R5bGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIENTUyBzdHlsZShzKSB0byBhZGQuXG4gICAqIEBleGFtcGxlXG4gICAqIHN0eWxlLmFkZE92ZXJyaWRlKCdiYWNrZ3JvdW5kLWNvbG9yOiByZWQnKTtcbiAgICovXG4gIGFkZE92ZXJyaWRlKC4uLnZhbHVlKSB7XG4gICAgY29uc3QgdG9BZGQgPSB2YWx1ZS5maWx0ZXIoKHYpID0+ICF0aGlzLmNzc092ZXJyaWRlcy5pbmNsdWRlcyh2KSk7XG4gICAgaWYgKHRvQWRkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY3NzT3ZlcnJpZGVzLnB1c2goLi4udG9BZGQpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbnkgb3ZlcnJpZGVzIHRoYXQgbWF0Y2ggdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBDU1Mgc3R5bGUgdG8gcmVtb3ZlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBzdHlsZS5yZW1vdmVPdmVycmlkZSgnYmFja2dyb3VuZC1jb2xvcjogcmVkJyk7XG4gICAqL1xuICByZW1vdmVPdmVycmlkZSguLi52YWx1ZSkge1xuICAgIGNvbnN0IHRvUmVtb3ZlID0gdmFsdWUuZmlsdGVyKCh2KSA9PiB0aGlzLmNzc092ZXJyaWRlcy5pbmNsdWRlcyh2KSk7XG4gICAgaWYgKHRvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY3NzT3ZlcnJpZGVzID0gdGhpcy5jc3NPdmVycmlkZXMuZmlsdGVyKCh2KSA9PiAhdG9SZW1vdmUuaW5jbHVkZXModikpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgc2V0IGZpbGwodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgd2FybihcIltIVE1MVGV4dFN0eWxlXSBvbmx5IGNvbG9yIGZpbGwgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgICB9XG4gICAgc3VwZXIuZmlsbCA9IHZhbHVlO1xuICB9XG4gIHNldCBzdHJva2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgd2FybihcIltIVE1MVGV4dFN0eWxlXSBvbmx5IGNvbG9yIHN0cm9rZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICAgIH1cbiAgICBzdXBlci5zdHJva2UgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBIVE1MVGV4dFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IdG1sVGV4dFN0eWxlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZXh0cmFjdEZvbnRGYW1pbGllcyh0ZXh0LCBzdHlsZSkge1xuICBjb25zdCBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseTtcbiAgY29uc3QgZm9udEZhbWlsaWVzID0gW107XG4gIGNvbnN0IGRlZHVwZSA9IHt9O1xuICBjb25zdCByZWdleCA9IC9mb250LWZhbWlseTooW147XCJcXHNdKykvZztcbiAgY29uc3QgbWF0Y2hlcyA9IHRleHQubWF0Y2gocmVnZXgpO1xuICBmdW5jdGlvbiBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkyKSB7XG4gICAgaWYgKCFkZWR1cGVbZm9udEZhbWlseTJdKSB7XG4gICAgICBmb250RmFtaWxpZXMucHVzaChmb250RmFtaWx5Mik7XG4gICAgICBkZWR1cGVbZm9udEZhbWlseTJdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZm9udEZhbWlseSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbnRGYW1pbHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZEZvbnRGYW1pbHkoZm9udEZhbWlseVtpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFkZEZvbnRGYW1pbHkoZm9udEZhbWlseSk7XG4gIH1cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBjb25zdCBmb250RmFtaWx5MiA9IG1hdGNoLnNwbGl0KFwiOlwiKVsxXS50cmltKCk7XG4gICAgICBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkyKTtcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IGkgaW4gc3R5bGUudGFnU3R5bGVzKSB7XG4gICAgY29uc3QgZm9udEZhbWlseTIgPSBzdHlsZS50YWdTdHlsZXNbaV0uZm9udEZhbWlseTtcbiAgICBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkyKTtcbiAgfVxuICByZXR1cm4gZm9udEZhbWlsaWVzO1xufVxuXG5leHBvcnQgeyBleHRyYWN0Rm9udEZhbWlsaWVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0Rm9udEZhbWlsaWVzLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuYXN5bmMgZnVuY3Rpb24gbG9hZEZvbnRBc0Jhc2U2NCh1cmwpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBET01BZGFwdGVyLmdldCgpLmZldGNoKHVybCk7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGNvbnN0IGRhdGFTcmMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gIH0pO1xuICByZXR1cm4gZGF0YVNyYztcbn1cblxuZXhwb3J0IHsgbG9hZEZvbnRBc0Jhc2U2NCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEZvbnRBc0Jhc2U2NC5tanMubWFwXG4iLCJpbXBvcnQgeyBsb2FkRm9udEFzQmFzZTY0IH0gZnJvbSAnLi9sb2FkRm9udEFzQmFzZTY0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuYXN5bmMgZnVuY3Rpb24gbG9hZEZvbnRDU1Moc3R5bGUsIHVybCkge1xuICBjb25zdCBkYXRhU3JjID0gYXdhaXQgbG9hZEZvbnRBc0Jhc2U2NCh1cmwpO1xuICByZXR1cm4gYEBmb250LWZhY2Uge1xuICAgICAgICBmb250LWZhbWlseTogXCIke3N0eWxlLmZvbnRGYW1pbHl9XCI7XG4gICAgICAgIHNyYzogdXJsKCcke2RhdGFTcmN9Jyk7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiAke3N0eWxlLmZvbnRXZWlnaHR9O1xuICAgICAgICBmb250LXN0eWxlOiAke3N0eWxlLmZvbnRTdHlsZX07XG4gICAgfWA7XG59XG5cbmV4cG9ydCB7IGxvYWRGb250Q1NTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkRm9udENTUy5tanMubWFwXG4iLCJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4uLy4uLy4uL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgbG9hZEZvbnRDU1MgfSBmcm9tICcuL2xvYWRGb250Q1NTLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgRm9udFN0eWxlUHJvbWlzZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmFzeW5jIGZ1bmN0aW9uIGdldEZvbnRDc3MoZm9udEZhbWlsaWVzLCBzdHlsZSwgZGVmYXVsdE9wdGlvbnMpIHtcbiAgY29uc3QgZm9udFByb21pc2VzID0gZm9udEZhbWlsaWVzLmZpbHRlcigoZm9udEZhbWlseSkgPT4gQ2FjaGUuaGFzKGAke2ZvbnRGYW1pbHl9LWFuZC11cmxgKSkubWFwKChmb250RmFtaWx5LCBpKSA9PiB7XG4gICAgaWYgKCFGb250U3R5bGVQcm9taXNlQ2FjaGUuaGFzKGZvbnRGYW1pbHkpKSB7XG4gICAgICBjb25zdCB7IHVybCB9ID0gQ2FjaGUuZ2V0KGAke2ZvbnRGYW1pbHl9LWFuZC11cmxgKTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIEZvbnRTdHlsZVByb21pc2VDYWNoZS5zZXQoZm9udEZhbWlseSwgbG9hZEZvbnRDU1Moc3R5bGUsIHVybCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRm9udFN0eWxlUHJvbWlzZUNhY2hlLnNldChmb250RmFtaWx5LCBsb2FkRm9udENTUyh7XG4gICAgICAgICAgZm9udFdlaWdodDogZGVmYXVsdE9wdGlvbnMuZm9udFdlaWdodCxcbiAgICAgICAgICBmb250U3R5bGU6IGRlZmF1bHRPcHRpb25zLmZvbnRTdHlsZSxcbiAgICAgICAgICBmb250RmFtaWx5XG4gICAgICAgIH0sIHVybCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRm9udFN0eWxlUHJvbWlzZUNhY2hlLmdldChmb250RmFtaWx5KTtcbiAgfSk7XG4gIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoZm9udFByb21pc2VzKSkuam9pbihcIlxcblwiKTtcbn1cblxuZXhwb3J0IHsgRm9udFN0eWxlUHJvbWlzZUNhY2hlLCBnZXRGb250Q3NzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGb250Q3NzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0U1ZHVXJsKHRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBmb250Q1NTLCBodG1sVGV4dERhdGEpIHtcbiAgY29uc3QgeyBkb21FbGVtZW50LCBzdHlsZUVsZW1lbnQsIHN2Z1Jvb3QgfSA9IGh0bWxUZXh0RGF0YTtcbiAgZG9tRWxlbWVudC5pbm5lckhUTUwgPSBgPHN0eWxlPiR7c3R5bGUuY3NzU3R5bGV9PC9zdHlsZT48ZGl2PiR7dGV4dH08L2Rpdj5gO1xuICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGB0cmFuc2Zvcm06IHNjYWxlKCR7cmVzb2x1dGlvbn0pO3RyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0OyBkaXNwbGF5OiBpbmxpbmUtYmxvY2tgKTtcbiAgc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gZm9udENTUztcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBodG1sVGV4dERhdGEuaW1hZ2U7XG4gIHN2Z1Jvb3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGgudG9TdHJpbmcoKSk7XG4gIHN2Z1Jvb3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodC50b1N0cmluZygpKTtcbiAgcmV0dXJuIG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnUm9vdCk7XG59XG5cbmV4cG9ydCB7IGdldFNWR1VybCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0U1ZHVXJsLm1qcy5tYXBcbiIsImltcG9ydCB7IENhbnZhc1Bvb2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UoaW1hZ2UsIHJlc29sdXRpb24pIHtcbiAgY29uc3QgY2FudmFzQW5kQ29udGV4dCA9IENhbnZhc1Bvb2wuZ2V0T3B0aW1hbENhbnZhc0FuZENvbnRleHQoXG4gICAgaW1hZ2Uud2lkdGgsXG4gICAgaW1hZ2UuaGVpZ2h0LFxuICAgIHJlc29sdXRpb25cbiAgKTtcbiAgY29uc3QgeyBjb250ZXh0IH0gPSBjYW52YXNBbmRDb250ZXh0O1xuICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcbiAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICBDYW52YXNQb29sLnJldHVybkNhbnZhc0FuZENvbnRleHQoY2FudmFzQW5kQ29udGV4dCk7XG4gIHJldHVybiBjYW52YXNBbmRDb250ZXh0LmNhbnZhcztcbn1cblxuZXhwb3J0IHsgZ2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBsb2FkU1ZHSW1hZ2UoaW1hZ2UsIHVybCwgZGVsYXkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTIpID0+IHNldFRpbWVvdXQocmVzb2x2ZTIsIDEwMCkpO1xuICAgIH1cbiAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBpbWFnZS5zcmMgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmOCwke2VuY29kZVVSSUNvbXBvbmVudCh1cmwpfWA7XG4gICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgbG9hZFNWR0ltYWdlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkU1ZHSW1hZ2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuLi8uLi90ZXh0L2NhbnZhcy9DYW52YXNUZXh0TWV0cmljcy5tanMnO1xuaW1wb3J0IHsgSFRNTFRleHRSZW5kZXJEYXRhIH0gZnJvbSAnLi4vSFRNTFRleHRSZW5kZXJEYXRhLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xubGV0IHRlbXBIVE1MVGV4dFJlbmRlckRhdGE7XG5mdW5jdGlvbiBtZWFzdXJlSHRtbFRleHQodGV4dCwgc3R5bGUsIGZvbnRTdHlsZUNTUywgaHRtbFRleHRSZW5kZXJEYXRhKSB7XG4gIGh0bWxUZXh0UmVuZGVyRGF0YSA9IGh0bWxUZXh0UmVuZGVyRGF0YSB8fCB0ZW1wSFRNTFRleHRSZW5kZXJEYXRhIHx8ICh0ZW1wSFRNTFRleHRSZW5kZXJEYXRhID0gbmV3IEhUTUxUZXh0UmVuZGVyRGF0YSgpKTtcbiAgY29uc3QgeyBkb21FbGVtZW50LCBzdHlsZUVsZW1lbnQsIHN2Z1Jvb3QgfSA9IGh0bWxUZXh0UmVuZGVyRGF0YTtcbiAgZG9tRWxlbWVudC5pbm5lckhUTUwgPSBgPHN0eWxlPiR7c3R5bGUuY3NzU3R5bGV9PC9zdHlsZT48ZGl2PiR7dGV4dH08L2Rpdj5gO1xuICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwidHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7IGRpc3BsYXk6IGlubGluZS1ibG9ja1wiKTtcbiAgaWYgKGZvbnRTdHlsZUNTUykge1xuICAgIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCA9IGZvbnRTdHlsZUNTUztcbiAgfVxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2Z1Jvb3QpO1xuICBjb25zdCBjb250ZW50Qm91bmRzID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgc3ZnUm9vdC5yZW1vdmUoKTtcbiAgY29uc3QgZGVzY2VuZGVyUGFkZGluZyA9IENhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVGb250KHN0eWxlLmZvbnRTdHlsZSkuZGVzY2VudDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogY29udGVudEJvdW5kcy53aWR0aCxcbiAgICBoZWlnaHQ6IGNvbnRlbnRCb3VuZHMuaGVpZ2h0ICsgZGVzY2VuZGVyUGFkZGluZ1xuICB9O1xufVxuXG5leHBvcnQgeyBtZWFzdXJlSHRtbFRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lYXN1cmVIdG1sVGV4dC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlUG9vbCB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVBvb2wubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvdHlwZXMubWpzJztcbmltcG9ydCB7IGlzU2FmYXJpIH0gZnJvbSAnLi4vLi4vdXRpbHMvYnJvd3Nlci9pc1NhZmFyaS5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZSB9IGZyb20gJy4uL3RleHQvdXRpbHMvZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UubWpzJztcbmltcG9ydCB7IEhUTUxUZXh0UmVuZGVyRGF0YSB9IGZyb20gJy4vSFRNTFRleHRSZW5kZXJEYXRhLm1qcyc7XG5pbXBvcnQgeyBIVE1MVGV4dFN0eWxlIH0gZnJvbSAnLi9IdG1sVGV4dFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBleHRyYWN0Rm9udEZhbWlsaWVzIH0gZnJvbSAnLi91dGlscy9leHRyYWN0Rm9udEZhbWlsaWVzLm1qcyc7XG5pbXBvcnQgeyBnZXRGb250Q3NzIH0gZnJvbSAnLi91dGlscy9nZXRGb250Q3NzLm1qcyc7XG5pbXBvcnQgeyBnZXRTVkdVcmwgfSBmcm9tICcuL3V0aWxzL2dldFNWR1VybC5tanMnO1xuaW1wb3J0IHsgZ2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlIH0gZnJvbSAnLi91dGlscy9nZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UubWpzJztcbmltcG9ydCB7IGxvYWRTVkdJbWFnZSB9IGZyb20gJy4vdXRpbHMvbG9hZFNWR0ltYWdlLm1qcyc7XG5pbXBvcnQgeyBtZWFzdXJlSHRtbFRleHQgfSBmcm9tICcuL3V0aWxzL21lYXN1cmVIdG1sVGV4dC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEhUTUxUZXh0U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fY3JlYXRlQ2FudmFzID0gcmVuZGVyZXIudHlwZSA9PT0gUmVuZGVyZXJUeXBlLldFQkdQVTtcbiAgfVxuICBnZXRUZXh0dXJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVpbGRUZXh0dXJlUHJvbWlzZShcbiAgICAgIG9wdGlvbnMudGV4dCxcbiAgICAgIG9wdGlvbnMucmVzb2x1dGlvbixcbiAgICAgIG9wdGlvbnMuc3R5bGVcbiAgICApO1xuICB9XG4gIGdldE1hbmFnZWRUZXh0dXJlKHRleHQsIHJlc29sdXRpb24sIHN0eWxlLCB0ZXh0S2V5KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldKSB7XG4gICAgICB0aGlzLl9pbmNyZWFzZVJlZmVyZW5jZUNvdW50KHRleHRLZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9idWlsZFRleHR1cmVQcm9taXNlKHRleHQsIHJlc29sdXRpb24sIHN0eWxlKS50aGVuKCh0ZXh0dXJlKSA9PiB7XG4gICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pO1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldID0ge1xuICAgICAgdGV4dHVyZTogbnVsbCxcbiAgICAgIHByb21pc2UsXG4gICAgICB1c2FnZUNvdW50OiAxXG4gICAgfTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBfYnVpbGRUZXh0dXJlUHJvbWlzZSh0ZXh0LCByZXNvbHV0aW9uLCBzdHlsZSkge1xuICAgIGNvbnN0IGh0bWxUZXh0RGF0YSA9IEJpZ1Bvb2wuZ2V0KEhUTUxUZXh0UmVuZGVyRGF0YSk7XG4gICAgY29uc3QgZm9udEZhbWlsaWVzID0gZXh0cmFjdEZvbnRGYW1pbGllcyh0ZXh0LCBzdHlsZSk7XG4gICAgY29uc3QgZm9udENTUyA9IGF3YWl0IGdldEZvbnRDc3MoXG4gICAgICBmb250RmFtaWxpZXMsXG4gICAgICBzdHlsZSxcbiAgICAgIEhUTUxUZXh0U3R5bGUuZGVmYXVsdFRleHRTdHlsZVxuICAgICk7XG4gICAgY29uc3QgbWVhc3VyZWQgPSBtZWFzdXJlSHRtbFRleHQodGV4dCwgc3R5bGUsIGZvbnRDU1MsIGh0bWxUZXh0RGF0YSk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLndpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgbWVhc3VyZWQuaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGltYWdlID0gaHRtbFRleHREYXRhLmltYWdlO1xuICAgIGltYWdlLndpZHRoID0gd2lkdGggfCAwO1xuICAgIGltYWdlLmhlaWdodCA9IGhlaWdodCB8IDA7XG4gICAgY29uc3Qgc3ZnVVJMID0gZ2V0U1ZHVXJsKHRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBmb250Q1NTLCBodG1sVGV4dERhdGEpO1xuICAgIGF3YWl0IGxvYWRTVkdJbWFnZShpbWFnZSwgc3ZnVVJMLCBpc1NhZmFyaSgpICYmIGZvbnRGYW1pbGllcy5sZW5ndGggPiAwKTtcbiAgICBsZXQgcmVzb3VyY2UgPSBpbWFnZTtcbiAgICBpZiAodGhpcy5fY3JlYXRlQ2FudmFzKSB7XG4gICAgICByZXNvdXJjZSA9IGdldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZShpbWFnZSwgcmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZShyZXNvdXJjZSwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgaWYgKHRoaXMuX2NyZWF0ZUNhbnZhcykge1xuICAgICAgdGhpcy5fcmVuZGVyZXIudGV4dHVyZS5pbml0U291cmNlKHRleHR1cmUuc291cmNlKTtcbiAgICB9XG4gICAgQmlnUG9vbC5yZXR1cm4oaHRtbFRleHREYXRhKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICBfaW5jcmVhc2VSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udXNhZ2VDb3VudCsrO1xuICB9XG4gIGRlY3JlYXNlUmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIGNvbnN0IGFjdGl2ZVRleHR1cmUgPSB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XTtcbiAgICBpZiAoIWFjdGl2ZVRleHR1cmUpXG4gICAgICByZXR1cm47XG4gICAgYWN0aXZlVGV4dHVyZS51c2FnZUNvdW50LS07XG4gICAgaWYgKGFjdGl2ZVRleHR1cmUudXNhZ2VDb3VudCA9PT0gMCkge1xuICAgICAgaWYgKGFjdGl2ZVRleHR1cmUudGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9jbGVhblVwKGFjdGl2ZVRleHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlVGV4dHVyZS5wcm9taXNlLnRoZW4oKHRleHR1cmUpID0+IHtcbiAgICAgICAgICBhY3RpdmVUZXh0dXJlLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICAgIHRoaXMuX2NsZWFuVXAoYWN0aXZlVGV4dHVyZSk7XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICB3YXJuKFwiSFRNTFRleHRTeXN0ZW06IEZhaWxlZCB0byBjbGVhbiB0ZXh0dXJlXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgX2NsZWFuVXAoYWN0aXZlVGV4dHVyZSkge1xuICAgIFRleHR1cmVQb29sLnJldHVyblRleHR1cmUoYWN0aXZlVGV4dHVyZS50ZXh0dXJlKTtcbiAgICBhY3RpdmVUZXh0dXJlLnRleHR1cmUuc291cmNlLnJlc291cmNlID0gbnVsbDtcbiAgICBhY3RpdmVUZXh0dXJlLnRleHR1cmUuc291cmNlLnVwbG9hZE1ldGhvZElkID0gXCJ1bmtub3duXCI7XG4gIH1cbiAgZ2V0UmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS51c2FnZUNvdW50O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXMgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuSFRNTFRleHRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1N5c3RlbVxuICBdLFxuICBuYW1lOiBcImh0bWxUZXh0XCJcbn07XG5IVE1MVGV4dFN5c3RlbS5kZWZhdWx0Rm9udE9wdGlvbnMgPSB7XG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiXG59O1xuXG5leHBvcnQgeyBIVE1MVGV4dFN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRNTFRleHRTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgSFRNTFRleHRQaXBlIH0gZnJvbSAnLi9IVE1MVGV4dFBpcGUubWpzJztcbmltcG9ydCB7IEhUTUxUZXh0U3lzdGVtIH0gZnJvbSAnLi9IVE1MVGV4dFN5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKEhUTUxUZXh0U3lzdGVtKTtcbmV4dGVuc2lvbnMuYWRkKEhUTUxUZXh0UGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1709\n')},3779:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   p: () => (/* binding */ TextStyle)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1580);\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8409);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(156);\n/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(557);\n/* harmony import */ var _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6653);\n/* harmony import */ var _graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4915);\n/* harmony import */ var _utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(740);\n\n\n\n\n\n\n\n\n\"use strict\";\nconst _TextStyle = class _TextStyle extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Z {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === \"object\") {\n      this._dropShadow = {\n        ..._TextStyle.defaultDropShadow,\n        ...value\n      };\n    } else {\n      this._dropShadow = value ? {\n        ..._TextStyle.defaultDropShadow\n      } : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === \"string\") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value;\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    this._fill = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .convertFillInputToFillStyle */ .w)(\n      value === 0 ? \"black\" : value,\n      _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_2__/* .GraphicsContext */ .g.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    this._stroke = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .convertFillInputToFillStyle */ .w)(value, _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_2__/* .GraphicsContext */ .g.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = (0,_utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_3__/* .generateTextStyleKey */ .L)(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit(\"update\", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth\n    });\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n};\n/** The default drop shadow settings */\n_TextStyle.defaultDropShadow = {\n  /** Set alpha for the drop shadow */\n  alpha: 1,\n  /** Set a angle of the drop shadow */\n  angle: Math.PI / 6,\n  /** Set a shadow blur radius */\n  blur: 0,\n  /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n  color: \"black\",\n  /** Set a distance of the drop shadow */\n  distance: 5\n};\n/** The default text style settings */\n_TextStyle.defaultTextStyle = {\n  /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */\n  align: \"left\",\n  /** See {@link TextStyle.breakWords} */\n  breakWords: false,\n  /** See {@link TextStyle.dropShadow} */\n  dropShadow: null,\n  /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: \"black\",\n  /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: \"Arial\",\n  /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */\n  fontSize: 26,\n  /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */\n  fontStyle: \"normal\",\n  /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */\n  fontVariant: \"normal\",\n  /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  fontWeight: \"normal\",\n  /** See {@link TextStyle.leading} */\n  leading: 0,\n  /** See {@link TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link TextStyle.lineHeight} */\n  lineHeight: 0,\n  /** See {@link TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: null,\n  /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  textBaseline: \"alphabetic\",\n  /** See {@link TextStyle.trim} */\n  trim: false,\n  /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */\n  whiteSpace: \"pre\",\n  /** See {@link TextStyle.wordWrap} */\n  wordWrap: false,\n  /** See {@link TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness !== void 0) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .v8_0_0 */ .P, \"strokeThickness is now a part of stroke\");\n    const color = oldStyle.stroke;\n    style.stroke = {\n      color,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fill)) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__/* .v8_0_0 */ .P, \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n    const gradientFill = new _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__/* .FillGradient */ .f(0, 0, 0, style.fontSize * 1.7);\n    const fills = oldStyle.fill.map((color) => _color_Color_mjs__WEBPACK_IMPORTED_MODULE_6__/* .Color */ .I.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\n\n//# sourceMappingURL=TextStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0EsVUFBVTtBQUNWLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0Qiw2QkFBNkIseUZBQVk7QUFDekMsK0NBQStDLDREQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9UZXh0U3R5bGUubWpzPzNmOWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5pbXBvcnQgeyBGaWxsR3JhZGllbnQgfSBmcm9tICcuLi9ncmFwaGljcy9zaGFyZWQvZmlsbC9GaWxsR3JhZGllbnQubWpzJztcbmltcG9ydCB7IEdyYXBoaWNzQ29udGV4dCB9IGZyb20gJy4uL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljc0NvbnRleHQubWpzJztcbmltcG9ydCB7IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZSB9IGZyb20gJy4uL2dyYXBoaWNzL3NoYXJlZC91dGlscy9jb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlVGV4dFN0eWxlS2V5IH0gZnJvbSAnLi91dGlscy9nZW5lcmF0ZVRleHRTdHlsZUtleS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9UZXh0U3R5bGUgPSBjbGFzcyBfVGV4dFN0eWxlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Ioc3R5bGUgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29udmVydFY3VG92OFN0eWxlKHN0eWxlKTtcbiAgICBjb25zdCBmdWxsU3R5bGUgPSB7IC4uLl9UZXh0U3R5bGUuZGVmYXVsdFRleHRTdHlsZSwgLi4uc3R5bGUgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmdWxsU3R5bGUpIHtcbiAgICAgIGNvbnN0IHRoaXNLZXkgPSBrZXk7XG4gICAgICB0aGlzW3RoaXNLZXldID0gZnVsbFN0eWxlW2tleV07XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQsIGRvZXMgbm90IGFmZmVjdCBzaW5nbGUgbGluZSB0ZXh0LlxuICAgKiBAbWVtYmVyIHsnbGVmdCd8J2NlbnRlcid8J3JpZ2h0J3wnanVzdGlmeSd9XG4gICAqL1xuICBnZXQgYWxpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsaWduO1xuICB9XG4gIHNldCBhbGlnbih2YWx1ZSkge1xuICAgIHRoaXMuX2FsaWduID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogSW5kaWNhdGVzIGlmIGxpbmVzIGNhbiBiZSB3cmFwcGVkIHdpdGhpbiB3b3JkcywgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWUuICovXG4gIGdldCBicmVha1dvcmRzKCkge1xuICAgIHJldHVybiB0aGlzLl9icmVha1dvcmRzO1xuICB9XG4gIHNldCBicmVha1dvcmRzKHZhbHVlKSB7XG4gICAgdGhpcy5fYnJlYWtXb3JkcyA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFNldCBhIGRyb3Agc2hhZG93IGZvciB0aGUgdGV4dC4gKi9cbiAgZ2V0IGRyb3BTaGFkb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3c7XG4gIH1cbiAgc2V0IGRyb3BTaGFkb3codmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93ID0ge1xuICAgICAgICAuLi5fVGV4dFN0eWxlLmRlZmF1bHREcm9wU2hhZG93LFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZHJvcFNoYWRvdyA9IHZhbHVlID8ge1xuICAgICAgICAuLi5fVGV4dFN0eWxlLmRlZmF1bHREcm9wU2hhZG93XG4gICAgICB9IDogbnVsbDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIGZvbnQgZmFtaWx5LCBjYW4gYmUgYSBzaW5nbGUgZm9udCBuYW1lLCBvciBhIGxpc3Qgb2YgbmFtZXMgd2hlcmUgdGhlIGZpcnN0IGlzIHRoZSBwcmVmZXJyZWQgZm9udC4gKi9cbiAgZ2V0IGZvbnRGYW1pbHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRGYW1pbHk7XG4gIH1cbiAgc2V0IGZvbnRGYW1pbHkodmFsdWUpIHtcbiAgICB0aGlzLl9mb250RmFtaWx5ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIGZvbnQgc2l6ZSAoYXMgYSBudW1iZXIgaXQgY29udmVydHMgdG8gcHgsIGJ1dCBhcyBhIHN0cmluZywgZXF1aXZhbGVudHMgYXJlICcyNnB4JywnMjBwdCcsJzE2MCUnIG9yICcxLjZlbScpICovXG4gIGdldCBmb250U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFNpemU7XG4gIH1cbiAgc2V0IGZvbnRTaXplKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5fZm9udFNpemUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mb250U2l6ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9udCBzdHlsZS5cbiAgICogQG1lbWJlciB7J25vcm1hbCd8J2l0YWxpYyd8J29ibGlxdWUnfVxuICAgKi9cbiAgZ2V0IGZvbnRTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFN0eWxlO1xuICB9XG4gIHNldCBmb250U3R5bGUodmFsdWUpIHtcbiAgICB0aGlzLl9mb250U3R5bGUgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9udCB2YXJpYW50LlxuICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wnc21hbGwtY2Fwcyd9XG4gICAqL1xuICBnZXQgZm9udFZhcmlhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRWYXJpYW50O1xuICB9XG4gIHNldCBmb250VmFyaWFudCh2YWx1ZSkge1xuICAgIHRoaXMuX2ZvbnRWYXJpYW50ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvbnQgd2VpZ2h0LlxuICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wnYm9sZCd8J2JvbGRlcid8J2xpZ2h0ZXInfCcxMDAnfCcyMDAnfCczMDAnfCc0MDAnfCc1MDAnfCc2MDAnfCc3MDAnfCc4MDAnfCc5MDAnfVxuICAgKi9cbiAgZ2V0IGZvbnRXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRXZWlnaHQ7XG4gIH1cbiAgc2V0IGZvbnRXZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl9mb250V2VpZ2h0ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIHNwYWNlIGJldHdlZW4gbGluZXMuICovXG4gIGdldCBsZWFkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9sZWFkaW5nO1xuICB9XG4gIHNldCBsZWFkaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5fbGVhZGluZyA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFRoZSBhbW91bnQgb2Ygc3BhY2luZyBiZXR3ZWVuIGxldHRlcnMsIGRlZmF1bHQgaXMgMC4gKi9cbiAgZ2V0IGxldHRlclNwYWNpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldHRlclNwYWNpbmc7XG4gIH1cbiAgc2V0IGxldHRlclNwYWNpbmcodmFsdWUpIHtcbiAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIGxpbmUgaGVpZ2h0LCBhIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHZlcnRpY2FsIHNwYWNlIHRoYXQgYSBsZXR0ZXIgdXNlcy4gKi9cbiAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gIH1cbiAgc2V0IGxpbmVIZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl9saW5lSGVpZ2h0ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogT2NjYXNpb25hbGx5IHNvbWUgZm9udHMgYXJlIGNyb3BwZWQuIEFkZGluZyBzb21lIHBhZGRpbmcgd2lsbCBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmdcbiAgICogYnkgYWRkaW5nIHBhZGRpbmcgdG8gYWxsIHNpZGVzIG9mIHRoZSB0ZXh0LlxuICAgKi9cbiAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gIH1cbiAgc2V0IHBhZGRpbmcodmFsdWUpIHtcbiAgICB0aGlzLl9wYWRkaW5nID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogVHJpbSB0cmFuc3BhcmVudCBib3JkZXJzLiBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gb25seSB1c2UgdGhpcyBpZiB5b3UgaGF2ZSB0byEgKi9cbiAgZ2V0IHRyaW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyaW07XG4gIH1cbiAgc2V0IHRyaW0odmFsdWUpIHtcbiAgICB0aGlzLl90cmltID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2VsaW5lIG9mIHRoZSB0ZXh0IHRoYXQgaXMgcmVuZGVyZWQuXG4gICAqIEBtZW1iZXIgeydhbHBoYWJldGljJ3wndG9wJ3wnaGFuZ2luZyd8J21pZGRsZSd8J2lkZW9ncmFwaGljJ3wnYm90dG9tJ31cbiAgICovXG4gIGdldCB0ZXh0QmFzZWxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHRCYXNlbGluZTtcbiAgfVxuICBzZXQgdGV4dEJhc2VsaW5lKHZhbHVlKSB7XG4gICAgdGhpcy5fdGV4dEJhc2VsaW5lID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogSG93IG5ld2xpbmVzIGFuZCBzcGFjZXMgc2hvdWxkIGJlIGhhbmRsZWQuXG4gICAqIERlZmF1bHQgaXMgJ3ByZScgKHByZXNlcnZlLCBwcmVzZXJ2ZSkuXG4gICAqXG4gICAqICB2YWx1ZSAgICAgICB8IE5ldyBsaW5lcyAgICAgfCAgIFNwYWNlc1xuICAgKiAgLS0tICAgICAgICAgfCAtLS0gICAgICAgICAgIHwgICAtLS1cbiAgICogJ25vcm1hbCcgICAgIHwgQ29sbGFwc2UgICAgICB8ICAgQ29sbGFwc2VcbiAgICogJ3ByZScgICAgICAgIHwgUHJlc2VydmUgICAgICB8ICAgUHJlc2VydmVcbiAgICogJ3ByZS1saW5lJyAgIHwgUHJlc2VydmUgICAgICB8ICAgQ29sbGFwc2VcbiAgICogQG1lbWJlciB7J25vcm1hbCd8J3ByZSd8J3ByZS1saW5lJ31cbiAgICovXG4gIGdldCB3aGl0ZVNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xuICB9XG4gIHNldCB3aGl0ZVNwYWNlKHZhbHVlKSB7XG4gICAgdGhpcy5fd2hpdGVTcGFjZSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqIEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWQuICovXG4gIGdldCB3b3JkV3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd29yZFdyYXA7XG4gIH1cbiAgc2V0IHdvcmRXcmFwKHZhbHVlKSB7XG4gICAgdGhpcy5fd29yZFdyYXAgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggYXQgd2hpY2ggdGV4dCB3aWxsIHdyYXAsIGl0IG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlLiAqL1xuICBnZXQgd29yZFdyYXBXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd29yZFdyYXBXaWR0aDtcbiAgfVxuICBzZXQgd29yZFdyYXBXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3dvcmRXcmFwV2lkdGggPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKiBBIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBlLmcuLCAncmVkJywgJyMwMEZGMDAnLiAqL1xuICBnZXQgZmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxGaWxsO1xuICB9XG4gIHNldCBmaWxsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLl9vcmlnaW5hbEZpbGwpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fb3JpZ2luYWxGaWxsID0gdmFsdWU7XG4gICAgdGhpcy5fZmlsbCA9IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZShcbiAgICAgIHZhbHVlID09PSAwID8gXCJibGFja1wiIDogdmFsdWUsXG4gICAgICBHcmFwaGljc0NvbnRleHQuZGVmYXVsdEZpbGxTdHlsZVxuICAgICk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKiogQSBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlLCBlLmcuLCAnYmx1ZScsICcjRkNGRjAwJy4gKi9cbiAgZ2V0IHN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxTdHJva2U7XG4gIH1cbiAgc2V0IHN0cm9rZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fb3JpZ2luYWxTdHJva2UpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fb3JpZ2luYWxTdHJva2UgPSB2YWx1ZTtcbiAgICB0aGlzLl9zdHJva2UgPSBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUodmFsdWUsIEdyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgX2dlbmVyYXRlS2V5KCkge1xuICAgIHRoaXMuX3N0eWxlS2V5ID0gZ2VuZXJhdGVUZXh0U3R5bGVLZXkodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlS2V5O1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9zdHlsZUtleSA9IG51bGw7XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICB9XG4gIC8qKiBSZXNldHMgYWxsIHByb3BlcnRpZXMgdG8gdGhlIGRlZmF1bHQgdmFsdWVzICovXG4gIHJlc2V0KCkge1xuICAgIGNvbnN0IGRlZmF1bHRTdHlsZSA9IF9UZXh0U3R5bGUuZGVmYXVsdFRleHRTdHlsZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0U3R5bGUpIHtcbiAgICAgIHRoaXNba2V5XSA9IGRlZmF1bHRTdHlsZVtrZXldO1xuICAgIH1cbiAgfVxuICBnZXQgc3R5bGVLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlS2V5IHx8IHRoaXMuX2dlbmVyYXRlS2V5KCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVGV4dFN0eWxlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICogQHJldHVybnMgTmV3IGNsb25lZCBUZXh0U3R5bGUgb2JqZWN0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9UZXh0U3R5bGUoe1xuICAgICAgYWxpZ246IHRoaXMuYWxpZ24sXG4gICAgICBicmVha1dvcmRzOiB0aGlzLmJyZWFrV29yZHMsXG4gICAgICBkcm9wU2hhZG93OiB0aGlzLmRyb3BTaGFkb3csXG4gICAgICBmaWxsOiB0aGlzLl9maWxsLFxuICAgICAgZm9udEZhbWlseTogdGhpcy5mb250RmFtaWx5LFxuICAgICAgZm9udFNpemU6IHRoaXMuZm9udFNpemUsXG4gICAgICBmb250U3R5bGU6IHRoaXMuZm9udFN0eWxlLFxuICAgICAgZm9udFZhcmlhbnQ6IHRoaXMuZm9udFZhcmlhbnQsXG4gICAgICBmb250V2VpZ2h0OiB0aGlzLmZvbnRXZWlnaHQsXG4gICAgICBsZWFkaW5nOiB0aGlzLmxlYWRpbmcsXG4gICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcsXG4gICAgICBsaW5lSGVpZ2h0OiB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICBwYWRkaW5nOiB0aGlzLnBhZGRpbmcsXG4gICAgICBzdHJva2U6IHRoaXMuX3N0cm9rZSxcbiAgICAgIHRleHRCYXNlbGluZTogdGhpcy50ZXh0QmFzZWxpbmUsXG4gICAgICB3aGl0ZVNwYWNlOiB0aGlzLndoaXRlU3BhY2UsXG4gICAgICB3b3JkV3JhcDogdGhpcy53b3JkV3JhcCxcbiAgICAgIHdvcmRXcmFwV2lkdGg6IHRoaXMud29yZFdyYXBXaWR0aFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHRleHQgc3R5bGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgdGhpcyBzdHlsZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmVTb3VyY2U9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmVTb3VyY2Ugb2YgdGhlIHRoaXMgc3R5bGVcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCBkZXN0cm95VGV4dHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy50ZXh0dXJlO1xuICAgIGlmIChkZXN0cm95VGV4dHVyZSkge1xuICAgICAgY29uc3QgZGVzdHJveVRleHR1cmVTb3VyY2UgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zIDogb3B0aW9ucz8udGV4dHVyZVNvdXJjZTtcbiAgICAgIGlmICh0aGlzLl9maWxsPy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX2ZpbGwudGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lUZXh0dXJlU291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEZpbGw/LnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxGaWxsLnRleHR1cmUuZGVzdHJveShkZXN0cm95VGV4dHVyZVNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc3Ryb2tlPy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX3N0cm9rZS50ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX29yaWdpbmFsU3Ryb2tlPy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsU3Ryb2tlLnRleHR1cmUuZGVzdHJveShkZXN0cm95VGV4dHVyZVNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ZpbGwgPSBudWxsO1xuICAgIHRoaXMuX3N0cm9rZSA9IG51bGw7XG4gICAgdGhpcy5kcm9wU2hhZG93ID0gbnVsbDtcbiAgICB0aGlzLl9vcmlnaW5hbFN0cm9rZSA9IG51bGw7XG4gICAgdGhpcy5fb3JpZ2luYWxGaWxsID0gbnVsbDtcbiAgfVxufTtcbi8qKiBUaGUgZGVmYXVsdCBkcm9wIHNoYWRvdyBzZXR0aW5ncyAqL1xuX1RleHRTdHlsZS5kZWZhdWx0RHJvcFNoYWRvdyA9IHtcbiAgLyoqIFNldCBhbHBoYSBmb3IgdGhlIGRyb3Agc2hhZG93ICovXG4gIGFscGhhOiAxLFxuICAvKiogU2V0IGEgYW5nbGUgb2YgdGhlIGRyb3Agc2hhZG93ICovXG4gIGFuZ2xlOiBNYXRoLlBJIC8gNixcbiAgLyoqIFNldCBhIHNoYWRvdyBibHVyIHJhZGl1cyAqL1xuICBibHVyOiAwLFxuICAvKiogQSBmaWxsIHN0eWxlIHRvIGJlIHVzZWQgb24gdGhlICBlLmcuLCAncmVkJywgJyMwMEZGMDAnICovXG4gIGNvbG9yOiBcImJsYWNrXCIsXG4gIC8qKiBTZXQgYSBkaXN0YW5jZSBvZiB0aGUgZHJvcCBzaGFkb3cgKi9cbiAgZGlzdGFuY2U6IDVcbn07XG4vKiogVGhlIGRlZmF1bHQgdGV4dCBzdHlsZSBzZXR0aW5ncyAqL1xuX1RleHRTdHlsZS5kZWZhdWx0VGV4dFN0eWxlID0ge1xuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuYWxpZ259XG4gICAqIEB0eXBlIHsnbGVmdCd8J2NlbnRlcid8J3JpZ2h0J3wnanVzdGlmeSd9XG4gICAqL1xuICBhbGlnbjogXCJsZWZ0XCIsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS5icmVha1dvcmRzfSAqL1xuICBicmVha1dvcmRzOiBmYWxzZSxcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmRyb3BTaGFkb3d9ICovXG4gIGRyb3BTaGFkb3c6IG51bGwsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS5maWxsfVxuICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfG51bWJlcnxudW1iZXJbXXxDYW52YXNHcmFkaWVudHxDYW52YXNQYXR0ZXJufVxuICAgKi9cbiAgZmlsbDogXCJibGFja1wiLFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuZm9udEZhbWlseX1cbiAgICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXX1cbiAgICovXG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmZvbnRTaXplfVxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cbiAgICovXG4gIGZvbnRTaXplOiAyNixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmZvbnRTdHlsZX1cbiAgICogQHR5cGUgeydub3JtYWwnfCdpdGFsaWMnfCdvYmxpcXVlJ31cbiAgICovXG4gIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmZvbnRWYXJpYW50fVxuICAgKiBAdHlwZSB7J25vcm1hbCd8J3NtYWxsLWNhcHMnfVxuICAgKi9cbiAgZm9udFZhcmlhbnQ6IFwibm9ybWFsXCIsXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIFRleHRTdHlsZS5mb250V2VpZ2h0fVxuICAgKiBAdHlwZSB7J25vcm1hbCd8J2JvbGQnfCdib2xkZXInfCdsaWdodGVyJ3wnMTAwJ3wnMjAwJ3wnMzAwJ3wnNDAwJ3wnNTAwJ3wnNjAwJ3wnNzAwJ3wnODAwJ3wnOTAwJ31cbiAgICovXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS5sZWFkaW5nfSAqL1xuICBsZWFkaW5nOiAwLFxuICAvKiogU2VlIHtAbGluayBUZXh0U3R5bGUubGV0dGVyU3BhY2luZ30gKi9cbiAgbGV0dGVyU3BhY2luZzogMCxcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLmxpbmVIZWlnaHR9ICovXG4gIGxpbmVIZWlnaHQ6IDAsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS5wYWRkaW5nfSAqL1xuICBwYWRkaW5nOiAwLFxuICAvKipcbiAgICogU2VlIHtAbGluayBUZXh0U3R5bGUuc3Ryb2tlfVxuICAgKiBAdHlwZSB7c3RyaW5nfG51bWJlcn1cbiAgICovXG4gIHN0cm9rZTogbnVsbCxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLnRleHRCYXNlbGluZX1cbiAgICogQHR5cGUgeydhbHBoYWJldGljJ3wndG9wJ3wnaGFuZ2luZyd8J21pZGRsZSd8J2lkZW9ncmFwaGljJ3wnYm90dG9tJ31cbiAgICovXG4gIHRleHRCYXNlbGluZTogXCJhbHBoYWJldGljXCIsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS50cmltfSAqL1xuICB0cmltOiBmYWxzZSxcbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLndoaXRlU3BhY2V9XG4gICAqIEB0eXBlIHsnbm9ybWFsJ3wncHJlJ3wncHJlLWxpbmUnfVxuICAgKi9cbiAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgLyoqIFNlZSB7QGxpbmsgVGV4dFN0eWxlLndvcmRXcmFwfSAqL1xuICB3b3JkV3JhcDogZmFsc2UsXG4gIC8qKiBTZWUge0BsaW5rIFRleHRTdHlsZS53b3JkV3JhcFdpZHRofSAqL1xuICB3b3JkV3JhcFdpZHRoOiAxMDBcbn07XG5sZXQgVGV4dFN0eWxlID0gX1RleHRTdHlsZTtcbmZ1bmN0aW9uIGNvbnZlcnRWN1RvdjhTdHlsZShzdHlsZSkge1xuICBjb25zdCBvbGRTdHlsZSA9IHN0eWxlO1xuICBpZiAodHlwZW9mIG9sZFN0eWxlLmRyb3BTaGFkb3cgPT09IFwiYm9vbGVhblwiICYmIG9sZFN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IFRleHRTdHlsZS5kZWZhdWx0RHJvcFNoYWRvdztcbiAgICBzdHlsZS5kcm9wU2hhZG93ID0ge1xuICAgICAgYWxwaGE6IG9sZFN0eWxlLmRyb3BTaGFkb3dBbHBoYSA/PyBkZWZhdWx0cy5hbHBoYSxcbiAgICAgIGFuZ2xlOiBvbGRTdHlsZS5kcm9wU2hhZG93QW5nbGUgPz8gZGVmYXVsdHMuYW5nbGUsXG4gICAgICBibHVyOiBvbGRTdHlsZS5kcm9wU2hhZG93Qmx1ciA/PyBkZWZhdWx0cy5ibHVyLFxuICAgICAgY29sb3I6IG9sZFN0eWxlLmRyb3BTaGFkb3dDb2xvciA/PyBkZWZhdWx0cy5jb2xvcixcbiAgICAgIGRpc3RhbmNlOiBvbGRTdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgPz8gZGVmYXVsdHMuZGlzdGFuY2VcbiAgICB9O1xuICB9XG4gIGlmIChvbGRTdHlsZS5zdHJva2VUaGlja25lc3MgIT09IHZvaWQgMCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJzdHJva2VUaGlja25lc3MgaXMgbm93IGEgcGFydCBvZiBzdHJva2VcIik7XG4gICAgY29uc3QgY29sb3IgPSBvbGRTdHlsZS5zdHJva2U7XG4gICAgc3R5bGUuc3Ryb2tlID0ge1xuICAgICAgY29sb3IsXG4gICAgICB3aWR0aDogb2xkU3R5bGUuc3Ryb2tlVGhpY2tuZXNzXG4gICAgfTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvbGRTdHlsZS5maWxsKSkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJncmFkaWVudCBmaWxsIGlzIG5vdyBhIGZpbGwgcGF0dGVybjogYG5ldyBGaWxsR3JhZGllbnQoLi4uKWBcIik7XG4gICAgY29uc3QgZ3JhZGllbnRGaWxsID0gbmV3IEZpbGxHcmFkaWVudCgwLCAwLCAwLCBzdHlsZS5mb250U2l6ZSAqIDEuNyk7XG4gICAgY29uc3QgZmlsbHMgPSBvbGRTdHlsZS5maWxsLm1hcCgoY29sb3IpID0+IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShjb2xvcikudG9OdW1iZXIoKSk7XG4gICAgZmlsbHMuZm9yRWFjaCgobnVtYmVyLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcmF0aW8gPSBvbGRTdHlsZS5maWxsR3JhZGllbnRTdG9wc1tpbmRleF0gPz8gaW5kZXggLyBmaWxscy5sZW5ndGg7XG4gICAgICBncmFkaWVudEZpbGwuYWRkQ29sb3JTdG9wKHJhdGlvLCBudW1iZXIpO1xuICAgIH0pO1xuICAgIHN0eWxlLmZpbGwgPSB7XG4gICAgICBmaWxsOiBncmFkaWVudEZpbGxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCB7IFRleHRTdHlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dFN0eWxlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3779\n")},3374:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ CanvasTextMetrics)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n/* harmony import */ var _utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);\n\n\n\n"use strict";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = " ", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = (0,_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .fontStringFromTextStyle */ .M)(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    let width = context.measureText(text).width;\n    if (width > 0) {\n      if (useExperimentalLetterSpacing) {\n        width -= letterSpacing;\n      } else {\n        width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n      }\n    }\n    return width;\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object\'s wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext("2d", contextSettings);\n    let width = 0;\n    let line = "";\n    let lines = "";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = "";\n          width = 0;\n          continue;\n        }\n        token = " ";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== "") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = "";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = "";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = "";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== "number") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === "normal" || whiteSpace === "pre-line";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === "normal";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== "string") {\n      return "";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = "";\n    if (typeof text !== "string") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== "") {\n          tokens.push(token);\n          token = "";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== "") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class\'s behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = "") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext("2d", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n      } catch (ex) {\n        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn\'t because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = "|\\xC9q\\xC5";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = "M";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode "character", or "grapheme cluster", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `\'\\u0065\\u0301\'`, letter e with acute)\n * or emojis with modifiers (e.g. `\'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don\'t support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won\'t use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === "function") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome\'s new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\n\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM3NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RDtBQUNnQjs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5RUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxHQUFHLGVBQWU7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQixvR0FBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUVBQVU7QUFDM0IsUUFBUTtBQUNSLGlCQUFpQix5RUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELGtCQUFrQiwrQ0FBK0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L2NhbnZhcy9DYW52YXNUZXh0TWV0cmljcy5tanM/NzdhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUgfSBmcm9tICcuL3V0aWxzL2ZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgY29udGV4dFNldHRpbmdzID0ge1xuICAvLyBUZXh0TWV0cmljcyByZXF1aXJlcyBnZXRJbWFnZURhdGEgcmVhZGJhY2sgZm9yIG1lYXN1cmluZyBmb250cy5cbiAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG59O1xuY29uc3QgX0NhbnZhc1RleHRNZXRyaWNzID0gY2xhc3MgX0NhbnZhc1RleHRNZXRyaWNzIHtcbiAgLyoqXG4gICAqIENoZWNraW5nIHRoYXQgd2UgY2FuIHVzZSBtb2Rlcm4gY2FudmFzIDJEIEFQSS5cbiAgICpcbiAgICogTm90ZTogVGhpcyBpcyBhbiB1bnN0YWJsZSBBUEksIENocm9tZSA8IDk0IHVzZSBgdGV4dExldHRlclNwYWNpbmdgLCBsYXRlciB2ZXJzaW9ucyB1c2UgYGxldHRlclNwYWNpbmdgLlxuICAgKiBAc2VlIFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSUNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9sZXR0ZXJTcGFjaW5nXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9vcmlnaW50cmlhbHMvIy92aWV3X3RyaWFsLzM1ODU5OTEyMDMyOTM3NTc0NDFcbiAgICovXG4gIHN0YXRpYyBnZXQgZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZCgpIHtcbiAgICBsZXQgcmVzdWx0ID0gX0NhbnZhc1RleHRNZXRyaWNzLl9leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkO1xuICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgcHJvdG8gPSBET01BZGFwdGVyLmdldCgpLmdldENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCgpLnByb3RvdHlwZTtcbiAgICAgIHJlc3VsdCA9IF9DYW52YXNUZXh0TWV0cmljcy5fZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZCA9IFwibGV0dGVyU3BhY2luZ1wiIGluIHByb3RvIHx8IFwidGV4dExldHRlclNwYWNpbmdcIiBpbiBwcm90bztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHRleHQgLSB0aGUgdGV4dCB0aGF0IHdhcyBtZWFzdXJlZFxuICAgKiBAcGFyYW0gc3R5bGUgLSB0aGUgc3R5bGUgdGhhdCB3YXMgbWVhc3VyZWRcbiAgICogQHBhcmFtIHdpZHRoIC0gdGhlIG1lYXN1cmVkIHdpZHRoIG9mIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSBoZWlnaHQgLSB0aGUgbWVhc3VyZWQgaGVpZ2h0IG9mIHRoZSB0ZXh0XG4gICAqIEBwYXJhbSBsaW5lcyAtIGFuIGFycmF5IG9mIHRoZSBsaW5lcyBvZiB0ZXh0IGJyb2tlbiBieSBuZXcgbGluZXMgYW5kIHdyYXBwaW5nIGlmIHNwZWNpZmllZCBpbiBzdHlsZVxuICAgKiBAcGFyYW0gbGluZVdpZHRocyAtIGFuIGFycmF5IG9mIHRoZSBsaW5lIHdpZHRocyBmb3IgZWFjaCBsaW5lIG1hdGNoZWQgdG8gYGxpbmVzYFxuICAgKiBAcGFyYW0gbGluZUhlaWdodCAtIHRoZSBtZWFzdXJlZCBsaW5lIGhlaWdodCBmb3IgdGhpcyBzdHlsZVxuICAgKiBAcGFyYW0gbWF4TGluZVdpZHRoIC0gdGhlIG1heGltdW0gbGluZSB3aWR0aCBmb3IgYWxsIG1lYXN1cmVkIGxpbmVzXG4gICAqIEBwYXJhbSB7Rm9udE1ldHJpY3N9IGZvbnRQcm9wZXJ0aWVzIC0gdGhlIGZvbnQgcHJvcGVydGllcyBvYmplY3QgZnJvbSBUZXh0TWV0cmljcy5tZWFzdXJlRm9udFxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0LCBtYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xuICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgdGhpcy5tYXhMaW5lV2lkdGggPSBtYXhMaW5lV2lkdGg7XG4gICAgdGhpcy5mb250UHJvcGVydGllcyA9IGZvbnRQcm9wZXJ0aWVzO1xuICB9XG4gIC8qKlxuICAgKiBNZWFzdXJlcyB0aGUgc3VwcGxpZWQgc3RyaW5nIG9mIHRleHQgYW5kIHJldHVybnMgYSBSZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHQgdG8gbWVhc3VyZS5cbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHRleHQgc3R5bGUgdG8gdXNlIGZvciBtZWFzdXJpbmdcbiAgICogQHBhcmFtIGNhbnZhcyAtIG9wdGlvbmFsIHNwZWNpZmljYXRpb24gb2YgdGhlIGNhbnZhcyB0byB1c2UgZm9yIG1lYXN1cmluZy5cbiAgICogQHBhcmFtIHdvcmRXcmFwXG4gICAqIEByZXR1cm5zIE1lYXN1cmVkIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHRleHQuXG4gICAqL1xuICBzdGF0aWMgbWVhc3VyZVRleHQodGV4dCA9IFwiIFwiLCBzdHlsZSwgY2FudmFzID0gX0NhbnZhc1RleHRNZXRyaWNzLl9jYW52YXMsIHdvcmRXcmFwID0gc3R5bGUud29yZFdyYXApIHtcbiAgICBjb25zdCB0ZXh0S2V5ID0gYCR7dGV4dH06JHtzdHlsZS5zdHlsZUtleX1gO1xuICAgIGlmIChfQ2FudmFzVGV4dE1ldHJpY3MuX21lYXN1cmVtZW50Q2FjaGVbdGV4dEtleV0pXG4gICAgICByZXR1cm4gX0NhbnZhc1RleHRNZXRyaWNzLl9tZWFzdXJlbWVudENhY2hlW3RleHRLZXldO1xuICAgIGNvbnN0IGZvbnQgPSBmb250U3RyaW5nRnJvbVRleHRTdHlsZShzdHlsZSk7XG4gICAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBfQ2FudmFzVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udCk7XG4gICAgaWYgKGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplID09PSAwKSB7XG4gICAgICBmb250UHJvcGVydGllcy5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xuICAgICAgZm9udFByb3BlcnRpZXMuYXNjZW50ID0gc3R5bGUuZm9udFNpemU7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX19jb250ZXh0O1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgY29uc3Qgb3V0cHV0VGV4dCA9IHdvcmRXcmFwID8gX0NhbnZhc1RleHRNZXRyaWNzLl93b3JkV3JhcCh0ZXh0LCBzdHlsZSwgY2FudmFzKSA6IHRleHQ7XG4gICAgY29uc3QgbGluZXMgPSBvdXRwdXRUZXh0LnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKTtcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgbGV0IG1heExpbmVXaWR0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZVdpZHRoID0gX0NhbnZhc1RleHRNZXRyaWNzLl9tZWFzdXJlVGV4dChsaW5lc1tpXSwgc3R5bGUubGV0dGVyU3BhY2luZywgY29udGV4dCk7XG4gICAgICBsaW5lV2lkdGhzW2ldID0gbGluZVdpZHRoO1xuICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsaW5lV2lkdGgpO1xuICAgIH1cbiAgICBjb25zdCBzdHJva2VXaWR0aCA9IHN0eWxlLl9zdHJva2U/LndpZHRoIHx8IDA7XG4gICAgbGV0IHdpZHRoID0gbWF4TGluZVdpZHRoICsgc3Ryb2tlV2lkdGg7XG4gICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICAgIHdpZHRoICs9IHN0eWxlLmRyb3BTaGFkb3cuZGlzdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3Ryb2tlV2lkdGg7XG4gICAgbGV0IGhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3Ryb2tlV2lkdGggKiAyKSArIChsaW5lcy5sZW5ndGggLSAxKSAqIChsaW5lSGVpZ2h0ICsgc3R5bGUubGVhZGluZyk7XG4gICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICAgIGhlaWdodCArPSBzdHlsZS5kcm9wU2hhZG93LmRpc3RhbmNlO1xuICAgIH1cbiAgICBjb25zdCBtZWFzdXJlbWVudHMgPSBuZXcgX0NhbnZhc1RleHRNZXRyaWNzKFxuICAgICAgdGV4dCxcbiAgICAgIHN0eWxlLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsaW5lcyxcbiAgICAgIGxpbmVXaWR0aHMsXG4gICAgICBsaW5lSGVpZ2h0ICsgc3R5bGUubGVhZGluZyxcbiAgICAgIG1heExpbmVXaWR0aCxcbiAgICAgIGZvbnRQcm9wZXJ0aWVzXG4gICAgKTtcbiAgICByZXR1cm4gbWVhc3VyZW1lbnRzO1xuICB9XG4gIHN0YXRpYyBfbWVhc3VyZVRleHQodGV4dCwgbGV0dGVyU3BhY2luZywgY29udGV4dCkge1xuICAgIGxldCB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gZmFsc2U7XG4gICAgaWYgKF9DYW52YXNUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoX0NhbnZhc1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcpIHtcbiAgICAgICAgY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGA7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgICBjb250ZXh0LnRleHRMZXR0ZXJTcGFjaW5nID0gXCIwcHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICBpZiAodXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgICB3aWR0aCAtPSBsZXR0ZXJTcGFjaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggKz0gKF9DYW52YXNUZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlcih0ZXh0KS5sZW5ndGggLSAxKSAqIGxldHRlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBuZXdsaW5lcyB0byBhIHN0cmluZyB0byBoYXZlIGl0IG9wdGltYWxseSBmaXQgaW50byB0aGUgaG9yaXpvbnRhbFxuICAgKiBib3VuZHMgc2V0IGJ5IHRoZSBUZXh0IG9iamVjdCdzIHdvcmRXcmFwV2lkdGggcHJvcGVydHkuXG4gICAqIEBwYXJhbSB0ZXh0IC0gU3RyaW5nIHRvIGFwcGx5IHdvcmQgd3JhcHBpbmcgdG9cbiAgICogQHBhcmFtIHN0eWxlIC0gdGhlIHN0eWxlIHRvIHVzZSB3aGVuIHdyYXBwaW5nXG4gICAqIEBwYXJhbSBjYW52YXMgLSBvcHRpb25hbCBzcGVjaWZpY2F0aW9uIG9mIHRoZSBjYW52YXMgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gICAqIEByZXR1cm5zIE5ldyBzdHJpbmcgd2l0aCBuZXcgbGluZXMgYXBwbGllZCB3aGVyZSByZXF1aXJlZFxuICAgKi9cbiAgc3RhdGljIF93b3JkV3JhcCh0ZXh0LCBzdHlsZSwgY2FudmFzID0gX0NhbnZhc1RleHRNZXRyaWNzLl9jYW52YXMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0U2V0dGluZ3MpO1xuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgbGV0IGxpbmUgPSBcIlwiO1xuICAgIGxldCBsaW5lcyA9IFwiXCI7XG4gICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCB7IGxldHRlclNwYWNpbmcsIHdoaXRlU3BhY2UgfSA9IHN0eWxlO1xuICAgIGNvbnN0IGNvbGxhcHNlU3BhY2VzID0gX0NhbnZhc1RleHRNZXRyaWNzLl9jb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKTtcbiAgICBjb25zdCBjb2xsYXBzZU5ld2xpbmVzID0gX0NhbnZhc1RleHRNZXRyaWNzLl9jb2xsYXBzZU5ld2xpbmVzKHdoaXRlU3BhY2UpO1xuICAgIGxldCBjYW5QcmVwZW5kU3BhY2VzID0gIWNvbGxhcHNlU3BhY2VzO1xuICAgIGNvbnN0IHdvcmRXcmFwV2lkdGggPSBzdHlsZS53b3JkV3JhcFdpZHRoICsgbGV0dGVyU3BhY2luZztcbiAgICBjb25zdCB0b2tlbnMgPSBfQ2FudmFzVGV4dE1ldHJpY3MuX3Rva2VuaXplKHRleHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBpZiAoX0NhbnZhc1RleHRNZXRyaWNzLl9pc05ld2xpbmUodG9rZW4pKSB7XG4gICAgICAgIGlmICghY29sbGFwc2VOZXdsaW5lcykge1xuICAgICAgICAgIGxpbmVzICs9IF9DYW52YXNUZXh0TWV0cmljcy5fYWRkTGluZShsaW5lKTtcbiAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gIWNvbGxhcHNlU3BhY2VzO1xuICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IFwiIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGNvbGxhcHNlU3BhY2VzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJJc0JyZWFraW5nU3BhY2UgPSBfQ2FudmFzVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKHRva2VuKTtcbiAgICAgICAgY29uc3QgbGFzdElzQnJlYWtpbmdTcGFjZSA9IF9DYW52YXNUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UobGluZVtsaW5lLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKGN1cnJJc0JyZWFraW5nU3BhY2UgJiYgbGFzdElzQnJlYWtpbmdTcGFjZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0b2tlbldpZHRoID0gX0NhbnZhc1RleHRNZXRyaWNzLl9nZXRGcm9tQ2FjaGUodG9rZW4sIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KTtcbiAgICAgIGlmICh0b2tlbldpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICBpZiAobGluZSAhPT0gXCJcIikge1xuICAgICAgICAgIGxpbmVzICs9IF9DYW52YXNUZXh0TWV0cmljcy5fYWRkTGluZShsaW5lKTtcbiAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9DYW52YXNUZXh0TWV0cmljcy5jYW5CcmVha1dvcmRzKHRva2VuLCBzdHlsZS5icmVha1dvcmRzKSkge1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBfQ2FudmFzVGV4dE1ldHJpY3Mud29yZFdyYXBTcGxpdCh0b2tlbik7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGFyYWN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGNoYXJhY3RlcnNbal07XG4gICAgICAgICAgICBsZXQgbGFzdENoYXIgPSBjaGFyO1xuICAgICAgICAgICAgbGV0IGsgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3RlcnNbaiArIGtdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gY2hhcmFjdGVyc1tqICsga107XG4gICAgICAgICAgICAgIGlmICghX0NhbnZhc1RleHRNZXRyaWNzLmNhbkJyZWFrQ2hhcnMobGFzdENoYXIsIG5leHRDaGFyLCB0b2tlbiwgaiwgc3R5bGUuYnJlYWtXb3JkcykpIHtcbiAgICAgICAgICAgICAgICBjaGFyICs9IG5leHRDaGFyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RDaGFyID0gbmV4dENoYXI7XG4gICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGogKz0gayAtIDE7XG4gICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJXaWR0aCA9IF9DYW52YXNUZXh0TWV0cmljcy5fZ2V0RnJvbUNhY2hlKGNoYXIsIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJXaWR0aCArIHdpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgICBsaW5lcyArPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2FkZExpbmUobGluZSk7XG4gICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmUgKz0gY2hhcjtcbiAgICAgICAgICAgIHdpZHRoICs9IGNoYXJhY3RlcldpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsaW5lcyArPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2FkZExpbmUobGluZSk7XG4gICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNMYXN0VG9rZW4gPSBpID09PSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBsaW5lcyArPSBfQ2FudmFzVGV4dE1ldHJpY3MuX2FkZExpbmUodG9rZW4sICFpc0xhc3RUb2tlbik7XG4gICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9IGZhbHNlO1xuICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva2VuV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgbGluZXMgKz0gX0NhbnZhc1RleHRNZXRyaWNzLl9hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwIHx8ICFfQ2FudmFzVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKHRva2VuKSB8fCBjYW5QcmVwZW5kU3BhY2VzKSB7XG4gICAgICAgICAgbGluZSArPSB0b2tlbjtcbiAgICAgICAgICB3aWR0aCArPSB0b2tlbldpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxpbmVzICs9IF9DYW52YXNUZXh0TWV0cmljcy5fYWRkTGluZShsaW5lLCBmYWxzZSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIC8qKlxuICAgKiBDb252aWVuaWVuY2UgZnVuY3Rpb24gZm9yIGxvZ2dpbmcgZWFjaCBsaW5lIGFkZGVkIGR1cmluZyB0aGUgd29yZFdyYXAgbWV0aG9kLlxuICAgKiBAcGFyYW0gbGluZSAgICAtIFRoZSBsaW5lIG9mIHRleHQgdG8gYWRkXG4gICAqIEBwYXJhbSBuZXdMaW5lIC0gQWRkIG5ldyBsaW5lIGNoYXJhY3RlciB0byBlbmRcbiAgICogQHJldHVybnMgQSBmb3JtYXR0ZWQgbGluZVxuICAgKi9cbiAgc3RhdGljIF9hZGRMaW5lKGxpbmUsIG5ld0xpbmUgPSB0cnVlKSB7XG4gICAgbGluZSA9IF9DYW52YXNUZXh0TWV0cmljcy5fdHJpbVJpZ2h0KGxpbmUpO1xuICAgIGxpbmUgPSBuZXdMaW5lID8gYCR7bGluZX1cbmAgOiBsaW5lO1xuICAgIHJldHVybiBsaW5lO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzICYgc2V0cyB0aGUgd2lkdGhzIG9mIGNhbGN1bGF0ZWQgY2hhcmFjdGVycyBpbiBhIGNhY2hlIG9iamVjdFxuICAgKiBAcGFyYW0ga2V5ICAgICAgICAgICAgLSBUaGUga2V5XG4gICAqIEBwYXJhbSBsZXR0ZXJTcGFjaW5nICAtIFRoZSBsZXR0ZXIgc3BhY2luZ1xuICAgKiBAcGFyYW0gY2FjaGUgICAgICAgICAgLSBUaGUgY2FjaGVcbiAgICogQHBhcmFtIGNvbnRleHQgICAgICAgIC0gVGhlIGNhbnZhcyBjb250ZXh0XG4gICAqIEByZXR1cm5zIFRoZSBmcm9tIGNhY2hlLlxuICAgKi9cbiAgc3RhdGljIF9nZXRGcm9tQ2FjaGUoa2V5LCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCkge1xuICAgIGxldCB3aWR0aCA9IGNhY2hlW2tleV07XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgd2lkdGggPSBfQ2FudmFzVGV4dE1ldHJpY3MuX21lYXN1cmVUZXh0KGtleSwgbGV0dGVyU3BhY2luZywgY29udGV4dCkgKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgY2FjaGVba2V5XSA9IHdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgY29sbGFwc2UgYnJlYWtpbmcgc3BhY2VzLlxuICAgKiBAcGFyYW0gd2hpdGVTcGFjZSAtIFRoZSBUZXh0U3R5bGUgcHJvcGVydHkgd2hpdGVTcGFjZVxuICAgKiBAcmV0dXJucyBTaG91bGQgY29sbGFwc2VcbiAgICovXG4gIHN0YXRpYyBfY29sbGFwc2VTcGFjZXMod2hpdGVTcGFjZSkge1xuICAgIHJldHVybiB3aGl0ZVNwYWNlID09PSBcIm5vcm1hbFwiIHx8IHdoaXRlU3BhY2UgPT09IFwicHJlLWxpbmVcIjtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBjb2xsYXBzZSBuZXdMaW5lIGNoYXJzLlxuICAgKiBAcGFyYW0gd2hpdGVTcGFjZSAtIFRoZSB3aGl0ZSBzcGFjZVxuICAgKiBAcmV0dXJucyBzaG91bGQgY29sbGFwc2VcbiAgICovXG4gIHN0YXRpYyBfY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKSB7XG4gICAgcmV0dXJuIHdoaXRlU3BhY2UgPT09IFwibm9ybWFsXCI7XG4gIH1cbiAgLyoqXG4gICAqIFRyaW1zIGJyZWFraW5nIHdoaXRlc3BhY2VzIGZyb20gc3RyaW5nLlxuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0XG4gICAqIEByZXR1cm5zIFRyaW1tZWQgc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgX3RyaW1SaWdodCh0ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0W2ldO1xuICAgICAgaWYgKCFfQ2FudmFzVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBjaGFyIGlzIGEgbmV3bGluZS5cbiAgICogQHBhcmFtIGNoYXIgLSBUaGUgY2hhcmFjdGVyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgbmV3bGluZSwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIF9pc05ld2xpbmUoY2hhcikge1xuICAgIGlmICh0eXBlb2YgY2hhciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gX0NhbnZhc1RleHRNZXRyaWNzLl9uZXdsaW5lcy5pbmNsdWRlcyhjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBicmVha2luZyB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBJdCBhbGxvd3Mgb25lIHRvIGRldGVybWluZSB3aGV0aGVyIGNoYXIgc2hvdWxkIGJlIGEgYnJlYWtpbmcgd2hpdGVzcGFjZVxuICAgKiBGb3IgZXhhbXBsZSBjZXJ0YWluIGNoYXJhY3RlcnMgaW4gQ0pLIGxhbmdzIG9yIG51bWJlcnMuXG4gICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICogQHBhcmFtIGNoYXIgLSBUaGUgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBbX25leHRDaGFyXSAtIFRoZSBuZXh0IGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHdoaXRlc3BhY2UsIEZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0JyZWFraW5nU3BhY2UoY2hhciwgX25leHRDaGFyKSB7XG4gICAgaWYgKHR5cGVvZiBjaGFyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzLmluY2x1ZGVzKGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIHdvcmRzLCBicmVha2luZy1zcGFjZXMgYW5kIG5ld0xpbmUgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0XG4gICAqIEByZXR1cm5zIEEgdG9rZW5pemVkIGFycmF5XG4gICAqL1xuICBzdGF0aWMgX3Rva2VuaXplKHRleHQpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgdG9rZW4gPSBcIlwiO1xuICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gdGV4dFtpXTtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gdGV4dFtpICsgMV07XG4gICAgICBpZiAoX0NhbnZhc1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShjaGFyLCBuZXh0Q2hhcikgfHwgX0NhbnZhc1RleHRNZXRyaWNzLl9pc05ld2xpbmUoY2hhcikpIHtcbiAgICAgICAgaWYgKHRva2VuICE9PSBcIlwiKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIHRva2VuID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucHVzaChjaGFyKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0b2tlbiArPSBjaGFyO1xuICAgIH1cbiAgICBpZiAodG9rZW4gIT09IFwiXCIpIHtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgaGVscGVyIG1ldGhvZCB1c2VkIGludGVybmFsbHkgYnkgVGV4dE1ldHJpY3MsIGV4cG9zZWQgdG8gYWxsb3cgY3VzdG9taXppbmcgdGhlIGNsYXNzJ3MgYmVoYXZpb3IuXG4gICAqXG4gICAqIEl0IGFsbG93cyBvbmUgdG8gY3VzdG9taXNlIHdoaWNoIHdvcmRzIHNob3VsZCBicmVha1xuICAgKiBFeGFtcGxlcyBhcmUgaWYgdGhlIHRva2VuIGlzIENKSyBvciBudW1iZXJzLlxuICAgKiBJdCBtdXN0IHJldHVybiBhIGJvb2xlYW4uXG4gICAqIEBwYXJhbSBfdG9rZW4gLSBUaGUgdG9rZW5cbiAgICogQHBhcmFtIGJyZWFrV29yZHMgLSBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRvIGJyZWFrIHdvcmQgb3Igbm90XG4gICAqL1xuICBzdGF0aWMgY2FuQnJlYWtXb3JkcyhfdG9rZW4sIGJyZWFrV29yZHMpIHtcbiAgICByZXR1cm4gYnJlYWtXb3JkcztcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgaGVscGVyIG1ldGhvZCB1c2VkIGludGVybmFsbHkgYnkgVGV4dE1ldHJpY3MsIGV4cG9zZWQgdG8gYWxsb3cgY3VzdG9taXppbmcgdGhlIGNsYXNzJ3MgYmVoYXZpb3IuXG4gICAqXG4gICAqIEl0IGFsbG93cyBvbmUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwYWlyIG9mIGNoYXJhY3RlcnNcbiAgICogc2hvdWxkIGJlIGJyb2tlbiBieSBuZXdsaW5lc1xuICAgKiBGb3IgZXhhbXBsZSBjZXJ0YWluIGNoYXJhY3RlcnMgaW4gQ0pLIGxhbmdzIG9yIG51bWJlcnMuXG4gICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICogQHBhcmFtIF9jaGFyIC0gVGhlIGNoYXJhY3RlclxuICAgKiBAcGFyYW0gX25leHRDaGFyIC0gVGhlIG5leHQgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBfdG9rZW4gLSBUaGUgdG9rZW4vd29yZCB0aGUgY2hhcmFjdGVycyBhcmUgZnJvbVxuICAgKiBAcGFyYW0gX2luZGV4IC0gVGhlIGluZGV4IGluIHRoZSB0b2tlbiBvZiB0aGUgY2hhclxuICAgKiBAcGFyYW0gX2JyZWFrV29yZHMgLSBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xuICAgKiBAcmV0dXJucyB3aGV0aGVyIHRvIGJyZWFrIHdvcmQgb3Igbm90XG4gICAqL1xuICBzdGF0aWMgY2FuQnJlYWtDaGFycyhfY2hhciwgX25leHRDaGFyLCBfdG9rZW4sIF9pbmRleCwgX2JyZWFrV29yZHMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGFibGUgaGVscGVyIG1ldGhvZCB1c2VkIGludGVybmFsbHkgYnkgVGV4dE1ldHJpY3MsIGV4cG9zZWQgdG8gYWxsb3cgY3VzdG9taXppbmcgdGhlIGNsYXNzJ3MgYmVoYXZpb3IuXG4gICAqXG4gICAqIEl0IGlzIGNhbGxlZCB3aGVuIGEgdG9rZW4gKHVzdWFsbHkgYSB3b3JkKSBoYXMgdG8gYmUgc3BsaXQgaW50byBzZXBhcmF0ZSBwaWVjZXNcbiAgICogaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHRoZSBwb2ludCB0byBicmVhayBhIHdvcmQuXG4gICAqIEl0IG11c3QgcmV0dXJuIGFuIGFycmF5IG9mIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSB0b2tlbiAtIFRoZSB0b2tlbiB0byBzcGxpdFxuICAgKiBAcmV0dXJucyBUaGUgY2hhcmFjdGVycyBvZiB0aGUgdG9rZW5cbiAgICogQHNlZSBDYW52YXNUZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlclxuICAgKi9cbiAgc3RhdGljIHdvcmRXcmFwU3BsaXQodG9rZW4pIHtcbiAgICByZXR1cm4gX0NhbnZhc1RleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyKHRva2VuKTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgYXNjZW50LCBkZXNjZW50IGFuZCBmb250U2l6ZSBvZiBhIGdpdmVuIGZvbnQtc3R5bGVcbiAgICogQHBhcmFtIGZvbnQgLSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSBvZiB0aGUgZm9udFxuICAgKiBAcmV0dXJucyBGb250IHByb3BlcnRpZXMgb2JqZWN0XG4gICAqL1xuICBzdGF0aWMgbWVhc3VyZUZvbnQoZm9udCkge1xuICAgIGlmIChfQ2FudmFzVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdKSB7XG4gICAgICByZXR1cm4gX0NhbnZhc1RleHRNZXRyaWNzLl9mb250c1tmb250XTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IF9DYW52YXNUZXh0TWV0cmljcy5fY29udGV4dDtcbiAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KF9DYW52YXNUZXh0TWV0cmljcy5NRVRSSUNTX1NUUklORyArIF9DYW52YXNUZXh0TWV0cmljcy5CQVNFTElORV9TWU1CT0wpO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBhc2NlbnQ6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICBkZXNjZW50OiBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgIGZvbnRTaXplOiBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnRcbiAgICB9O1xuICAgIF9DYW52YXNUZXh0TWV0cmljcy5fZm9udHNbZm9udF0gPSBwcm9wZXJ0aWVzO1xuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBmb250IG1ldHJpY3MgaW4gbWV0cmljcyBjYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmb250XSAtIGZvbnQgbmFtZS4gSWYgZm9udCBuYW1lIG5vdCBzZXQgdGhlbiBjbGVhciBjYWNoZSBmb3IgYWxsIGZvbnRzLlxuICAgKi9cbiAgc3RhdGljIGNsZWFyTWV0cmljcyhmb250ID0gXCJcIikge1xuICAgIGlmIChmb250KSB7XG4gICAgICBkZWxldGUgX0NhbnZhc1RleHRNZXRyaWNzLl9mb250c1tmb250XTtcbiAgICB9IGVsc2Uge1xuICAgICAgX0NhbnZhc1RleHRNZXRyaWNzLl9mb250cyA9IHt9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FjaGVkIGNhbnZhcyBlbGVtZW50IGZvciBtZWFzdXJpbmcgdGV4dFxuICAgKiBUT0RPOiB0aGlzIHNob3VsZCBiZSBwcml2YXRlLCBidXQgaXNuJ3QgYmVjYXVzZSBvZiBiYWNrd2FyZCBjb21wYXQsIHdpbGwgZml4IGxhdGVyLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgZ2V0IF9jYW52YXMoKSB7XG4gICAgaWYgKCFfQ2FudmFzVGV4dE1ldHJpY3MuX19jYW52YXMpIHtcbiAgICAgIGxldCBjYW52YXM7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjID0gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgICAgIGlmIChjb250ZXh0Py5tZWFzdXJlVGV4dCkge1xuICAgICAgICAgIF9DYW52YXNUZXh0TWV0cmljcy5fX2NhbnZhcyA9IGM7XG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKCk7XG4gICAgICB9XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTA7XG4gICAgICBfQ2FudmFzVGV4dE1ldHJpY3MuX19jYW52YXMgPSBjYW52YXM7XG4gICAgfVxuICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuX19jYW52YXM7XG4gIH1cbiAgLyoqXG4gICAqIFRPRE86IHRoaXMgc2hvdWxkIGJlIHByaXZhdGUsIGJ1dCBpc24ndCBiZWNhdXNlIG9mIGJhY2t3YXJkIGNvbXBhdCwgd2lsbCBmaXggbGF0ZXIuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBnZXQgX2NvbnRleHQoKSB7XG4gICAgaWYgKCFfQ2FudmFzVGV4dE1ldHJpY3MuX19jb250ZXh0KSB7XG4gICAgICBfQ2FudmFzVGV4dE1ldHJpY3MuX19jb250ZXh0ID0gX0NhbnZhc1RleHRNZXRyaWNzLl9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgfVxuICAgIHJldHVybiBfQ2FudmFzVGV4dE1ldHJpY3MuX19jb250ZXh0O1xuICB9XG59O1xuLyoqXG4gKiBTdHJpbmcgdXNlZCBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy5cbiAqIFRoZXNlIGNoYXJhY3RlcnMgYXJlIGFsbCB0YWxsIHRvIGhlbHAgY2FsY3VsYXRlIHRoZSBoZWlnaHQgcmVxdWlyZWQgZm9yIHRleHQuXG4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5NRVRSSUNTX1NUUklORyA9IFwifFxceEM5cVxceEM1XCI7XG4vKiogQmFzZWxpbmUgc3ltYm9sIGZvciBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLiAqL1xuX0NhbnZhc1RleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCA9IFwiTVwiO1xuLyoqIEJhc2VsaW5lIG11bHRpcGxpZXIgZm9yIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuICovXG5fQ2FudmFzVGV4dE1ldHJpY3MuQkFTRUxJTkVfTVVMVElQTElFUiA9IDEuNDtcbi8qKiBIZWlnaHQgbXVsdGlwbGllciBmb3Igc2V0dGluZyBoZWlnaHQgb2YgY2FudmFzIHRvIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuICovXG5fQ2FudmFzVGV4dE1ldHJpY3MuSEVJR0hUX01VTFRJUExJRVIgPSAyO1xuLyoqXG4gKiBBIFVuaWNvZGUgXCJjaGFyYWN0ZXJcIiwgb3IgXCJncmFwaGVtZSBjbHVzdGVyXCIsIGNhbiBiZSBjb21wb3NlZCBvZiBtdWx0aXBsZSBVbmljb2RlIGNvZGUgcG9pbnRzLFxuICogc3VjaCBhcyBsZXR0ZXJzIHdpdGggZGlhY3JpdGljYWwgbWFya3MgKGUuZy4gYCdcXHUwMDY1XFx1MDMwMSdgLCBsZXR0ZXIgZSB3aXRoIGFjdXRlKVxuICogb3IgZW1vamlzIHdpdGggbW9kaWZpZXJzIChlLmcuIGAnXFx1RDgzRVxcdURERDFcXHUyMDBEXFx1RDgzRFxcdURDQkInYCwgdGVjaG5vbG9naXN0KS5cbiAqIFRoZSBuZXcgYEludGwuU2VnbWVudGVyYCBBUEkgaW4gRVMyMDIyIGNhbiBzcGxpdCB0aGUgc3RyaW5nIGludG8gZ3JhcGhlbWUgY2x1c3RlcnMgY29ycmVjdGx5LiBJZiBpdCBpcyBub3QgYXZhaWxhYmxlLFxuICogUGl4aUpTIHdpbGwgZmFsbGJhY2sgdG8gdXNlIHRoZSBpdGVyYXRvciBvZiBTdHJpbmcsIHdoaWNoIGNhbiBvbmx5IHNwaWx0IHRoZSBzdHJpbmcgaW50byBjb2RlIHBvaW50cy5cbiAqIElmIHlvdSB3YW50IHRvIGdldCBmdWxsIGZ1bmN0aW9uYWxpdHkgaW4gZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBgSW50bC5TZWdtZW50ZXJgIChzdWNoIGFzIEZpcmVmb3gpLFxuICogeW91IGNhbiB1c2Ugb3RoZXIgbGlicmFyaWVzIHN1Y2ggYXMgW2dyYXBoZW1lLXNwbGl0dGVyXXtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9ncmFwaGVtZS1zcGxpdHRlcn1cbiAqIG9yIFtncmFwaGVtZXJde0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2dyYXBoZW1lcn0gdG8gY3JlYXRlIGEgcG9seWZpbGwuIFNpbmNlIHRoZXNlIGxpYnJhcmllcyBjYW4gYmVcbiAqIHJlbGF0aXZlbHkgbGFyZ2UgaW4gc2l6ZSB0byBoYW5kbGUgdmFyaW91cyBVbmljb2RlIGdyYXBoZW1lIGNsdXN0ZXJzIHByb3Blcmx5LCBQaXhpSlMgd29uJ3QgdXNlIHRoZW0gZGlyZWN0bHkuXG4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlciA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgSW50bD8uU2VnbWVudGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBzZWdtZW50ZXIgPSBuZXcgSW50bC5TZWdtZW50ZXIoKTtcbiAgICByZXR1cm4gKHMpID0+IFsuLi5zZWdtZW50ZXIuc2VnbWVudChzKV0ubWFwKCh4KSA9PiB4LnNlZ21lbnQpO1xuICB9XG4gIHJldHVybiAocykgPT4gWy4uLnNdO1xufSkoKTtcbi8qKlxuICogTmV3IHJlbmRlcmluZyBiZWhhdmlvciBmb3IgbGV0dGVyLXNwYWNpbmcgd2hpY2ggdXNlcyBDaHJvbWUncyBuZXcgbmF0aXZlIEFQSS4gVGhpcyB3aWxsXG4gKiBsZWFkIHRvIG1vcmUgYWNjdXJhdGUgbGV0dGVyLXNwYWNpbmcgcmVzdWx0cyBiZWNhdXNlIGl0IGRvZXMgbm90IHRyeSB0byBtYW51YWxseSBkcmF3XG4gKiBlYWNoIGNoYXJhY3Rlci4gSG93ZXZlciwgdGhpcyBDaHJvbWUgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IG5vdCBzZXJ2ZSBhbGwgY2FzZXMgeWV0LlxuICogQHNlZSBUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkXG4gKi9cbl9DYW52YXNUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gZmFsc2U7XG4vKiogQ2FjaGUgb2Yge0BzZWUgVGV4dE1ldHJpY3MuRm9udE1ldHJpY3N9IG9iamVjdHMuICovXG5fQ2FudmFzVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XG4vKiogQ2FjaGUgb2YgbmV3IGxpbmUgY2hhcnMuICovXG5fQ2FudmFzVGV4dE1ldHJpY3MuX25ld2xpbmVzID0gW1xuICAxMCxcbiAgLy8gbGluZSBmZWVkXG4gIDEzXG4gIC8vIGNhcnJpYWdlIHJldHVyblxuXTtcbi8qKiBDYWNoZSBvZiBicmVha2luZyBzcGFjZXMuICovXG5fQ2FudmFzVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzID0gW1xuICA5LFxuICAvLyBjaGFyYWN0ZXIgdGFidWxhdGlvblxuICAzMixcbiAgLy8gc3BhY2VcbiAgODE5MixcbiAgLy8gZW4gcXVhZFxuICA4MTkzLFxuICAvLyBlbSBxdWFkXG4gIDgxOTQsXG4gIC8vIGVuIHNwYWNlXG4gIDgxOTUsXG4gIC8vIGVtIHNwYWNlXG4gIDgxOTYsXG4gIC8vIHRocmVlLXBlci1lbSBzcGFjZVxuICA4MTk3LFxuICAvLyBmb3VyLXBlci1lbSBzcGFjZVxuICA4MTk4LFxuICAvLyBzaXgtcGVyLWVtIHNwYWNlXG4gIDgyMDAsXG4gIC8vIHB1bmN0dWF0aW9uIHNwYWNlXG4gIDgyMDEsXG4gIC8vIHRoaW4gc3BhY2VcbiAgODIwMixcbiAgLy8gaGFpciBzcGFjZVxuICA4Mjg3LFxuICAvLyBtZWRpdW0gbWF0aGVtYXRpY2FsIHNwYWNlXG4gIDEyMjg4XG4gIC8vIGlkZW9ncmFwaGljIHNwYWNlXG5dO1xuX0NhbnZhc1RleHRNZXRyaWNzLl9tZWFzdXJlbWVudENhY2hlID0ge307XG5sZXQgQ2FudmFzVGV4dE1ldHJpY3MgPSBfQ2FudmFzVGV4dE1ldHJpY3M7XG5cbmV4cG9ydCB7IENhbnZhc1RleHRNZXRyaWNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNUZXh0TWV0cmljcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3374\n')},13:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   M: () => (/* binding */ fontStringFromTextStyle)\n/* harmony export */ });\n\nconst genericFontFamilies = [\n  "serif",\n  "sans-serif",\n  "monospace",\n  "cursive",\n  "fantasy",\n  "system-ui"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(",");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\"\\\'])[^\\\'\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `"${fontFamily}"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;\n}\n\n\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLHVCQUF1QjtBQUNqSDs7QUFFbUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvY2FudmFzL3V0aWxzL2ZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlLm1qcz9mZjEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgZ2VuZXJpY0ZvbnRGYW1pbGllcyA9IFtcbiAgXCJzZXJpZlwiLFxuICBcInNhbnMtc2VyaWZcIixcbiAgXCJtb25vc3BhY2VcIixcbiAgXCJjdXJzaXZlXCIsXG4gIFwiZmFudGFzeVwiLFxuICBcInN5c3RlbS11aVwiXG5dO1xuZnVuY3Rpb24gZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUoc3R5bGUpIHtcbiAgY29uc3QgZm9udFNpemVTdHJpbmcgPSB0eXBlb2Ygc3R5bGUuZm9udFNpemUgPT09IFwibnVtYmVyXCIgPyBgJHtzdHlsZS5mb250U2l6ZX1weGAgOiBzdHlsZS5mb250U2l6ZTtcbiAgbGV0IGZvbnRGYW1pbGllcyA9IHN0eWxlLmZvbnRGYW1pbHk7XG4gIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS5mb250RmFtaWx5KSkge1xuICAgIGZvbnRGYW1pbGllcyA9IHN0eWxlLmZvbnRGYW1pbHkuc3BsaXQoXCIsXCIpO1xuICB9XG4gIGZvciAobGV0IGkgPSBmb250RmFtaWxpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgZm9udEZhbWlseSA9IGZvbnRGYW1pbGllc1tpXS50cmltKCk7XG4gICAgaWYgKCEvKFtcXFwiXFwnXSlbXlxcJ1xcXCJdK1xcMS8udGVzdChmb250RmFtaWx5KSAmJiAhZ2VuZXJpY0ZvbnRGYW1pbGllcy5pbmNsdWRlcyhmb250RmFtaWx5KSkge1xuICAgICAgZm9udEZhbWlseSA9IGBcIiR7Zm9udEZhbWlseX1cImA7XG4gICAgfVxuICAgIGZvbnRGYW1pbGllc1tpXSA9IGZvbnRGYW1pbHk7XG4gIH1cbiAgcmV0dXJuIGAke3N0eWxlLmZvbnRTdHlsZX0gJHtzdHlsZS5mb250VmFyaWFudH0gJHtzdHlsZS5mb250V2VpZ2h0fSAke2ZvbnRTaXplU3RyaW5nfSAke2ZvbnRGYW1pbGllcy5qb2luKFwiLFwiKX1gO1xufVxuXG5leHBvcnQgeyBmb250U3RyaW5nRnJvbVRleHRTdHlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9udFN0cmluZ0Zyb21UZXh0U3R5bGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n')},778:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   m: () => (/* binding */ getCanvasFillStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8409);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9853);\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4796);\n/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(557);\n/* harmony import */ var _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1261);\n\n\n\n\n\n\n\n"use strict";\nfunction getCanvasFillStyle(fillStyle, context) {\n  if (fillStyle.texture === _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Texture */ .x.WHITE && !fillStyle.fill) {\n    return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(fillStyle.color).toHex();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, "repeat");\n    const tempMatrix = fillStyle.matrix.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix */ .y.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__/* .FillPattern */ .h) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, "repeat");\n    const tempMatrix = fillPattern.transform.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix */ .y.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__/* .FillGradient */ .f) {\n    const fillGradient = fillStyle.fill;\n    if (fillGradient.type === "linear") {\n      const gradient = context.createLinearGradient(\n        fillGradient.x0,\n        fillGradient.y0,\n        fillGradient.x1,\n        fillGradient.y1\n      );\n      fillGradient.gradientStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(stop.color).toHex());\n      });\n      return gradient;\n    }\n  }\n  (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__/* .warn */ .Z)("FillStyle not recognised", fillStyle);\n  return "red";\n}\n\n\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRDtBQUNTO0FBQ3dCO0FBQzNCO0FBQ29CO0FBQ0Y7O0FBRTVFO0FBQ0E7QUFDQSw0QkFBNEIsNkZBQU87QUFDbkMsV0FBVyw0REFBSztBQUNoQixJQUFJO0FBQ0o7QUFDQSwrQ0FBK0MscUVBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUMsdUZBQVc7QUFDbEQ7QUFDQTtBQUNBLG9EQUFvRCxxRUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQyx5RkFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNERBQUs7QUFDaEQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0VBQUk7QUFDTjtBQUNBOztBQUU4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9jYW52YXMvdXRpbHMvZ2V0Q2FudmFzRmlsbFN0eWxlLm1qcz8zZjExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IEZpbGxHcmFkaWVudCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoaWNzL3NoYXJlZC9maWxsL0ZpbGxHcmFkaWVudC5tanMnO1xuaW1wb3J0IHsgRmlsbFBhdHRlcm4gfSBmcm9tICcuLi8uLi8uLi9ncmFwaGljcy9zaGFyZWQvZmlsbC9GaWxsUGF0dGVybi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldENhbnZhc0ZpbGxTdHlsZShmaWxsU3R5bGUsIGNvbnRleHQpIHtcbiAgaWYgKGZpbGxTdHlsZS50ZXh0dXJlID09PSBUZXh0dXJlLldISVRFICYmICFmaWxsU3R5bGUuZmlsbCkge1xuICAgIHJldHVybiBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZmlsbFN0eWxlLmNvbG9yKS50b0hleCgpO1xuICB9IGVsc2UgaWYgKCFmaWxsU3R5bGUuZmlsbCkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oZmlsbFN0eWxlLnRleHR1cmUuc291cmNlLnJlc291cmNlLCBcInJlcGVhdFwiKTtcbiAgICBjb25zdCB0ZW1wTWF0cml4ID0gZmlsbFN0eWxlLm1hdHJpeC5jb3B5VG8oTWF0cml4LnNoYXJlZCk7XG4gICAgdGVtcE1hdHJpeC5zY2FsZShmaWxsU3R5bGUudGV4dHVyZS5mcmFtZS53aWR0aCwgZmlsbFN0eWxlLnRleHR1cmUuZnJhbWUuaGVpZ2h0KTtcbiAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybSh0ZW1wTWF0cml4KTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfSBlbHNlIGlmIChmaWxsU3R5bGUuZmlsbCBpbnN0YW5jZW9mIEZpbGxQYXR0ZXJuKSB7XG4gICAgY29uc3QgZmlsbFBhdHRlcm4gPSBmaWxsU3R5bGUuZmlsbDtcbiAgICBjb25zdCBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKGZpbGxQYXR0ZXJuLnRleHR1cmUuc291cmNlLnJlc291cmNlLCBcInJlcGVhdFwiKTtcbiAgICBjb25zdCB0ZW1wTWF0cml4ID0gZmlsbFBhdHRlcm4udHJhbnNmb3JtLmNvcHlUbyhNYXRyaXguc2hhcmVkKTtcbiAgICB0ZW1wTWF0cml4LnNjYWxlKFxuICAgICAgZmlsbFBhdHRlcm4udGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgIGZpbGxQYXR0ZXJuLnRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgKTtcbiAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybSh0ZW1wTWF0cml4KTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfSBlbHNlIGlmIChmaWxsU3R5bGUuZmlsbCBpbnN0YW5jZW9mIEZpbGxHcmFkaWVudCkge1xuICAgIGNvbnN0IGZpbGxHcmFkaWVudCA9IGZpbGxTdHlsZS5maWxsO1xuICAgIGlmIChmaWxsR3JhZGllbnQudHlwZSA9PT0gXCJsaW5lYXJcIikge1xuICAgICAgY29uc3QgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICBmaWxsR3JhZGllbnQueDAsXG4gICAgICAgIGZpbGxHcmFkaWVudC55MCxcbiAgICAgICAgZmlsbEdyYWRpZW50LngxLFxuICAgICAgICBmaWxsR3JhZGllbnQueTFcbiAgICAgICk7XG4gICAgICBmaWxsR3JhZGllbnQuZ3JhZGllbnRTdG9wcy5mb3JFYWNoKChzdG9wKSA9PiB7XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLm9mZnNldCwgQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0b3AuY29sb3IpLnRvSGV4KCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICB9XG4gIHdhcm4oXCJGaWxsU3R5bGUgbm90IHJlY29nbmlzZWRcIiwgZmlsbFN0eWxlKTtcbiAgcmV0dXJuIFwicmVkXCI7XG59XG5cbmV4cG9ydCB7IGdldENhbnZhc0ZpbGxTdHlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q2FudmFzRmlsbFN0eWxlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///778\n')},2:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs\nvar updateQuadBounds = __webpack_require__(3747);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(900);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs\n\n\n\n\n\n"use strict";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text._getKey();\n    if (gpuText.currentKey !== newKey) {\n      const resolution = text.resolution ?? this._renderer.resolution;\n      const { width, height } = this._renderer.canvasText.getTextureSize(\n        text.text,\n        resolution,\n        text._style\n      );\n      if (\n        // is only being used by this text:\n        this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height\n      ) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  addRenderable(text, _instructionSet) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(text) {\n    this._destroyRenderableById(text.uid);\n  }\n  _destroyRenderableById(textUid) {\n    const gpuText = this._gpuText[textUid];\n    this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    PoolGroup/* BigPool */.u.return(gpuText.batchableSprite);\n    this._gpuText[textUid] = null;\n  }\n  _updateText(text) {\n    const newKey = text._getKey();\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(text);\n    }\n    text._didTextUpdate = false;\n    const padding = text._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.w)(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n  }\n  _updateGpuText(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    }\n    gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n    gpuText.currentKey = text._getKey();\n    batchableSprite.texture = gpuText.texture;\n  }\n  _getGpuText(text) {\n    return this._gpuText[text.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const gpuTextData = {\n      texture: null,\n      currentKey: "--",\n      batchableSprite: PoolGroup/* BigPool */.u.get(BatchableSprite/* BatchableSprite */.c)\n    };\n    gpuTextData.batchableSprite.renderable = text;\n    gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    this._gpuText[text.uid] = gpuTextData;\n    this._updateText(text);\n    text.on("destroyed", () => {\n      this.destroyRenderable(text);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipes,\n    Extensions/* ExtensionType */.nw.WebGPUPipes,\n    Extensions/* ExtensionType */.nw.CanvasPipes\n  ],\n  name: "text"\n};\n\n\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/pow2.mjs\nvar pow2 = __webpack_require__(4181);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(131);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6669);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs\n\n\n"use strict";\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas, resolution = 1) {\n  const { width, height } = canvas;\n  const context = canvas.getContext("2d", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError("Failed to get canvas 2D context");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return Rectangle/* Rectangle */.A.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  return new Rectangle/* Rectangle */.A(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n\n\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(3779);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs\nvar getPo2TextureFromSource = __webpack_require__(1647);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3374);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(13);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(778);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._activeTextures = {};\n    this._renderer = _renderer;\n  }\n  getTextureSize(text, resolution, style) {\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    width = Math.ceil(width - 1e-6);\n    height = Math.ceil(height - 1e-6);\n    width = (0,pow2/* nextPow2 */.a9)(width);\n    height = (0,pow2/* nextPow2 */.a9)(height);\n    return { width, height };\n  }\n  getTexture(options, resolution, style, _textKey) {\n    if (typeof options === "string") {\n      (0,deprecation/* deprecation */.a)("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");\n      options = {\n        text: options,\n        style,\n        resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle/* TextStyle */.p)) {\n      options.style = new TextStyle/* TextStyle */.p(options.style);\n    }\n    const { texture, canvasAndContext } = this.createTextureAndCanvas(\n      options\n    );\n    this._renderer.texture.initSource(texture._source);\n    CanvasPool/* CanvasPool */.h.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  createTextureAndCanvas(options) {\n    const { text, style } = options;\n    const resolution = options.resolution ?? this._renderer.resolution;\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const canvasAndContext = CanvasPool/* CanvasPool */.h.getOptimalCanvasAndContext(width, height);\n    const { canvas } = canvasAndContext;\n    this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n    const texture = (0,getPo2TextureFromSource/* getPo2TextureFromSource */.H)(canvas, width, height, resolution);\n    if (style.trim) {\n      const trimmed = getCanvasBoundingBox(canvas, resolution);\n      texture.frame.copyFrom(trimmed);\n      texture.updateUvs();\n    }\n    return { texture, canvasAndContext };\n  }\n  getManagedTexture(text) {\n    const textKey = text._getKey();\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n    this._activeTextures[textKey] = {\n      canvasAndContext,\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      CanvasPool/* CanvasPool */.h.returnCanvasAndContext(activeTexture.canvasAndContext);\n      TexturePool/* TexturePool */.z.returnTexture(activeTexture.texture);\n      const source = activeTexture.texture.source;\n      source.resource = null;\n      source.uploadMethodId = "unknown";\n      source.alphaMode = "no-premultiply-alpha";\n      this._activeTextures[textKey] = null;\n    }\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to \'pre-generate\' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */\n  renderTextToCanvas(text, style, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.M)(style);\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.c.measureText(text || " ", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    const padding = style.padding * 2;\n    context.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = "black";\n        context.strokeStyle = "black";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color/* Color */.I.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.globalAlpha = style._fill?.alpha ?? 1;\n        context.fillStyle = style._fill ? (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._fill, context) : null;\n        if (style._stroke?.width) {\n          context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.m)(style._stroke, context);\n        }\n        context.shadowColor = "black";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === "right") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === "center") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke?.width) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it\'s for the inside fill\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics/* CanvasTextMetrics */.c.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics/* CanvasTextMetrics */.c.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics/* CanvasTextMetrics */.c.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = "";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "canvasText"\n};\n\n\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(CanvasTextSystem);\nExtensions/* extensions */.Rw.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1FO0FBQ1M7QUFDaEI7QUFDTzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0Q0FBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUFPLEtBQUssc0NBQWU7QUFDbEQ7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUUwQjtBQUMxQjs7Ozs7Ozs7Ozs7OztBQ25INkQ7O0FBRTdEO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBUztBQUN0Qjs7QUFFZ0M7QUFDaEM7Ozs7Ozs7Ozs7Ozs7OztBQ2hEaUQ7QUFDa0I7QUFDWDtBQUNnQztBQUNFO0FBQ0o7QUFDakI7QUFDeEI7QUFDa0M7QUFDbkI7QUFDa0I7QUFDVjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBUTtBQUNwQixhQUFhLHlCQUFRO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtDQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBUztBQUM1QywwQkFBMEIsMEJBQVM7QUFDbkM7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0EscUJBQXFCLDBDQUFpQjtBQUN0QztBQUNBO0FBQ0EsNkJBQTZCLDRCQUFVO0FBQ3ZDLFlBQVksU0FBUztBQUNyQjtBQUNBLG9CQUFvQiwwREFBdUI7QUFDM0M7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDRCQUFVO0FBQ2hCLE1BQU0sOEJBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QixpQkFBaUIsMERBQXVCO0FBQ3hDLHFCQUFxQiwwQ0FBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDBDQUEwQyxnREFBa0I7QUFDNUQ7QUFDQSxnQ0FBZ0MsZ0RBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLFFBQVEsMENBQWlCO0FBQ3pCLFVBQVUsMENBQWlCO0FBQzNCLG1DQUFtQyxjQUFjO0FBQ2pELHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQWlCO0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRTRCO0FBQzVCOzs7QUNwUTZEO0FBQ0E7QUFDSTs7QUFFakU7QUFDQSw2QkFBVSxLQUFLLGdCQUFnQjtBQUMvQiw2QkFBVSxLQUFLLGNBQWM7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvY2FudmFzL0NhbnZhc1RleHRQaXBlLm1qcz9iYTI2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvY2FudmFzL2dldENhbnZhc0JvdW5kaW5nQm94Lm1qcz80M2FhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9jYW52YXMvQ2FudmFzVGV4dFN5c3RlbS5tanM/OGUzZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvaW5pdC5tanM/YzA5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVRdWFkQm91bmRzIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZGF0YS91cGRhdGVRdWFkQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBCaWdQb29sIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvcG9vbC9Qb29sR3JvdXAubWpzJztcbmltcG9ydCB7IEJhdGNoYWJsZVNwcml0ZSB9IGZyb20gJy4uLy4uL3Nwcml0ZS9CYXRjaGFibGVTcHJpdGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDYW52YXNUZXh0UGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZ3B1VGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKHRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBuZXdLZXkgPSB0ZXh0Ll9nZXRLZXkoKTtcbiAgICBpZiAoZ3B1VGV4dC5jdXJyZW50S2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0ZXh0LnJlc29sdXRpb24gPz8gdGhpcy5fcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5nZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgdGV4dC50ZXh0LFxuICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICB0ZXh0Ll9zdHlsZVxuICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gaXMgb25seSBiZWluZyB1c2VkIGJ5IHRoaXMgdGV4dDpcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5nZXRSZWZlcmVuY2VDb3VudChncHVUZXh0LmN1cnJlbnRLZXkpID09PSAxICYmIHdpZHRoID09PSBncHVUZXh0LnRleHR1cmUuX3NvdXJjZS53aWR0aCAmJiBoZWlnaHQgPT09IGdwdVRleHQudGV4dHVyZS5fc291cmNlLmhlaWdodFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZSh0ZXh0LCBfaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAodGV4dC5fZGlkVGV4dFVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dCh0ZXh0KTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYWRkVG9CYXRjaChiYXRjaGFibGVTcHJpdGUpO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUodGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KHRleHQpO1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlO1xuICAgIGlmICh0ZXh0Ll9kaWRUZXh0VXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0KHRleHQpO1xuICAgIH1cbiAgICBiYXRjaGFibGVTcHJpdGUuYmF0Y2hlci51cGRhdGVFbGVtZW50KGJhdGNoYWJsZVNwcml0ZSk7XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUodGV4dCkge1xuICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZCh0ZXh0LnVpZCk7XG4gIH1cbiAgX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZCh0ZXh0VWlkKSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dwdVRleHRbdGV4dFVpZF07XG4gICAgdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5kZWNyZWFzZVJlZmVyZW5jZUNvdW50KGdwdVRleHQuY3VycmVudEtleSk7XG4gICAgQmlnUG9vbC5yZXR1cm4oZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGUpO1xuICAgIHRoaXMuX2dwdVRleHRbdGV4dFVpZF0gPSBudWxsO1xuICB9XG4gIF91cGRhdGVUZXh0KHRleHQpIHtcbiAgICBjb25zdCBuZXdLZXkgPSB0ZXh0Ll9nZXRLZXkoKTtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoZ3B1VGV4dC5jdXJyZW50S2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUdwdVRleHQodGV4dCk7XG4gICAgfVxuICAgIHRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGV4dC5fc3R5bGUucGFkZGluZztcbiAgICB1cGRhdGVRdWFkQm91bmRzKGJhdGNoYWJsZVNwcml0ZS5ib3VuZHMsIHRleHQuX2FuY2hvciwgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUsIHBhZGRpbmcpO1xuICB9XG4gIF91cGRhdGVHcHVUZXh0KHRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoZ3B1VGV4dC50ZXh0dXJlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5jYW52YXNUZXh0LmRlY3JlYXNlUmVmZXJlbmNlQ291bnQoZ3B1VGV4dC5jdXJyZW50S2V5KTtcbiAgICB9XG4gICAgZ3B1VGV4dC50ZXh0dXJlID0gYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUgPSB0aGlzLl9yZW5kZXJlci5jYW52YXNUZXh0LmdldE1hbmFnZWRUZXh0dXJlKHRleHQpO1xuICAgIGdwdVRleHQuY3VycmVudEtleSA9IHRleHQuX2dldEtleSgpO1xuICAgIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlID0gZ3B1VGV4dC50ZXh0dXJlO1xuICB9XG4gIF9nZXRHcHVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1VGV4dFt0ZXh0LnVpZF0gfHwgdGhpcy5pbml0R3B1VGV4dCh0ZXh0KTtcbiAgfVxuICBpbml0R3B1VGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dERhdGEgPSB7XG4gICAgICB0ZXh0dXJlOiBudWxsLFxuICAgICAgY3VycmVudEtleTogXCItLVwiLFxuICAgICAgYmF0Y2hhYmxlU3ByaXRlOiBCaWdQb29sLmdldChCYXRjaGFibGVTcHJpdGUpXG4gICAgfTtcbiAgICBncHVUZXh0RGF0YS5iYXRjaGFibGVTcHJpdGUucmVuZGVyYWJsZSA9IHRleHQ7XG4gICAgZ3B1VGV4dERhdGEuYmF0Y2hhYmxlU3ByaXRlLmJvdW5kcyA9IHsgbWluWDogMCwgbWF4WDogMSwgbWluWTogMCwgbWF4WTogMCB9O1xuICAgIGdwdVRleHREYXRhLmJhdGNoYWJsZVNwcml0ZS5yb3VuZFBpeGVscyA9IHRoaXMuX3JlbmRlcmVyLl9yb3VuZFBpeGVscyB8IHRleHQuX3JvdW5kUGl4ZWxzO1xuICAgIHRoaXMuX2dwdVRleHRbdGV4dC51aWRdID0gZ3B1VGV4dERhdGE7XG4gICAgdGhpcy5fdXBkYXRlVGV4dCh0ZXh0KTtcbiAgICB0ZXh0Lm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUodGV4dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdwdVRleHREYXRhO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2dwdVRleHQpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZChpKTtcbiAgICB9XG4gICAgdGhpcy5fZ3B1VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuQ2FudmFzVGV4dFBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcInRleHRcIlxufTtcblxuZXhwb3J0IHsgQ2FudmFzVGV4dFBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1RleHRQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjaGVja1JvdyhkYXRhLCB3aWR0aCwgeSkge1xuICBmb3IgKGxldCB4ID0gMCwgaW5kZXggPSA0ICogeSAqIHdpZHRoOyB4IDwgd2lkdGg7ICsreCwgaW5kZXggKz0gNCkge1xuICAgIGlmIChkYXRhW2luZGV4ICsgM10gIT09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjaGVja0NvbHVtbihkYXRhLCB3aWR0aCwgeCwgdG9wLCBib3R0b20pIHtcbiAgY29uc3Qgc3RyaWRlID0gNCAqIHdpZHRoO1xuICBmb3IgKGxldCB5ID0gdG9wLCBpbmRleCA9IHRvcCAqIHN0cmlkZSArIDQgKiB4OyB5IDw9IGJvdHRvbTsgKyt5LCBpbmRleCArPSBzdHJpZGUpIHtcbiAgICBpZiAoZGF0YVtpbmRleCArIDNdICE9PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0Q2FudmFzQm91bmRpbmdCb3goY2FudmFzLCByZXNvbHV0aW9uID0gMSkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNhbnZhcztcbiAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICB9KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGdldCBjYW52YXMgMkQgY29udGV4dFwiKTtcbiAgfVxuICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICBsZXQgbGVmdCA9IDA7XG4gIGxldCB0b3AgPSAwO1xuICBsZXQgcmlnaHQgPSB3aWR0aCAtIDE7XG4gIGxldCBib3R0b20gPSBoZWlnaHQgLSAxO1xuICB3aGlsZSAodG9wIDwgaGVpZ2h0ICYmIGNoZWNrUm93KGRhdGEsIHdpZHRoLCB0b3ApKVxuICAgICsrdG9wO1xuICBpZiAodG9wID09PSBoZWlnaHQpXG4gICAgcmV0dXJuIFJlY3RhbmdsZS5FTVBUWTtcbiAgd2hpbGUgKGNoZWNrUm93KGRhdGEsIHdpZHRoLCBib3R0b20pKVxuICAgIC0tYm90dG9tO1xuICB3aGlsZSAoY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIGxlZnQsIHRvcCwgYm90dG9tKSlcbiAgICArK2xlZnQ7XG4gIHdoaWxlIChjaGVja0NvbHVtbihkYXRhLCB3aWR0aCwgcmlnaHQsIHRvcCwgYm90dG9tKSlcbiAgICAtLXJpZ2h0O1xuICArK3JpZ2h0O1xuICArK2JvdHRvbTtcbiAgcmV0dXJuIG5ldyBSZWN0YW5nbGUobGVmdCAvIHJlc29sdXRpb24sIHRvcCAvIHJlc29sdXRpb24sIChyaWdodCAtIGxlZnQpIC8gcmVzb2x1dGlvbiwgKGJvdHRvbSAtIHRvcCkgLyByZXNvbHV0aW9uKTtcbn1cblxuZXhwb3J0IHsgZ2V0Q2FudmFzQm91bmRpbmdCb3ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENhbnZhc0JvdW5kaW5nQm94Lm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IG5leHRQb3cyIH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWlzYy9wb3cyLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNQb29sIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9DYW52YXNQb29sLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlUG9vbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVBvb2wubWpzJztcbmltcG9ydCB7IGdldENhbnZhc0JvdW5kaW5nQm94IH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2FudmFzL2dldENhbnZhc0JvdW5kaW5nQm94Lm1qcyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IFRleHRTdHlsZSB9IGZyb20gJy4uL1RleHRTdHlsZS5tanMnO1xuaW1wb3J0IHsgZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UgfSBmcm9tICcuLi91dGlscy9nZXRQbzJUZXh0dXJlRnJvbVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuL0NhbnZhc1RleHRNZXRyaWNzLm1qcyc7XG5pbXBvcnQgeyBmb250U3RyaW5nRnJvbVRleHRTdHlsZSB9IGZyb20gJy4vdXRpbHMvZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUubWpzJztcbmltcG9ydCB7IGdldENhbnZhc0ZpbGxTdHlsZSB9IGZyb20gJy4vdXRpbHMvZ2V0Q2FudmFzRmlsbFN0eWxlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ2FudmFzVGV4dFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKF9yZW5kZXJlcikge1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzID0ge307XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gIH1cbiAgZ2V0VGV4dHVyZVNpemUodGV4dCwgcmVzb2x1dGlvbiwgc3R5bGUpIHtcbiAgICBjb25zdCBtZWFzdXJlZCA9IENhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVUZXh0KHRleHQgfHwgXCIgXCIsIHN0eWxlKTtcbiAgICBsZXQgd2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLndpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGxldCBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLmhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAtIDFlLTYpO1xuICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgLSAxZS02KTtcbiAgICB3aWR0aCA9IG5leHRQb3cyKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBuZXh0UG93MihoZWlnaHQpO1xuICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgfVxuICBnZXRUZXh0dXJlKG9wdGlvbnMsIHJlc29sdXRpb24sIHN0eWxlLCBfdGV4dEtleSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZGVwcmVjYXRpb24oXCI4LjAuMFwiLCBcIkNhbnZhc1RleHRTeXN0ZW0uZ2V0VGV4dHVyZTogVXNlIG9iamVjdCBUZXh0T3B0aW9ucyBpbnN0ZWFkIG9mIHNlcGFyYXRlIGFyZ3VtZW50c1wiKTtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHRleHQ6IG9wdGlvbnMsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICByZXNvbHV0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIShvcHRpb25zLnN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlKSkge1xuICAgICAgb3B0aW9ucy5zdHlsZSA9IG5ldyBUZXh0U3R5bGUob3B0aW9ucy5zdHlsZSk7XG4gICAgfVxuICAgIGNvbnN0IHsgdGV4dHVyZSwgY2FudmFzQW5kQ29udGV4dCB9ID0gdGhpcy5jcmVhdGVUZXh0dXJlQW5kQ2FudmFzKFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5fcmVuZGVyZXIudGV4dHVyZS5pbml0U291cmNlKHRleHR1cmUuX3NvdXJjZSk7XG4gICAgQ2FudmFzUG9vbC5yZXR1cm5DYW52YXNBbmRDb250ZXh0KGNhbnZhc0FuZENvbnRleHQpO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG4gIGNyZWF0ZVRleHR1cmVBbmRDYW52YXMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGV4dCwgc3R5bGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbiA/PyB0aGlzLl9yZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IG1lYXN1cmVkID0gQ2FudmFzVGV4dE1ldHJpY3MubWVhc3VyZVRleHQodGV4dCB8fCBcIiBcIiwgc3R5bGUpO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKE1hdGguY2VpbChNYXRoLm1heCgxLCBtZWFzdXJlZC53aWR0aCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLmhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gQ2FudmFzUG9vbC5nZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB7IGNhbnZhcyB9ID0gY2FudmFzQW5kQ29udGV4dDtcbiAgICB0aGlzLnJlbmRlclRleHRUb0NhbnZhcyh0ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbiwgY2FudmFzQW5kQ29udGV4dCk7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdldFBvMlRleHR1cmVGcm9tU291cmNlKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgaWYgKHN0eWxlLnRyaW0pIHtcbiAgICAgIGNvbnN0IHRyaW1tZWQgPSBnZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMsIHJlc29sdXRpb24pO1xuICAgICAgdGV4dHVyZS5mcmFtZS5jb3B5RnJvbSh0cmltbWVkKTtcbiAgICAgIHRleHR1cmUudXBkYXRlVXZzKCk7XG4gICAgfVxuICAgIHJldHVybiB7IHRleHR1cmUsIGNhbnZhc0FuZENvbnRleHQgfTtcbiAgfVxuICBnZXRNYW5hZ2VkVGV4dHVyZSh0ZXh0KSB7XG4gICAgY29uc3QgdGV4dEtleSA9IHRleHQuX2dldEtleSgpO1xuICAgIGlmICh0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XSkge1xuICAgICAgdGhpcy5faW5jcmVhc2VSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KTtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS50ZXh0dXJlO1xuICAgIH1cbiAgICBjb25zdCB7IHRleHR1cmUsIGNhbnZhc0FuZENvbnRleHQgfSA9IHRoaXMuY3JlYXRlVGV4dHVyZUFuZENhbnZhcyh0ZXh0KTtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XSA9IHtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQsXG4gICAgICB0ZXh0dXJlLFxuICAgICAgdXNhZ2VDb3VudDogMVxuICAgIH07XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbiAgX2luY3JlYXNlUmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnVzYWdlQ291bnQrKztcbiAgfVxuICBkZWNyZWFzZVJlZmVyZW5jZUNvdW50KHRleHRLZXkpIHtcbiAgICBjb25zdCBhY3RpdmVUZXh0dXJlID0gdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV07XG4gICAgYWN0aXZlVGV4dHVyZS51c2FnZUNvdW50LS07XG4gICAgaWYgKGFjdGl2ZVRleHR1cmUudXNhZ2VDb3VudCA9PT0gMCkge1xuICAgICAgQ2FudmFzUG9vbC5yZXR1cm5DYW52YXNBbmRDb250ZXh0KGFjdGl2ZVRleHR1cmUuY2FudmFzQW5kQ29udGV4dCk7XG4gICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKGFjdGl2ZVRleHR1cmUudGV4dHVyZSk7XG4gICAgICBjb25zdCBzb3VyY2UgPSBhY3RpdmVUZXh0dXJlLnRleHR1cmUuc291cmNlO1xuICAgICAgc291cmNlLnJlc291cmNlID0gbnVsbDtcbiAgICAgIHNvdXJjZS51cGxvYWRNZXRob2RJZCA9IFwidW5rbm93blwiO1xuICAgICAgc291cmNlLmFscGhhTW9kZSA9IFwibm8tcHJlbXVsdGlwbHktYWxwaGFcIjtcbiAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZ2V0UmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS51c2FnZUNvdW50O1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRleHQgdG8gaXRzIGNhbnZhcywgYW5kIHVwZGF0ZXMgaXRzIHRleHR1cmUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpcyB1c2VkIGludGVybmFsbHkgdG8gZW5zdXJlIHRoZSB0ZXh0dXJlIGlzIGNvcnJlY3QgYmVmb3JlIHJlbmRlcmluZyxcbiAgICogYnV0IGl0IGNhbiBiZSB1c2VkIGNhbGxlZCBleHRlcm5hbGx5LCBmb3IgZXhhbXBsZSBmcm9tIHRoaXMgY2xhc3MgdG8gJ3ByZS1nZW5lcmF0ZScgdGhlIHRleHR1cmUgZnJvbSBhIHBpZWNlIG9mIHRleHQsXG4gICAqIGFuZCB0aGVuIHNoYXJlZCBhY3Jvc3MgbXVsdGlwbGUgU3ByaXRlcy5cbiAgICogQHBhcmFtIHRleHRcbiAgICogQHBhcmFtIHN0eWxlXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uXG4gICAqIEBwYXJhbSBjYW52YXNBbmRDb250ZXh0XG4gICAqL1xuICByZW5kZXJUZXh0VG9DYW52YXModGV4dCwgc3R5bGUsIHJlc29sdXRpb24sIGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBjb25zdCB7IGNhbnZhcywgY29udGV4dCB9ID0gY2FudmFzQW5kQ29udGV4dDtcbiAgICBjb25zdCBmb250ID0gZm9udFN0cmluZ0Zyb21UZXh0U3R5bGUoc3R5bGUpO1xuICAgIGNvbnN0IG1lYXN1cmVkID0gQ2FudmFzVGV4dE1ldHJpY3MubWVhc3VyZVRleHQodGV4dCB8fCBcIiBcIiwgc3R5bGUpO1xuICAgIGNvbnN0IGxpbmVzID0gbWVhc3VyZWQubGluZXM7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IG1lYXN1cmVkLmxpbmVIZWlnaHQ7XG4gICAgY29uc3QgbGluZVdpZHRocyA9IG1lYXN1cmVkLmxpbmVXaWR0aHM7XG4gICAgY29uc3QgbWF4TGluZVdpZHRoID0gbWVhc3VyZWQubWF4TGluZVdpZHRoO1xuICAgIGNvbnN0IGZvbnRQcm9wZXJ0aWVzID0gbWVhc3VyZWQuZm9udFByb3BlcnRpZXM7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICBjb250ZXh0LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgY29udGV4dC5zY2FsZShyZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBwYWRkaW5nID0gc3R5bGUucGFkZGluZyAqIDI7XG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgbWVhc3VyZWQud2lkdGggKyA0ICsgcGFkZGluZywgbWVhc3VyZWQuaGVpZ2h0ICsgNCArIHBhZGRpbmcpO1xuICAgIGlmIChzdHlsZS5fc3Ryb2tlPy53aWR0aCkge1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdHlsZS5fc3Ryb2tlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHJva2VTdHlsZS53aWR0aDtcbiAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHN0cm9rZVN0eWxlLm1pdGVyTGltaXQ7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gc3Ryb2tlU3R5bGUuam9pbjtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9IHN0cm9rZVN0eWxlLmNhcDtcbiAgICB9XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICBsZXQgbGluZVBvc2l0aW9uWDtcbiAgICBsZXQgbGluZVBvc2l0aW9uWTtcbiAgICBjb25zdCBwYXNzZXNDb3VudCA9IHN0eWxlLmRyb3BTaGFkb3cgPyAyIDogMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhc3Nlc0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGlzU2hhZG93UGFzcyA9IHN0eWxlLmRyb3BTaGFkb3cgJiYgaSA9PT0gMDtcbiAgICAgIGNvbnN0IGRzT2Zmc2V0VGV4dCA9IGlzU2hhZG93UGFzcyA/IE1hdGguY2VpbChNYXRoLm1heCgxLCBoZWlnaHQpICsgc3R5bGUucGFkZGluZyAqIDIpIDogMDtcbiAgICAgIGNvbnN0IGRzT2Zmc2V0U2hhZG93ID0gZHNPZmZzZXRUZXh0ICogcmVzb2x1dGlvbjtcbiAgICAgIGlmIChpc1NoYWRvd1Bhc3MpIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGNvbnN0IHNoYWRvd09wdGlvbnMgPSBzdHlsZS5kcm9wU2hhZG93O1xuICAgICAgICBjb25zdCBkcm9wU2hhZG93Q29sb3IgPSBzaGFkb3dPcHRpb25zLmNvbG9yO1xuICAgICAgICBjb25zdCBkcm9wU2hhZG93QWxwaGEgPSBzaGFkb3dPcHRpb25zLmFscGhhO1xuICAgICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGRyb3BTaGFkb3dDb2xvcikuc2V0QWxwaGEoZHJvcFNoYWRvd0FscGhhKS50b1JnYmFTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0JsdXIgPSBzaGFkb3dPcHRpb25zLmJsdXIgKiByZXNvbHV0aW9uO1xuICAgICAgICBjb25zdCBkcm9wU2hhZG93RGlzdGFuY2UgPSBzaGFkb3dPcHRpb25zLmRpc3RhbmNlICogcmVzb2x1dGlvbjtcbiAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gZHJvcFNoYWRvd0JsdXI7XG4gICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IE1hdGguY29zKHNoYWRvd09wdGlvbnMuYW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSBNYXRoLnNpbihzaGFkb3dPcHRpb25zLmFuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZSArIGRzT2Zmc2V0U2hhZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHN0eWxlLl9maWxsPy5hbHBoYSA/PyAxO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0eWxlLl9maWxsID8gZ2V0Q2FudmFzRmlsbFN0eWxlKHN0eWxlLl9maWxsLCBjb250ZXh0KSA6IG51bGw7XG4gICAgICAgIGlmIChzdHlsZS5fc3Ryb2tlPy53aWR0aCkge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNGaWxsU3R5bGUoc3R5bGUuX3N0cm9rZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lUG9zaXRpb25ZU2hpZnQgPSAobGluZUhlaWdodCAtIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplKSAvIDI7XG4gICAgICBpZiAobGluZUhlaWdodCAtIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplIDwgMCkge1xuICAgICAgICBsaW5lUG9zaXRpb25ZU2hpZnQgPSAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBzdHlsZS5fc3Ryb2tlPy53aWR0aCA/PyAwO1xuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGxpbmVzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICBsaW5lUG9zaXRpb25YID0gc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgICBsaW5lUG9zaXRpb25ZID0gc3Ryb2tlV2lkdGggLyAyICsgaTIgKiBsaW5lSGVpZ2h0ICsgZm9udFByb3BlcnRpZXMuYXNjZW50ICsgbGluZVBvc2l0aW9uWVNoaWZ0O1xuICAgICAgICBpZiAoc3R5bGUuYWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpMl07XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2kyXSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZS5fc3Ryb2tlPy53aWR0aCkge1xuICAgICAgICAgIHRoaXMuX2RyYXdMZXR0ZXJTcGFjaW5nKFxuICAgICAgICAgICAgbGluZXNbaTJdLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBjYW52YXNBbmRDb250ZXh0LFxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyAtIGRzT2Zmc2V0VGV4dCxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZS5fZmlsbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhpcy5fZHJhd0xldHRlclNwYWNpbmcoXG4gICAgICAgICAgICBsaW5lc1tpMl0sXG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgIGNhbnZhc0FuZENvbnRleHQsXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YICsgc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nIC0gZHNPZmZzZXRUZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHRoZSB0ZXh0IHdpdGggbGV0dGVyLXNwYWNpbmcuXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIHRleHQgdG8gZHJhd1xuICAgKiBAcGFyYW0gc3R5bGVcbiAgICogQHBhcmFtIGNhbnZhc0FuZENvbnRleHRcbiAgICogQHBhcmFtIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIHRvIGRyYXcgdGhlIHRleHRcbiAgICogQHBhcmFtIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XG4gICAqIEBwYXJhbSBpc1N0cm9rZSAtIElzIHRoaXMgZHJhd2luZyBmb3IgdGhlIG91dHNpZGUgc3Ryb2tlIG9mIHRoZVxuICAgKiAgdGV4dD8gSWYgbm90LCBpdCdzIGZvciB0aGUgaW5zaWRlIGZpbGxcbiAgICovXG4gIF9kcmF3TGV0dGVyU3BhY2luZyh0ZXh0LCBzdHlsZSwgY2FudmFzQW5kQ29udGV4dCwgeCwgeSwgaXNTdHJva2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgY29udGV4dCB9ID0gY2FudmFzQW5kQ29udGV4dDtcbiAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gc3R5bGUubGV0dGVyU3BhY2luZztcbiAgICBsZXQgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IGZhbHNlO1xuICAgIGlmIChDYW52YXNUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoQ2FudmFzVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgO1xuICAgICAgICB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGV0dGVyU3BhY2luZyA9IFwiMHB4XCI7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGV0dGVyU3BhY2luZyA9PT0gMCB8fCB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nKSB7XG4gICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHg7XG4gICAgY29uc3Qgc3RyaW5nQXJyYXkgPSBDYW52YXNUZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlcih0ZXh0KTtcbiAgICBsZXQgcHJldmlvdXNXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgbGV0IGN1cnJlbnRXaWR0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY3VycmVudENoYXIgPSBzdHJpbmdBcnJheVtpXTtcbiAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoY3VycmVudENoYXIsIGN1cnJlbnRQb3NpdGlvbiwgeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGN1cnJlbnRDaGFyLCBjdXJyZW50UG9zaXRpb24sIHkpO1xuICAgICAgfVxuICAgICAgbGV0IHRleHRTdHIgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgc3RyaW5nQXJyYXkubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdGV4dFN0ciArPSBzdHJpbmdBcnJheVtqXTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dFN0cikud2lkdGg7XG4gICAgICBjdXJyZW50UG9zaXRpb24gKz0gcHJldmlvdXNXaWR0aCAtIGN1cnJlbnRXaWR0aCArIGxldHRlclNwYWNpbmc7XG4gICAgICBwcmV2aW91c1dpZHRoID0gY3VycmVudFdpZHRoO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkNhbnZhc1RleHRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1N5c3RlbVxuICBdLFxuICBuYW1lOiBcImNhbnZhc1RleHRcIlxufTtcblxuZXhwb3J0IHsgQ2FudmFzVGV4dFN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzVGV4dFN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNUZXh0UGlwZSB9IGZyb20gJy4vY2FudmFzL0NhbnZhc1RleHRQaXBlLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNUZXh0U3lzdGVtIH0gZnJvbSAnLi9jYW52YXMvQ2FudmFzVGV4dFN5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKENhbnZhc1RleHRTeXN0ZW0pO1xuZXh0ZW5zaW9ucy5hZGQoQ2FudmFzVGV4dFBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},740:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   L: () => (/* binding */ generateTextStyleKey)\n/* harmony export */ });\n\nconst valuesToIterateForKeys = [\n  "_fontFamily",\n  "_fontStyle",\n  "_fontSize",\n  "_fontVariant",\n  "_fontWeight",\n  "_breakWords",\n  "_align",\n  "_leading",\n  "_letterSpacing",\n  "_lineHeight",\n  "_textBaseline",\n  "_whiteSpace",\n  "_wordWrap",\n  "_wordWrapWidth",\n  "_padding",\n  "_cssOverrides",\n  "_trim"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = valuesToIterateForKeys[i];\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  return key.join("-");\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.uid;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\n\n\n//# sourceMappingURL=generateTextStyleKey.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQwLmpzIiwibWFwcGluZ3MiOiI7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUNBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L3V0aWxzL2dlbmVyYXRlVGV4dFN0eWxlS2V5Lm1qcz9lZjRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdmFsdWVzVG9JdGVyYXRlRm9yS2V5cyA9IFtcbiAgXCJfZm9udEZhbWlseVwiLFxuICBcIl9mb250U3R5bGVcIixcbiAgXCJfZm9udFNpemVcIixcbiAgXCJfZm9udFZhcmlhbnRcIixcbiAgXCJfZm9udFdlaWdodFwiLFxuICBcIl9icmVha1dvcmRzXCIsXG4gIFwiX2FsaWduXCIsXG4gIFwiX2xlYWRpbmdcIixcbiAgXCJfbGV0dGVyU3BhY2luZ1wiLFxuICBcIl9saW5lSGVpZ2h0XCIsXG4gIFwiX3RleHRCYXNlbGluZVwiLFxuICBcIl93aGl0ZVNwYWNlXCIsXG4gIFwiX3dvcmRXcmFwXCIsXG4gIFwiX3dvcmRXcmFwV2lkdGhcIixcbiAgXCJfcGFkZGluZ1wiLFxuICBcIl9jc3NPdmVycmlkZXNcIixcbiAgXCJfdHJpbVwiXG5dO1xuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0U3R5bGVLZXkoc3R5bGUpIHtcbiAgY29uc3Qga2V5ID0gW107XG4gIGxldCBpbmRleCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzVG9JdGVyYXRlRm9yS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByb3AgPSB2YWx1ZXNUb0l0ZXJhdGVGb3JLZXlzW2ldO1xuICAgIGtleVtpbmRleCsrXSA9IHN0eWxlW3Byb3BdO1xuICB9XG4gIGluZGV4ID0gYWRkRmlsbFN0eWxlS2V5KHN0eWxlLl9maWxsLCBrZXksIGluZGV4KTtcbiAgaW5kZXggPSBhZGRTdG9rZVN0eWxlS2V5KHN0eWxlLl9zdHJva2UsIGtleSwgaW5kZXgpO1xuICByZXR1cm4ga2V5LmpvaW4oXCItXCIpO1xufVxuZnVuY3Rpb24gYWRkRmlsbFN0eWxlS2V5KGZpbGxTdHlsZSwga2V5LCBpbmRleCkge1xuICBpZiAoIWZpbGxTdHlsZSlcbiAgICByZXR1cm4gaW5kZXg7XG4gIGtleVtpbmRleCsrXSA9IGZpbGxTdHlsZS5jb2xvcjtcbiAga2V5W2luZGV4KytdID0gZmlsbFN0eWxlLmFscGhhO1xuICBrZXlbaW5kZXgrK10gPSBmaWxsU3R5bGUuZmlsbD8udWlkO1xuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBhZGRTdG9rZVN0eWxlS2V5KHN0cm9rZVN0eWxlLCBrZXksIGluZGV4KSB7XG4gIGlmICghc3Ryb2tlU3R5bGUpXG4gICAgcmV0dXJuIGluZGV4O1xuICBpbmRleCA9IGFkZEZpbGxTdHlsZUtleShzdHJva2VTdHlsZSwga2V5LCBpbmRleCk7XG4gIGtleVtpbmRleCsrXSA9IHN0cm9rZVN0eWxlLndpZHRoO1xuICBrZXlbaW5kZXgrK10gPSBzdHJva2VTdHlsZS5hbGlnbm1lbnQ7XG4gIGtleVtpbmRleCsrXSA9IHN0cm9rZVN0eWxlLmNhcDtcbiAga2V5W2luZGV4KytdID0gc3Ryb2tlU3R5bGUuam9pbjtcbiAga2V5W2luZGV4KytdID0gc3Ryb2tlU3R5bGUubWl0ZXJMaW1pdDtcbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgeyBnZW5lcmF0ZVRleHRTdHlsZUtleSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVUZXh0U3R5bGVLZXkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///740\n')},1647:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   H: () => (/* binding */ getPo2TextureFromSource)\n/* harmony export */ });\n/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6669);\n/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(535);\n\n\n\n"use strict";\nconst tempBounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Bounds */ .Y();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TexturePool */ .z.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = "image";\n  texture.source.resource = image;\n  texture.source.alphaMode = "premultiply-alpha-on-upload";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit("update", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\n\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwRjtBQUMvQjs7QUFFM0Q7QUFDQSx1QkFBdUIseUVBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFHQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1DO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0L3V0aWxzL2dldFBvMlRleHR1cmVGcm9tU291cmNlLm1qcz9kMzZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHR1cmVQb29sIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlUG9vbC5tanMnO1xuaW1wb3J0IHsgQm91bmRzIH0gZnJvbSAnLi4vLi4vY29udGFpbmVyL2JvdW5kcy9Cb3VuZHMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wQm91bmRzID0gbmV3IEJvdW5kcygpO1xuZnVuY3Rpb24gZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UoaW1hZ2UsIHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgY29uc3QgYm91bmRzID0gdGVtcEJvdW5kcztcbiAgYm91bmRzLm1pblggPSAwO1xuICBib3VuZHMubWluWSA9IDA7XG4gIGJvdW5kcy5tYXhYID0gaW1hZ2Uud2lkdGggLyByZXNvbHV0aW9uIHwgMDtcbiAgYm91bmRzLm1heFkgPSBpbWFnZS5oZWlnaHQgLyByZXNvbHV0aW9uIHwgMDtcbiAgY29uc3QgdGV4dHVyZSA9IFRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKFxuICAgIGJvdW5kcy53aWR0aCxcbiAgICBib3VuZHMuaGVpZ2h0LFxuICAgIHJlc29sdXRpb24sXG4gICAgZmFsc2VcbiAgKTtcbiAgdGV4dHVyZS5zb3VyY2UudXBsb2FkTWV0aG9kSWQgPSBcImltYWdlXCI7XG4gIHRleHR1cmUuc291cmNlLnJlc291cmNlID0gaW1hZ2U7XG4gIHRleHR1cmUuc291cmNlLmFscGhhTW9kZSA9IFwicHJlbXVsdGlwbHktYWxwaGEtb24tdXBsb2FkXCI7XG4gIHRleHR1cmUuZnJhbWUud2lkdGggPSB3aWR0aCAvIHJlc29sdXRpb247XG4gIHRleHR1cmUuZnJhbWUuaGVpZ2h0ID0gaGVpZ2h0IC8gcmVzb2x1dGlvbjtcbiAgdGV4dHVyZS5zb3VyY2UuZW1pdChcInVwZGF0ZVwiLCB0ZXh0dXJlLnNvdXJjZSk7XG4gIHRleHR1cmUudXBkYXRlVXZzKCk7XG4gIHJldHVybiB0ZXh0dXJlO1xufVxuXG5leHBvcnQgeyBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1647\n')}}]);