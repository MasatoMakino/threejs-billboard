"use strict";(self.webpackChunk_masatomakino_threejs_billboard=self.webpackChunk_masatomakino_threejs_billboard||[]).push([[411],{3391:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   R: () => (/* binding */ textureBit),\n/* harmony export */   m: () => (/* binding */ textureBitGl)\n/* harmony export */ });\n\nconst textureBit = {\n  name: "texture-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: "texture-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n         \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=textureBit.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM5MS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvdGV4dHVyZUJpdC5tanM/ZWU5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRleHR1cmVCaXQgPSB7XG4gIG5hbWU6IFwidGV4dHVyZS1iaXRcIixcbiAgdmVydGV4OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG5cbiAgICAgICAgc3RydWN0IFRleHR1cmVVbmlmb3JtcyB7XG4gICAgICAgICAgICB1VGV4dHVyZU1hdHJpeDptYXQzeDM8ZjMyPixcbiAgICAgICAgfVxuXG4gICAgICAgIEBncm91cCgyKSBAYmluZGluZygyKSB2YXI8dW5pZm9ybT4gdGV4dHVyZVVuaWZvcm1zIDogVGV4dHVyZVVuaWZvcm1zO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICB1diA9ICh0ZXh0dXJlVW5pZm9ybXMudVRleHR1cmVNYXRyaXggKiB2ZWMzKHV2LCAxLjApKS54eTtcbiAgICAgICAgYFxuICAgIClcbiAgfSxcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygwKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygxKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XG5cbiAgICAgICAgIFxuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICBvdXRDb2xvciA9IHRleHR1cmVTYW1wbGUodVRleHR1cmUsIHVTYW1wbGVyLCB2VVYpO1xuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuY29uc3QgdGV4dHVyZUJpdEdsID0ge1xuICBuYW1lOiBcInRleHR1cmUtYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHVUZXh0dXJlTWF0cml4O1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB1diA9ICh1VGV4dHVyZU1hdHJpeCAqIHZlYzModXYsIDEuMCkpLnh5O1xuICAgICAgICBgXG4gICAgKVxuICB9LFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcblxuICAgICAgICAgXG4gICAgICAgIGBcbiAgICApLFxuICAgIG1haW46IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIG91dENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZSwgdlVWKTtcbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcblxuZXhwb3J0IHsgdGV4dHVyZUJpdCwgdGV4dHVyZUJpdEdsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0dXJlQml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3391\n')},7084:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   q: () => (/* binding */ ensureAttributes)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(268);\n/* harmony import */ var _shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8306);\n\n\n\n"use strict";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .R)(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += (0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__/* .getAttributeInfoFromFormat */ .m)(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += (0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__/* .getAttributeInfoFromFormat */ .m)(attribute.format).stride;\n  }\n}\n\n\n//# sourceMappingURL=ensureAttributes.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA4NC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RDtBQUM4Qzs7QUFFM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU0sc0VBQUksY0FBYyxHQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMEhBQTBCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMEhBQTBCO0FBQ2pFO0FBQ0E7O0FBRTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2Vuc3VyZUF0dHJpYnV0ZXMubWpzP2Q1MjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlSW5mb0Zyb21Gb3JtYXQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvZ2V0QXR0cmlidXRlSW5mb0Zyb21Gb3JtYXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBlbnN1cmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBleHRyYWN0ZWREYXRhKSB7XG4gIGZvciAoY29uc3QgaSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1tpXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVEYXRhID0gZXh0cmFjdGVkRGF0YVtpXTtcbiAgICBpZiAoYXR0cmlidXRlRGF0YSkge1xuICAgICAgYXR0cmlidXRlLmZvcm1hdCA/PyAoYXR0cmlidXRlLmZvcm1hdCA9IGF0dHJpYnV0ZURhdGEuZm9ybWF0KTtcbiAgICAgIGF0dHJpYnV0ZS5vZmZzZXQgPz8gKGF0dHJpYnV0ZS5vZmZzZXQgPSBhdHRyaWJ1dGVEYXRhLm9mZnNldCk7XG4gICAgICBhdHRyaWJ1dGUuaW5zdGFuY2UgPz8gKGF0dHJpYnV0ZS5pbnN0YW5jZSA9IGF0dHJpYnV0ZURhdGEuaW5zdGFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKGBBdHRyaWJ1dGUgJHtpfSBpcyBub3QgcHJlc2VudCBpbiB0aGUgc2hhZGVyLCBidXQgaXMgcHJlc2VudCBpbiB0aGUgZ2VvbWV0cnkuIFVuYWJsZSB0byBpbmZlciBhdHRyaWJ1dGUgZGV0YWlscy5gKTtcbiAgICB9XG4gIH1cbiAgZW5zdXJlU3RhcnRBbmRTdHJpZGUoZ2VvbWV0cnkpO1xufVxuZnVuY3Rpb24gZW5zdXJlU3RhcnRBbmRTdHJpZGUoZ2VvbWV0cnkpIHtcbiAgY29uc3QgeyBidWZmZXJzLCBhdHRyaWJ1dGVzIH0gPSBnZW9tZXRyeTtcbiAgY29uc3QgdGVtcFN0cmlkZSA9IHt9O1xuICBjb25zdCB0ZW1wU3RhcnQgPSB7fTtcbiAgZm9yIChjb25zdCBqIGluIGJ1ZmZlcnMpIHtcbiAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2pdO1xuICAgIHRlbXBTdHJpZGVbYnVmZmVyLnVpZF0gPSAwO1xuICAgIHRlbXBTdGFydFtidWZmZXIudWlkXSA9IDA7XG4gIH1cbiAgZm9yIChjb25zdCBqIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2pdO1xuICAgIHRlbXBTdHJpZGVbYXR0cmlidXRlLmJ1ZmZlci51aWRdICs9IGdldEF0dHJpYnV0ZUluZm9Gcm9tRm9ybWF0KGF0dHJpYnV0ZS5mb3JtYXQpLnN0cmlkZTtcbiAgfVxuICBmb3IgKGNvbnN0IGogaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XG4gICAgYXR0cmlidXRlLnN0cmlkZSA/PyAoYXR0cmlidXRlLnN0cmlkZSA9IHRlbXBTdHJpZGVbYXR0cmlidXRlLmJ1ZmZlci51aWRdKTtcbiAgICBhdHRyaWJ1dGUuc3RhcnQgPz8gKGF0dHJpYnV0ZS5zdGFydCA9IHRlbXBTdGFydFthdHRyaWJ1dGUuYnVmZmVyLnVpZF0pO1xuICAgIHRlbXBTdGFydFthdHRyaWJ1dGUuYnVmZmVyLnVpZF0gKz0gZ2V0QXR0cmlidXRlSW5mb0Zyb21Gb3JtYXQoYXR0cmlidXRlLmZvcm1hdCkuc3RyaWRlO1xuICB9XG59XG5cbmV4cG9ydCB7IGVuc3VyZUF0dHJpYnV0ZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuc3VyZUF0dHJpYnV0ZXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7084\n')},1172:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: () => (/* binding */ GpuStencilModesToPixi)\n/* harmony export */ });\n/* harmony import */ var _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1957);\n\n\n"use strict";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.NONE] = void 0;\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: "equal",\n    passOp: "increment-clamp"\n  },\n  stencilBack: {\n    compare: "equal",\n    passOp: "increment-clamp"\n  }\n};\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: "equal",\n    passOp: "decrement-clamp"\n  },\n  stencilBack: {\n    compare: "equal",\n    passOp: "decrement-clamp"\n  }\n};\nGpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .STENCIL_MODES */ .K.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: "equal",\n    passOp: "keep"\n  },\n  stencilBack: {\n    compare: "equal",\n    passOp: "keep"\n  }\n};\n\n\n//# sourceMappingURL=GpuStencilModesToPixi.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3Mi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTZEOztBQUU3RDtBQUNBO0FBQ0Esc0JBQXNCLDJFQUFhO0FBQ25DLHNCQUFzQiwyRUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUM7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3N0YXRlL0dwdVN0ZW5jaWxNb2Rlc1RvUGl4aS5tanM/YjJkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTVEVOQ0lMX01PREVTIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3N0YXRlL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgR3B1U3RlbmNpbE1vZGVzVG9QaXhpID0gW107XG5HcHVTdGVuY2lsTW9kZXNUb1BpeGlbU1RFTkNJTF9NT0RFUy5OT05FXSA9IHZvaWQgMDtcbkdwdVN0ZW5jaWxNb2Rlc1RvUGl4aVtTVEVOQ0lMX01PREVTLkRJU0FCTEVEXSA9IHtcbiAgc3RlbmNpbFdyaXRlTWFzazogMCxcbiAgc3RlbmNpbFJlYWRNYXNrOiAwXG59O1xuR3B1U3RlbmNpbE1vZGVzVG9QaXhpW1NURU5DSUxfTU9ERVMuUkVOREVSSU5HX01BU0tfQUREXSA9IHtcbiAgc3RlbmNpbEZyb250OiB7XG4gICAgY29tcGFyZTogXCJlcXVhbFwiLFxuICAgIHBhc3NPcDogXCJpbmNyZW1lbnQtY2xhbXBcIlxuICB9LFxuICBzdGVuY2lsQmFjazoge1xuICAgIGNvbXBhcmU6IFwiZXF1YWxcIixcbiAgICBwYXNzT3A6IFwiaW5jcmVtZW50LWNsYW1wXCJcbiAgfVxufTtcbkdwdVN0ZW5jaWxNb2Rlc1RvUGl4aVtTVEVOQ0lMX01PREVTLlJFTkRFUklOR19NQVNLX1JFTU9WRV0gPSB7XG4gIHN0ZW5jaWxGcm9udDoge1xuICAgIGNvbXBhcmU6IFwiZXF1YWxcIixcbiAgICBwYXNzT3A6IFwiZGVjcmVtZW50LWNsYW1wXCJcbiAgfSxcbiAgc3RlbmNpbEJhY2s6IHtcbiAgICBjb21wYXJlOiBcImVxdWFsXCIsXG4gICAgcGFzc09wOiBcImRlY3JlbWVudC1jbGFtcFwiXG4gIH1cbn07XG5HcHVTdGVuY2lsTW9kZXNUb1BpeGlbU1RFTkNJTF9NT0RFUy5NQVNLX0FDVElWRV0gPSB7XG4gIHN0ZW5jaWxXcml0ZU1hc2s6IDAsXG4gIHN0ZW5jaWxGcm9udDoge1xuICAgIGNvbXBhcmU6IFwiZXF1YWxcIixcbiAgICBwYXNzT3A6IFwia2VlcFwiXG4gIH0sXG4gIHN0ZW5jaWxCYWNrOiB7XG4gICAgY29tcGFyZTogXCJlcXVhbFwiLFxuICAgIHBhc3NPcDogXCJrZWVwXCJcbiAgfVxufTtcblxuZXhwb3J0IHsgR3B1U3RlbmNpbE1vZGVzVG9QaXhpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVTdGVuY2lsTW9kZXNUb1BpeGkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1172\n')},581:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   d: () => (/* binding */ BufferResource)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8875);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(133);\n\n\n\n"use strict";\nclass BufferResource extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .L)("buffer");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = "bufferResource";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .L)("resource");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on("change", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .L)("resource");\n    this.emit("change", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit("change", this);\n    this.buffer = null;\n  }\n}\n\n\n//# sourceMappingURL=BufferResource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTgxLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlDO0FBQ1k7O0FBRXJEO0FBQ0EsNkJBQTZCLDhEQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpRUFBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci9CdWZmZXJSZXNvdXJjZS5tanM/NTI1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCdWZmZXJSZXNvdXJjZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQnVmZmVyIFJlc291cmNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgYnVmZmVyIHJlc291cmNlXG4gICAqIEBwYXJhbSBvcHRpb25zLmJ1ZmZlciAtIFRoZSB1bmRlcmx5aW5nIGJ1ZmZlciB0aGF0IHRoaXMgcmVzb3VyY2UgaXMgdXNpbmdcbiAgICogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IC0gVGhlIG9mZnNldCBvZiB0aGUgYnVmZmVyIHRoaXMgcmVzb3VyY2UgaXMgdXNpbmcuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIHVzZSB0aGUgb2Zmc2V0IG9mIHRoZSBidWZmZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgYnVmZmVyIHRoaXMgcmVzb3VyY2UgaXMgdXNpbmcuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIHVzZSB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBidWZmZXIsIG9mZnNldCwgc2l6ZSB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBlbWl0cyB3aGVuIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBoYXMgY2hhbmdlZCBzaGFwZSAoaS5lLiByZXNpemVkKVxuICAgICAqIGxldHRpbmcgdGhlIHJlbmRlcmVyIGtub3cgdGhhdCBpdCBuZWVkcyB0byBkaXNjYXJkIHRoZSBvbGQgYnVmZmVyIG9uIHRoZSBHUFUgYW5kIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICovXG4gICAgLyoqIGEgdW5pcXVlIGlkIGZvciB0aGlzIHVuaWZvcm0gZ3JvdXAgdXNlZCB0aHJvdWdoIHRoZSByZW5kZXJlciAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwiYnVmZmVyXCIpO1xuICAgIC8qKlxuICAgICAqIGEgcmVzb3VyY2UgdHlwZSwgdXNlZCB0byBpZGVudGlmeSBob3cgdG8gaGFuZGxlIGl0IHdoZW4gaXRzIGluIGEgYmluZCBncm91cCAvIHNoYWRlciByZXNvdXJjZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvdXJjZVR5cGUgPSBcImJ1ZmZlclJlc291cmNlXCI7XG4gICAgLyoqXG4gICAgICogdXNlZCBpbnRlcm5hbGx5IHRvIGtub3cgaWYgYSB1bmlmb3JtIGdyb3VwIHdhcyB1c2VkIGluIHRoZSBsYXN0IHJlbmRlciBwYXNzXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3RvdWNoZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIHRoZSByZXNvdXJjZSBpZCB1c2VkIGludGVybmFsbHkgYnkgdGhlIHJlbmRlcmVyIHRvIGJ1aWxkIGJpbmQgZ3JvdXAga2V5c1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvdXJjZUlkID0gdWlkKFwicmVzb3VyY2VcIik7XG4gICAgLyoqXG4gICAgICogQSBjaGVla3kgaGludCB0byB0aGUgR0wgcmVuZGVyZXIgdG8gbGV0IGl0IGtub3cgdGhpcyBpcyBhIEJ1ZmZlclJlc291cmNlXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX2J1ZmZlclJlc291cmNlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBIYXMgdGhlIEJ1ZmZlciByZXNvdXJjZSBiZWVuIGRlc3Ryb3llZD9cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuYnVmZmVyLm9uKFwiY2hhbmdlXCIsIHRoaXMub25CdWZmZXJDaGFuZ2UsIHRoaXMpO1xuICB9XG4gIG9uQnVmZmVyQ2hhbmdlKCkge1xuICAgIHRoaXMuX3Jlc291cmNlSWQgPSB1aWQoXCJyZXNvdXJjZVwiKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgcmVzb3VyY2UuIE1ha2Ugc3VyZSB0aGUgdW5kZXJseWluZyBidWZmZXIgaXMgbm90IHVzZWQgYW55d2hlcmUgZWxzZVxuICAgKiBpZiB5b3Ugd2FudCB0byBkZXN0cm95IGl0IGFzIHdlbGwsIG9yIGNvZGUgd2lsbCBleHBsb2RlXG4gICAqIEBwYXJhbSBkZXN0cm95QnVmZmVyIC0gU2hvdWxkIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBiZSBkZXN0cm95ZWQgYXMgd2VsbD9cbiAgICovXG4gIGRlc3Ryb3koZGVzdHJveUJ1ZmZlciA9IGZhbHNlKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGlmIChkZXN0cm95QnVmZmVyKSB7XG4gICAgICB0aGlzLmJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB0aGlzKTtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgQnVmZmVyUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlclJlc291cmNlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///581\n')},279:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   O: () => (/* binding */ RenderTarget)\n/* harmony export */ });\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(133);\n/* harmony import */ var _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6932);\n/* harmony import */ var _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4492);\n\n\n\n\n"use strict";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    /** unique id for this render target */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .L)("renderTarget");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === "number") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(\n          new _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TextureSource */ .v({\n            width: descriptor.width,\n            height: descriptor.height,\n            resolution: descriptor.resolution,\n            antialias: descriptor.antialias\n          })\n        );\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on("resize", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .g || descriptor.depthStencilTexture instanceof _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TextureSource */ .v) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   * @ignore\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TextureSource */ .v({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: "depth24plus-stencil8",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0)\n        return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off("resize", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach((texture) => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\n\n\n//# sourceMappingURL=RenderTarget.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRDtBQUNnQjtBQUNwQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLGVBQWUsaUVBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQSxjQUFjLHNGQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtFQUFPLDhDQUE4QyxzRkFBYTtBQUN0SDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0ZBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC9SZW5kZXJUYXJnZXQubWpzPzhmNmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcbmltcG9ydCB7IFRleHR1cmVTb3VyY2UgfSBmcm9tICcuLi90ZXh0dXJlL3NvdXJjZXMvVGV4dHVyZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9SZW5kZXJUYXJnZXQgPSBjbGFzcyBfUmVuZGVyVGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBbZGVzY3JpcHRvcl0gLSBPcHRpb25zIGZvciBjcmVhdGluZyBhIHJlbmRlciB0YXJnZXQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZXNjcmlwdG9yID0ge30pIHtcbiAgICAvKiogdW5pcXVlIGlkIGZvciB0aGlzIHJlbmRlciB0YXJnZXQgKi9cbiAgICB0aGlzLnVpZCA9IHVpZChcInJlbmRlclRhcmdldFwiKTtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiB0ZXh0dXJlcyB0aGF0IGNhbiBiZSB3cml0dGVuIHRvIGJ5IHRoZSBHUFUgLSBtb3N0bHkgdGhpcyBoYXMgb25lIHRleHR1cmUgaW4gUGl4aSwgYnV0IHlvdSBjb3VsZFxuICAgICAqIHdyaXRlIHRvIG11bHRpcGxlIGlmIHJlcXVpcmVkISAoZWcgZGVmZXJyZWQgbGlnaHRpbmcpXG4gICAgICovXG4gICAgdGhpcy5jb2xvclRleHR1cmVzID0gW107XG4gICAgdGhpcy5kaXJ0eUlkID0gMDtcbiAgICB0aGlzLmlzUm9vdCA9IGZhbHNlO1xuICAgIHRoaXMuX3NpemUgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIC8qKiBpZiB0cnVlLCB0aGVuIHdoZW4gdGhlIHJlbmRlciB0YXJnZXQgaXMgZGVzdHJveWVkLCBpdCB3aWxsIGRlc3Ryb3kgYWxsIHRoZSB0ZXh0dXJlcyB0aGF0IHdlcmUgY3JlYXRlZCBmb3IgaXQuICovXG4gICAgdGhpcy5fbWFuYWdlZENvbG9yVGV4dHVyZXMgPSBmYWxzZTtcbiAgICBkZXNjcmlwdG9yID0geyAuLi5fUmVuZGVyVGFyZ2V0LmRlZmF1bHRPcHRpb25zLCAuLi5kZXNjcmlwdG9yIH07XG4gICAgdGhpcy5zdGVuY2lsID0gZGVzY3JpcHRvci5zdGVuY2lsO1xuICAgIHRoaXMuZGVwdGggPSBkZXNjcmlwdG9yLmRlcHRoO1xuICAgIHRoaXMuaXNSb290ID0gZGVzY3JpcHRvci5pc1Jvb3Q7XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmNvbG9yVGV4dHVyZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMuX21hbmFnZWRDb2xvclRleHR1cmVzID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3JpcHRvci5jb2xvclRleHR1cmVzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jb2xvclRleHR1cmVzLnB1c2goXG4gICAgICAgICAgbmV3IFRleHR1cmVTb3VyY2Uoe1xuICAgICAgICAgICAgd2lkdGg6IGRlc2NyaXB0b3Iud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGRlc2NyaXB0b3IuaGVpZ2h0LFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogZGVzY3JpcHRvci5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgYW50aWFsaWFzOiBkZXNjcmlwdG9yLmFudGlhbGlhc1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sb3JUZXh0dXJlcyA9IFsuLi5kZXNjcmlwdG9yLmNvbG9yVGV4dHVyZXMubWFwKCh0ZXh0dXJlKSA9PiB0ZXh0dXJlLnNvdXJjZSldO1xuICAgICAgY29uc3QgY29sb3JTb3VyY2UgPSB0aGlzLmNvbG9yVGV4dHVyZS5zb3VyY2U7XG4gICAgICB0aGlzLnJlc2l6ZShjb2xvclNvdXJjZS53aWR0aCwgY29sb3JTb3VyY2UuaGVpZ2h0LCBjb2xvclNvdXJjZS5fcmVzb2x1dGlvbik7XG4gICAgfVxuICAgIHRoaXMuY29sb3JUZXh0dXJlLnNvdXJjZS5vbihcInJlc2l6ZVwiLCB0aGlzLm9uU291cmNlUmVzaXplLCB0aGlzKTtcbiAgICBpZiAoZGVzY3JpcHRvci5kZXB0aFN0ZW5jaWxUZXh0dXJlIHx8IHRoaXMuc3RlbmNpbCkge1xuICAgICAgaWYgKGRlc2NyaXB0b3IuZGVwdGhTdGVuY2lsVGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUgfHwgZGVzY3JpcHRvci5kZXB0aFN0ZW5jaWxUZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZVNvdXJjZSkge1xuICAgICAgICB0aGlzLmRlcHRoU3RlbmNpbFRleHR1cmUgPSBkZXNjcmlwdG9yLmRlcHRoU3RlbmNpbFRleHR1cmUuc291cmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbnN1cmVEZXB0aFN0ZW5jaWxUZXh0dXJlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBzaXplKCkge1xuICAgIGNvbnN0IF9zaXplID0gdGhpcy5fc2l6ZTtcbiAgICBfc2l6ZVswXSA9IHRoaXMucGl4ZWxXaWR0aDtcbiAgICBfc2l6ZVsxXSA9IHRoaXMucGl4ZWxIZWlnaHQ7XG4gICAgcmV0dXJuIF9zaXplO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclRleHR1cmUuc291cmNlLndpZHRoO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JUZXh0dXJlLnNvdXJjZS5oZWlnaHQ7XG4gIH1cbiAgZ2V0IHBpeGVsV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JUZXh0dXJlLnNvdXJjZS5waXhlbFdpZHRoO1xuICB9XG4gIGdldCBwaXhlbEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclRleHR1cmUuc291cmNlLnBpeGVsSGVpZ2h0O1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yVGV4dHVyZS5zb3VyY2UuX3Jlc29sdXRpb247XG4gIH1cbiAgZ2V0IGNvbG9yVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclRleHR1cmVzWzBdO1xuICB9XG4gIG9uU291cmNlUmVzaXplKHNvdXJjZSkge1xuICAgIHRoaXMucmVzaXplKHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCwgc291cmNlLl9yZXNvbHV0aW9uLCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyB3aWxsIGVuc3VyZSBhIGRlcHRoU3RlbmNpbCB0ZXh0dXJlIGlzIGNyZWF0ZWQgZm9yIHRoaXMgcmVuZGVyIHRhcmdldC5cbiAgICogTW9zdCBsaWtlbHkgY2FsbGVkIGJ5IHRoZSBtYXNrIHN5c3RlbSB0byBtYWtlIHN1cmUgd2UgaGF2ZSBzdGVuY2lsIGJ1ZmZlciBhZGRlZC5cbiAgICogQGludGVybmFsXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGVuc3VyZURlcHRoU3RlbmNpbFRleHR1cmUoKSB7XG4gICAgaWYgKCF0aGlzLmRlcHRoU3RlbmNpbFRleHR1cmUpIHtcbiAgICAgIHRoaXMuZGVwdGhTdGVuY2lsVGV4dHVyZSA9IG5ldyBUZXh0dXJlU291cmNlKHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIHJlc29sdXRpb246IHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgZm9ybWF0OiBcImRlcHRoMjRwbHVzLXN0ZW5jaWw4XCIsXG4gICAgICAgIGF1dG9HZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuICAgICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgICBtaXBMZXZlbENvdW50OiAxXG4gICAgICAgIC8vIHNhbXBsZUNvdW50OiBoYW5kbGVkIGJ5IHRoZSByZW5kZXIgdGFyZ2V0IHN5c3RlbS4uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24sIHNraXBDb2xvclRleHR1cmUgPSBmYWxzZSkge1xuICAgIHRoaXMuZGlydHlJZCsrO1xuICAgIHRoaXMuY29sb3JUZXh0dXJlcy5mb3JFYWNoKChjb2xvclRleHR1cmUsIGkpID0+IHtcbiAgICAgIGlmIChza2lwQ29sb3JUZXh0dXJlICYmIGkgPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbG9yVGV4dHVyZS5zb3VyY2UucmVzaXplKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmRlcHRoU3RlbmNpbFRleHR1cmUpIHtcbiAgICAgIHRoaXMuZGVwdGhTdGVuY2lsVGV4dHVyZS5zb3VyY2UucmVzaXplKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY29sb3JUZXh0dXJlLnNvdXJjZS5vZmYoXCJyZXNpemVcIiwgdGhpcy5vblNvdXJjZVJlc2l6ZSwgdGhpcyk7XG4gICAgaWYgKHRoaXMuX21hbmFnZWRDb2xvclRleHR1cmVzKSB7XG4gICAgICB0aGlzLmNvbG9yVGV4dHVyZXMuZm9yRWFjaCgodGV4dHVyZSkgPT4ge1xuICAgICAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZXB0aFN0ZW5jaWxUZXh0dXJlKSB7XG4gICAgICB0aGlzLmRlcHRoU3RlbmNpbFRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZGVwdGhTdGVuY2lsVGV4dHVyZTtcbiAgICB9XG4gIH1cbn07XG4vKiogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgYSByZW5kZXIgdGFyZ2V0ICovXG5fUmVuZGVyVGFyZ2V0LmRlZmF1bHRPcHRpb25zID0ge1xuICAvKiogdGhlIHdpZHRoIG9mIHRoZSBSZW5kZXJUYXJnZXQgKi9cbiAgd2lkdGg6IDAsXG4gIC8qKiB0aGUgaGVpZ2h0IG9mIHRoZSBSZW5kZXJUYXJnZXQgKi9cbiAgaGVpZ2h0OiAwLFxuICAvKiogdGhlIHJlc29sdXRpb24gb2YgdGhlIFJlbmRlclRhcmdldCAqL1xuICByZXNvbHV0aW9uOiAxLFxuICAvKiogYW4gYXJyYXkgb2YgdGV4dHVyZXMsIG9yIGEgbnVtYmVyIGluZGljYXRpbmcgaG93IG1hbnkgY29sb3IgdGV4dHVyZXMgdGhlcmUgc2hvdWxkIGJlICovXG4gIGNvbG9yVGV4dHVyZXM6IDEsXG4gIC8qKiBzaG91bGQgdGhpcyByZW5kZXIgdGFyZ2V0IGhhdmUgYSBzdGVuY2lsIGJ1ZmZlcj8gKi9cbiAgc3RlbmNpbDogZmFsc2UsXG4gIC8qKiBzaG91bGQgdGhpcyByZW5kZXIgdGFyZ2V0IGhhdmUgYSBkZXB0aCBidWZmZXI/ICovXG4gIGRlcHRoOiBmYWxzZSxcbiAgLyoqIHNob3VsZCB0aGlzIHJlbmRlciB0YXJnZXQgYmUgYW50aWFsaWFzZWQ/ICovXG4gIGFudGlhbGlhczogZmFsc2UsXG4gIC8vIHNhdmUgb24gcGVyZiBieSBkZWZhdWx0IVxuICAvKiogaXMgdGhpcyBhIHJvb3QgZWxlbWVudCwgdHJ1ZSBpZiB0aGlzIGlzIGdsIGNvbnRleHQgb3duZXJzIHJlbmRlciB0YXJnZXQgKi9cbiAgaXNSb290OiBmYWxzZVxufTtcbmxldCBSZW5kZXJUYXJnZXQgPSBfUmVuZGVyVGFyZ2V0O1xuXG5leHBvcnQgeyBSZW5kZXJUYXJnZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlclRhcmdldC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///279\n')},7238:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  l: () => (/* binding */ RenderTargetSystem)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(9313);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(9252);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs\nvar gl_const = __webpack_require__(1257);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs\n\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\n\n//# sourceMappingURL=calculateProjection.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs\nvar SystemRunner = __webpack_require__(7729);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs\nvar CanvasSource = __webpack_require__(4884);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 2 modules\nvar TextureSource = __webpack_require__(6932);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(4492);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs\nvar getCanvasTexture = __webpack_require__(8725);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs\n\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\n\n//# sourceMappingURL=isRenderingToScreen.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs\nvar RenderTarget = __webpack_require__(279);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle/* Rectangle */.M();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle/* Rectangle */.M();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner/* SystemRunner */.C(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix/* Matrix */.u();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture/* Texture */.g) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = gl_const/* CLEAR */.u.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = gl_const/* CLEAR */.u.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource/* CanvasSource */.q.test(renderSurface)) {\n      renderSurface = (0,getCanvasTexture/* getCanvasTexture */.c)(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget/* RenderTarget */.O) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource/* TextureSource */.v) {\n      renderTarget = new RenderTarget/* RenderTarget */.O({\n        colorTextures: [renderSurface]\n      });\n      if (CanvasSource/* CanvasSource */.q.test(renderSurface.source.resource)) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n}\n\n\n//# sourceMappingURL=RenderTargetSystem.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9jYWxjdWxhdGVQcm9qZWN0aW9uLm1qcz9hMGI1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvcmVuZGVyVGFyZ2V0L2lzUmVuZGVyaW5nVG9TY3JlZW4ubWpzPzRkMjQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9yZW5kZXJUYXJnZXQvUmVuZGVyVGFyZ2V0U3lzdGVtLm1qcz82MjQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY2FsY3VsYXRlUHJvamVjdGlvbihwbSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZmxpcFkpIHtcbiAgY29uc3Qgc2lnbiA9IGZsaXBZID8gMSA6IC0xO1xuICBwbS5pZGVudGl0eSgpO1xuICBwbS5hID0gMSAvIHdpZHRoICogMjtcbiAgcG0uZCA9IHNpZ24gKiAoMSAvIGhlaWdodCAqIDIpO1xuICBwbS50eCA9IC0xIC0geCAqIHBtLmE7XG4gIHBtLnR5ID0gLXNpZ24gLSB5ICogcG0uZDtcbiAgcmV0dXJuIHBtO1xufVxuXG5leHBvcnQgeyBjYWxjdWxhdGVQcm9qZWN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxjdWxhdGVQcm9qZWN0aW9uLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNSZW5kZXJpbmdUb1NjcmVlbihyZW5kZXJUYXJnZXQpIHtcbiAgY29uc3QgcmVzb3VyY2UgPSByZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlLnNvdXJjZS5yZXNvdXJjZTtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuSFRNTENhbnZhc0VsZW1lbnQgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCAmJiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJlc291cmNlKTtcbn1cblxuZXhwb3J0IHsgaXNSZW5kZXJpbmdUb1NjcmVlbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNSZW5kZXJpbmdUb1NjcmVlbi5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyBDTEVBUiB9IGZyb20gJy4uLy4uL2dsL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVQcm9qZWN0aW9uIH0gZnJvbSAnLi4vLi4vZ3B1L3JlbmRlclRhcmdldC9jYWxjdWxhdGVQcm9qZWN0aW9uLm1qcyc7XG5pbXBvcnQgeyBTeXN0ZW1SdW5uZXIgfSBmcm9tICcuLi9zeXN0ZW0vU3lzdGVtUnVubmVyLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNTb3VyY2UgfSBmcm9tICcuLi90ZXh0dXJlL3NvdXJjZXMvQ2FudmFzU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlU291cmNlIH0gZnJvbSAnLi4vdGV4dHVyZS9zb3VyY2VzL1RleHR1cmVTb3VyY2UubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IGdldENhbnZhc1RleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlL3V0aWxzL2dldENhbnZhc1RleHR1cmUubWpzJztcbmltcG9ydCB7IGlzUmVuZGVyaW5nVG9TY3JlZW4gfSBmcm9tICcuL2lzUmVuZGVyaW5nVG9TY3JlZW4ubWpzJztcbmltcG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gJy4vUmVuZGVyVGFyZ2V0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgUmVuZGVyVGFyZ2V0U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAvKiogVGhpcyBpcyB0aGUgcm9vdCB2aWV3cG9ydCBmb3IgdGhlIHJlbmRlciBwYXNzKi9cbiAgICB0aGlzLnJvb3RWaWV3UG9ydCA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICAvKiogdGhlIGN1cnJlbnQgdmlld3BvcnQgdGhhdCB0aGUgZ3B1IGlzIHVzaW5nICovXG4gICAgdGhpcy52aWV3cG9ydCA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICAvKipcbiAgICAgKiBhIHJ1bm5lciB0aGF0IGxldHMgc3lzdGVtcyBrbm93IGlmIHRoZSBhY3RpdmUgcmVuZGVyIHRhcmdldCBoYXMgY2hhbmdlZC5cbiAgICAgKiBFZyB0aGUgU3RlbmNpbCBTeXN0ZW0gbmVlZHMgdG8ga25vdyBzbyBpdCBjYW4gbWFuYWdlIHRoZSBzdGVuY2lsIGJ1ZmZlclxuICAgICAqL1xuICAgIHRoaXMub25SZW5kZXJUYXJnZXRDaGFuZ2UgPSBuZXcgU3lzdGVtUnVubmVyKFwib25SZW5kZXJUYXJnZXRDaGFuZ2VcIik7XG4gICAgLyoqIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCB0aGF0IGlzIHVzZWQgYnkgdGhlIHNoYWRlcnMgYmFzZWQgb24gdGhlIGFjdGl2ZSByZW5kZXIgdGFyZ2V0IGFuZCB0aGUgdmlld3BvcnQgKi9cbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgLyoqIHRoZSBkZWZhdWx0IGNsZWFyIGNvbG9yIGZvciByZW5kZXIgdGFyZ2V0cyAqL1xuICAgIHRoaXMuZGVmYXVsdENsZWFyQ29sb3IgPSBbMCwgMCwgMCwgMF07XG4gICAgLyoqXG4gICAgICogYSBoYXNoIHRoYXQgc3RvcmVzIHRoZSByZW5kZXIgdGFyZ2V0IGZvciBhIGdpdmVuIHJlbmRlciBzdXJmYWNlLiBXaGVuIHlvdSBwYXNzIGluIGEgdGV4dHVyZSBzb3VyY2UsXG4gICAgICogYSByZW5kZXIgdGFyZ2V0IGlzIGNyZWF0ZWQgZm9yIGl0LiBUaGlzIG1hcCBzdG9yZXMgYW5kIG1ha2VzIGl0IGVhc3kgdG8gcmV0cmlldmUgdGhlIHJlbmRlciB0YXJnZXRcbiAgICAgKi9cbiAgICB0aGlzLl9yZW5kZXJTdXJmYWNlVG9SZW5kZXJUYXJnZXRIYXNoID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAvKiogQSBoYXNoIHRoYXQgc3RvcmVzIGEgZ3B1IHJlbmRlciB0YXJnZXQgZm9yIGEgZ2l2ZW4gcmVuZGVyIHRhcmdldC4gKi9cbiAgICB0aGlzLl9ncHVSZW5kZXJUYXJnZXRIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLyoqXG4gICAgICogQSBzdGFjayB0aGF0IHN0b3JlcyB0aGUgcmVuZGVyIHRhcmdldCBhbmQgZnJhbWUgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWQgdG8uXG4gICAgICogV2hlbiBwdXNoIGlzIGNhbGxlZCwgdGhlIGN1cnJlbnQgcmVuZGVyIHRhcmdldCBpcyBzdG9yZWQgaW4gdGhpcyBzdGFjay5cbiAgICAgKiBXaGVuIHBvcCBpcyBjYWxsZWQsIHRoZSBwcmV2aW91cyByZW5kZXIgdGFyZ2V0IGlzIHJlc3RvcmVkLlxuICAgICAqL1xuICAgIHRoaXMuX3JlbmRlclRhcmdldFN0YWNrID0gW107XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICAvKiogY2FsbGVkIHdoZW4gZGV2IHdhbnRzIHRvIGZpbmlzaCBhIHJlbmRlciBwYXNzICovXG4gIGZpbmlzaFJlbmRlclBhc3MoKSB7XG4gICAgdGhpcy5hZGFwdG9yLmZpbmlzaFJlbmRlclBhc3ModGhpcy5yZW5kZXJUYXJnZXQpO1xuICB9XG4gIC8qKlxuICAgKiBjYWxsZWQgd2hlbiB0aGUgcmVuZGVyZXIgc3RhcnRzIHRvIHJlbmRlciBhIHNjZW5lLlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy50YXJnZXQgLSB0aGUgcmVuZGVyIHRhcmdldCB0byByZW5kZXIgdG9cbiAgICogQHBhcmFtIG9wdGlvbnMuY2xlYXIgLSB0aGUgY2xlYXIgbW9kZSB0byB1c2UuIENhbiBiZSB0cnVlIG9yIGEgQ0xFQVIgbnVtYmVyICdDT0xPUiB8IERFUFRIIHwgU1RFTkNJTCcgMGIxMTFcbiAgICogQHBhcmFtIG9wdGlvbnMuY2xlYXJDb2xvciAtIHRoZSBjb2xvciB0byBjbGVhciB0b1xuICAgKiBAcGFyYW0gb3B0aW9ucy5mcmFtZSAtIHRoZSBmcmFtZSB0byByZW5kZXIgdG9cbiAgICovXG4gIHJlbmRlclN0YXJ0KHtcbiAgICB0YXJnZXQsXG4gICAgY2xlYXIsXG4gICAgY2xlYXJDb2xvcixcbiAgICBmcmFtZVxuICB9KSB7XG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0U3RhY2subGVuZ3RoID0gMDtcbiAgICB0aGlzLnB1c2goXG4gICAgICB0YXJnZXQsXG4gICAgICBjbGVhcixcbiAgICAgIGNsZWFyQ29sb3IsXG4gICAgICBmcmFtZVxuICAgICk7XG4gICAgdGhpcy5yb290Vmlld1BvcnQuY29weUZyb20odGhpcy52aWV3cG9ydCk7XG4gICAgdGhpcy5yb290UmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgdGhpcy5yZW5kZXJpbmdUb1NjcmVlbiA9IGlzUmVuZGVyaW5nVG9TY3JlZW4odGhpcy5yb290UmVuZGVyVGFyZ2V0KTtcbiAgfVxuICAvKipcbiAgICogQmluZGluZyBhIHJlbmRlciBzdXJmYWNlISBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIG9mIHRoZSByZW5kZXIgdGFyZ2V0IHN5c3RlbS5cbiAgICogSXQgd2lsbCB0YWtlIHRoZSBSZW5kZXJTdXJmYWNlICh3aGljaCBjYW4gYmUgYSB0ZXh0dXJlLCBjYW52YXMsIG9yIHJlbmRlciB0YXJnZXQpIGFuZCBiaW5kIGl0IHRvIHRoZSByZW5kZXJlci5cbiAgICogT25jZSBib3VuZCBhbGwgZHJhdyBjYWxscyB3aWxsIGJlIHJlbmRlcmVkIHRvIHRoZSByZW5kZXIgc3VyZmFjZS5cbiAgICpcbiAgICogSWYgYSBmcmFtZSBpcyBub3QgcHJvdmlkZSBhbmQgdGhlIHJlbmRlciBzdXJmYWNlIGlzIGEgdGV4dHVyZSwgdGhlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlIHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIHJlbmRlclN1cmZhY2UgLSB0aGUgcmVuZGVyIHN1cmZhY2UgdG8gYmluZFxuICAgKiBAcGFyYW0gY2xlYXIgLSB0aGUgY2xlYXIgbW9kZSB0byB1c2UuIENhbiBiZSB0cnVlIG9yIGEgQ0xFQVIgbnVtYmVyICdDT0xPUiB8IERFUFRIIHwgU1RFTkNJTCcgMGIxMTFcbiAgICogQHBhcmFtIGNsZWFyQ29sb3IgLSB0aGUgY29sb3IgdG8gY2xlYXIgdG9cbiAgICogQHBhcmFtIGZyYW1lIC0gdGhlIGZyYW1lIHRvIHJlbmRlciB0b1xuICAgKiBAcmV0dXJucyB0aGUgcmVuZGVyIHRhcmdldCB0aGF0IHdhcyBib3VuZFxuICAgKi9cbiAgYmluZChyZW5kZXJTdXJmYWNlLCBjbGVhciA9IHRydWUsIGNsZWFyQ29sb3IsIGZyYW1lKSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5nZXRSZW5kZXJUYXJnZXQocmVuZGVyU3VyZmFjZSk7XG4gICAgY29uc3QgZGlkQ2hhbmdlID0gdGhpcy5yZW5kZXJUYXJnZXQgIT09IHJlbmRlclRhcmdldDtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICB0aGlzLnJlbmRlclN1cmZhY2UgPSByZW5kZXJTdXJmYWNlO1xuICAgIGNvbnN0IGdwdVJlbmRlclRhcmdldCA9IHRoaXMuZ2V0R3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgaWYgKHJlbmRlclRhcmdldC5waXhlbFdpZHRoICE9PSBncHVSZW5kZXJUYXJnZXQud2lkdGggfHwgcmVuZGVyVGFyZ2V0LnBpeGVsSGVpZ2h0ICE9PSBncHVSZW5kZXJUYXJnZXQuaGVpZ2h0KSB7XG4gICAgICB0aGlzLmFkYXB0b3IucmVzaXplR3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgICBncHVSZW5kZXJUYXJnZXQud2lkdGggPSByZW5kZXJUYXJnZXQucGl4ZWxXaWR0aDtcbiAgICAgIGdwdVJlbmRlclRhcmdldC5oZWlnaHQgPSByZW5kZXJUYXJnZXQucGl4ZWxIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHJlbmRlclRhcmdldC5jb2xvclRleHR1cmU7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0O1xuICAgIGNvbnN0IHBpeGVsV2lkdGggPSBzb3VyY2UucGl4ZWxXaWR0aDtcbiAgICBjb25zdCBwaXhlbEhlaWdodCA9IHNvdXJjZS5waXhlbEhlaWdodDtcbiAgICBpZiAoIWZyYW1lICYmIHJlbmRlclN1cmZhY2UgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICBmcmFtZSA9IHJlbmRlclN1cmZhY2UuZnJhbWU7XG4gICAgfVxuICAgIGlmIChmcmFtZSkge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHNvdXJjZS5fcmVzb2x1dGlvbjtcbiAgICAgIHZpZXdwb3J0LnggPSBmcmFtZS54ICogcmVzb2x1dGlvbiArIDAuNSB8IDA7XG4gICAgICB2aWV3cG9ydC55ID0gZnJhbWUueSAqIHJlc29sdXRpb24gKyAwLjUgfCAwO1xuICAgICAgdmlld3BvcnQud2lkdGggPSBmcmFtZS53aWR0aCAqIHJlc29sdXRpb24gKyAwLjUgfCAwO1xuICAgICAgdmlld3BvcnQuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbiArIDAuNSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXdwb3J0LnggPSAwO1xuICAgICAgdmlld3BvcnQueSA9IDA7XG4gICAgICB2aWV3cG9ydC53aWR0aCA9IHBpeGVsV2lkdGg7XG4gICAgICB2aWV3cG9ydC5oZWlnaHQgPSBwaXhlbEhlaWdodDtcbiAgICB9XG4gICAgY2FsY3VsYXRlUHJvamVjdGlvbihcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgdmlld3BvcnQud2lkdGggLyBzb3VyY2UucmVzb2x1dGlvbixcbiAgICAgIHZpZXdwb3J0LmhlaWdodCAvIHNvdXJjZS5yZXNvbHV0aW9uLFxuICAgICAgIXJlbmRlclRhcmdldC5pc1Jvb3RcbiAgICApO1xuICAgIHRoaXMuYWRhcHRvci5zdGFydFJlbmRlclBhc3MocmVuZGVyVGFyZ2V0LCBjbGVhciwgY2xlYXJDb2xvciwgdmlld3BvcnQpO1xuICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgIHRoaXMub25SZW5kZXJUYXJnZXRDaGFuZ2UuZW1pdChyZW5kZXJUYXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyVGFyZ2V0O1xuICB9XG4gIGNsZWFyKHRhcmdldCwgY2xlYXIgPSBDTEVBUi5BTEwsIGNsZWFyQ29sb3IpIHtcbiAgICBpZiAoIWNsZWFyKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRhcmdldCA9IHRoaXMuZ2V0UmVuZGVyVGFyZ2V0KHRhcmdldCk7XG4gICAgfVxuICAgIHRoaXMuYWRhcHRvci5jbGVhcihcbiAgICAgIHRhcmdldCB8fCB0aGlzLnJlbmRlclRhcmdldCxcbiAgICAgIGNsZWFyLFxuICAgICAgY2xlYXJDb2xvcixcbiAgICAgIHRoaXMudmlld3BvcnRcbiAgICApO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5fZ3B1UmVuZGVyVGFyZ2V0SGFzaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoIGEgcmVuZGVyIHN1cmZhY2UgdG8gdGhlIHJlbmRlcmVyLiBUaGlzIHdpbGwgYmluZCB0aGUgcmVuZGVyIHN1cmZhY2UgdG8gdGhlIHJlbmRlcmVyLFxuICAgKiBAcGFyYW0gcmVuZGVyU3VyZmFjZSAtIHRoZSByZW5kZXIgc3VyZmFjZSB0byBwdXNoXG4gICAqIEBwYXJhbSBjbGVhciAtIHRoZSBjbGVhciBtb2RlIHRvIHVzZS4gQ2FuIGJlIHRydWUgb3IgYSBDTEVBUiBudW1iZXIgJ0NPTE9SIHwgREVQVEggfCBTVEVOQ0lMJyAwYjExMVxuICAgKiBAcGFyYW0gY2xlYXJDb2xvciAtIHRoZSBjb2xvciB0byBjbGVhciB0b1xuICAgKiBAcGFyYW0gZnJhbWUgLSB0aGUgZnJhbWUgdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRvIHRoZSByZW5kZXIgc3VyZmFjZVxuICAgKi9cbiAgcHVzaChyZW5kZXJTdXJmYWNlLCBjbGVhciA9IENMRUFSLkFMTCwgY2xlYXJDb2xvciwgZnJhbWUpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLmJpbmQocmVuZGVyU3VyZmFjZSwgY2xlYXIsIGNsZWFyQ29sb3IsIGZyYW1lKTtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXRTdGFjay5wdXNoKHtcbiAgICAgIHJlbmRlclRhcmdldCxcbiAgICAgIGZyYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlbmRlclRhcmdldDtcbiAgfVxuICAvKiogUG9wcyB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0IGZyb20gdGhlIHJlbmRlcmVyIGFuZCByZXN0b3JlcyB0aGUgcHJldmlvdXMgcmVuZGVyIHRhcmdldC4gKi9cbiAgcG9wKCkge1xuICAgIHRoaXMuX3JlbmRlclRhcmdldFN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXREYXRhID0gdGhpcy5fcmVuZGVyVGFyZ2V0U3RhY2tbdGhpcy5fcmVuZGVyVGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgdGhpcy5iaW5kKGN1cnJlbnRSZW5kZXJUYXJnZXREYXRhLnJlbmRlclRhcmdldCwgZmFsc2UsIG51bGwsIGN1cnJlbnRSZW5kZXJUYXJnZXREYXRhLmZyYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcmVuZGVyIHRhcmdldCBmcm9tIHRoZSBwcm92aWRlIHJlbmRlciBzdXJmYWNlLiBFZyBpZiBpdHMgYSB0ZXh0dXJlLFxuICAgKiBpdCB3aWxsIHJldHVybiB0aGUgcmVuZGVyIHRhcmdldCBmb3IgdGhlIHRleHR1cmUuXG4gICAqIElmIGl0cyBhIHJlbmRlciB0YXJnZXQsIGl0IHdpbGwgcmV0dXJuIHRoZSBzYW1lIHJlbmRlciB0YXJnZXQuXG4gICAqIEBwYXJhbSByZW5kZXJTdXJmYWNlIC0gdGhlIHJlbmRlciBzdXJmYWNlIHRvIGdldCB0aGUgcmVuZGVyIHRhcmdldCBmb3JcbiAgICogQHJldHVybnMgdGhlIHJlbmRlciB0YXJnZXQgZm9yIHRoZSByZW5kZXIgc3VyZmFjZVxuICAgKi9cbiAgZ2V0UmVuZGVyVGFyZ2V0KHJlbmRlclN1cmZhY2UpIHtcbiAgICBpZiAocmVuZGVyU3VyZmFjZS5pc1RleHR1cmUpIHtcbiAgICAgIHJlbmRlclN1cmZhY2UgPSByZW5kZXJTdXJmYWNlLnNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclN1cmZhY2VUb1JlbmRlclRhcmdldEhhc2guZ2V0KHJlbmRlclN1cmZhY2UpID8/IHRoaXMuX2luaXRSZW5kZXJUYXJnZXQocmVuZGVyU3VyZmFjZSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhIHJlbmRlciBzdXJmYWNlIHRvIGFub3RoZXIgdGV4dHVyZVxuICAgKiBAcGFyYW0gc291cmNlUmVuZGVyU3VyZmFjZVRleHR1cmUgLSB0aGUgcmVuZGVyIHN1cmZhY2UgdG8gY29weSBmcm9tXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvblRleHR1cmUgLSB0aGUgdGV4dHVyZSB0byBjb3B5IHRvXG4gICAqIEBwYXJhbSBvcmlnaW5TcmMgLSB0aGUgb3JpZ2luIG9mIHRoZSBjb3B5XG4gICAqIEBwYXJhbSBvcmlnaW5TcmMueCAtIHRoZSB4IG9yaWdpbiBvZiB0aGUgY29weVxuICAgKiBAcGFyYW0gb3JpZ2luU3JjLnkgLSB0aGUgeSBvcmlnaW4gb2YgdGhlIGNvcHlcbiAgICogQHBhcmFtIHNpemUgLSB0aGUgc2l6ZSBvZiB0aGUgY29weVxuICAgKiBAcGFyYW0gc2l6ZS53aWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgY29weVxuICAgKiBAcGFyYW0gc2l6ZS5oZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIHRoZSBjb3B5XG4gICAqIEBwYXJhbSBvcmlnaW5EZXN0IC0gdGhlIGRlc3RpbmF0aW9uIG9yaWdpbiAodG9wIGxlZnQgdG8gcGFzdGUgZnJvbSEpXG4gICAqIEBwYXJhbSBvcmlnaW5EZXN0LnggLSB0aGUgeCBvcmlnaW4gb2YgdGhlIHBhc3RlXG4gICAqIEBwYXJhbSBvcmlnaW5EZXN0LnkgLSB0aGUgeSBvcmlnaW4gb2YgdGhlIHBhc3RlXG4gICAqL1xuICBjb3B5VG9UZXh0dXJlKHNvdXJjZVJlbmRlclN1cmZhY2VUZXh0dXJlLCBkZXN0aW5hdGlvblRleHR1cmUsIG9yaWdpblNyYywgc2l6ZSwgb3JpZ2luRGVzdCkge1xuICAgIGlmIChvcmlnaW5TcmMueCA8IDApIHtcbiAgICAgIHNpemUud2lkdGggKz0gb3JpZ2luU3JjLng7XG4gICAgICBvcmlnaW5EZXN0LnggLT0gb3JpZ2luU3JjLng7XG4gICAgICBvcmlnaW5TcmMueCA9IDA7XG4gICAgfVxuICAgIGlmIChvcmlnaW5TcmMueSA8IDApIHtcbiAgICAgIHNpemUuaGVpZ2h0ICs9IG9yaWdpblNyYy55O1xuICAgICAgb3JpZ2luRGVzdC55IC09IG9yaWdpblNyYy55O1xuICAgICAgb3JpZ2luU3JjLnkgPSAwO1xuICAgIH1cbiAgICBjb25zdCB7IHBpeGVsV2lkdGgsIHBpeGVsSGVpZ2h0IH0gPSBzb3VyY2VSZW5kZXJTdXJmYWNlVGV4dHVyZTtcbiAgICBzaXplLndpZHRoID0gTWF0aC5taW4oc2l6ZS53aWR0aCwgcGl4ZWxXaWR0aCAtIG9yaWdpblNyYy54KTtcbiAgICBzaXplLmhlaWdodCA9IE1hdGgubWluKHNpemUuaGVpZ2h0LCBwaXhlbEhlaWdodCAtIG9yaWdpblNyYy55KTtcbiAgICByZXR1cm4gdGhpcy5hZGFwdG9yLmNvcHlUb1RleHR1cmUoXG4gICAgICBzb3VyY2VSZW5kZXJTdXJmYWNlVGV4dHVyZSxcbiAgICAgIGRlc3RpbmF0aW9uVGV4dHVyZSxcbiAgICAgIG9yaWdpblNyYyxcbiAgICAgIHNpemUsXG4gICAgICBvcmlnaW5EZXN0XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogZW5zdXJlcyB0aGF0IHdlIGhhdmUgYSBkZXB0aCBzdGVuY2lsIGJ1ZmZlciBhdmFpbGFibGUgdG8gcmVuZGVyIHRvXG4gICAqIFRoaXMgaXMgdXNlZCBieSB0aGUgbWFzayBzeXN0ZW0gdG8gbWFrZSBzdXJlIHdlIGhhdmUgYSBzdGVuY2lsIGJ1ZmZlci5cbiAgICovXG4gIGVuc3VyZURlcHRoU3RlbmNpbCgpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyVGFyZ2V0LnN0ZW5jaWwpIHtcbiAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LnN0ZW5jaWwgPSB0cnVlO1xuICAgICAgdGhpcy5hZGFwdG9yLnN0YXJ0UmVuZGVyUGFzcyh0aGlzLnJlbmRlclRhcmdldCwgZmFsc2UsIG51bGwsIHRoaXMudmlld3BvcnQpO1xuICAgIH1cbiAgfVxuICAvKiogbnVrZXMgdGhlIHJlbmRlciB0YXJnZXQgc3lzdGVtICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlclN1cmZhY2VUb1JlbmRlclRhcmdldEhhc2guZm9yRWFjaCgocmVuZGVyVGFyZ2V0LCBrZXkpID0+IHtcbiAgICAgIGlmIChyZW5kZXJUYXJnZXQgIT09IGtleSkge1xuICAgICAgICByZW5kZXJUYXJnZXQuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3JlbmRlclN1cmZhY2VUb1JlbmRlclRhcmdldEhhc2guY2xlYXIoKTtcbiAgICB0aGlzLl9ncHVSZW5kZXJUYXJnZXRIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgX2luaXRSZW5kZXJUYXJnZXQocmVuZGVyU3VyZmFjZSkge1xuICAgIGxldCByZW5kZXJUYXJnZXQgPSBudWxsO1xuICAgIGlmIChDYW52YXNTb3VyY2UudGVzdChyZW5kZXJTdXJmYWNlKSkge1xuICAgICAgcmVuZGVyU3VyZmFjZSA9IGdldENhbnZhc1RleHR1cmUocmVuZGVyU3VyZmFjZSkuc291cmNlO1xuICAgIH1cbiAgICBpZiAocmVuZGVyU3VyZmFjZSBpbnN0YW5jZW9mIFJlbmRlclRhcmdldCkge1xuICAgICAgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyU3VyZmFjZTtcbiAgICB9IGVsc2UgaWYgKHJlbmRlclN1cmZhY2UgaW5zdGFuY2VvZiBUZXh0dXJlU291cmNlKSB7XG4gICAgICByZW5kZXJUYXJnZXQgPSBuZXcgUmVuZGVyVGFyZ2V0KHtcbiAgICAgICAgY29sb3JUZXh0dXJlczogW3JlbmRlclN1cmZhY2VdXG4gICAgICB9KTtcbiAgICAgIGlmIChDYW52YXNTb3VyY2UudGVzdChyZW5kZXJTdXJmYWNlLnNvdXJjZS5yZXNvdXJjZSkpIHtcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmlzUm9vdCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZW5kZXJTdXJmYWNlLm9uY2UoXCJkZXN0cm95XCIsICgpID0+IHtcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3VyZmFjZVRvUmVuZGVyVGFyZ2V0SGFzaC5kZWxldGUocmVuZGVyU3VyZmFjZSk7XG4gICAgICAgIGNvbnN0IGdwdVJlbmRlclRhcmdldCA9IHRoaXMuX2dwdVJlbmRlclRhcmdldEhhc2hbcmVuZGVyVGFyZ2V0LnVpZF07XG4gICAgICAgIGlmIChncHVSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICB0aGlzLl9ncHVSZW5kZXJUYXJnZXRIYXNoW3JlbmRlclRhcmdldC51aWRdID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmFkYXB0b3IuZGVzdHJveUdwdVJlbmRlclRhcmdldChncHVSZW5kZXJUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyU3VyZmFjZVRvUmVuZGVyVGFyZ2V0SGFzaC5zZXQocmVuZGVyU3VyZmFjZSwgcmVuZGVyVGFyZ2V0KTtcbiAgICByZXR1cm4gcmVuZGVyVGFyZ2V0O1xuICB9XG4gIGdldEdwdVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1UmVuZGVyVGFyZ2V0SGFzaFtyZW5kZXJUYXJnZXQudWlkXSB8fCAodGhpcy5fZ3B1UmVuZGVyVGFyZ2V0SGFzaFtyZW5kZXJUYXJnZXQudWlkXSA9IHRoaXMuYWRhcHRvci5pbml0R3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkpO1xuICB9XG59XG5cbmV4cG9ydCB7IFJlbmRlclRhcmdldFN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyVGFyZ2V0U3lzdGVtLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7238\n")},7047:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   W: () => (/* binding */ UboSystem)\n/* harmony export */ });\n/* harmony import */ var _utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4577);\n/* harmony import */ var _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(949);\n/* harmony import */ var _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1132);\n\n\n\n\n"use strict";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don\'t have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn\'t support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!(0,_utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_0__/* .unsafeEvalSupported */ .f)()) {\n      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .h({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .S.UNIFORM | _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .S.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .h({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .S.UNIFORM | _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .S.COPY_DST\n    }));\n    data || (data = uniformGroup.buffer.data);\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId)\n      return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\n\n//# sourceMappingURL=UboSystem.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0Y7QUFDMUM7QUFDSTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0dBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0RBQU07QUFDNUQ7QUFDQSxhQUFhLG1FQUFXLFdBQVcsbUVBQVc7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0RBQU07QUFDNUQ7QUFDQSxhQUFhLG1FQUFXLFdBQVcsbUVBQVc7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVWJvU3lzdGVtLm1qcz85ZTNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVuc2FmZUV2YWxTdXBwb3J0ZWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9icm93c2VyL3Vuc2FmZUV2YWxTdXBwb3J0ZWQubWpzJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IEJ1ZmZlclVzYWdlIH0gZnJvbSAnLi4vYnVmZmVyL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgVWJvU3lzdGVtIHtcbiAgY29uc3RydWN0b3IoYWRhcHRvcikge1xuICAgIC8qKiBDYWNoZSBvZiB1bmlmb3JtIGJ1ZmZlciBsYXlvdXRzIGFuZCBzeW5jIGZ1bmN0aW9ucywgc28gd2UgZG9uJ3QgaGF2ZSB0byByZS1jcmVhdGUgdGhlbSAqL1xuICAgIHRoaXMuX3N5bmNGdW5jdGlvbkhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9hZGFwdG9yID0gYWRhcHRvcjtcbiAgICB0aGlzLl9zeXN0ZW1DaGVjaygpO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBmdW5jdGlvbiBieSBgcGl4aS5qcy91bnNhZmUtZXZhbGAgdG8gc2lsZW5jZVxuICAgKiB0aHJvd2luZyBhbiBlcnJvciBpZiBwbGF0Zm9ybSBkb2Vzbid0IHN1cHBvcnQgdW5zYWZlLWV2YWxzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N5c3RlbUNoZWNrKCkge1xuICAgIGlmICghdW5zYWZlRXZhbFN1cHBvcnRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IGFsbG93IHVuc2FmZS1ldmFsLCBwbGVhc2UgdXNlIHBpeGkuanMvdW5zYWZlLWV2YWwgbW9kdWxlIHRvIGVuYWJsZSBzdXBwb3J0LlwiKTtcbiAgICB9XG4gIH1cbiAgZW5zdXJlVW5pZm9ybUdyb3VwKHVuaWZvcm1Hcm91cCkge1xuICAgIGNvbnN0IHVuaWZvcm1EYXRhID0gdGhpcy5nZXRVbmlmb3JtR3JvdXBEYXRhKHVuaWZvcm1Hcm91cCk7XG4gICAgdW5pZm9ybUdyb3VwLmJ1ZmZlciB8fCAodW5pZm9ybUdyb3VwLmJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogbmV3IEZsb2F0MzJBcnJheSh1bmlmb3JtRGF0YS5sYXlvdXQuc2l6ZSAvIDQpLFxuICAgICAgdXNhZ2U6IEJ1ZmZlclVzYWdlLlVOSUZPUk0gfCBCdWZmZXJVc2FnZS5DT1BZX0RTVFxuICAgIH0pKTtcbiAgfVxuICBnZXRVbmlmb3JtR3JvdXBEYXRhKHVuaWZvcm1Hcm91cCkge1xuICAgIHJldHVybiB0aGlzLl9zeW5jRnVuY3Rpb25IYXNoW3VuaWZvcm1Hcm91cC5fc2lnbmF0dXJlXSB8fCB0aGlzLl9pbml0VW5pZm9ybUdyb3VwKHVuaWZvcm1Hcm91cCk7XG4gIH1cbiAgX2luaXRVbmlmb3JtR3JvdXAodW5pZm9ybUdyb3VwKSB7XG4gICAgY29uc3QgdW5pZm9ybUdyb3VwU2lnbmF0dXJlID0gdW5pZm9ybUdyb3VwLl9zaWduYXR1cmU7XG4gICAgbGV0IHVuaWZvcm1EYXRhID0gdGhpcy5fc3luY0Z1bmN0aW9uSGFzaFt1bmlmb3JtR3JvdXBTaWduYXR1cmVdO1xuICAgIGlmICghdW5pZm9ybURhdGEpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gT2JqZWN0LmtleXModW5pZm9ybUdyb3VwLnVuaWZvcm1TdHJ1Y3R1cmVzKS5tYXAoKGkpID0+IHVuaWZvcm1Hcm91cC51bmlmb3JtU3RydWN0dXJlc1tpXSk7XG4gICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLl9hZGFwdG9yLmNyZWF0ZVVib0VsZW1lbnRzKGVsZW1lbnRzKTtcbiAgICAgIGNvbnN0IHN5bmNGdW5jdGlvbiA9IHRoaXMuX2dlbmVyYXRlVWJvU3luYyhsYXlvdXQudWJvRWxlbWVudHMpO1xuICAgICAgdW5pZm9ybURhdGEgPSB0aGlzLl9zeW5jRnVuY3Rpb25IYXNoW3VuaWZvcm1Hcm91cFNpZ25hdHVyZV0gPSB7XG4gICAgICAgIGxheW91dCxcbiAgICAgICAgc3luY0Z1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3luY0Z1bmN0aW9uSGFzaFt1bmlmb3JtR3JvdXBTaWduYXR1cmVdO1xuICB9XG4gIF9nZW5lcmF0ZVVib1N5bmModWJvRWxlbWVudHMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRhcHRvci5nZW5lcmF0ZVVib1N5bmModWJvRWxlbWVudHMpO1xuICB9XG4gIHN5bmNVbmlmb3JtR3JvdXAodW5pZm9ybUdyb3VwLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBjb25zdCB1bmlmb3JtR3JvdXBEYXRhID0gdGhpcy5nZXRVbmlmb3JtR3JvdXBEYXRhKHVuaWZvcm1Hcm91cCk7XG4gICAgdW5pZm9ybUdyb3VwLmJ1ZmZlciB8fCAodW5pZm9ybUdyb3VwLmJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogbmV3IEZsb2F0MzJBcnJheSh1bmlmb3JtR3JvdXBEYXRhLmxheW91dC5zaXplIC8gNCksXG4gICAgICB1c2FnZTogQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgfSkpO1xuICAgIGRhdGEgfHwgKGRhdGEgPSB1bmlmb3JtR3JvdXAuYnVmZmVyLmRhdGEpO1xuICAgIG9mZnNldCB8fCAob2Zmc2V0ID0gMCk7XG4gICAgdW5pZm9ybUdyb3VwRGF0YS5zeW5jRnVuY3Rpb24odW5pZm9ybUdyb3VwLnVuaWZvcm1zLCBkYXRhLCBvZmZzZXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHVwZGF0ZVVuaWZvcm1Hcm91cCh1bmlmb3JtR3JvdXApIHtcbiAgICBpZiAodW5pZm9ybUdyb3VwLmlzU3RhdGljICYmICF1bmlmb3JtR3JvdXAuX2RpcnR5SWQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgdW5pZm9ybUdyb3VwLl9kaXJ0eUlkID0gMDtcbiAgICBjb25zdCBzeW5jZWQgPSB0aGlzLnN5bmNVbmlmb3JtR3JvdXAodW5pZm9ybUdyb3VwKTtcbiAgICB1bmlmb3JtR3JvdXAuYnVmZmVyLnVwZGF0ZSgpO1xuICAgIHJldHVybiBzeW5jZWQ7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9zeW5jRnVuY3Rpb25IYXNoID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBVYm9TeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVib1N5c3RlbS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7047\n')},6423:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ createUboSyncFunction)\n/* harmony export */ });\n/* harmony import */ var _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8166);\n\n\n"use strict";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uniformParsers */ .$.length; j++) {\n      const uniformParser = _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uniformParsers */ .$[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = "${name}";`,\n          `offset += ${offset - prev};`,\n          _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uniformParsers */ .$[j][parserCode] || _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uniformParsers */ .$[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join("\\n");\n  return new Function(\n    "uv",\n    "data",\n    "offset",\n    fragmentSrc\n  );\n}\n\n\n//# sourceMappingURL=createUboSyncFunction.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQyMy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJLHdFQUFjLFNBQVM7QUFDL0MsNEJBQTRCLHdFQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLLEVBQUU7QUFDNUIsdUJBQXVCLGVBQWU7QUFDdEMsVUFBVSx3RUFBYyxtQkFBbUIsd0VBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib1N5bmNGdW5jdGlvbi5tanM/ZTZlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bmlmb3JtUGFyc2VycyB9IGZyb20gJy4vdW5pZm9ybVBhcnNlcnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjcmVhdGVVYm9TeW5jRnVuY3Rpb24odWJvRWxlbWVudHMsIHBhcnNlckNvZGUsIGFycmF5R2VuZXJhdGlvbkZ1bmN0aW9uLCBzaW5nbGVTZXR0ZXJzTWFwKSB7XG4gIGNvbnN0IGZ1bmNGcmFnbWVudHMgPSBbYFxuICAgICAgICB2YXIgdiA9IG51bGw7XG4gICAgICAgIHZhciB2MiA9IG51bGw7XG4gICAgICAgIHZhciB0ID0gMDtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICB2YXIgYXJyYXlPZmZzZXQgPSBudWxsO1xuICAgIGBdO1xuICBsZXQgcHJldiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdWJvRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB1Ym9FbGVtZW50ID0gdWJvRWxlbWVudHNbaV07XG4gICAgY29uc3QgbmFtZSA9IHVib0VsZW1lbnQuZGF0YS5uYW1lO1xuICAgIGxldCBwYXJzZWQgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHVuaWZvcm1QYXJzZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCB1bmlmb3JtUGFyc2VyID0gdW5pZm9ybVBhcnNlcnNbal07XG4gICAgICBpZiAodW5pZm9ybVBhcnNlci50ZXN0KHVib0VsZW1lbnQuZGF0YSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gdWJvRWxlbWVudC5vZmZzZXQgLyA0O1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goXG4gICAgICAgICAgYG5hbWUgPSBcIiR7bmFtZX1cIjtgLFxuICAgICAgICAgIGBvZmZzZXQgKz0gJHtvZmZzZXQgLSBwcmV2fTtgLFxuICAgICAgICAgIHVuaWZvcm1QYXJzZXJzW2pdW3BhcnNlckNvZGVdIHx8IHVuaWZvcm1QYXJzZXJzW2pdLnVib1xuICAgICAgICApO1xuICAgICAgICBwYXJzZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIGlmICh1Ym9FbGVtZW50LmRhdGEuc2l6ZSA+IDEpIHtcbiAgICAgICAgb2Zmc2V0ID0gdWJvRWxlbWVudC5vZmZzZXQgLyA0O1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYXJyYXlHZW5lcmF0aW9uRnVuY3Rpb24odWJvRWxlbWVudCwgb2Zmc2V0IC0gcHJldikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBzaW5nbGVTZXR0ZXJzTWFwW3Vib0VsZW1lbnQuZGF0YS50eXBlXTtcbiAgICAgICAgb2Zmc2V0ID0gdWJvRWxlbWVudC5vZmZzZXQgLyA0O1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goXG4gICAgICAgICAgLyogd2dzbCAqL1xuICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAke29mZnNldCAtIHByZXZ9O1xuICAgICAgICAgICAgICAgICAgICAke3RlbXBsYXRlfTtcbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBvZmZzZXQ7XG4gIH1cbiAgY29uc3QgZnJhZ21lbnRTcmMgPSBmdW5jRnJhZ21lbnRzLmpvaW4oXCJcXG5cIik7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXG4gICAgXCJ1dlwiLFxuICAgIFwiZGF0YVwiLFxuICAgIFwib2Zmc2V0XCIsXG4gICAgZnJhZ21lbnRTcmNcbiAgKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlVWJvU3luY0Z1bmN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVVYm9TeW5jRnVuY3Rpb24ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6423\n')},1266:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ uboSyncFunctionsWGSL),\n/* harmony export */   g: () => (/* binding */ uboSyncFunctionsSTD40)\n/* harmony export */ });\n\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        data[offset] = v;`,\n  "vec2<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  "vec3<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  "vec4<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  "mat2x2<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  "mat3x3<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  "mat4x4<f32>": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  "mat3x2<f32>": loopMatrix(3, 2),\n  "mat4x2<f32>": loopMatrix(4, 2),\n  "mat2x3<f32>": loopMatrix(2, 3),\n  "mat4x3<f32>": loopMatrix(4, 3),\n  "mat2x4<f32>": loopMatrix(2, 4),\n  "mat3x4<f32>": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  "mat2x2<f32>": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\n\n//# sourceMappingURL=uboSyncFunctions.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2Ni5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTSxRQUFRO0FBQ3RDLG1DQUFtQyxJQUFJLG1CQUFtQixJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVEO0FBQ3ZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvdXRpbHMvdWJvU3luY0Z1bmN0aW9ucy5tanM/MzU2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGxvb3BNYXRyaXgoY29sLCByb3cpIHtcbiAgY29uc3QgdG90YWwgPSBjb2wgKiByb3c7XG4gIHJldHVybiBgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJHt0b3RhbH07IGkrKykge1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAoKChpIC8gJHtjb2x9KXwwKSAqIDQpICsgKGkgJSAke2NvbH0pXSA9IHZbaV07XG4gICAgICAgIH1cbiAgICBgO1xufVxuY29uc3QgdWJvU3luY0Z1bmN0aW9uc1NURDQwID0ge1xuICBmMzI6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdjtgLFxuICBpMzI6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdjtgLFxuICBcInZlYzI8ZjMyPlwiOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSB2WzFdO2AsXG4gIFwidmVjMzxmMzI+XCI6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IHZbMV07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSB2WzJdO2AsXG4gIFwidmVjNDxmMzI+XCI6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IHZbMV07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSB2WzJdO1xuICAgICAgICBkYXRhW29mZnNldCArIDNdID0gdlszXTtgLFxuICBcIm1hdDJ4MjxmMzI+XCI6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IHZbMV07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNF0gPSB2WzJdO1xuICAgICAgICBkYXRhW29mZnNldCArIDVdID0gdlszXTtgLFxuICBcIm1hdDN4MzxmMzI+XCI6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IHZbMV07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSB2WzJdO1xuICAgICAgICBkYXRhW29mZnNldCArIDRdID0gdlszXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA1XSA9IHZbNF07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNl0gPSB2WzVdO1xuICAgICAgICBkYXRhW29mZnNldCArIDhdID0gdls2XTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA5XSA9IHZbN107XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMTBdID0gdls4XTtgLFxuICBcIm1hdDR4NDxmMzI+XCI6IGBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIGldID0gdltpXTtcbiAgICAgICAgfWAsXG4gIFwibWF0M3gyPGYzMj5cIjogbG9vcE1hdHJpeCgzLCAyKSxcbiAgXCJtYXQ0eDI8ZjMyPlwiOiBsb29wTWF0cml4KDQsIDIpLFxuICBcIm1hdDJ4MzxmMzI+XCI6IGxvb3BNYXRyaXgoMiwgMyksXG4gIFwibWF0NHgzPGYzMj5cIjogbG9vcE1hdHJpeCg0LCAzKSxcbiAgXCJtYXQyeDQ8ZjMyPlwiOiBsb29wTWF0cml4KDIsIDQpLFxuICBcIm1hdDN4NDxmMzI+XCI6IGxvb3BNYXRyaXgoMywgNClcbn07XG5jb25zdCB1Ym9TeW5jRnVuY3Rpb25zV0dTTCA9IHtcbiAgLi4udWJvU3luY0Z1bmN0aW9uc1NURDQwLFxuICBcIm1hdDJ4MjxmMzI+XCI6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IHZbMV07XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSB2WzJdO1xuICAgICAgICBkYXRhW29mZnNldCArIDNdID0gdlszXTtcbiAgICBgXG59O1xuXG5leHBvcnQgeyB1Ym9TeW5jRnVuY3Rpb25zU1RENDAsIHVib1N5bmNGdW5jdGlvbnNXR1NMIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11Ym9TeW5jRnVuY3Rpb25zLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1266\n')},8166:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ uniformParsers)\n/* harmony export */ });\n\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: "mat3x3<f32>",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: "vec4<f32>",\n    test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: "vec2<f32>",\n    test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: "vec4<f32>",\n    test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: "vec3<f32>",\n    test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\n\n//# sourceMappingURL=uniformParsers.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE2Ni5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvdXRpbHMvdW5pZm9ybVBhcnNlcnMubWpzPzUxMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB1bmlmb3JtUGFyc2VycyA9IFtcbiAgLy8gdXBsb2FkaW5nIHBpeGkgbWF0cml4IG9iamVjdCB0byBtYXQzXG4gIHtcbiAgICB0eXBlOiBcIm1hdDN4MzxmMzI+XCIsXG4gICAgdGVzdDogKGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZS5hICE9PSB2b2lkIDA7XG4gICAgfSxcbiAgICB1Ym86IGBcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSB1dltuYW1lXS50b0FycmF5KHRydWUpO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gbWF0cml4WzBdO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IG1hdHJpeFsxXTtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSBtYXRyaXhbMl07XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDRdID0gbWF0cml4WzNdO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA1XSA9IG1hdHJpeFs0XTtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgNl0gPSBtYXRyaXhbNV07XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDhdID0gbWF0cml4WzZdO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA5XSA9IG1hdHJpeFs3XTtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMTBdID0gbWF0cml4WzhdO1xuICAgICAgICBgLFxuICAgIHVuaWZvcm06IGBcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodWRbbmFtZV0ubG9jYXRpb24sIGZhbHNlLCB1dltuYW1lXS50b0FycmF5KHRydWUpKTtcbiAgICAgICAgYFxuICB9LFxuICAvLyB1cGxvYWRpbmcgYSBwaXhpIHJlY3RhbmdsZSBhcyBhIHZlYzRcbiAge1xuICAgIHR5cGU6IFwidmVjNDxmMzI+XCIsXG4gICAgdGVzdDogKGRhdGEpID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWM0PGYzMj5cIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgZGF0YS52YWx1ZS53aWR0aCAhPT0gdm9pZCAwLFxuICAgIHVibzogYFxuICAgICAgICAgICAgdiA9IHV2W25hbWVdO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi54O1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IHYueTtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSB2LndpZHRoO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAzXSA9IHYuaGVpZ2h0O1xuICAgICAgICBgLFxuICAgIHVuaWZvcm06IGBcbiAgICAgICAgICAgIGN2ID0gdWRbbmFtZV0udmFsdWU7XG4gICAgICAgICAgICB2ID0gdXZbbmFtZV07XG4gICAgICAgICAgICBpZiAoY3ZbMF0gIT09IHYueCB8fCBjdlsxXSAhPT0gdi55IHx8IGN2WzJdICE9PSB2LndpZHRoIHx8IGN2WzNdICE9PSB2LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGN2WzBdID0gdi54O1xuICAgICAgICAgICAgICAgIGN2WzFdID0gdi55O1xuICAgICAgICAgICAgICAgIGN2WzJdID0gdi53aWR0aDtcbiAgICAgICAgICAgICAgICBjdlszXSA9IHYuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih1ZFtuYW1lXS5sb2NhdGlvbiwgdi54LCB2LnksIHYud2lkdGgsIHYuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICB9LFxuICAvLyB1cGxvYWRpbmcgYSBwaXhpIHBvaW50IGFzIGEgdmVjMlxuICB7XG4gICAgdHlwZTogXCJ2ZWMyPGYzMj5cIixcbiAgICB0ZXN0OiAoZGF0YSkgPT4gZGF0YS50eXBlID09PSBcInZlYzI8ZjMyPlwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiBkYXRhLnZhbHVlLnggIT09IHZvaWQgMCxcbiAgICB1Ym86IGBcbiAgICAgICAgICAgIHYgPSB1dltuYW1lXTtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHYueDtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSB2Lnk7XG4gICAgICAgIGAsXG4gICAgdW5pZm9ybTogYFxuICAgICAgICAgICAgY3YgPSB1ZFtuYW1lXS52YWx1ZTtcbiAgICAgICAgICAgIHYgPSB1dltuYW1lXTtcbiAgICAgICAgICAgIGlmIChjdlswXSAhPT0gdi54IHx8IGN2WzFdICE9PSB2LnkpIHtcbiAgICAgICAgICAgICAgICBjdlswXSA9IHYueDtcbiAgICAgICAgICAgICAgICBjdlsxXSA9IHYueTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYodWRbbmFtZV0ubG9jYXRpb24sIHYueCwgdi55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYFxuICB9LFxuICAvLyB1cGxvYWRpbmcgYSBwaXhpIGNvbG9yIGFzIGEgdmVjNFxuICB7XG4gICAgdHlwZTogXCJ2ZWM0PGYzMj5cIixcbiAgICB0ZXN0OiAoZGF0YSkgPT4gZGF0YS50eXBlID09PSBcInZlYzQ8ZjMyPlwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiBkYXRhLnZhbHVlLnJlZCAhPT0gdm9pZCAwLFxuICAgIHVibzogYFxuICAgICAgICAgICAgdiA9IHV2W25hbWVdO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi5yZWQ7XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSB2LmJsdWU7XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDNdID0gdi5hbHBoYTtcbiAgICAgICAgYCxcbiAgICB1bmlmb3JtOiBgXG4gICAgICAgICAgICBjdiA9IHVkW25hbWVdLnZhbHVlO1xuICAgICAgICAgICAgdiA9IHV2W25hbWVdO1xuICAgICAgICAgICAgaWYgKGN2WzBdICE9PSB2LnJlZCB8fCBjdlsxXSAhPT0gdi5ncmVlbiB8fCBjdlsyXSAhPT0gdi5ibHVlIHx8IGN2WzNdICE9PSB2LmFscGhhKSB7XG4gICAgICAgICAgICAgICAgY3ZbMF0gPSB2LnJlZDtcbiAgICAgICAgICAgICAgICBjdlsxXSA9IHYuZ3JlZW47XG4gICAgICAgICAgICAgICAgY3ZbMl0gPSB2LmJsdWU7XG4gICAgICAgICAgICAgICAgY3ZbM10gPSB2LmFscGhhO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih1ZFtuYW1lXS5sb2NhdGlvbiwgdi5yZWQsIHYuZ3JlZW4sIHYuYmx1ZSwgdi5hbHBoYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGBcbiAgfSxcbiAgLy8gdXBsb2FkaW5nIGEgcGl4aSBjb2xvciBhcyBhIHZlYzNcbiAge1xuICAgIHR5cGU6IFwidmVjMzxmMzI+XCIsXG4gICAgdGVzdDogKGRhdGEpID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWMzPGYzMj5cIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgZGF0YS52YWx1ZS5yZWQgIT09IHZvaWQgMCxcbiAgICB1Ym86IGBcbiAgICAgICAgICAgIHYgPSB1dltuYW1lXTtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHYucmVkO1xuICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IHYuZ3JlZW47XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIDJdID0gdi5ibHVlO1xuICAgICAgICBgLFxuICAgIHVuaWZvcm06IGBcbiAgICAgICAgICAgIGN2ID0gdWRbbmFtZV0udmFsdWU7XG4gICAgICAgICAgICB2ID0gdXZbbmFtZV07XG4gICAgICAgICAgICBpZiAoY3ZbMF0gIT09IHYucmVkIHx8IGN2WzFdICE9PSB2LmdyZWVuIHx8IGN2WzJdICE9PSB2LmJsdWUpIHtcbiAgICAgICAgICAgICAgICBjdlswXSA9IHYucmVkO1xuICAgICAgICAgICAgICAgIGN2WzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICBjdlsyXSA9IHYuYmx1ZTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2YodWRbbmFtZV0ubG9jYXRpb24sIHYucmVkLCB2LmdyZWVuLCB2LmJsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gIH1cbl07XG5cbmV4cG9ydCB7IHVuaWZvcm1QYXJzZXJzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlmb3JtUGFyc2Vycy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8166\n')},5411:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  f: () => (/* binding */ SharedRenderPipes),\n  i: () => (/* binding */ SharedSystems)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(8507);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs\n\n\n"use strict";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable)\n      return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "customRender"\n};\n\n\n//# sourceMappingURL=CustomRenderPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs\n\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\n\n//# sourceMappingURL=executeInstructions.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs\n\n\n\n"use strict";\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(renderGroup);\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable)\n      return;\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.worldTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "renderGroup"\n};\n\n\n//# sourceMappingURL=RenderGroupPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(9313);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs\n\nfunction buildInstructions(renderGroup, rendererOrPipes) {\n  const root = renderGroup.root;\n  const instructionSet = renderGroup.instructionSet;\n  instructionSet.reset();\n  const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n  const renderPipes = renderer.renderPipes;\n  renderPipes.batch.buildStart(instructionSet);\n  renderPipes.blendMode.buildStart();\n  renderPipes.colorMask.buildStart();\n  if (root.sortableChildren) {\n    root.sortChildren();\n  }\n  collectAllRenderablesAdvanced(root, instructionSet, renderer, true);\n  renderPipes.batch.buildEnd(instructionSet);\n  renderPipes.blendMode.buildEnd(instructionSet);\n}\nfunction collectAllRenderables(container, instructionSet, rendererOrPipes) {\n  const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n  if (container.globalDisplayStatus < 7 || !container.includeInBuild)\n    return;\n  if (container.sortableChildren) {\n    container.sortChildren();\n  }\n  if (container.isSimple) {\n    collectAllRenderablesSimple(container, instructionSet, renderer);\n  } else {\n    collectAllRenderablesAdvanced(container, instructionSet, renderer, false);\n  }\n}\nfunction collectAllRenderablesSimple(container, instructionSet, renderer) {\n  if (container.renderPipeId) {\n    const { renderPipes, renderableGC } = renderer;\n    renderPipes.blendMode.setBlendMode(container, container.groupBlendMode, instructionSet);\n    container.didViewUpdate = false;\n    const rp = renderPipes;\n    rp[container.renderPipeId].addRenderable(container, instructionSet);\n    renderableGC.addRenderable(container, instructionSet);\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      collectAllRenderables(children[i], instructionSet, renderer);\n    }\n  }\n}\nfunction collectAllRenderablesAdvanced(container, instructionSet, renderer, isRoot) {\n  const { renderPipes, renderableGC } = renderer;\n  if (!isRoot && container.renderGroup) {\n    renderPipes.renderGroup.addRenderGroup(container.renderGroup, instructionSet);\n  } else {\n    for (let i = 0; i < container.effects.length; i++) {\n      const effect = container.effects[i];\n      const pipe = renderPipes[effect.pipe];\n      pipe.push(effect, container, instructionSet);\n    }\n    const renderPipeId = container.renderPipeId;\n    if (renderPipeId) {\n      renderPipes.blendMode.setBlendMode(container, container.groupBlendMode, instructionSet);\n      container.didViewUpdate = false;\n      const pipe = renderPipes[renderPipeId];\n      pipe.addRenderable(container, instructionSet);\n      renderableGC.addRenderable(container, instructionSet);\n    }\n    const children = container.children;\n    if (children.length) {\n      for (let i = 0; i < children.length; i++) {\n        collectAllRenderables(children[i], instructionSet, renderer);\n      }\n    }\n    for (let i = container.effects.length - 1; i >= 0; i--) {\n      const effect = container.effects[i];\n      const pipe = renderPipes[effect.pipe];\n      pipe.pop(effect, container, instructionSet);\n    }\n  }\n}\n\n\n//# sourceMappingURL=buildInstructions.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/clearList.mjs\n\nfunction clearList(list, index) {\n  index || (index = 0);\n  for (let j = index; j < list.length; j++) {\n    if (list[j]) {\n      list[j] = null;\n    } else {\n      break;\n    }\n  }\n}\n\n\n//# sourceMappingURL=clearList.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs\n\nfunction collectRenderGroups(renderGroup, out = []) {\n  out.push(renderGroup);\n  for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n    collectRenderGroups(renderGroup.renderGroupChildren[i], out);\n  }\n  return out;\n}\n\n\n//# sourceMappingURL=collectRenderGroups.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(4263);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs\n\nfunction mixHexColors_mixHexColors(color1, color2, ratio) {\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 + (r2 - r1) * ratio;\n  const g = g1 + (g2 - g1) * ratio;\n  const b = b1 + (b2 - b1) * ratio;\n  return (r << 16) + (g << 8) + b;\n}\n\n\n//# sourceMappingURL=mixHexColors.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs\n\n\n"use strict";\nconst WHITE_BGR = 16777215;\nfunction mixColors(localBGRColor, parentBGRColor) {\n  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {\n    return localBGRColor + parentBGRColor - WHITE_BGR;\n  }\n  return mixHexColors_mixHexColors(localBGRColor, parentBGRColor, 0.5);\n}\nfunction mixStandardAnd32BitColors(localColorRGB, localAlpha, parentColor) {\n  const parentAlpha = (parentColor >> 24 & 255) / 255;\n  const globalAlpha = localAlpha * parentAlpha * 255;\n  const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);\n  const parentBGRColor = parentColor & 16777215;\n  let sharedBGRColor;\n  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {\n    sharedBGRColor = localBGRColor + parentBGRColor - WHITE_BGR;\n  } else {\n    sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);\n  }\n  return sharedBGRColor + (globalAlpha << 24);\n}\n\n\n//# sourceMappingURL=mixColors.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs\n\n\n\n\n"use strict";\nconst tempContainer = new Container/* Container */.mc();\nconst UPDATE_BLEND_COLOR_VISIBLE = Container/* UPDATE_VISIBLE */.fR | Container/* UPDATE_COLOR */.ig | Container/* UPDATE_BLEND */.u;\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = mixColors(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick)\n    return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags = updateFlags | container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    if (container.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(container);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & Container/* UPDATE_COLOR */.ig) {\n    container.groupColor = mixColors(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & Container/* UPDATE_BLEND */.u) {\n    container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & Container/* UPDATE_VISIBLE */.fR) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\n\n//# sourceMappingURL=updateRenderGroupTransforms.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs\n\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list, index } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\n\n//# sourceMappingURL=validateRenderables.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.u();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    container.isRenderGroup = true;\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    const renderGroups = collectRenderGroups(container.renderGroup, []);\n    let originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    for (let i = 0; i < renderGroups.length; i++) {\n      const renderGroup = renderGroups[i];\n      renderGroup.runOnRender();\n      renderGroup.instructionSet.renderPipes = renderPipes;\n      if (!renderGroup.structureDidChange) {\n        validateRenderables(renderGroup, renderPipes);\n      } else {\n        clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n      }\n      updateRenderGroupTransforms(renderGroup);\n      if (renderGroup.structureDidChange) {\n        renderGroup.structureDidChange = false;\n        buildInstructions(renderGroup, renderer);\n      } else {\n        updateRenderables(renderGroup);\n      }\n      renderGroup.childrenRenderablesToUpdate.index = 0;\n      renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    }\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "renderGroup"\n};\nfunction updateRenderables(renderGroup) {\n  const { list, index } = renderGroup.childrenRenderablesToUpdate;\n  for (let i = 0; i < index; i++) {\n    const container = list[i];\n    if (container.didViewUpdate) {\n      renderGroup.updateRenderable(container);\n    }\n  }\n  clearList(list, index);\n}\n\n\n//# sourceMappingURL=RenderGroupSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(8218);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(8422);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs\n\n\n\n\n"use strict";\nclass SpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._destroyRenderableBound = this.destroyRenderable.bind(this);\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, _instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite.batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const texture = sprite._texture;\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (gpuSprite.texture._source !== texture._source) {\n      return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n    }\n    return false;\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    PoolGroup/* BigPool */.Z.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n    sprite.off("destroyed", this._destroyRenderableBound);\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    sprite._didSpriteUpdate = false;\n    batchableSprite.bounds = sprite.bounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = PoolGroup/* BigPool */.Z.get(BatchableSprite/* BatchableSprite */.K);\n    batchableSprite.renderable = sprite;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.bounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableSprite;\n    sprite._didSpriteUpdate = false;\n    sprite.on("destroyed", this._destroyRenderableBound);\n    return batchableSprite;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      PoolGroup/* BigPool */.Z.return(this._gpuSpriteHash[i]);\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "sprite"\n};\n\n\n//# sourceMappingURL=SpritePipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/global/globalHooks.mjs\nvar globalHooks = __webpack_require__(7073);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(7547);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs + 2 modules\nvar Batcher = __webpack_require__(5130);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs\nvar BatchGeometry = __webpack_require__(1617);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs\n\n\n\n\n\n"use strict";\nclass BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State/* State */.U.for2d();\n    this._batches = /* @__PURE__ */ Object.create(null);\n    this._geometries = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init(this);\n  }\n  buildStart(instructionSet) {\n    if (!this._batches[instructionSet.uid]) {\n      const batcher = new Batcher/* Batcher */.i();\n      this._batches[instructionSet.uid] = batcher;\n      this._geometries[batcher.uid] = new BatchGeometry/* BatchGeometry */.J();\n    }\n    this._activeBatch = this._batches[instructionSet.uid];\n    this._activeGeometry = this._geometries[this._activeBatch.uid];\n    this._activeBatch.begin();\n  }\n  addToBatch(batchableObject) {\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    const activeBatch = this._activeBatch;\n    const geometry = this._activeGeometry;\n    activeBatch.finish(instructionSet);\n    geometry.indexBuffer.setDataWithSize(activeBatch.indexBuffer, activeBatch.indexSize, true);\n    geometry.buffers[0].setDataWithSize(activeBatch.attributeBuffer.float32View, activeBatch.attributeSize, false);\n  }\n  upload(instructionSet) {\n    const batcher = this._batches[instructionSet.uid];\n    const geometry = this._geometries[batcher.uid];\n    if (batcher.dirty) {\n      batcher.dirty = false;\n      geometry.buffers[0].update(batcher.attributeSize * 4);\n    }\n  }\n  execute(batch) {\n    if (batch.action === "startBatch") {\n      const batcher = batch.batcher;\n      const geometry = this._geometries[batcher.uid];\n      this._adaptor.start(this, geometry);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    for (const i in this._batches) {\n      this._batches[i].destroy();\n    }\n    this._batches = null;\n    for (const i in this._geometries) {\n      this._geometries[i].destroy();\n    }\n    this._geometries = null;\n  }\n}\n/** @ignore */\nBatcherPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "batch"\n};\n\n\n//# sourceMappingURL=BatcherPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/filters/FilterEffect.mjs\nvar FilterEffect = __webpack_require__(9049);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs + 6 modules\nvar GlProgram = __webpack_require__(9113);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs + 6 modules\nvar GpuProgram = __webpack_require__(3012);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(5811);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs\nvar TextureMatrix = __webpack_require__(1196);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(8475);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/Filter.mjs\n\n\n\n\n\n"use strict";\nconst _Filter = class _Filter extends Shader/* Shader */.M {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    this._state = State/* State */.U.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === "boolean") {\n      this.antialias = options.antialias ? "on" : "off";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.addResource("uTexture", 0, 1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default "normal"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram/* GpuProgram */.B.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram/* GlProgram */.M.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/**\n * The default filter settings\n * @static\n */\n_Filter.defaultOptions = {\n  blendMode: "normal",\n  resolution: 1,\n  padding: 0,\n  antialias: "off",\n  blendRequired: false\n};\nlet Filter = _Filter;\n\n\n//# sourceMappingURL=Filter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/mask/mask.frag.mjs\nvar fragment = "in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha; \\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    original *= (alphaMul * masky.r * uAlpha * clip);\\n\\n    finalColor = original;\\n}\\n";\n\n\n//# sourceMappingURL=mask.frag.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/mask/mask.vert.mjs\nvar vertex = "in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n";\n\n\n//# sourceMappingURL=mask.vert.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs\nvar source = "struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,  \\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n};\\n\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n\\n  \\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n\\n     var clip = step(3.5,\\n        step(maskClamp.x, filterUv.x) +\\n        step(maskClamp.y, filterUv.y) +\\n        step(filterUv.x, maskClamp.z) +\\n        step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    \\n    var npmAlpha = 0.0;\\n\\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\\n\\n    var a = (alphaMul * mask.r) * clip;\\n\\n    return vec4(source.rgb, source.a) * a;\\n}";\n\n\n//# sourceMappingURL=mask.wgsl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix/* TextureMatrix */.N(sprite.texture);\n    const filterUniforms = new UniformGroup/* UniformGroup */.k({\n      uFilterMatrix: { value: new Matrix/* Matrix */.u(), type: "mat3x3<f32>" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },\n      uAlpha: { value: 1, type: "f32" }\n    });\n    const gpuProgram = GpuProgram/* GpuProgram */.B.from({\n      vertex: {\n        source: source,\n        entryPoint: "mainVertex"\n      },\n      fragment: {\n        source: source,\n        entryPoint: "mainFragment"\n      }\n    });\n    const glProgram = GlProgram/* GlProgram */.M.from({\n      vertex: vertex,\n      fragment: fragment,\n      name: "mask-filter"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\n\n//# sourceMappingURL=MaskFilter.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(9636);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs\nvar getGlobalBounds = __webpack_require__(9443);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs\nvar Sprite = __webpack_require__(6844);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(4492);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(2437);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5099);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempBounds = new Bounds/* Bounds */.c();\nclass AlphaMaskEffect extends FilterEffect/* FilterEffect */.a {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite/* Sprite */.k(Texture/* Texture */.g.EMPTY),\n      resolution: "inherit",\n      antialias: "inherit"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "alphaMask",\n      action: "pushMaskBegin",\n      mask,\n      canBundle: false,\n      maskedContainer\n    });\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      collectAllRenderables(\n        maskContainer,\n        instructionSet,\n        renderer\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "alphaMask",\n      action: "pushMaskEnd",\n      mask,\n      maskedContainer,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "alphaMask",\n      action: "popMaskEnd",\n      mask,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === "pushMaskBegin") {\n      const filterEffect = PoolGroup/* BigPool */.Z.get(AlphaMaskEffect);\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = (0,getGlobalBounds/* getGlobalBounds */.fB)(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool/* TexturePool */.W.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          colorTextureSource._resolution,\n          colorTextureSource.antialias\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === "pushMaskEnd") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === types/* RendererType */.W.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: "filter",\n        action: "pushFilter",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === "popMaskEnd") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool/* TexturePool */.W.returnTexture(maskData.filterTexture);\n      }\n      PoolGroup/* BigPool */.Z.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "alphaMask"\n};\n\n\n//# sourceMappingURL=AlphaMaskPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs\n\n\n"use strict";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: "colorMask",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: "colorMask",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "colorMask"\n};\n\n\n//# sourceMappingURL=ColorMaskPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs\nvar gl_const = __webpack_require__(1257);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs\nvar state_const = __webpack_require__(1957);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs\n\n\n\n\n\n"use strict";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);\n    instructionSet.add({\n      renderPipeId: "stencilMask",\n      action: "pushMaskBegin",\n      mask,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    collectAllRenderables(\n      maskContainer,\n      instructionSet,\n      renderer\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "stencilMask",\n      action: "pushMaskEnd",\n      mask,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);\n    instructionSet.add({\n      renderPipeId: "stencilMask",\n      action: "popMaskBegin",\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: "stencilMask",\n      action: "popMaskEnd",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === "pushMaskBegin") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === "pushMaskEnd") {\n      renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.MASK_ACTIVE, maskStackIndex);\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === "popMaskBegin") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, gl_const/* CLEAR */.u.STENCIL);\n        renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === "popMaskEnd") {\n      renderer.stencil.setStencilMode(state_const/* STENCIL_MODES */.K.MASK_ACTIVE, maskStackIndex);\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "stencilMask"\n};\n\n\n//# sourceMappingURL=StencilMaskPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(2577);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs\n\n\n\n"use strict";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color/* Color */.Q(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   * @ignore\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "background",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\n\n//# sourceMappingURL=BackgroundSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(268);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs\n\n\n\n\n"use strict";\nconst BLEND_MODE_FILTERS = {};\nExtensions/* extensions */.XO.handle(Extensions/* ExtensionType */.Ag.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error("BlendMode extension must have a name property");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  /**\n   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n   * @param renderable - The renderable we are adding to the instruction set\n   * @param blendMode - The blend mode of the renderable\n   * @param instructionSet - The instruction set we are adding to\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced)\n        this._renderableList.push(renderable);\n      return;\n    }\n    this._activeBlendMode = blendMode;\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced) {\n      this._beginAdvancedBlendMode(instructionSet);\n      this._renderableList.push(renderable);\n    }\n  }\n  _beginAdvancedBlendMode(instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      (0,warn/* warn */.R)(`Unable to assign BlendMode: \'${blendMode}\'. You may want to include: import \'pixi.js/advanced-blend-modes\'`);\n      return;\n    }\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect/* FilterEffect */.a();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    const instruction = {\n      renderPipeId: "filter",\n      action: "pushFilter",\n      renderables: [],\n      filterEffect,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      action: "popFilter",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   * @ignore\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   * @ignore\n   */\n  buildEnd(instructionSet) {\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n  }\n  /**\n   * @internal\n   * @ignore\n   */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLPipes,\n    Extensions/* ExtensionType */.Ag.WebGPUPipes,\n    Extensions/* ExtensionType */.Ag.CanvasPipes\n  ],\n  name: "blendMode"\n};\n\n\n//# sourceMappingURL=BlendModePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs\n\n\n\n\n"use strict";\nconst imageTypes = {\n  png: "image/png",\n  jpg: "image/jpeg",\n  webp: "image/webp"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container/* Container */.mc || options instanceof Texture/* Texture */.g) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Will return a HTML Image of the target\n   * @param options - The options for creating the image, or the target to extract\n   * @returns - HTML Image of the target\n   */\n  async image(options) {\n    const image = new Image();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Will return a base64 encoded string of this target. It works by calling\n   * `Extract.canvas` and then running toDataURL on that.\n   * @param options - The options for creating the image, or the target to extract\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error("ICanvas.toBlob failed!"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");\n  }\n  /**\n   * Creates a Canvas element, renders this target to it and then returns it.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns - A Canvas element with the texture rendered on.\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture/* Texture */.g) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy();\n    return canvas;\n  }\n  /**\n   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n   * order, with integer values between 0 and 255 (included).\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns - One-dimensional array containing the pixel data of the entire texture\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture/* Texture */.g ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container/* Container */.mc) {\n      texture.destroy();\n    }\n    return pixelInfo;\n  }\n  /**\n   * Will return a texture of the target\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns - A texture of the target\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture/* Texture */.g)\n      return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Will extract a HTMLImage of the target and download it\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement("a");\n    link.download = options.filename ?? "image.png";\n    link.href = canvas.toDataURL("image/png");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what\'s happening in the renderer.\n   * @param options - The options for logging the image, or the target to log\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      "font-size: 1px;",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      "background-size: contain;"\n    ].join(" ");\n    console.log("%c ", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "extract"\n};\n/** Default options for creating an image. */\n_ExtractSystem.defaultImageOptions = {\n  /** The format of the image. */\n  format: "png",\n  /** The quality of the image. */\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\n\n//# sourceMappingURL=ExtractSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(9252);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs\nvar getLocalBounds = __webpack_require__(7269);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 2 modules\nvar TextureSource = __webpack_require__(6932);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs\n\n\n\n"use strict";\nclass RenderTexture extends Texture/* Texture */.g {\n  static create(options) {\n    return new RenderTexture({\n      source: new TextureSource/* TextureSource */.v(options)\n    });\n  }\n  /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */\n  resize(width, height, resolution) {\n    this.source.resize(width, height, resolution);\n    return this;\n  }\n}\n\n\n//# sourceMappingURL=RenderTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempRect = new Rectangle/* Rectangle */.M();\nconst GenerateTextureSystem_tempBounds = new Bounds/* Bounds */.c();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * A Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your container is complicated and needs to be reused multiple times.\n   * @param {GenerateTextureOptions | Container} options - Generate texture options.\n   * @param {Container} [options.container] - If not given, the renderer\'s resolution is used.\n   * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n   * @param {number} [options.resolution] - The resolution of the texture being generated.\n   *        if no region is specified, defaults to the local bounds of the container.\n   * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n   * @returns a shiny new texture of the container passed in\n   */\n  generateTexture(options) {\n    if (options instanceof Container/* Container */.mc) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color/* Color */.Q.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || (0,getLocalBounds/* getLocalBounds */.n)(container, GenerateTextureSystem_tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix/* Matrix */.u.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    target.source.updateMipmaps();\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "textureGenerator"\n};\n\n\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(5101);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(2760);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(3513);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix/* Matrix */.u(),\n      worldColor: 4294967295,\n      offset: new Point/* Point */.b()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    (0,colorToUniform/* color32BitToUniform */.V)(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup/* BindGroup */.T();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === types/* RendererType */.W.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup/* UniformGroup */.k({\n      uProjectionMatrix: { value: new Matrix/* Matrix */.u(), type: "mat3x3<f32>" },\n      uWorldTransformMatrix: { value: new Matrix/* Matrix */.u(), type: "mat3x3<f32>" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },\n      uResolution: { value: [0, 0], type: "vec2<f32>" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "globalUniforms"\n};\n\n\n//# sourceMappingURL=GlobalUniformSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(7309);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs\n\n\n\n"use strict";\nlet uid = 1;\nclass SchedulerSystem {\n  constructor() {\n    this._tasks = [];\n  }\n  /** Initializes the scheduler system and starts the ticker. */\n  init() {\n    Ticker/* Ticker */.R.system.add(this._update, this);\n  }\n  /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @returns The unique identifier for the scheduled task.\n   */\n  repeat(func, duration) {\n    const id = uid++;\n    this._tasks.push({\n      func,\n      duration,\n      start: performance.now(),\n      last: performance.now(),\n      repeat: true,\n      id\n    });\n    return id;\n  }\n  /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */\n  cancel(id) {\n    for (let i = 0; i < this._tasks.length; i++) {\n      if (this._tasks[i].id === id) {\n        this._tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */\n  _update() {\n    const now = performance.now();\n    for (let i = 0; i < this._tasks.length; i++) {\n      const task = this._tasks[i];\n      if (now - task.last >= task.duration) {\n        const elapsed = now - task.start;\n        task.func(elapsed);\n        task.last = now;\n      }\n    }\n  }\n  /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   * @ignore\n   */\n  destroy() {\n    Ticker/* Ticker */.R.system.remove(this._update, this);\n    this._tasks.length = 0;\n  }\n}\n/** @ignore */\nSchedulerSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "scheduler",\n  priority: 0\n};\n\n\n//# sourceMappingURL=SchedulerSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/sayHello.mjs\nvar sayHello = __webpack_require__(7081);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs\n\n\n\n\n"use strict";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === types/* RendererType */.W.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      (0,sayHello/* sayHello */.e)(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "hello",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\n\n//# sourceMappingURL=HelloSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs\n\n\n"use strict";\nconst _RenderableGCSystem = class _RenderableGCSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._managedRenderables = [];\n    this._renderer = renderer;\n  }\n  init(options) {\n    options = { ..._RenderableGCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n    this._frequency = options.renderableGCFrequency;\n    this.enabled = options.renderableGCActive;\n  }\n  get enabled() {\n    return !!this._handler;\n  }\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => this.run(),\n        this._frequency\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n    }\n  }\n  prerender() {\n    this._now = performance.now();\n  }\n  addRenderable(renderable, instructionSet) {\n    if (!this.enabled)\n      return;\n    renderable._lastUsed = this._now;\n    if (renderable._lastInstructionTick === -1) {\n      this._managedRenderables.push(renderable);\n      renderable.once("destroyed", this._removeRenderable, this);\n    }\n    renderable._lastInstructionTick = instructionSet.tick;\n  }\n  /** Runs the scheduled garbage collection */\n  run() {\n    const now = performance.now();\n    const managedRenderables = this._managedRenderables;\n    const renderPipes = this._renderer.renderPipes;\n    let offset = 0;\n    for (let i = 0; i < managedRenderables.length; i++) {\n      const renderable = managedRenderables[i];\n      if (renderable === null) {\n        offset++;\n        continue;\n      }\n      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n      const currentIndex = renderGroup?.instructionSet?.tick ?? -1;\n      if (renderable._lastInstructionTick !== currentIndex && now - renderable._lastUsed > this.maxUnusedTime) {\n        if (!renderable.destroyed) {\n          const rp = renderPipes;\n          rp[renderable.renderPipeId].destroyRenderable(renderable);\n        }\n        renderable._lastInstructionTick = -1;\n        offset++;\n        renderable.off("destroyed", this._removeRenderable, this);\n      } else {\n        managedRenderables[i - offset] = renderable;\n      }\n    }\n    managedRenderables.length = managedRenderables.length - offset;\n  }\n  destroy() {\n    this.enabled = false;\n    this._renderer = null;\n    this._managedRenderables.length = 0;\n  }\n  _removeRenderable(renderable) {\n    const index = this._managedRenderables.indexOf(renderable);\n    if (index >= 0) {\n      renderable.off("destroyed", this._removeRenderable, this);\n      this._managedRenderables[index] = null;\n    }\n  }\n};\n/** @ignore */\n_RenderableGCSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "renderableGC"\n};\n/** default options for the renderableGCSystem */\n_RenderableGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  renderableGCActive: true,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  renderableGCMaxUnusedTime: 6e4,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  renderableGCFrequency: 3e4\n};\nlet RenderableGCSystem = _RenderableGCSystem;\n\n\n//# sourceMappingURL=RenderableGCSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs\n\n\n"use strict";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n  }\n  init(options) {\n    options = { ..._TextureGCSystem.defaultOptions, ...options };\n    this.checkCountMax = options.textureGCCheckCountMax;\n    this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n    this.active = options.textureGCActive;\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  postrender() {\n    if (!this._renderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (!this.active)\n      return;\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  run() {\n    const managedTextures = this._renderer.texture.managedTextures;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {\n        texture._touched = -1;\n        texture.unload();\n      }\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "textureGC"\n};\n/** default options for the TextureGCSystem */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystem.textureGCMaxIdle}\n   */\n  textureGCAMaxIdle: null,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\n\n\n//# sourceMappingURL=TextureGCSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(1761);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(4670);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs\nvar RenderTarget = __webpack_require__(279);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs\nvar getCanvasTexture = __webpack_require__(8725);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs\n\n\n\n\n\n\n\n"use strict";\nconst _ViewSystem = class _ViewSystem {\n  /**\n   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n   * @member {boolean}\n   */\n  get autoDensity() {\n    return this.texture.source.autoDensity;\n  }\n  set autoDensity(value) {\n    this.texture.source.autoDensity = value;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.texture.source._resolution;\n  }\n  set resolution(value) {\n    this.texture.source.resize(\n      this.texture.source.width,\n      this.texture.source.height,\n      value\n    );\n  }\n  /**\n   * initiates the view system\n   * @param options - the options for the view\n   */\n  init(options) {\n    options = {\n      ..._ViewSystem.defaultOptions,\n      ...options\n    };\n    if (options.view) {\n      (0,deprecation/* deprecation */.t)(deprecation/* v8_0_0 */.l, "ViewSystem.view has been renamed to ViewSystem.canvas");\n      options.canvas = options.view;\n    }\n    this.screen = new Rectangle/* Rectangle */.M(0, 0, options.width, options.height);\n    this.canvas = options.canvas || adapter/* DOMAdapter */.e.get().createCanvas();\n    this.antialias = !!options.antialias;\n    this.texture = (0,getCanvasTexture/* getCanvasTexture */.c)(this.canvas, options);\n    this.renderTarget = new RenderTarget/* RenderTarget */.O({\n      colorTextures: [this.texture],\n      depth: !!options.depth,\n      isRoot: true\n    });\n    this.texture.source.transparent = options.backgroundAlpha < 1;\n    this.multiView = !!options.multiView;\n    this.resolution = options.resolution;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.screen.width = this.texture.frame.width;\n    this.screen.height = this.texture.frame.height;\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or "false".\n   * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n   */\n  destroy(options = false) {\n    const removeView = typeof options === "boolean" ? options : !!options?.removeView;\n    if (removeView && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas);\n    }\n  }\n};\n/** @ignore */\n_ViewSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem\n  ],\n  name: "view",\n  priority: 0\n};\n/** The default options for the view system. */\n_ViewSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */\n  width: 800,\n  /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */\n  height: 600,\n  /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */\n  autoDensity: false,\n  /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */\n  antialias: false\n};\nlet ViewSystem = _ViewSystem;\n\n\n//# sourceMappingURL=ViewSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst SharedSystems = [\n  BackgroundSystem,\n  GlobalUniformSystem,\n  HelloSystem,\n  ViewSystem,\n  RenderGroupSystem,\n  TextureGCSystem,\n  GenerateTextureSystem,\n  ExtractSystem,\n  globalHooks/* RendererInitHook */.d,\n  RenderableGCSystem,\n  SchedulerSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  StencilMaskPipe,\n  ColorMaskPipe,\n  CustomRenderPipe\n];\n\n\n//# sourceMappingURL=SharedSystems.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDTztBQUNOO0FBQ0E7QUFDQTtBQUNNO0FBQ047QUFDTjtBQUNIO0FBQ2dCO0FBQ0M7QUFDckI7QUFDQTtBQUNjO0FBQ047QUFDYjs7QUFFcEQ7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCLEVBQUUsbUJBQW1CO0FBQ3JCLEVBQUUsV0FBVztBQUNiLEVBQUUsVUFBVTtBQUNaLEVBQUUsaUJBQWlCO0FBQ25CLEVBQUUsZUFBZTtBQUNqQixFQUFFLHFCQUFxQjtBQUN2QixFQUFFLGFBQWE7QUFDZixFQUFFLG1DQUFnQjtBQUNsQixFQUFFLGtCQUFrQjtBQUNwQixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBLEVBQUUsYUFBYTtBQUNmLEVBQUUsV0FBVztBQUNiLEVBQUUsVUFBVTtBQUNaLEVBQUUsZUFBZTtBQUNqQixFQUFFLGFBQWE7QUFDZixFQUFFLGVBQWU7QUFDakIsRUFBRSxhQUFhO0FBQ2YsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRTRDO0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvQ3VzdG9tUmVuZGVyUGlwZS5tanM/NTBhYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci91dGlscy9leGVjdXRlSW5zdHJ1Y3Rpb25zLm1qcz9mNTU5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL1JlbmRlckdyb3VwUGlwZS5tanM/N2I2YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci91dGlscy9idWlsZEluc3RydWN0aW9ucy5tanM/OWFkZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci91dGlscy9jbGVhckxpc3QubWpzP2JkMWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvY29sbGVjdFJlbmRlckdyb3Vwcy5tanM/YWI1NiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci91dGlscy9taXhIZXhDb2xvcnMubWpzPzNjMDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvbWl4Q29sb3JzLm1qcz9lY2U5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL3V0aWxzL3VwZGF0ZVJlbmRlckdyb3VwVHJhbnNmb3Jtcy5tanM/ODc1MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci91dGlscy92YWxpZGF0ZVJlbmRlcmFibGVzLm1qcz9lZmQzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL1JlbmRlckdyb3VwU3lzdGVtLm1qcz81YjE5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlL1Nwcml0ZVBpcGUubWpzP2ZlNGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hlclBpcGUubWpzPzMwNjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL0ZpbHRlci5tanM/MzkxNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvbWFzay9tYXNrLmZyYWcubWpzP2RkYzYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL21hc2svbWFzay52ZXJ0Lm1qcz82Y2U5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9tYXNrL21hc2sud2dzbC5tanM/ZTVjNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2ZpbHRlcnMvbWFzay9NYXNrRmlsdGVyLm1qcz80ZTgwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svYWxwaGEvQWxwaGFNYXNrUGlwZS5tanM/YWYyNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9tYXNrL2NvbG9yL0NvbG9yTWFza1BpcGUubWpzPzgzOGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvbWFzay9zdGVuY2lsL1N0ZW5jaWxNYXNrUGlwZS5tanM/Mzg1ZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2JhY2tncm91bmQvQmFja2dyb3VuZFN5c3RlbS5tanM/NDFmNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2JsZW5kTW9kZXMvQmxlbmRNb2RlUGlwZS5tanM/N2Q3YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2V4dHJhY3QvRXh0cmFjdFN5c3RlbS5tanM/ZDk5ZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvUmVuZGVyVGV4dHVyZS5tanM/YWM5OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2V4dHJhY3QvR2VuZXJhdGVUZXh0dXJlU3lzdGVtLm1qcz8zZjVjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvcmVuZGVyVGFyZ2V0L0dsb2JhbFVuaWZvcm1TeXN0ZW0ubWpzP2VlMjUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9TY2hlZHVsZXJTeXN0ZW0ubWpzPzI1YjgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGFydHVwL0hlbGxvU3lzdGVtLm1qcz9jZGM4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9SZW5kZXJhYmxlR0NTeXN0ZW0ubWpzP2M5ZGEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVHQ1N5c3RlbS5tanM/OTcyOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3ZpZXcvVmlld1N5c3RlbS5tanM/NzRlNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N5c3RlbS9TaGFyZWRTeXN0ZW1zLm1qcz84Y2JmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDdXN0b21SZW5kZXJQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoY29udGFpbmVyLCBpbnN0cnVjdGlvblNldCkge1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoY29udGFpbmVyKTtcbiAgfVxuICBleGVjdXRlKGNvbnRhaW5lcikge1xuICAgIGlmICghY29udGFpbmVyLmlzUmVuZGVyYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb250YWluZXIucmVuZGVyKHRoaXMuX3JlbmRlcmVyKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuQ3VzdG9tUmVuZGVyUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiY3VzdG9tUmVuZGVyXCJcbn07XG5cbmV4cG9ydCB7IEN1c3RvbVJlbmRlclBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUN1c3RvbVJlbmRlclBpcGUubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBleGVjdXRlSW5zdHJ1Y3Rpb25zKHJlbmRlckdyb3VwLCByZW5kZXJlcikge1xuICBjb25zdCBpbnN0cnVjdGlvblNldCA9IHJlbmRlckdyb3VwLmluc3RydWN0aW9uU2V0O1xuICBjb25zdCBpbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvblNldC5pbnN0cnVjdGlvbnM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25TZXQuaW5zdHJ1Y3Rpb25TaXplOyBpKyspIHtcbiAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcbiAgICByZW5kZXJlcltpbnN0cnVjdGlvbi5yZW5kZXJQaXBlSWRdLmV4ZWN1dGUoaW5zdHJ1Y3Rpb24pO1xuICB9XG59XG5cbmV4cG9ydCB7IGV4ZWN1dGVJbnN0cnVjdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4ZWN1dGVJbnN0cnVjdGlvbnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgZXhlY3V0ZUluc3RydWN0aW9ucyB9IGZyb20gJy4vdXRpbHMvZXhlY3V0ZUluc3RydWN0aW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFJlbmRlckdyb3VwUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBhZGRSZW5kZXJHcm91cChyZW5kZXJHcm91cCwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHJlbmRlckdyb3VwKTtcbiAgfVxuICBleGVjdXRlKHJlbmRlckdyb3VwKSB7XG4gICAgaWYgKCFyZW5kZXJHcm91cC5pc1JlbmRlcmFibGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMucHVzaCh7XG4gICAgICB3b3JsZFRyYW5zZm9ybU1hdHJpeDogcmVuZGVyR3JvdXAud29ybGRUcmFuc2Zvcm0sXG4gICAgICB3b3JsZENvbG9yOiByZW5kZXJHcm91cC53b3JsZENvbG9yQWxwaGFcbiAgICB9KTtcbiAgICBleGVjdXRlSW5zdHJ1Y3Rpb25zKHJlbmRlckdyb3VwLCB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMucG9wKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cblJlbmRlckdyb3VwUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwicmVuZGVyR3JvdXBcIlxufTtcblxuZXhwb3J0IHsgUmVuZGVyR3JvdXBQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJHcm91cFBpcGUubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBidWlsZEluc3RydWN0aW9ucyhyZW5kZXJHcm91cCwgcmVuZGVyZXJPclBpcGVzKSB7XG4gIGNvbnN0IHJvb3QgPSByZW5kZXJHcm91cC5yb290O1xuICBjb25zdCBpbnN0cnVjdGlvblNldCA9IHJlbmRlckdyb3VwLmluc3RydWN0aW9uU2V0O1xuICBpbnN0cnVjdGlvblNldC5yZXNldCgpO1xuICBjb25zdCByZW5kZXJlciA9IHJlbmRlcmVyT3JQaXBlcy5yZW5kZXJQaXBlcyA/IHJlbmRlcmVyT3JQaXBlcyA6IHJlbmRlcmVyT3JQaXBlcy5iYXRjaC5yZW5kZXJlcjtcbiAgY29uc3QgcmVuZGVyUGlwZXMgPSByZW5kZXJlci5yZW5kZXJQaXBlcztcbiAgcmVuZGVyUGlwZXMuYmF0Y2guYnVpbGRTdGFydChpbnN0cnVjdGlvblNldCk7XG4gIHJlbmRlclBpcGVzLmJsZW5kTW9kZS5idWlsZFN0YXJ0KCk7XG4gIHJlbmRlclBpcGVzLmNvbG9yTWFzay5idWlsZFN0YXJ0KCk7XG4gIGlmIChyb290LnNvcnRhYmxlQ2hpbGRyZW4pIHtcbiAgICByb290LnNvcnRDaGlsZHJlbigpO1xuICB9XG4gIGNvbGxlY3RBbGxSZW5kZXJhYmxlc0FkdmFuY2VkKHJvb3QsIGluc3RydWN0aW9uU2V0LCByZW5kZXJlciwgdHJ1ZSk7XG4gIHJlbmRlclBpcGVzLmJhdGNoLmJ1aWxkRW5kKGluc3RydWN0aW9uU2V0KTtcbiAgcmVuZGVyUGlwZXMuYmxlbmRNb2RlLmJ1aWxkRW5kKGluc3RydWN0aW9uU2V0KTtcbn1cbmZ1bmN0aW9uIGNvbGxlY3RBbGxSZW5kZXJhYmxlcyhjb250YWluZXIsIGluc3RydWN0aW9uU2V0LCByZW5kZXJlck9yUGlwZXMpIHtcbiAgY29uc3QgcmVuZGVyZXIgPSByZW5kZXJlck9yUGlwZXMucmVuZGVyUGlwZXMgPyByZW5kZXJlck9yUGlwZXMgOiByZW5kZXJlck9yUGlwZXMuYmF0Y2gucmVuZGVyZXI7XG4gIGlmIChjb250YWluZXIuZ2xvYmFsRGlzcGxheVN0YXR1cyA8IDcgfHwgIWNvbnRhaW5lci5pbmNsdWRlSW5CdWlsZClcbiAgICByZXR1cm47XG4gIGlmIChjb250YWluZXIuc29ydGFibGVDaGlsZHJlbikge1xuICAgIGNvbnRhaW5lci5zb3J0Q2hpbGRyZW4oKTtcbiAgfVxuICBpZiAoY29udGFpbmVyLmlzU2ltcGxlKSB7XG4gICAgY29sbGVjdEFsbFJlbmRlcmFibGVzU2ltcGxlKGNvbnRhaW5lciwgaW5zdHJ1Y3Rpb25TZXQsIHJlbmRlcmVyKTtcbiAgfSBlbHNlIHtcbiAgICBjb2xsZWN0QWxsUmVuZGVyYWJsZXNBZHZhbmNlZChjb250YWluZXIsIGluc3RydWN0aW9uU2V0LCByZW5kZXJlciwgZmFsc2UpO1xuICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0QWxsUmVuZGVyYWJsZXNTaW1wbGUoY29udGFpbmVyLCBpbnN0cnVjdGlvblNldCwgcmVuZGVyZXIpIHtcbiAgaWYgKGNvbnRhaW5lci5yZW5kZXJQaXBlSWQpIHtcbiAgICBjb25zdCB7IHJlbmRlclBpcGVzLCByZW5kZXJhYmxlR0MgfSA9IHJlbmRlcmVyO1xuICAgIHJlbmRlclBpcGVzLmJsZW5kTW9kZS5zZXRCbGVuZE1vZGUoY29udGFpbmVyLCBjb250YWluZXIuZ3JvdXBCbGVuZE1vZGUsIGluc3RydWN0aW9uU2V0KTtcbiAgICBjb250YWluZXIuZGlkVmlld1VwZGF0ZSA9IGZhbHNlO1xuICAgIGNvbnN0IHJwID0gcmVuZGVyUGlwZXM7XG4gICAgcnBbY29udGFpbmVyLnJlbmRlclBpcGVJZF0uYWRkUmVuZGVyYWJsZShjb250YWluZXIsIGluc3RydWN0aW9uU2V0KTtcbiAgICByZW5kZXJhYmxlR0MuYWRkUmVuZGVyYWJsZShjb250YWluZXIsIGluc3RydWN0aW9uU2V0KTtcbiAgfVxuICBpZiAoIWNvbnRhaW5lci5yZW5kZXJHcm91cCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuO1xuICAgIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2xsZWN0QWxsUmVuZGVyYWJsZXMoY2hpbGRyZW5baV0sIGluc3RydWN0aW9uU2V0LCByZW5kZXJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0QWxsUmVuZGVyYWJsZXNBZHZhbmNlZChjb250YWluZXIsIGluc3RydWN0aW9uU2V0LCByZW5kZXJlciwgaXNSb290KSB7XG4gIGNvbnN0IHsgcmVuZGVyUGlwZXMsIHJlbmRlcmFibGVHQyB9ID0gcmVuZGVyZXI7XG4gIGlmICghaXNSb290ICYmIGNvbnRhaW5lci5yZW5kZXJHcm91cCkge1xuICAgIHJlbmRlclBpcGVzLnJlbmRlckdyb3VwLmFkZFJlbmRlckdyb3VwKGNvbnRhaW5lci5yZW5kZXJHcm91cCwgaW5zdHJ1Y3Rpb25TZXQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVyLmVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVmZmVjdCA9IGNvbnRhaW5lci5lZmZlY3RzW2ldO1xuICAgICAgY29uc3QgcGlwZSA9IHJlbmRlclBpcGVzW2VmZmVjdC5waXBlXTtcbiAgICAgIHBpcGUucHVzaChlZmZlY3QsIGNvbnRhaW5lciwgaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJQaXBlSWQgPSBjb250YWluZXIucmVuZGVyUGlwZUlkO1xuICAgIGlmIChyZW5kZXJQaXBlSWQpIHtcbiAgICAgIHJlbmRlclBpcGVzLmJsZW5kTW9kZS5zZXRCbGVuZE1vZGUoY29udGFpbmVyLCBjb250YWluZXIuZ3JvdXBCbGVuZE1vZGUsIGluc3RydWN0aW9uU2V0KTtcbiAgICAgIGNvbnRhaW5lci5kaWRWaWV3VXBkYXRlID0gZmFsc2U7XG4gICAgICBjb25zdCBwaXBlID0gcmVuZGVyUGlwZXNbcmVuZGVyUGlwZUlkXTtcbiAgICAgIHBpcGUuYWRkUmVuZGVyYWJsZShjb250YWluZXIsIGluc3RydWN0aW9uU2V0KTtcbiAgICAgIHJlbmRlcmFibGVHQy5hZGRSZW5kZXJhYmxlKGNvbnRhaW5lciwgaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbGxlY3RBbGxSZW5kZXJhYmxlcyhjaGlsZHJlbltpXSwgaW5zdHJ1Y3Rpb25TZXQsIHJlbmRlcmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGNvbnRhaW5lci5lZmZlY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBlZmZlY3QgPSBjb250YWluZXIuZWZmZWN0c1tpXTtcbiAgICAgIGNvbnN0IHBpcGUgPSByZW5kZXJQaXBlc1tlZmZlY3QucGlwZV07XG4gICAgICBwaXBlLnBvcChlZmZlY3QsIGNvbnRhaW5lciwgaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZEluc3RydWN0aW9ucywgY29sbGVjdEFsbFJlbmRlcmFibGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZEluc3RydWN0aW9ucy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGNsZWFyTGlzdChsaXN0LCBpbmRleCkge1xuICBpbmRleCB8fCAoaW5kZXggPSAwKTtcbiAgZm9yIChsZXQgaiA9IGluZGV4OyBqIDwgbGlzdC5sZW5ndGg7IGorKykge1xuICAgIGlmIChsaXN0W2pdKSB7XG4gICAgICBsaXN0W2pdID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IGNsZWFyTGlzdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xlYXJMaXN0Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY29sbGVjdFJlbmRlckdyb3VwcyhyZW5kZXJHcm91cCwgb3V0ID0gW10pIHtcbiAgb3V0LnB1c2gocmVuZGVyR3JvdXApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlckdyb3VwLnJlbmRlckdyb3VwQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb2xsZWN0UmVuZGVyR3JvdXBzKHJlbmRlckdyb3VwLnJlbmRlckdyb3VwQ2hpbGRyZW5baV0sIG91dCk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IHsgY29sbGVjdFJlbmRlckdyb3VwcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sbGVjdFJlbmRlckdyb3Vwcy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG1peEhleENvbG9ycyhjb2xvcjEsIGNvbG9yMiwgcmF0aW8pIHtcbiAgY29uc3QgcjEgPSBjb2xvcjEgPj4gMTYgJiAyNTU7XG4gIGNvbnN0IGcxID0gY29sb3IxID4+IDggJiAyNTU7XG4gIGNvbnN0IGIxID0gY29sb3IxICYgMjU1O1xuICBjb25zdCByMiA9IGNvbG9yMiA+PiAxNiAmIDI1NTtcbiAgY29uc3QgZzIgPSBjb2xvcjIgPj4gOCAmIDI1NTtcbiAgY29uc3QgYjIgPSBjb2xvcjIgJiAyNTU7XG4gIGNvbnN0IHIgPSByMSArIChyMiAtIHIxKSAqIHJhdGlvO1xuICBjb25zdCBnID0gZzEgKyAoZzIgLSBnMSkgKiByYXRpbztcbiAgY29uc3QgYiA9IGIxICsgKGIyIC0gYjEpICogcmF0aW87XG4gIHJldHVybiAociA8PCAxNikgKyAoZyA8PCA4KSArIGI7XG59XG5cbmV4cG9ydCB7IG1peEhleENvbG9ycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWl4SGV4Q29sb3JzLm1qcy5tYXBcbiIsImltcG9ydCB7IG1peEhleENvbG9ycyB9IGZyb20gJy4vbWl4SGV4Q29sb3JzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgV0hJVEVfQkdSID0gMTY3NzcyMTU7XG5mdW5jdGlvbiBtaXhDb2xvcnMobG9jYWxCR1JDb2xvciwgcGFyZW50QkdSQ29sb3IpIHtcbiAgaWYgKGxvY2FsQkdSQ29sb3IgPT09IFdISVRFX0JHUiB8fCBwYXJlbnRCR1JDb2xvciA9PT0gV0hJVEVfQkdSKSB7XG4gICAgcmV0dXJuIGxvY2FsQkdSQ29sb3IgKyBwYXJlbnRCR1JDb2xvciAtIFdISVRFX0JHUjtcbiAgfVxuICByZXR1cm4gbWl4SGV4Q29sb3JzKGxvY2FsQkdSQ29sb3IsIHBhcmVudEJHUkNvbG9yLCAwLjUpO1xufVxuZnVuY3Rpb24gbWl4U3RhbmRhcmRBbmQzMkJpdENvbG9ycyhsb2NhbENvbG9yUkdCLCBsb2NhbEFscGhhLCBwYXJlbnRDb2xvcikge1xuICBjb25zdCBwYXJlbnRBbHBoYSA9IChwYXJlbnRDb2xvciA+PiAyNCAmIDI1NSkgLyAyNTU7XG4gIGNvbnN0IGdsb2JhbEFscGhhID0gbG9jYWxBbHBoYSAqIHBhcmVudEFscGhhICogMjU1O1xuICBjb25zdCBsb2NhbEJHUkNvbG9yID0gKChsb2NhbENvbG9yUkdCICYgMjU1KSA8PCAxNikgKyAobG9jYWxDb2xvclJHQiAmIDY1MjgwKSArIChsb2NhbENvbG9yUkdCID4+IDE2ICYgMjU1KTtcbiAgY29uc3QgcGFyZW50QkdSQ29sb3IgPSBwYXJlbnRDb2xvciAmIDE2Nzc3MjE1O1xuICBsZXQgc2hhcmVkQkdSQ29sb3I7XG4gIGlmIChsb2NhbEJHUkNvbG9yID09PSBXSElURV9CR1IgfHwgcGFyZW50QkdSQ29sb3IgPT09IFdISVRFX0JHUikge1xuICAgIHNoYXJlZEJHUkNvbG9yID0gbG9jYWxCR1JDb2xvciArIHBhcmVudEJHUkNvbG9yIC0gV0hJVEVfQkdSO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZEJHUkNvbG9yID0gbWl4SGV4Q29sb3JzKGxvY2FsQkdSQ29sb3IsIHBhcmVudEJHUkNvbG9yLCAwLjUpO1xuICB9XG4gIHJldHVybiBzaGFyZWRCR1JDb2xvciArIChnbG9iYWxBbHBoYSA8PCAyNCk7XG59XG5cbmV4cG9ydCB7IG1peENvbG9ycywgbWl4U3RhbmRhcmRBbmQzMkJpdENvbG9ycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWl4Q29sb3JzLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbnRhaW5lciwgVVBEQVRFX1ZJU0lCTEUsIFVQREFURV9DT0xPUiwgVVBEQVRFX0JMRU5EIH0gZnJvbSAnLi4vQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgeyBjbGVhckxpc3QgfSBmcm9tICcuL2NsZWFyTGlzdC5tanMnO1xuaW1wb3J0IHsgbWl4Q29sb3JzIH0gZnJvbSAnLi9taXhDb2xvcnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wQ29udGFpbmVyID0gbmV3IENvbnRhaW5lcigpO1xuY29uc3QgVVBEQVRFX0JMRU5EX0NPTE9SX1ZJU0lCTEUgPSBVUERBVEVfVklTSUJMRSB8IFVQREFURV9DT0xPUiB8IFVQREFURV9CTEVORDtcbmZ1bmN0aW9uIHVwZGF0ZVJlbmRlckdyb3VwVHJhbnNmb3JtcyhyZW5kZXJHcm91cCwgdXBkYXRlQ2hpbGRSZW5kZXJHcm91cHMgPSBmYWxzZSkge1xuICB1cGRhdGVSZW5kZXJHcm91cFRyYW5zZm9ybShyZW5kZXJHcm91cCk7XG4gIGNvbnN0IGNoaWxkcmVuVG9VcGRhdGUgPSByZW5kZXJHcm91cC5jaGlsZHJlblRvVXBkYXRlO1xuICBjb25zdCB1cGRhdGVUaWNrID0gcmVuZGVyR3JvdXAudXBkYXRlVGljaysrO1xuICBmb3IgKGNvbnN0IGogaW4gY2hpbGRyZW5Ub1VwZGF0ZSkge1xuICAgIGNvbnN0IHJlbmRlckdyb3VwRGVwdGggPSBOdW1iZXIoaik7XG4gICAgY29uc3QgY2hpbGRyZW5BdERlcHRoID0gY2hpbGRyZW5Ub1VwZGF0ZVtqXTtcbiAgICBjb25zdCBsaXN0ID0gY2hpbGRyZW5BdERlcHRoLmxpc3Q7XG4gICAgY29uc3QgaW5kZXggPSBjaGlsZHJlbkF0RGVwdGguaW5kZXg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGxpc3RbaV07XG4gICAgICBpZiAoY2hpbGQucGFyZW50UmVuZGVyR3JvdXAgPT09IHJlbmRlckdyb3VwICYmIGNoaWxkLnJlbGF0aXZlUmVuZGVyR3JvdXBEZXB0aCA9PT0gcmVuZGVyR3JvdXBEZXB0aCkge1xuICAgICAgICB1cGRhdGVUcmFuc2Zvcm1BbmRDaGlsZHJlbihjaGlsZCwgdXBkYXRlVGljaywgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsZWFyTGlzdChsaXN0LCBpbmRleCk7XG4gICAgY2hpbGRyZW5BdERlcHRoLmluZGV4ID0gMDtcbiAgfVxuICBpZiAodXBkYXRlQ2hpbGRSZW5kZXJHcm91cHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlckdyb3VwLnJlbmRlckdyb3VwQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVwZGF0ZVJlbmRlckdyb3VwVHJhbnNmb3JtcyhyZW5kZXJHcm91cC5yZW5kZXJHcm91cENoaWxkcmVuW2ldLCB1cGRhdGVDaGlsZFJlbmRlckdyb3Vwcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVSZW5kZXJHcm91cFRyYW5zZm9ybShyZW5kZXJHcm91cCkge1xuICBjb25zdCByb290ID0gcmVuZGVyR3JvdXAucm9vdDtcbiAgbGV0IHdvcmxkQWxwaGE7XG4gIGlmIChyZW5kZXJHcm91cC5yZW5kZXJHcm91cFBhcmVudCkge1xuICAgIGNvbnN0IHJlbmRlckdyb3VwUGFyZW50ID0gcmVuZGVyR3JvdXAucmVuZGVyR3JvdXBQYXJlbnQ7XG4gICAgcmVuZGVyR3JvdXAud29ybGRUcmFuc2Zvcm0uYXBwZW5kRnJvbShcbiAgICAgIHJvb3QucmVsYXRpdmVHcm91cFRyYW5zZm9ybSxcbiAgICAgIHJlbmRlckdyb3VwUGFyZW50LndvcmxkVHJhbnNmb3JtXG4gICAgKTtcbiAgICByZW5kZXJHcm91cC53b3JsZENvbG9yID0gbWl4Q29sb3JzKFxuICAgICAgcm9vdC5ncm91cENvbG9yLFxuICAgICAgcmVuZGVyR3JvdXBQYXJlbnQud29ybGRDb2xvclxuICAgICk7XG4gICAgd29ybGRBbHBoYSA9IHJvb3QuZ3JvdXBBbHBoYSAqIHJlbmRlckdyb3VwUGFyZW50LndvcmxkQWxwaGE7XG4gIH0gZWxzZSB7XG4gICAgcmVuZGVyR3JvdXAud29ybGRUcmFuc2Zvcm0uY29weUZyb20ocm9vdC5sb2NhbFRyYW5zZm9ybSk7XG4gICAgcmVuZGVyR3JvdXAud29ybGRDb2xvciA9IHJvb3QubG9jYWxDb2xvcjtcbiAgICB3b3JsZEFscGhhID0gcm9vdC5sb2NhbEFscGhhO1xuICB9XG4gIHdvcmxkQWxwaGEgPSB3b3JsZEFscGhhIDwgMCA/IDAgOiB3b3JsZEFscGhhID4gMSA/IDEgOiB3b3JsZEFscGhhO1xuICByZW5kZXJHcm91cC53b3JsZEFscGhhID0gd29ybGRBbHBoYTtcbiAgcmVuZGVyR3JvdXAud29ybGRDb2xvckFscGhhID0gcmVuZGVyR3JvdXAud29ybGRDb2xvciArICgod29ybGRBbHBoYSAqIDI1NSB8IDApIDw8IDI0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zZm9ybUFuZENoaWxkcmVuKGNvbnRhaW5lciwgdXBkYXRlVGljaywgdXBkYXRlRmxhZ3MpIHtcbiAgaWYgKHVwZGF0ZVRpY2sgPT09IGNvbnRhaW5lci51cGRhdGVUaWNrKVxuICAgIHJldHVybjtcbiAgY29udGFpbmVyLnVwZGF0ZVRpY2sgPSB1cGRhdGVUaWNrO1xuICBjb250YWluZXIuZGlkQ2hhbmdlID0gZmFsc2U7XG4gIGNvbnN0IGxvY2FsVHJhbnNmb3JtID0gY29udGFpbmVyLmxvY2FsVHJhbnNmb3JtO1xuICBjb250YWluZXIudXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgY29uc3QgcGFyZW50ID0gY29udGFpbmVyLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhcGFyZW50LnJlbmRlckdyb3VwKSB7XG4gICAgdXBkYXRlRmxhZ3MgPSB1cGRhdGVGbGFncyB8IGNvbnRhaW5lci5fdXBkYXRlRmxhZ3M7XG4gICAgY29udGFpbmVyLnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0uYXBwZW5kRnJvbShcbiAgICAgIGxvY2FsVHJhbnNmb3JtLFxuICAgICAgcGFyZW50LnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm1cbiAgICApO1xuICAgIGlmICh1cGRhdGVGbGFncyAmIFVQREFURV9CTEVORF9DT0xPUl9WSVNJQkxFKSB7XG4gICAgICB1cGRhdGVDb2xvckJsZW5kVmlzaWJpbGl0eShjb250YWluZXIsIHBhcmVudCwgdXBkYXRlRmxhZ3MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVGbGFncyA9IGNvbnRhaW5lci5fdXBkYXRlRmxhZ3M7XG4gICAgY29udGFpbmVyLnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0uY29weUZyb20obG9jYWxUcmFuc2Zvcm0pO1xuICAgIGlmICh1cGRhdGVGbGFncyAmIFVQREFURV9CTEVORF9DT0xPUl9WSVNJQkxFKSB7XG4gICAgICB1cGRhdGVDb2xvckJsZW5kVmlzaWJpbGl0eShjb250YWluZXIsIHRlbXBDb250YWluZXIsIHVwZGF0ZUZsYWdzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFjb250YWluZXIucmVuZGVyR3JvdXApIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5jaGlsZHJlbjtcbiAgICBjb25zdCBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdXBkYXRlVHJhbnNmb3JtQW5kQ2hpbGRyZW4oY2hpbGRyZW5baV0sIHVwZGF0ZVRpY2ssIHVwZGF0ZUZsYWdzKTtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyR3JvdXAgPSBjb250YWluZXIucGFyZW50UmVuZGVyR3JvdXA7XG4gICAgaWYgKGNvbnRhaW5lci5yZW5kZXJQaXBlSWQgJiYgIXJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSkge1xuICAgICAgcmVuZGVyR3JvdXAudXBkYXRlUmVuZGVyYWJsZShjb250YWluZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29sb3JCbGVuZFZpc2liaWxpdHkoY29udGFpbmVyLCBwYXJlbnQsIHVwZGF0ZUZsYWdzKSB7XG4gIGlmICh1cGRhdGVGbGFncyAmIFVQREFURV9DT0xPUikge1xuICAgIGNvbnRhaW5lci5ncm91cENvbG9yID0gbWl4Q29sb3JzKFxuICAgICAgY29udGFpbmVyLmxvY2FsQ29sb3IsXG4gICAgICBwYXJlbnQuZ3JvdXBDb2xvclxuICAgICk7XG4gICAgbGV0IGdyb3VwQWxwaGEgPSBjb250YWluZXIubG9jYWxBbHBoYSAqIHBhcmVudC5ncm91cEFscGhhO1xuICAgIGdyb3VwQWxwaGEgPSBncm91cEFscGhhIDwgMCA/IDAgOiBncm91cEFscGhhID4gMSA/IDEgOiBncm91cEFscGhhO1xuICAgIGNvbnRhaW5lci5ncm91cEFscGhhID0gZ3JvdXBBbHBoYTtcbiAgICBjb250YWluZXIuZ3JvdXBDb2xvckFscGhhID0gY29udGFpbmVyLmdyb3VwQ29sb3IgKyAoKGdyb3VwQWxwaGEgKiAyNTUgfCAwKSA8PCAyNCk7XG4gIH1cbiAgaWYgKHVwZGF0ZUZsYWdzICYgVVBEQVRFX0JMRU5EKSB7XG4gICAgY29udGFpbmVyLmdyb3VwQmxlbmRNb2RlID0gY29udGFpbmVyLmxvY2FsQmxlbmRNb2RlID09PSBcImluaGVyaXRcIiA/IHBhcmVudC5ncm91cEJsZW5kTW9kZSA6IGNvbnRhaW5lci5sb2NhbEJsZW5kTW9kZTtcbiAgfVxuICBpZiAodXBkYXRlRmxhZ3MgJiBVUERBVEVfVklTSUJMRSkge1xuICAgIGNvbnRhaW5lci5nbG9iYWxEaXNwbGF5U3RhdHVzID0gY29udGFpbmVyLmxvY2FsRGlzcGxheVN0YXR1cyAmIHBhcmVudC5nbG9iYWxEaXNwbGF5U3RhdHVzO1xuICB9XG4gIGNvbnRhaW5lci5fdXBkYXRlRmxhZ3MgPSAwO1xufVxuXG5leHBvcnQgeyB1cGRhdGVSZW5kZXJHcm91cFRyYW5zZm9ybSwgdXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zLCB1cGRhdGVUcmFuc2Zvcm1BbmRDaGlsZHJlbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gdmFsaWRhdGVSZW5kZXJhYmxlcyhyZW5kZXJHcm91cCwgcmVuZGVyUGlwZXMpIHtcbiAgY29uc3QgeyBsaXN0LCBpbmRleCB9ID0gcmVuZGVyR3JvdXAuY2hpbGRyZW5SZW5kZXJhYmxlc1RvVXBkYXRlO1xuICBsZXQgcmVidWlsZFJlcXVpcmVkID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGxpc3RbaV07XG4gICAgY29uc3QgcmVuZGVyYWJsZSA9IGNvbnRhaW5lcjtcbiAgICBjb25zdCBwaXBlID0gcmVuZGVyUGlwZXNbcmVuZGVyYWJsZS5yZW5kZXJQaXBlSWRdO1xuICAgIHJlYnVpbGRSZXF1aXJlZCA9IHBpcGUudmFsaWRhdGVSZW5kZXJhYmxlKGNvbnRhaW5lcik7XG4gICAgaWYgKHJlYnVpbGRSZXF1aXJlZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSA9IHJlYnVpbGRSZXF1aXJlZDtcbiAgcmV0dXJuIHJlYnVpbGRSZXF1aXJlZDtcbn1cblxuZXhwb3J0IHsgdmFsaWRhdGVSZW5kZXJhYmxlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGVSZW5kZXJhYmxlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBidWlsZEluc3RydWN0aW9ucyB9IGZyb20gJy4vdXRpbHMvYnVpbGRJbnN0cnVjdGlvbnMubWpzJztcbmltcG9ydCB7IGNsZWFyTGlzdCB9IGZyb20gJy4vdXRpbHMvY2xlYXJMaXN0Lm1qcyc7XG5pbXBvcnQgeyBjb2xsZWN0UmVuZGVyR3JvdXBzIH0gZnJvbSAnLi91dGlscy9jb2xsZWN0UmVuZGVyR3JvdXBzLm1qcyc7XG5pbXBvcnQgeyBleGVjdXRlSW5zdHJ1Y3Rpb25zIH0gZnJvbSAnLi91dGlscy9leGVjdXRlSW5zdHJ1Y3Rpb25zLm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVSZW5kZXJHcm91cFRyYW5zZm9ybXMgfSBmcm9tICcuL3V0aWxzL3VwZGF0ZVJlbmRlckdyb3VwVHJhbnNmb3Jtcy5tanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVSZW5kZXJhYmxlcyB9IGZyb20gJy4vdXRpbHMvdmFsaWRhdGVSZW5kZXJhYmxlcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5jbGFzcyBSZW5kZXJHcm91cFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICByZW5kZXIoeyBjb250YWluZXIsIHRyYW5zZm9ybSB9KSB7XG4gICAgY29udGFpbmVyLmlzUmVuZGVyR3JvdXAgPSB0cnVlO1xuICAgIGNvbnN0IHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnQ7XG4gICAgY29uc3QgcmVuZGVyR3JvdXBQYXJlbnQgPSBjb250YWluZXIucmVuZGVyR3JvdXAucmVuZGVyR3JvdXBQYXJlbnQ7XG4gICAgY29udGFpbmVyLnBhcmVudCA9IG51bGw7XG4gICAgY29udGFpbmVyLnJlbmRlckdyb3VwLnJlbmRlckdyb3VwUGFyZW50ID0gbnVsbDtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IHJlbmRlckdyb3VwcyA9IGNvbGxlY3RSZW5kZXJHcm91cHMoY29udGFpbmVyLnJlbmRlckdyb3VwLCBbXSk7XG4gICAgbGV0IG9yaWdpbmFsTG9jYWxUcmFuc2Zvcm0gPSB0ZW1wTWF0cml4O1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIG9yaWdpbmFsTG9jYWxUcmFuc2Zvcm0gPSBvcmlnaW5hbExvY2FsVHJhbnNmb3JtLmNvcHlGcm9tKGNvbnRhaW5lci5yZW5kZXJHcm91cC5sb2NhbFRyYW5zZm9ybSk7XG4gICAgICBjb250YWluZXIucmVuZGVyR3JvdXAubG9jYWxUcmFuc2Zvcm0uY29weUZyb20odHJhbnNmb3JtKTtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyUGlwZXMgPSByZW5kZXJlci5yZW5kZXJQaXBlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVuZGVyR3JvdXAgPSByZW5kZXJHcm91cHNbaV07XG4gICAgICByZW5kZXJHcm91cC5ydW5PblJlbmRlcigpO1xuICAgICAgcmVuZGVyR3JvdXAuaW5zdHJ1Y3Rpb25TZXQucmVuZGVyUGlwZXMgPSByZW5kZXJQaXBlcztcbiAgICAgIGlmICghcmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlKSB7XG4gICAgICAgIHZhbGlkYXRlUmVuZGVyYWJsZXMocmVuZGVyR3JvdXAsIHJlbmRlclBpcGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFyTGlzdChyZW5kZXJHcm91cC5jaGlsZHJlblJlbmRlcmFibGVzVG9VcGRhdGUubGlzdCwgMCk7XG4gICAgICB9XG4gICAgICB1cGRhdGVSZW5kZXJHcm91cFRyYW5zZm9ybXMocmVuZGVyR3JvdXApO1xuICAgICAgaWYgKHJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSkge1xuICAgICAgICByZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgYnVpbGRJbnN0cnVjdGlvbnMocmVuZGVyR3JvdXAsIHJlbmRlcmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVJlbmRlcmFibGVzKHJlbmRlckdyb3VwKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlckdyb3VwLmNoaWxkcmVuUmVuZGVyYWJsZXNUb1VwZGF0ZS5pbmRleCA9IDA7XG4gICAgICByZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC51cGxvYWQocmVuZGVyR3JvdXAuaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIH1cbiAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy5zdGFydCh7XG4gICAgICB3b3JsZFRyYW5zZm9ybU1hdHJpeDogdHJhbnNmb3JtID8gY29udGFpbmVyLnJlbmRlckdyb3VwLmxvY2FsVHJhbnNmb3JtIDogY29udGFpbmVyLnJlbmRlckdyb3VwLndvcmxkVHJhbnNmb3JtLFxuICAgICAgd29ybGRDb2xvcjogY29udGFpbmVyLnJlbmRlckdyb3VwLndvcmxkQ29sb3JBbHBoYVxuICAgIH0pO1xuICAgIGV4ZWN1dGVJbnN0cnVjdGlvbnMoY29udGFpbmVyLnJlbmRlckdyb3VwLCByZW5kZXJQaXBlcyk7XG4gICAgaWYgKHJlbmRlclBpcGVzLnVuaWZvcm1CYXRjaCkge1xuICAgICAgcmVuZGVyUGlwZXMudW5pZm9ybUJhdGNoLnJlbmRlckVuZCgpO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICBjb250YWluZXIucmVuZGVyR3JvdXAubG9jYWxUcmFuc2Zvcm0uY29weUZyb20ob3JpZ2luYWxMb2NhbFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGNvbnRhaW5lci5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgY29udGFpbmVyLnJlbmRlckdyb3VwLnJlbmRlckdyb3VwUGFyZW50ID0gcmVuZGVyR3JvdXBQYXJlbnQ7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5SZW5kZXJHcm91cFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwicmVuZGVyR3JvdXBcIlxufTtcbmZ1bmN0aW9uIHVwZGF0ZVJlbmRlcmFibGVzKHJlbmRlckdyb3VwKSB7XG4gIGNvbnN0IHsgbGlzdCwgaW5kZXggfSA9IHJlbmRlckdyb3VwLmNoaWxkcmVuUmVuZGVyYWJsZXNUb1VwZGF0ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbGlzdFtpXTtcbiAgICBpZiAoY29udGFpbmVyLmRpZFZpZXdVcGRhdGUpIHtcbiAgICAgIHJlbmRlckdyb3VwLnVwZGF0ZVJlbmRlcmFibGUoY29udGFpbmVyKTtcbiAgICB9XG4gIH1cbiAgY2xlYXJMaXN0KGxpc3QsIGluZGV4KTtcbn1cblxuZXhwb3J0IHsgUmVuZGVyR3JvdXBTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlckdyb3VwU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlU3ByaXRlIH0gZnJvbSAnLi9CYXRjaGFibGVTcHJpdGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBTcHJpdGVQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZGVzdHJveVJlbmRlcmFibGVCb3VuZCA9IHRoaXMuZGVzdHJveVJlbmRlcmFibGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoc3ByaXRlLCBfaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVTcHJpdGUgPSB0aGlzLl9nZXRHcHVTcHJpdGUoc3ByaXRlKTtcbiAgICBpZiAoc3ByaXRlLl9kaWRTcHJpdGVVcGRhdGUpXG4gICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVTcHJpdGUoc3ByaXRlLCBncHVTcHJpdGUpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmFkZFRvQmF0Y2goZ3B1U3ByaXRlKTtcbiAgfVxuICB1cGRhdGVSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IGdwdVNwcml0ZSA9IHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF07XG4gICAgaWYgKHNwcml0ZS5fZGlkU3ByaXRlVXBkYXRlKVxuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hhYmxlU3ByaXRlKHNwcml0ZSwgZ3B1U3ByaXRlKTtcbiAgICBncHVTcHJpdGUuYmF0Y2hlci51cGRhdGVFbGVtZW50KGdwdVNwcml0ZSk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgY29uc3QgZ3B1U3ByaXRlID0gdGhpcy5fZ2V0R3B1U3ByaXRlKHNwcml0ZSk7XG4gICAgaWYgKGdwdVNwcml0ZS50ZXh0dXJlLl9zb3VyY2UgIT09IHRleHR1cmUuX3NvdXJjZSkge1xuICAgICAgcmV0dXJuICFncHVTcHJpdGUuYmF0Y2hlci5jaGVja0FuZFVwZGF0ZVRleHR1cmUoZ3B1U3ByaXRlLCB0ZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF07XG4gICAgQmlnUG9vbC5yZXR1cm4oYmF0Y2hhYmxlU3ByaXRlKTtcbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoW3Nwcml0ZS51aWRdID0gbnVsbDtcbiAgICBzcHJpdGUub2ZmKFwiZGVzdHJveWVkXCIsIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQm91bmQpO1xuICB9XG4gIF91cGRhdGVCYXRjaGFibGVTcHJpdGUoc3ByaXRlLCBiYXRjaGFibGVTcHJpdGUpIHtcbiAgICBzcHJpdGUuX2RpZFNwcml0ZVVwZGF0ZSA9IGZhbHNlO1xuICAgIGJhdGNoYWJsZVNwcml0ZS5ib3VuZHMgPSBzcHJpdGUuYm91bmRzO1xuICAgIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuICB9XG4gIF9nZXRHcHVTcHJpdGUoc3ByaXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF0gfHwgdGhpcy5faW5pdEdQVVNwcml0ZShzcHJpdGUpO1xuICB9XG4gIF9pbml0R1BVU3ByaXRlKHNwcml0ZSkge1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IEJpZ1Bvb2wuZ2V0KEJhdGNoYWJsZVNwcml0ZSk7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnJlbmRlcmFibGUgPSBzcHJpdGU7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLmJvdW5kcyA9IHNwcml0ZS5ib3VuZHM7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnJvdW5kUGl4ZWxzID0gdGhpcy5fcmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgc3ByaXRlLl9yb3VuZFBpeGVscztcbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoW3Nwcml0ZS51aWRdID0gYmF0Y2hhYmxlU3ByaXRlO1xuICAgIHNwcml0ZS5fZGlkU3ByaXRlVXBkYXRlID0gZmFsc2U7XG4gICAgc3ByaXRlLm9uKFwiZGVzdHJveWVkXCIsIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQm91bmQpO1xuICAgIHJldHVybiBiYXRjaGFibGVTcHJpdGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fZ3B1U3ByaXRlSGFzaCkge1xuICAgICAgQmlnUG9vbC5yZXR1cm4odGhpcy5fZ3B1U3ByaXRlSGFzaFtpXSk7XG4gICAgfVxuICAgIHRoaXMuX2dwdVNwcml0ZUhhc2ggPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cblNwcml0ZVBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcInNwcml0ZVwiXG59O1xuXG5leHBvcnQgeyBTcHJpdGVQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGVQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9TdGF0ZS5tanMnO1xuaW1wb3J0IHsgQmF0Y2hlciB9IGZyb20gJy4vQmF0Y2hlci5tanMnO1xuaW1wb3J0IHsgQmF0Y2hHZW9tZXRyeSB9IGZyb20gJy4vQmF0Y2hHZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJhdGNoZXJQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIsIGFkYXB0b3IpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgICB0aGlzLl9iYXRjaGVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZ2VvbWV0cmllcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl9hZGFwdG9yID0gYWRhcHRvcjtcbiAgICB0aGlzLl9hZGFwdG9yLmluaXQodGhpcyk7XG4gIH1cbiAgYnVpbGRTdGFydChpbnN0cnVjdGlvblNldCkge1xuICAgIGlmICghdGhpcy5fYmF0Y2hlc1tpbnN0cnVjdGlvblNldC51aWRdKSB7XG4gICAgICBjb25zdCBiYXRjaGVyID0gbmV3IEJhdGNoZXIoKTtcbiAgICAgIHRoaXMuX2JhdGNoZXNbaW5zdHJ1Y3Rpb25TZXQudWlkXSA9IGJhdGNoZXI7XG4gICAgICB0aGlzLl9nZW9tZXRyaWVzW2JhdGNoZXIudWlkXSA9IG5ldyBCYXRjaEdlb21ldHJ5KCk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZUJhdGNoID0gdGhpcy5fYmF0Y2hlc1tpbnN0cnVjdGlvblNldC51aWRdO1xuICAgIHRoaXMuX2FjdGl2ZUdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cmllc1t0aGlzLl9hY3RpdmVCYXRjaC51aWRdO1xuICAgIHRoaXMuX2FjdGl2ZUJhdGNoLmJlZ2luKCk7XG4gIH1cbiAgYWRkVG9CYXRjaChiYXRjaGFibGVPYmplY3QpIHtcbiAgICB0aGlzLl9hY3RpdmVCYXRjaC5hZGQoYmF0Y2hhYmxlT2JqZWN0KTtcbiAgfVxuICBicmVhayhpbnN0cnVjdGlvblNldCkge1xuICAgIHRoaXMuX2FjdGl2ZUJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgfVxuICBidWlsZEVuZChpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGFjdGl2ZUJhdGNoID0gdGhpcy5fYWN0aXZlQmF0Y2g7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9hY3RpdmVHZW9tZXRyeTtcbiAgICBhY3RpdmVCYXRjaC5maW5pc2goaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGdlb21ldHJ5LmluZGV4QnVmZmVyLnNldERhdGFXaXRoU2l6ZShhY3RpdmVCYXRjaC5pbmRleEJ1ZmZlciwgYWN0aXZlQmF0Y2guaW5kZXhTaXplLCB0cnVlKTtcbiAgICBnZW9tZXRyeS5idWZmZXJzWzBdLnNldERhdGFXaXRoU2l6ZShhY3RpdmVCYXRjaC5hdHRyaWJ1dGVCdWZmZXIuZmxvYXQzMlZpZXcsIGFjdGl2ZUJhdGNoLmF0dHJpYnV0ZVNpemUsIGZhbHNlKTtcbiAgfVxuICB1cGxvYWQoaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBiYXRjaGVyID0gdGhpcy5fYmF0Y2hlc1tpbnN0cnVjdGlvblNldC51aWRdO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cmllc1tiYXRjaGVyLnVpZF07XG4gICAgaWYgKGJhdGNoZXIuZGlydHkpIHtcbiAgICAgIGJhdGNoZXIuZGlydHkgPSBmYWxzZTtcbiAgICAgIGdlb21ldHJ5LmJ1ZmZlcnNbMF0udXBkYXRlKGJhdGNoZXIuYXR0cmlidXRlU2l6ZSAqIDQpO1xuICAgIH1cbiAgfVxuICBleGVjdXRlKGJhdGNoKSB7XG4gICAgaWYgKGJhdGNoLmFjdGlvbiA9PT0gXCJzdGFydEJhdGNoXCIpIHtcbiAgICAgIGNvbnN0IGJhdGNoZXIgPSBiYXRjaC5iYXRjaGVyO1xuICAgICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyaWVzW2JhdGNoZXIudWlkXTtcbiAgICAgIHRoaXMuX2FkYXB0b3Iuc3RhcnQodGhpcywgZ2VvbWV0cnkpO1xuICAgIH1cbiAgICB0aGlzLl9hZGFwdG9yLmV4ZWN1dGUodGhpcywgYmF0Y2gpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fYWRhcHRvci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYWRhcHRvciA9IG51bGw7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2JhdGNoZXMpIHtcbiAgICAgIHRoaXMuX2JhdGNoZXNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl9iYXRjaGVzID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fZ2VvbWV0cmllcykge1xuICAgICAgdGhpcy5fZ2VvbWV0cmllc1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX2dlb21ldHJpZXMgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuQmF0Y2hlclBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcImJhdGNoXCJcbn07XG5cbmV4cG9ydCB7IEJhdGNoZXJQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaGVyUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBHbFByb2dyYW0gfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9HbFByb2dyYW0ubWpzJztcbmltcG9ydCB7IEdwdVByb2dyYW0gfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvR3B1UHJvZ3JhbS5tanMnO1xuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1NoYWRlci5tanMnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9TdGF0ZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9GaWx0ZXIgPSBjbGFzcyBfRmlsdGVyIGV4dGVuZHMgU2hhZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbmFsIHBhcmFtZXRlcnMgb2YgdGhpcyBmaWx0ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX0ZpbHRlci5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIC8qKiBJZiBlbmFibGVkIGlzIHRydWUgdGhlIGZpbHRlciBpcyBhcHBsaWVkLCBpZiBmYWxzZSBpdCB3aWxsIG5vdC4gKi9cbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFRoZSBncHUgc3RhdGUgdGhlIGZpbHRlciByZXF1aXJlcyB0byByZW5kZXIuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IG9wdGlvbnMuYmxlbmRNb2RlO1xuICAgIHRoaXMucGFkZGluZyA9IG9wdGlvbnMucGFkZGluZztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYW50aWFsaWFzID09PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhpcy5hbnRpYWxpYXMgPSBvcHRpb25zLmFudGlhbGlhcyA/IFwib25cIiA6IFwib2ZmXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYW50aWFsaWFzID0gb3B0aW9ucy5hbnRpYWxpYXM7XG4gICAgfVxuICAgIHRoaXMucmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICB0aGlzLmJsZW5kUmVxdWlyZWQgPSBvcHRpb25zLmJsZW5kUmVxdWlyZWQ7XG4gICAgdGhpcy5hZGRSZXNvdXJjZShcInVUZXh0dXJlXCIsIDAsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtIGZpbHRlck1hbmFnZXIgLSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXG4gICAqIEBwYXJhbSBpbnB1dCAtIFRoZSBpbnB1dCByZW5kZXIgdGFyZ2V0LlxuICAgKiBAcGFyYW0gb3V0cHV0IC0gVGhlIHRhcmdldCB0byBvdXRwdXQgdG8uXG4gICAqIEBwYXJhbSBjbGVhck1vZGUgLSBTaG91bGQgdGhlIG91dHB1dCBiZSBjbGVhcmVkIGJlZm9yZSByZW5kZXJpbmcgdG8gaXRcbiAgICovXG4gIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSkge1xuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBibGVuZCBtb2RlIG9mIHRoZSBmaWx0ZXIuXG4gICAqIEBkZWZhdWx0IFwibm9ybWFsXCJcbiAgICovXG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmJsZW5kTW9kZTtcbiAgfVxuICAvKiogU2V0cyB0aGUgYmxlbmQgbW9kZSBvZiB0aGUgZmlsdGVyLiAqL1xuICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5fc3RhdGUuYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEEgc2hvcnQgaGFuZCBmdW5jdGlvbiB0byBjcmVhdGUgYSBmaWx0ZXIgYmFzZWQgb2YgYSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlciBzcmMuXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm5zIEEgc2hpbnkgbmV3IFBpeGlKUyBmaWx0ZXIhXG4gICAqL1xuICBzdGF0aWMgZnJvbShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBncHUsIGdsLCAuLi5yZXN0IH0gPSBvcHRpb25zO1xuICAgIGxldCBncHVQcm9ncmFtO1xuICAgIGxldCBnbFByb2dyYW07XG4gICAgaWYgKGdwdSkge1xuICAgICAgZ3B1UHJvZ3JhbSA9IEdwdVByb2dyYW0uZnJvbShncHUpO1xuICAgIH1cbiAgICBpZiAoZ2wpIHtcbiAgICAgIGdsUHJvZ3JhbSA9IEdsUHJvZ3JhbS5mcm9tKGdsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfRmlsdGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICBnbFByb2dyYW0sXG4gICAgICAuLi5yZXN0XG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIFRoZSBkZWZhdWx0IGZpbHRlciBzZXR0aW5nc1xuICogQHN0YXRpY1xuICovXG5fRmlsdGVyLmRlZmF1bHRPcHRpb25zID0ge1xuICBibGVuZE1vZGU6IFwibm9ybWFsXCIsXG4gIHJlc29sdXRpb246IDEsXG4gIHBhZGRpbmc6IDAsXG4gIGFudGlhbGlhczogXCJvZmZcIixcbiAgYmxlbmRSZXF1aXJlZDogZmFsc2Vcbn07XG5sZXQgRmlsdGVyID0gX0ZpbHRlcjtcblxuZXhwb3J0IHsgRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJpbiB2ZWMyIHZNYXNrQ29vcmQ7XFxuaW4gdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVNYXNrVGV4dHVyZTtcXG5cXG51bmlmb3JtIGZsb2F0IHVBbHBoYTtcXG51bmlmb3JtIHZlYzQgdU1hc2tDbGFtcDtcXG5cXG5vdXQgdmVjNCBmaW5hbENvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZmxvYXQgY2xpcCA9IHN0ZXAoMy41LFxcbiAgICAgICAgc3RlcCh1TWFza0NsYW1wLngsIHZNYXNrQ29vcmQueCkgK1xcbiAgICAgICAgc3RlcCh1TWFza0NsYW1wLnksIHZNYXNrQ29vcmQueSkgK1xcbiAgICAgICAgc3RlcCh2TWFza0Nvb3JkLngsIHVNYXNrQ2xhbXAueikgK1xcbiAgICAgICAgc3RlcCh2TWFza0Nvb3JkLnksIHVNYXNrQ2xhbXAudykpO1xcblxcbiAgICAvLyBUT0RPIGxvb2sgaW50byB3aHkgdGhpcyBpcyBuZWVkZWRcXG4gICAgZmxvYXQgbnBtQWxwaGEgPSB1QWxwaGE7IFxcbiAgICB2ZWM0IG9yaWdpbmFsID0gdGV4dHVyZSh1VGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxuICAgIHZlYzQgbWFza3kgPSB0ZXh0dXJlKHVNYXNrVGV4dHVyZSwgdk1hc2tDb29yZCk7XFxuICAgIGZsb2F0IGFscGhhTXVsID0gMS4wIC0gbnBtQWxwaGEgKiAoMS4wIC0gbWFza3kuYSk7XFxuXFxuICAgIG9yaWdpbmFsICo9IChhbHBoYU11bCAqIG1hc2t5LnIgKiB1QWxwaGEgKiBjbGlwKTtcXG5cXG4gICAgZmluYWxDb2xvciA9IG9yaWdpbmFsO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFzay5mcmFnLm1qcy5tYXBcbiIsInZhciB2ZXJ0ZXggPSBcImluIHZlYzIgYVBvc2l0aW9uO1xcblxcbm91dCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxub3V0IHZlYzIgdk1hc2tDb29yZDtcXG5cXG5cXG51bmlmb3JtIHZlYzQgdUlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgdU91dHB1dEZyYW1lO1xcbnVuaWZvcm0gdmVjNCB1T3V0cHV0VGV4dHVyZTtcXG51bmlmb3JtIG1hdDMgdUZpbHRlck1hdHJpeDtcXG5cXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCAgdmVjMiBhUG9zaXRpb24gKVxcbntcXG4gICAgdmVjMiBwb3NpdGlvbiA9IGFQb3NpdGlvbiAqIHVPdXRwdXRGcmFtZS56dyArIHVPdXRwdXRGcmFtZS54eTtcXG4gICAgICAgXFxuICAgIHBvc2l0aW9uLnggPSBwb3NpdGlvbi54ICogKDIuMCAvIHVPdXRwdXRUZXh0dXJlLngpIC0gMS4wO1xcbiAgICBwb3NpdGlvbi55ID0gcG9zaXRpb24ueSAqICgyLjAqdU91dHB1dFRleHR1cmUueiAvIHVPdXRwdXRUZXh0dXJlLnkpIC0gdU91dHB1dFRleHR1cmUuejtcXG5cXG4gICAgcmV0dXJuIHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcXG59XFxuXFxudmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoICB2ZWMyIGFQb3NpdGlvbiApXFxue1xcbiAgICByZXR1cm4gYVBvc2l0aW9uICogKHVPdXRwdXRGcmFtZS56dyAqIHVJbnB1dFNpemUuencpO1xcbn1cXG5cXG52ZWMyIGdldEZpbHRlckNvb3JkKCB2ZWMyIGFQb3NpdGlvbiApXFxue1xcbiAgICByZXR1cm4gICggdUZpbHRlck1hdHJpeCAqIHZlYzMoIGZpbHRlclRleHR1cmVDb29yZChhUG9zaXRpb24pLCAxLjApICApLnh5O1xcbn0gICBcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oYVBvc2l0aW9uKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGZpbHRlclRleHR1cmVDb29yZChhUG9zaXRpb24pO1xcbiAgICB2TWFza0Nvb3JkID0gZ2V0RmlsdGVyQ29vcmQoYVBvc2l0aW9uKTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IHZlcnRleCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXNrLnZlcnQubWpzLm1hcFxuIiwidmFyIHNvdXJjZSA9IFwic3RydWN0IEdsb2JhbEZpbHRlclVuaWZvcm1zIHtcXG4gIHVJbnB1dFNpemU6dmVjNDxmMzI+LFxcbiAgdUlucHV0UGl4ZWw6dmVjNDxmMzI+LFxcbiAgdUlucHV0Q2xhbXA6dmVjNDxmMzI+LFxcbiAgdU91dHB1dEZyYW1lOnZlYzQ8ZjMyPixcXG4gIHVHbG9iYWxGcmFtZTp2ZWM0PGYzMj4sXFxuICB1T3V0cHV0VGV4dHVyZTp2ZWM0PGYzMj4sICBcXG59O1xcblxcbnN0cnVjdCBNYXNrVW5pZm9ybXMge1xcbiAgdUZpbHRlck1hdHJpeDptYXQzeDM8ZjMyPixcXG4gIHVNYXNrQ2xhbXA6dmVjNDxmMzI+LFxcbiAgdUFscGhhOmYzMixcXG59O1xcblxcblxcbkBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gZ2Z1OiBHbG9iYWxGaWx0ZXJVbmlmb3JtcztcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIHVUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47XFxuQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlciA6IHNhbXBsZXI7XFxuXFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiBmaWx0ZXJVbmlmb3JtcyA6IE1hc2tVbmlmb3JtcztcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMSkgdmFyIHVNYXNrVGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+O1xcblxcbnN0cnVjdCBWU091dHB1dCB7XFxuICAgIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbjogdmVjNDxmMzI+LFxcbiAgICBAbG9jYXRpb24oMCkgdXYgOiB2ZWMyPGYzMj4sXFxuICAgIEBsb2NhdGlvbigxKSBmaWx0ZXJVdiA6IHZlYzI8ZjMyPixcXG4gIH07XFxuXFxuZm4gZmlsdGVyVmVydGV4UG9zaXRpb24oYVBvc2l0aW9uOnZlYzI8ZjMyPikgLT4gdmVjNDxmMzI+XFxue1xcbiAgICB2YXIgcG9zaXRpb24gPSBhUG9zaXRpb24gKiBnZnUudU91dHB1dEZyYW1lLnp3ICsgZ2Z1LnVPdXRwdXRGcmFtZS54eTtcXG5cXG4gICAgcG9zaXRpb24ueCA9IHBvc2l0aW9uLnggKiAoMi4wIC8gZ2Z1LnVPdXRwdXRUZXh0dXJlLngpIC0gMS4wO1xcbiAgICBwb3NpdGlvbi55ID0gcG9zaXRpb24ueSAqICgyLjAqZ2Z1LnVPdXRwdXRUZXh0dXJlLnogLyBnZnUudU91dHB1dFRleHR1cmUueSkgLSBnZnUudU91dHB1dFRleHR1cmUuejtcXG5cXG4gICAgcmV0dXJuIHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcXG59XFxuXFxuZm4gZmlsdGVyVGV4dHVyZUNvb3JkKCBhUG9zaXRpb246dmVjMjxmMzI+ICkgLT4gdmVjMjxmMzI+XFxue1xcbiAgICByZXR1cm4gYVBvc2l0aW9uICogKGdmdS51T3V0cHV0RnJhbWUuencgKiBnZnUudUlucHV0U2l6ZS56dyk7XFxufVxcblxcbmZuIGdsb2JhbFRleHR1cmVDb29yZCggYVBvc2l0aW9uOnZlYzI8ZjMyPiApIC0+IHZlYzI8ZjMyPlxcbntcXG4gIHJldHVybiAgKGFQb3NpdGlvbi54eSAvIGdmdS51R2xvYmFsRnJhbWUuencpICsgKGdmdS51R2xvYmFsRnJhbWUueHkgLyBnZnUudUdsb2JhbEZyYW1lLnp3KTsgIFxcbn1cXG5cXG5mbiBnZXRGaWx0ZXJDb29yZChhUG9zaXRpb246dmVjMjxmMzI+ICkgLT4gdmVjMjxmMzI+XFxue1xcbiAgcmV0dXJuICggZmlsdGVyVW5pZm9ybXMudUZpbHRlck1hdHJpeCAqIHZlYzMoIGZpbHRlclRleHR1cmVDb29yZChhUG9zaXRpb24pLCAxLjApICApLnh5O1xcbn1cXG5cXG5mbiBnZXRTaXplKCkgLT4gdmVjMjxmMzI+XFxue1xcblxcbiAgXFxuICByZXR1cm4gZ2Z1LnVHbG9iYWxGcmFtZS56dztcXG59XFxuICBcXG5AdmVydGV4XFxuZm4gbWFpblZlcnRleChcXG4gIEBsb2NhdGlvbigwKSBhUG9zaXRpb24gOiB2ZWMyPGYzMj4sIFxcbikgLT4gVlNPdXRwdXQge1xcbiAgcmV0dXJuIFZTT3V0cHV0KFxcbiAgIGZpbHRlclZlcnRleFBvc2l0aW9uKGFQb3NpdGlvbiksXFxuICAgZmlsdGVyVGV4dHVyZUNvb3JkKGFQb3NpdGlvbiksXFxuICAgZ2V0RmlsdGVyQ29vcmQoYVBvc2l0aW9uKVxcbiAgKTtcXG59XFxuXFxuQGZyYWdtZW50XFxuZm4gbWFpbkZyYWdtZW50KFxcbiAgQGxvY2F0aW9uKDApIHV2OiB2ZWMyPGYzMj4sXFxuICBAbG9jYXRpb24oMSkgZmlsdGVyVXY6IHZlYzI8ZjMyPixcXG4gIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbjogdmVjNDxmMzI+XFxuKSAtPiBAbG9jYXRpb24oMCkgdmVjNDxmMzI+IHtcXG5cXG4gICAgdmFyIG1hc2tDbGFtcCA9IGZpbHRlclVuaWZvcm1zLnVNYXNrQ2xhbXA7XFxuXFxuICAgICB2YXIgY2xpcCA9IHN0ZXAoMy41LFxcbiAgICAgICAgc3RlcChtYXNrQ2xhbXAueCwgZmlsdGVyVXYueCkgK1xcbiAgICAgICAgc3RlcChtYXNrQ2xhbXAueSwgZmlsdGVyVXYueSkgK1xcbiAgICAgICAgc3RlcChmaWx0ZXJVdi54LCBtYXNrQ2xhbXAueikgK1xcbiAgICAgICAgc3RlcChmaWx0ZXJVdi55LCBtYXNrQ2xhbXAudykpO1xcblxcbiAgICB2YXIgbWFzayA9IHRleHR1cmVTYW1wbGUodU1hc2tUZXh0dXJlLCB1U2FtcGxlciwgZmlsdGVyVXYpO1xcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZVNhbXBsZSh1VGV4dHVyZSwgdVNhbXBsZXIsIHV2KTtcXG4gICAgXFxuICAgIHZhciBucG1BbHBoYSA9IDAuMDtcXG5cXG4gICAgdmFyIGFscGhhTXVsID0gMS4wIC0gbnBtQWxwaGEgKiAoMS4wIC0gbWFzay5hKTtcXG5cXG4gICAgdmFyIGEgPSAoYWxwaGFNdWwgKiBtYXNrLnIpICogY2xpcDtcXG5cXG4gICAgcmV0dXJuIHZlYzQoc291cmNlLnJnYiwgc291cmNlLmEpICogYTtcXG59XCI7XG5cbmV4cG9ydCB7IHNvdXJjZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXNrLndnc2wubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgR2xQcm9ncmFtIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvR2xQcm9ncmFtLm1qcyc7XG5pbXBvcnQgeyBHcHVQcm9ncmFtIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0dwdVByb2dyYW0ubWpzJztcbmltcG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IFRleHR1cmVNYXRyaXggfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVNYXRyaXgubWpzJztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4uL0ZpbHRlci5tanMnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vbWFzay5mcmFnLm1qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4vbWFzay52ZXJ0Lm1qcyc7XG5pbXBvcnQgc291cmNlIGZyb20gJy4vbWFzay53Z3NsLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgTWFza0ZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNwcml0ZSwgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB0ZXh0dXJlTWF0cml4ID0gbmV3IFRleHR1cmVNYXRyaXgoc3ByaXRlLnRleHR1cmUpO1xuICAgIGNvbnN0IGZpbHRlclVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1RmlsdGVyTWF0cml4OiB7IHZhbHVlOiBuZXcgTWF0cml4KCksIHR5cGU6IFwibWF0M3gzPGYzMj5cIiB9LFxuICAgICAgdU1hc2tDbGFtcDogeyB2YWx1ZTogdGV4dHVyZU1hdHJpeC51Q2xhbXBGcmFtZSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdUFscGhhOiB7IHZhbHVlOiAxLCB0eXBlOiBcImYzMlwiIH1cbiAgICB9KTtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gR3B1UHJvZ3JhbS5mcm9tKHtcbiAgICAgIHZlcnRleDoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwibWFpblZlcnRleFwiXG4gICAgICB9LFxuICAgICAgZnJhZ21lbnQ6IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbnRyeVBvaW50OiBcIm1haW5GcmFnbWVudFwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gR2xQcm9ncmFtLmZyb20oe1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICBuYW1lOiBcIm1hc2stZmlsdGVyXCJcbiAgICB9KTtcbiAgICBzdXBlcih7XG4gICAgICAuLi5yZXN0LFxuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIGdsUHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBmaWx0ZXJVbmlmb3JtcyxcbiAgICAgICAgdU1hc2tUZXh0dXJlOiBzcHJpdGUudGV4dHVyZS5zb3VyY2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNwcml0ZSA9IHNwcml0ZTtcbiAgICB0aGlzLl90ZXh0dXJlTWF0cml4ID0gdGV4dHVyZU1hdHJpeDtcbiAgfVxuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICB0aGlzLl90ZXh0dXJlTWF0cml4LnRleHR1cmUgPSB0aGlzLnNwcml0ZS50ZXh0dXJlO1xuICAgIGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlU3ByaXRlTWF0cml4KFxuICAgICAgdGhpcy5yZXNvdXJjZXMuZmlsdGVyVW5pZm9ybXMudW5pZm9ybXMudUZpbHRlck1hdHJpeCxcbiAgICAgIHRoaXMuc3ByaXRlXG4gICAgKS5wcmVwZW5kKHRoaXMuX3RleHR1cmVNYXRyaXgubWFwQ29vcmQpO1xuICAgIHRoaXMucmVzb3VyY2VzLnVNYXNrVGV4dHVyZSA9IHRoaXMuc3ByaXRlLnRleHR1cmUuc291cmNlO1xuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgfVxufVxuXG5leHBvcnQgeyBNYXNrRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXNrRmlsdGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEZpbHRlckVmZmVjdCB9IGZyb20gJy4uLy4uLy4uL2ZpbHRlcnMvRmlsdGVyRWZmZWN0Lm1qcyc7XG5pbXBvcnQgeyBNYXNrRmlsdGVyIH0gZnJvbSAnLi4vLi4vLi4vZmlsdGVycy9tYXNrL01hc2tGaWx0ZXIubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uLy4uLy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBnZXRHbG9iYWxCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldEdsb2JhbEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgY29sbGVjdEFsbFJlbmRlcmFibGVzIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2J1aWxkSW5zdHJ1Y3Rpb25zLm1qcyc7XG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tICcuLi8uLi8uLi9zY2VuZS9zcHJpdGUvU3ByaXRlLm1qcyc7XG5pbXBvcnQgeyBCaWdQb29sIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvcG9vbC9Qb29sR3JvdXAubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVBvb2wubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy90eXBlcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5jbGFzcyBBbHBoYU1hc2tFZmZlY3QgZXh0ZW5kcyBGaWx0ZXJFZmZlY3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZmlsdGVycyA9IFtuZXcgTWFza0ZpbHRlcih7XG4gICAgICBzcHJpdGU6IG5ldyBTcHJpdGUoVGV4dHVyZS5FTVBUWSksXG4gICAgICByZXNvbHV0aW9uOiBcImluaGVyaXRcIixcbiAgICAgIGFudGlhbGlhczogXCJpbmhlcml0XCJcbiAgICB9KV07XG4gIH1cbiAgZ2V0IHNwcml0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJzWzBdLnNwcml0ZTtcbiAgfVxuICBzZXQgc3ByaXRlKHZhbHVlKSB7XG4gICAgdGhpcy5maWx0ZXJzWzBdLnNwcml0ZSA9IHZhbHVlO1xuICB9XG59XG5jbGFzcyBBbHBoYU1hc2tQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9hY3RpdmVNYXNrU3RhZ2UgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHB1c2gobWFzaywgbWFza2VkQ29udGFpbmVyLCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGluc3RydWN0aW9uU2V0LmFkZCh7XG4gICAgICByZW5kZXJQaXBlSWQ6IFwiYWxwaGFNYXNrXCIsXG4gICAgICBhY3Rpb246IFwicHVzaE1hc2tCZWdpblwiLFxuICAgICAgbWFzayxcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2UsXG4gICAgICBtYXNrZWRDb250YWluZXJcbiAgICB9KTtcbiAgICBpZiAobWFzay5yZW5kZXJNYXNrVG9UZXh0dXJlKSB7XG4gICAgICBjb25zdCBtYXNrQ29udGFpbmVyID0gbWFzay5tYXNrO1xuICAgICAgbWFza0NvbnRhaW5lci5pbmNsdWRlSW5CdWlsZCA9IHRydWU7XG4gICAgICBjb2xsZWN0QWxsUmVuZGVyYWJsZXMoXG4gICAgICAgIG1hc2tDb250YWluZXIsXG4gICAgICAgIGluc3RydWN0aW9uU2V0LFxuICAgICAgICByZW5kZXJlclxuICAgICAgKTtcbiAgICAgIG1hc2tDb250YWluZXIuaW5jbHVkZUluQnVpbGQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGluc3RydWN0aW9uU2V0LmFkZCh7XG4gICAgICByZW5kZXJQaXBlSWQ6IFwiYWxwaGFNYXNrXCIsXG4gICAgICBhY3Rpb246IFwicHVzaE1hc2tFbmRcIixcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrZWRDb250YWluZXIsXG4gICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcG9wKG1hc2ssIF9tYXNrZWRDb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICByZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgIHJlbmRlclBpcGVJZDogXCJhbHBoYU1hc2tcIixcbiAgICAgIGFjdGlvbjogXCJwb3BNYXNrRW5kXCIsXG4gICAgICBtYXNrLFxuICAgICAgY2FuQnVuZGxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGV4ZWN1dGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IHJlbmRlck1hc2sgPSBpbnN0cnVjdGlvbi5tYXNrLnJlbmRlck1hc2tUb1RleHR1cmU7XG4gICAgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJwdXNoTWFza0JlZ2luXCIpIHtcbiAgICAgIGNvbnN0IGZpbHRlckVmZmVjdCA9IEJpZ1Bvb2wuZ2V0KEFscGhhTWFza0VmZmVjdCk7XG4gICAgICBpZiAocmVuZGVyTWFzaykge1xuICAgICAgICBpbnN0cnVjdGlvbi5tYXNrLm1hc2subWVhc3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGdldEdsb2JhbEJvdW5kcyhpbnN0cnVjdGlvbi5tYXNrLm1hc2ssIHRydWUsIHRlbXBCb3VuZHMpO1xuICAgICAgICBpbnN0cnVjdGlvbi5tYXNrLm1hc2subWVhc3VyYWJsZSA9IGZhbHNlO1xuICAgICAgICBib3VuZHMuY2VpbCgpO1xuICAgICAgICBjb25zdCBjb2xvclRleHR1cmVTb3VyY2UgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQucmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZS5zb3VyY2U7XG4gICAgICAgIGNvbnN0IGZpbHRlclRleHR1cmUgPSBUZXh0dXJlUG9vbC5nZXRPcHRpbWFsVGV4dHVyZShcbiAgICAgICAgICBib3VuZHMud2lkdGgsXG4gICAgICAgICAgYm91bmRzLmhlaWdodCxcbiAgICAgICAgICBjb2xvclRleHR1cmVTb3VyY2UuX3Jlc29sdXRpb24sXG4gICAgICAgICAgY29sb3JUZXh0dXJlU291cmNlLmFudGlhbGlhc1xuICAgICAgICApO1xuICAgICAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQucHVzaChmaWx0ZXJUZXh0dXJlLCB0cnVlKTtcbiAgICAgICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMucHVzaCh7XG4gICAgICAgICAgb2Zmc2V0OiBib3VuZHMsXG4gICAgICAgICAgd29ybGRDb2xvcjogNDI5NDk2NzI5NVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gZmlsdGVyRWZmZWN0LnNwcml0ZTtcbiAgICAgICAgc3ByaXRlLnRleHR1cmUgPSBmaWx0ZXJUZXh0dXJlO1xuICAgICAgICBzcHJpdGUud29ybGRUcmFuc2Zvcm0udHggPSBib3VuZHMubWluWDtcbiAgICAgICAgc3ByaXRlLndvcmxkVHJhbnNmb3JtLnR5ID0gYm91bmRzLm1pblk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU1hc2tTdGFnZS5wdXNoKHtcbiAgICAgICAgICBmaWx0ZXJFZmZlY3QsXG4gICAgICAgICAgbWFza2VkQ29udGFpbmVyOiBpbnN0cnVjdGlvbi5tYXNrZWRDb250YWluZXIsXG4gICAgICAgICAgZmlsdGVyVGV4dHVyZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlckVmZmVjdC5zcHJpdGUgPSBpbnN0cnVjdGlvbi5tYXNrLm1hc2s7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU1hc2tTdGFnZS5wdXNoKHtcbiAgICAgICAgICBmaWx0ZXJFZmZlY3QsXG4gICAgICAgICAgbWFza2VkQ29udGFpbmVyOiBpbnN0cnVjdGlvbi5tYXNrZWRDb250YWluZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwicHVzaE1hc2tFbmRcIikge1xuICAgICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLl9hY3RpdmVNYXNrU3RhZ2VbdGhpcy5fYWN0aXZlTWFza1N0YWdlLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHJlbmRlck1hc2spIHtcbiAgICAgICAgaWYgKHJlbmRlcmVyLnR5cGUgPT09IFJlbmRlcmVyVHlwZS5XRUJHTCkge1xuICAgICAgICAgIHJlbmRlcmVyLnJlbmRlclRhcmdldC5maW5pc2hSZW5kZXJQYXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnBvcCgpO1xuICAgICAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLmZpbHRlci5wdXNoKHtcbiAgICAgICAgcmVuZGVyUGlwZUlkOiBcImZpbHRlclwiLFxuICAgICAgICBhY3Rpb246IFwicHVzaEZpbHRlclwiLFxuICAgICAgICBjb250YWluZXI6IG1hc2tEYXRhLm1hc2tlZENvbnRhaW5lcixcbiAgICAgICAgZmlsdGVyRWZmZWN0OiBtYXNrRGF0YS5maWx0ZXJFZmZlY3QsXG4gICAgICAgIGNhbkJ1bmRsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInBvcE1hc2tFbmRcIikge1xuICAgICAgcmVuZGVyZXIuZmlsdGVyLnBvcCgpO1xuICAgICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLl9hY3RpdmVNYXNrU3RhZ2UucG9wKCk7XG4gICAgICBpZiAocmVuZGVyTWFzaykge1xuICAgICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKG1hc2tEYXRhLmZpbHRlclRleHR1cmUpO1xuICAgICAgfVxuICAgICAgQmlnUG9vbC5yZXR1cm4obWFza0RhdGEuZmlsdGVyRWZmZWN0KTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlTWFza1N0YWdlID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkFscGhhTWFza1BpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcImFscGhhTWFza1wiXG59O1xuXG5leHBvcnQgeyBBbHBoYU1hc2tQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbHBoYU1hc2tQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDb2xvck1hc2tQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9jb2xvclN0YWNrID0gW107XG4gICAgdGhpcy5fY29sb3JTdGFja0luZGV4ID0gMDtcbiAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSAwO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgYnVpbGRTdGFydCgpIHtcbiAgICB0aGlzLl9jb2xvclN0YWNrWzBdID0gMTU7XG4gICAgdGhpcy5fY29sb3JTdGFja0luZGV4ID0gMTtcbiAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSAxNTtcbiAgfVxuICBwdXNoKG1hc2ssIF9jb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICByZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgY29uc3QgY29sb3JTdGFjayA9IHRoaXMuX2NvbG9yU3RhY2s7XG4gICAgY29sb3JTdGFja1t0aGlzLl9jb2xvclN0YWNrSW5kZXhdID0gY29sb3JTdGFja1t0aGlzLl9jb2xvclN0YWNrSW5kZXggLSAxXSAmIG1hc2subWFzaztcbiAgICBjb25zdCBjdXJyZW50Q29sb3IgPSB0aGlzLl9jb2xvclN0YWNrW3RoaXMuX2NvbG9yU3RhY2tJbmRleF07XG4gICAgaWYgKGN1cnJlbnRDb2xvciAhPT0gdGhpcy5fY3VycmVudENvbG9yKSB7XG4gICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgICByZW5kZXJQaXBlSWQ6IFwiY29sb3JNYXNrXCIsXG4gICAgICAgIGNvbG9yTWFzazogY3VycmVudENvbG9yLFxuICAgICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fY29sb3JTdGFja0luZGV4Kys7XG4gIH1cbiAgcG9wKF9tYXNrLCBfY29udGFpbmVyLCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGNvbnN0IGNvbG9yU3RhY2sgPSB0aGlzLl9jb2xvclN0YWNrO1xuICAgIHRoaXMuX2NvbG9yU3RhY2tJbmRleC0tO1xuICAgIGNvbnN0IGN1cnJlbnRDb2xvciA9IGNvbG9yU3RhY2tbdGhpcy5fY29sb3JTdGFja0luZGV4IC0gMV07XG4gICAgaWYgKGN1cnJlbnRDb2xvciAhPT0gdGhpcy5fY3VycmVudENvbG9yKSB7XG4gICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgICByZW5kZXJQaXBlSWQ6IFwiY29sb3JNYXNrXCIsXG4gICAgICAgIGNvbG9yTWFzazogY3VycmVudENvbG9yLFxuICAgICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZShpbnN0cnVjdGlvbikge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgcmVuZGVyZXIuY29sb3JNYXNrLnNldE1hc2soaW5zdHJ1Y3Rpb24uY29sb3JNYXNrKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2NvbG9yU3RhY2sgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuQ29sb3JNYXNrUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiY29sb3JNYXNrXCJcbn07XG5cbmV4cG9ydCB7IENvbG9yTWFza1BpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yTWFza1BpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgY29sbGVjdEFsbFJlbmRlcmFibGVzIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2J1aWxkSW5zdHJ1Y3Rpb25zLm1qcyc7XG5pbXBvcnQgeyBDTEVBUiB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9nbC9jb25zdC5tanMnO1xuaW1wb3J0IHsgU1RFTkNJTF9NT0RFUyB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvY29uc3QubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBTdGVuY2lsTWFza1BpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIC8vIHVzZWQgd2hlbiBidWlsZGluZyBhbmQgYWxzbyB3aGVuIGV4ZWN1dGluZy4uXG4gICAgdGhpcy5fbWFza1N0YWNrSGFzaCA9IHt9O1xuICAgIHRoaXMuX21hc2tIYXNoID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBwdXNoKG1hc2ssIF9jb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVmZmVjdCA9IG1hc2s7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICByZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgcmVuZGVyZXIucmVuZGVyUGlwZXMuYmxlbmRNb2RlLnNldEJsZW5kTW9kZShlZmZlY3QubWFzaywgXCJub25lXCIsIGluc3RydWN0aW9uU2V0KTtcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgcmVuZGVyUGlwZUlkOiBcInN0ZW5jaWxNYXNrXCIsXG4gICAgICBhY3Rpb246IFwicHVzaE1hc2tCZWdpblwiLFxuICAgICAgbWFzayxcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBtYXNrQ29udGFpbmVyID0gZWZmZWN0Lm1hc2s7XG4gICAgbWFza0NvbnRhaW5lci5pbmNsdWRlSW5CdWlsZCA9IHRydWU7XG4gICAgaWYgKCF0aGlzLl9tYXNrSGFzaC5oYXMoZWZmZWN0KSkge1xuICAgICAgdGhpcy5fbWFza0hhc2guc2V0KGVmZmVjdCwge1xuICAgICAgICBpbnN0cnVjdGlvbnNTdGFydDogMCxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zTGVuZ3RoOiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLl9tYXNrSGFzaC5nZXQoZWZmZWN0KTtcbiAgICBtYXNrRGF0YS5pbnN0cnVjdGlvbnNTdGFydCA9IGluc3RydWN0aW9uU2V0Lmluc3RydWN0aW9uU2l6ZTtcbiAgICBjb2xsZWN0QWxsUmVuZGVyYWJsZXMoXG4gICAgICBtYXNrQ29udGFpbmVyLFxuICAgICAgaW5zdHJ1Y3Rpb25TZXQsXG4gICAgICByZW5kZXJlclxuICAgICk7XG4gICAgbWFza0NvbnRhaW5lci5pbmNsdWRlSW5CdWlsZCA9IGZhbHNlO1xuICAgIHJlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgcmVuZGVyUGlwZUlkOiBcInN0ZW5jaWxNYXNrXCIsXG4gICAgICBhY3Rpb246IFwicHVzaE1hc2tFbmRcIixcbiAgICAgIG1hc2ssXG4gICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zTGVuZ3RoID0gaW5zdHJ1Y3Rpb25TZXQuaW5zdHJ1Y3Rpb25TaXplIC0gbWFza0RhdGEuaW5zdHJ1Y3Rpb25zU3RhcnQgLSAxO1xuICAgIG1hc2tEYXRhLmluc3RydWN0aW9uc0xlbmd0aCA9IGluc3RydWN0aW9uc0xlbmd0aDtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRVaWQgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQucmVuZGVyVGFyZ2V0LnVpZDtcbiAgICAoX2EgPSB0aGlzLl9tYXNrU3RhY2tIYXNoKVtyZW5kZXJUYXJnZXRVaWRdID8/IChfYVtyZW5kZXJUYXJnZXRVaWRdID0gMCk7XG4gIH1cbiAgcG9wKG1hc2ssIF9jb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgZWZmZWN0ID0gbWFzaztcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHJlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICByZW5kZXJlci5yZW5kZXJQaXBlcy5ibGVuZE1vZGUuc2V0QmxlbmRNb2RlKGVmZmVjdC5tYXNrLCBcIm5vbmVcIiwgaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGluc3RydWN0aW9uU2V0LmFkZCh7XG4gICAgICByZW5kZXJQaXBlSWQ6IFwic3RlbmNpbE1hc2tcIixcbiAgICAgIGFjdGlvbjogXCJwb3BNYXNrQmVnaW5cIixcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBtYXNrRGF0YSA9IHRoaXMuX21hc2tIYXNoLmdldChtYXNrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hc2tEYXRhLmluc3RydWN0aW9uc0xlbmd0aDsgaSsrKSB7XG4gICAgICBpbnN0cnVjdGlvblNldC5pbnN0cnVjdGlvbnNbaW5zdHJ1Y3Rpb25TZXQuaW5zdHJ1Y3Rpb25TaXplKytdID0gaW5zdHJ1Y3Rpb25TZXQuaW5zdHJ1Y3Rpb25zW21hc2tEYXRhLmluc3RydWN0aW9uc1N0YXJ0KytdO1xuICAgIH1cbiAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgcmVuZGVyUGlwZUlkOiBcInN0ZW5jaWxNYXNrXCIsXG4gICAgICBhY3Rpb246IFwicG9wTWFza0VuZFwiLFxuICAgICAgY2FuQnVuZGxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGV4ZWN1dGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRVaWQgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQucmVuZGVyVGFyZ2V0LnVpZDtcbiAgICBsZXQgbWFza1N0YWNrSW5kZXggPSAoX2EgPSB0aGlzLl9tYXNrU3RhY2tIYXNoKVtyZW5kZXJUYXJnZXRVaWRdID8/IChfYVtyZW5kZXJUYXJnZXRVaWRdID0gMCk7XG4gICAgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJwdXNoTWFza0JlZ2luXCIpIHtcbiAgICAgIHJlbmRlcmVyLnJlbmRlclRhcmdldC5lbnN1cmVEZXB0aFN0ZW5jaWwoKTtcbiAgICAgIHJlbmRlcmVyLnN0ZW5jaWwuc2V0U3RlbmNpbE1vZGUoU1RFTkNJTF9NT0RFUy5SRU5ERVJJTkdfTUFTS19BREQsIG1hc2tTdGFja0luZGV4KTtcbiAgICAgIG1hc2tTdGFja0luZGV4Kys7XG4gICAgICByZW5kZXJlci5jb2xvck1hc2suc2V0TWFzaygwKTtcbiAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJwdXNoTWFza0VuZFwiKSB7XG4gICAgICByZW5kZXJlci5zdGVuY2lsLnNldFN0ZW5jaWxNb2RlKFNURU5DSUxfTU9ERVMuTUFTS19BQ1RJVkUsIG1hc2tTdGFja0luZGV4KTtcbiAgICAgIHJlbmRlcmVyLmNvbG9yTWFzay5zZXRNYXNrKDE1KTtcbiAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJwb3BNYXNrQmVnaW5cIikge1xuICAgICAgcmVuZGVyZXIuY29sb3JNYXNrLnNldE1hc2soMCk7XG4gICAgICBpZiAobWFza1N0YWNrSW5kZXggIT09IDApIHtcbiAgICAgICAgcmVuZGVyZXIuc3RlbmNpbC5zZXRTdGVuY2lsTW9kZShTVEVOQ0lMX01PREVTLlJFTkRFUklOR19NQVNLX1JFTU9WRSwgbWFza1N0YWNrSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmNsZWFyKG51bGwsIENMRUFSLlNURU5DSUwpO1xuICAgICAgICByZW5kZXJlci5zdGVuY2lsLnNldFN0ZW5jaWxNb2RlKFNURU5DSUxfTU9ERVMuRElTQUJMRUQsIG1hc2tTdGFja0luZGV4KTtcbiAgICAgIH1cbiAgICAgIG1hc2tTdGFja0luZGV4LS07XG4gICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwicG9wTWFza0VuZFwiKSB7XG4gICAgICByZW5kZXJlci5zdGVuY2lsLnNldFN0ZW5jaWxNb2RlKFNURU5DSUxfTU9ERVMuTUFTS19BQ1RJVkUsIG1hc2tTdGFja0luZGV4KTtcbiAgICAgIHJlbmRlcmVyLmNvbG9yTWFzay5zZXRNYXNrKDE1KTtcbiAgICB9XG4gICAgdGhpcy5fbWFza1N0YWNrSGFzaFtyZW5kZXJUYXJnZXRVaWRdID0gbWFza1N0YWNrSW5kZXg7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fbWFza1N0YWNrSGFzaCA9IG51bGw7XG4gICAgdGhpcy5fbWFza0hhc2ggPSBudWxsO1xuICB9XG59XG5TdGVuY2lsTWFza1BpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcInN0ZW5jaWxNYXNrXCJcbn07XG5cbmV4cG9ydCB7IFN0ZW5jaWxNYXNrUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RlbmNpbE1hc2tQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfQmFja2dyb3VuZFN5c3RlbSA9IGNsYXNzIF9CYWNrZ3JvdW5kU3lzdGVtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IHRydWU7XG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDApO1xuICAgIHRoaXMuY29sb3IgPSB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7XG4gICAgdGhpcy5hbHBoYSA9IDE7XG4gIH1cbiAgLyoqXG4gICAqIGluaXRpYXRlcyB0aGUgYmFja2dyb3VuZCBzeXN0ZW1cbiAgICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgb3B0aW9ucyBmb3IgdGhlIGJhY2tncm91bmQgY29sb3JzXG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fQmFja2dyb3VuZFN5c3RlbS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSBvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyO1xuICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmJhY2tncm91bmQgfHwgb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy5fYmFja2dyb3VuZENvbG9yO1xuICAgIHRoaXMuYWxwaGEgPSBvcHRpb25zLmJhY2tncm91bmRBbHBoYTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3Iuc2V0QWxwaGEob3B0aW9ucy5iYWNrZ3JvdW5kQWxwaGEpO1xuICB9XG4gIC8qKiBUaGUgYmFja2dyb3VuZCBjb2xvciB0byBmaWxsIGlmIG5vdCB0cmFuc3BhcmVudCAqL1xuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvcjtcbiAgfVxuICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3Iuc2V0VmFsdWUodmFsdWUpO1xuICB9XG4gIC8qKiBUaGUgYmFja2dyb3VuZCBjb2xvciBhbHBoYS4gU2V0dGluZyB0aGlzIHRvIDAgd2lsbCBtYWtlIHRoZSBjYW52YXMgdHJhbnNwYXJlbnQuICovXG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yLmFscGhhO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvci5zZXRBbHBoYSh2YWx1ZSk7XG4gIH1cbiAgLyoqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFzIGFuIFtSLCBHLCBCLCBBXSBhcnJheS4gKi9cbiAgZ2V0IGNvbG9yUmdiYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yLnRvQXJyYXkoKTtcbiAgfVxuICAvKipcbiAgICogZGVzdHJveXMgdGhlIGJhY2tncm91bmQgc3lzdGVtXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAaWdub3JlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICB9XG59O1xuLyoqIEBpZ25vcmUgKi9cbl9CYWNrZ3JvdW5kU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJiYWNrZ3JvdW5kXCIsXG4gIHByaW9yaXR5OiAwXG59O1xuLyoqIGRlZmF1bHQgb3B0aW9ucyB1c2VkIGJ5IHRoZSBzeXN0ZW0gKi9cbl9CYWNrZ3JvdW5kU3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICAvKipcbiAgICoge0BsaW5rIFdlYkdMT3B0aW9ucy5iYWNrZ3JvdW5kQWxwaGF9XG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGJhY2tncm91bmRBbHBoYTogMSxcbiAgLyoqXG4gICAqIHtAbGluayBXZWJHTE9wdGlvbnMuYmFja2dyb3VuZENvbG9yfVxuICAgKiBAZGVmYXVsdCAweDAwMDAwMFxuICAgKi9cbiAgYmFja2dyb3VuZENvbG9yOiAwLFxuICAvKipcbiAgICoge0BsaW5rIFdlYkdMT3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWVcbn07XG5sZXQgQmFja2dyb3VuZFN5c3RlbSA9IF9CYWNrZ3JvdW5kU3lzdGVtO1xuXG5leHBvcnQgeyBCYWNrZ3JvdW5kU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYWNrZ3JvdW5kU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEZpbHRlckVmZmVjdCB9IGZyb20gJy4uLy4uLy4uLy4uL2ZpbHRlcnMvRmlsdGVyRWZmZWN0Lm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgQkxFTkRfTU9ERV9GSUxURVJTID0ge307XG5leHRlbnNpb25zLmhhbmRsZShFeHRlbnNpb25UeXBlLkJsZW5kTW9kZSwgKHZhbHVlKSA9PiB7XG4gIGlmICghdmFsdWUubmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJsZW5kTW9kZSBleHRlbnNpb24gbXVzdCBoYXZlIGEgbmFtZSBwcm9wZXJ0eVwiKTtcbiAgfVxuICBCTEVORF9NT0RFX0ZJTFRFUlNbdmFsdWUubmFtZV0gPSB2YWx1ZS5yZWY7XG59LCAodmFsdWUpID0+IHtcbiAgZGVsZXRlIEJMRU5EX01PREVfRklMVEVSU1t2YWx1ZS5uYW1lXTtcbn0pO1xuY2xhc3MgQmxlbmRNb2RlUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5faXNBZHZhbmNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbHRlckhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGVuc3VyZXMgdGhhdCBhIGJsZW5kTW9kZSBzd2l0Y2ggaXMgYWRkZWQgdG8gdGhlIGluc3RydWN0aW9uIHNldCBpZiB0aGUgYmxlbmQgbW9kZSBoYXMgY2hhbmdlZC5cbiAgICogQHBhcmFtIHJlbmRlcmFibGUgLSBUaGUgcmVuZGVyYWJsZSB3ZSBhcmUgYWRkaW5nIHRvIHRoZSBpbnN0cnVjdGlvbiBzZXRcbiAgICogQHBhcmFtIGJsZW5kTW9kZSAtIFRoZSBibGVuZCBtb2RlIG9mIHRoZSByZW5kZXJhYmxlXG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvblNldCAtIFRoZSBpbnN0cnVjdGlvbiBzZXQgd2UgYXJlIGFkZGluZyB0b1xuICAgKi9cbiAgc2V0QmxlbmRNb2RlKHJlbmRlcmFibGUsIGJsZW5kTW9kZSwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlQmxlbmRNb2RlID09PSBibGVuZE1vZGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc0FkdmFuY2VkKVxuICAgICAgICB0aGlzLl9yZW5kZXJhYmxlTGlzdC5wdXNoKHJlbmRlcmFibGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmVCbGVuZE1vZGUgPSBibGVuZE1vZGU7XG4gICAgaWYgKHRoaXMuX2lzQWR2YW5jZWQpIHtcbiAgICAgIHRoaXMuX2VuZEFkdmFuY2VkQmxlbmRNb2RlKGluc3RydWN0aW9uU2V0KTtcbiAgICB9XG4gICAgdGhpcy5faXNBZHZhbmNlZCA9ICEhQkxFTkRfTU9ERV9GSUxURVJTW2JsZW5kTW9kZV07XG4gICAgaWYgKHRoaXMuX2lzQWR2YW5jZWQpIHtcbiAgICAgIHRoaXMuX2JlZ2luQWR2YW5jZWRCbGVuZE1vZGUoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgICAgdGhpcy5fcmVuZGVyYWJsZUxpc3QucHVzaChyZW5kZXJhYmxlKTtcbiAgICB9XG4gIH1cbiAgX2JlZ2luQWR2YW5jZWRCbGVuZE1vZGUoaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgY29uc3QgYmxlbmRNb2RlID0gdGhpcy5fYWN0aXZlQmxlbmRNb2RlO1xuICAgIGlmICghQkxFTkRfTU9ERV9GSUxURVJTW2JsZW5kTW9kZV0pIHtcbiAgICAgIHdhcm4oYFVuYWJsZSB0byBhc3NpZ24gQmxlbmRNb2RlOiAnJHtibGVuZE1vZGV9Jy4gWW91IG1heSB3YW50IHRvIGluY2x1ZGU6IGltcG9ydCAncGl4aS5qcy9hZHZhbmNlZC1ibGVuZC1tb2RlcydgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZpbHRlckVmZmVjdCA9IHRoaXMuX2ZpbHRlckhhc2hbYmxlbmRNb2RlXTtcbiAgICBpZiAoIWZpbHRlckVmZmVjdCkge1xuICAgICAgZmlsdGVyRWZmZWN0ID0gdGhpcy5fZmlsdGVySGFzaFtibGVuZE1vZGVdID0gbmV3IEZpbHRlckVmZmVjdCgpO1xuICAgICAgZmlsdGVyRWZmZWN0LmZpbHRlcnMgPSBbbmV3IEJMRU5EX01PREVfRklMVEVSU1tibGVuZE1vZGVdKCldO1xuICAgIH1cbiAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHtcbiAgICAgIHJlbmRlclBpcGVJZDogXCJmaWx0ZXJcIixcbiAgICAgIGFjdGlvbjogXCJwdXNoRmlsdGVyXCIsXG4gICAgICByZW5kZXJhYmxlczogW10sXG4gICAgICBmaWx0ZXJFZmZlY3QsXG4gICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLl9yZW5kZXJhYmxlTGlzdCA9IGluc3RydWN0aW9uLnJlbmRlcmFibGVzO1xuICAgIGluc3RydWN0aW9uU2V0LmFkZChpbnN0cnVjdGlvbik7XG4gIH1cbiAgX2VuZEFkdmFuY2VkQmxlbmRNb2RlKGluc3RydWN0aW9uU2V0KSB7XG4gICAgdGhpcy5fcmVuZGVyYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoe1xuICAgICAgcmVuZGVyUGlwZUlkOiBcImZpbHRlclwiLFxuICAgICAgYWN0aW9uOiBcInBvcEZpbHRlclwiLFxuICAgICAgY2FuQnVuZGxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBjYWxsZWQgd2hlbiB0aGUgaW5zdHJ1Y3Rpb24gYnVpbGQgcHJvY2VzcyBpcyBzdGFydGluZyB0aGlzIHdpbGwgcmVzZXQgaW50ZXJuYWxseSB0byB0aGUgZGVmYXVsdCBibGVuZCBtb2RlXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAaWdub3JlXG4gICAqL1xuICBidWlsZFN0YXJ0KCkge1xuICAgIHRoaXMuX2lzQWR2YW5jZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogY2FsbGVkIHdoZW4gdGhlIGluc3RydWN0aW9uIGJ1aWxkIHByb2Nlc3MgaXMgZmluaXNoZWQsIGVuc3VyaW5nIHRoYXQgaWYgdGhlcmUgaXMgYW4gYWR2YW5jZWQgYmxlbmQgbW9kZVxuICAgKiBhY3RpdmUsIHdlIGFkZCB0aGUgZmluYWwgcmVuZGVyIGluc3RydWN0aW9ucyBhZGRlZCB0byB0aGUgaW5zdHJ1Y3Rpb24gc2V0XG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvblNldCAtIFRoZSBpbnN0cnVjdGlvbiBzZXQgd2UgYXJlIGFkZGluZyB0b1xuICAgKiBAaW50ZXJuYWxcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgYnVpbGRFbmQoaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBpZiAodGhpcy5faXNBZHZhbmNlZCkge1xuICAgICAgdGhpcy5fZW5kQWR2YW5jZWRCbGVuZE1vZGUoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmFibGVMaXN0ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fZmlsdGVySGFzaCkge1xuICAgICAgdGhpcy5fZmlsdGVySGFzaFtpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX2ZpbHRlckhhc2ggPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuQmxlbmRNb2RlUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiYmxlbmRNb2RlXCJcbn07XG5cbmV4cG9ydCB7IEJsZW5kTW9kZVBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsZW5kTW9kZVBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGltYWdlVHlwZXMgPSB7XG4gIHBuZzogXCJpbWFnZS9wbmdcIixcbiAganBnOiBcImltYWdlL2pwZWdcIixcbiAgd2VicDogXCJpbWFnZS93ZWJwXCJcbn07XG5jb25zdCBfRXh0cmFjdFN5c3RlbSA9IGNsYXNzIF9FeHRyYWN0U3lzdGVtIHtcbiAgLyoqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBfbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0cyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBDb250YWluZXIgfHwgb3B0aW9ucyBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogb3B0aW9ucyxcbiAgICAgICAgLi4uZGVmYXVsdHNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWZhdWx0cyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiBhIEhUTUwgSW1hZ2Ugb2YgdGhlIHRhcmdldFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgaW1hZ2UsIG9yIHRoZSB0YXJnZXQgdG8gZXh0cmFjdFxuICAgKiBAcmV0dXJucyAtIEhUTUwgSW1hZ2Ugb2YgdGhlIHRhcmdldFxuICAgKi9cbiAgYXN5bmMgaW1hZ2Uob3B0aW9ucykge1xuICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uuc3JjID0gYXdhaXQgdGhpcy5iYXNlNjQob3B0aW9ucyk7XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiB0aGlzIHRhcmdldC4gSXQgd29ya3MgYnkgY2FsbGluZ1xuICAgKiBgRXh0cmFjdC5jYW52YXNgIGFuZCB0aGVuIHJ1bm5pbmcgdG9EYXRhVVJMIG9uIHRoYXQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBpbWFnZSwgb3IgdGhlIHRhcmdldCB0byBleHRyYWN0XG4gICAqL1xuICBhc3luYyBiYXNlNjQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLl9ub3JtYWxpemVPcHRpb25zKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIF9FeHRyYWN0U3lzdGVtLmRlZmF1bHRJbWFnZU9wdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IHsgZm9ybWF0LCBxdWFsaXR5IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzKG9wdGlvbnMpO1xuICAgIGlmIChjYW52YXMudG9CbG9iICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNhbnZhcy50b0Jsb2IoKGJsb2IpID0+IHtcbiAgICAgICAgICBpZiAoIWJsb2IpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJJQ2FudmFzLnRvQmxvYiBmYWlsZWQhXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICAgICAgfSwgaW1hZ2VUeXBlc1tmb3JtYXRdLCBxdWFsaXR5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY2FudmFzLnRvRGF0YVVSTCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChpbWFnZVR5cGVzW2Zvcm1hdF0sIHF1YWxpdHkpO1xuICAgIH1cbiAgICBpZiAoY2FudmFzLmNvbnZlcnRUb0Jsb2IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IGNhbnZhcy5jb252ZXJ0VG9CbG9iKHsgdHlwZTogaW1hZ2VUeXBlc1tmb3JtYXRdLCBxdWFsaXR5IH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRyYWN0LmJhc2U2NCgpIHJlcXVpcmVzIElDYW52YXMudG9EYXRhVVJMLCBJQ2FudmFzLnRvQmxvYiwgb3IgSUNhbnZhcy5jb252ZXJ0VG9CbG9iIHRvIGJlIGltcGxlbWVudGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ2FudmFzIGVsZW1lbnQsIHJlbmRlcnMgdGhpcyB0YXJnZXQgdG8gaXQgYW5kIHRoZW4gcmV0dXJucyBpdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIGNhbnZhcywgb3IgdGhlIHRhcmdldCB0byBleHRyYWN0XG4gICAqIEByZXR1cm5zIC0gQSBDYW52YXMgZWxlbWVudCB3aXRoIHRoZSB0ZXh0dXJlIHJlbmRlcmVkIG9uLlxuICAgKi9cbiAgY2FudmFzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5fbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIudGV4dHVyZS5nZW5lcmF0ZUNhbnZhcyh0YXJnZXQpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0dXJlID0gcmVuZGVyZXIudGV4dHVyZUdlbmVyYXRvci5nZW5lcmF0ZVRleHR1cmUob3B0aW9ucyk7XG4gICAgY29uc3QgY2FudmFzID0gcmVuZGVyZXIudGV4dHVyZS5nZW5lcmF0ZUNhbnZhcyh0ZXh0dXJlKTtcbiAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiBhIG9uZS1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIG9mIHRoZSBlbnRpcmUgdGV4dHVyZSBpbiBSR0JBXG4gICAqIG9yZGVyLCB3aXRoIGludGVnZXIgdmFsdWVzIGJldHdlZW4gMCBhbmQgMjU1IChpbmNsdWRlZCkuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGV4dHJhY3RpbmcgdGhlIGltYWdlLCBvciB0aGUgdGFyZ2V0IHRvIGV4dHJhY3RcbiAgICogQHJldHVybnMgLSBPbmUtZGltZW5zaW9uYWwgYXJyYXkgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBvZiB0aGUgZW50aXJlIHRleHR1cmVcbiAgICovXG4gIHBpeGVscyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuX25vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGFyZ2V0IGluc3RhbmNlb2YgVGV4dHVyZSA/IHRhcmdldCA6IHJlbmRlcmVyLnRleHR1cmVHZW5lcmF0b3IuZ2VuZXJhdGVUZXh0dXJlKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBpeGVsSW5mbyA9IHJlbmRlcmVyLnRleHR1cmUuZ2V0UGl4ZWxzKHRleHR1cmUpO1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcbiAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxJbmZvO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiBhIHRleHR1cmUgb2YgdGhlIHRhcmdldFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgdGV4dHVyZSwgb3IgdGhlIHRhcmdldCB0byBleHRyYWN0XG4gICAqIEByZXR1cm5zIC0gQSB0ZXh0dXJlIG9mIHRoZSB0YXJnZXRcbiAgICovXG4gIHRleHR1cmUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLl9ub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRhcmdldCBpbnN0YW5jZW9mIFRleHR1cmUpXG4gICAgICByZXR1cm4gb3B0aW9ucy50YXJnZXQ7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnRleHR1cmVHZW5lcmF0b3IuZ2VuZXJhdGVUZXh0dXJlKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIGV4dHJhY3QgYSBIVE1MSW1hZ2Ugb2YgdGhlIHRhcmdldCBhbmQgZG93bmxvYWQgaXRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgZG93bmxvYWRpbmcgYW5kIGV4dHJhY3RpbmcgdGhlIGltYWdlLCBvciB0aGUgdGFyZ2V0IHRvIGV4dHJhY3RcbiAgICovXG4gIGRvd25sb2FkKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5fbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcyhvcHRpb25zKTtcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbGluay5kb3dubG9hZCA9IG9wdGlvbnMuZmlsZW5hbWUgPz8gXCJpbWFnZS5wbmdcIjtcbiAgICBsaW5rLmhyZWYgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgbGluay5jbGljaygpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG4gIH1cbiAgLyoqXG4gICAqIExvZ3MgdGhlIHRhcmdldCB0byB0aGUgY29uc29sZSBhcyBhbiBpbWFnZS4gVGhpcyBpcyBhIHVzZWZ1bCB3YXkgdG8gZGVidWcgd2hhdCdzIGhhcHBlbmluZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGxvZ2dpbmcgdGhlIGltYWdlLCBvciB0aGUgdGFyZ2V0IHRvIGxvZ1xuICAgKi9cbiAgbG9nKG9wdGlvbnMpIHtcbiAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMud2lkdGggPz8gMjAwO1xuICAgIG9wdGlvbnMgPSB0aGlzLl9ub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGJhc2U2NCA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICBjb25zb2xlLmxvZyhgW1BpeGkgVGV4dHVyZV0gJHtjYW52YXMud2lkdGh9cHggJHtjYW52YXMuaGVpZ2h0fXB4YCk7XG4gICAgY29uc3Qgc3R5bGUgPSBbXG4gICAgICBcImZvbnQtc2l6ZTogMXB4O1wiLFxuICAgICAgYHBhZGRpbmc6ICR7d2lkdGh9cHggJHszMDB9cHg7YCxcbiAgICAgIGBiYWNrZ3JvdW5kOiB1cmwoJHtiYXNlNjR9KSBuby1yZXBlYXQ7YCxcbiAgICAgIFwiYmFja2dyb3VuZC1zaXplOiBjb250YWluO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgICBjb25zb2xlLmxvZyhcIiVjIFwiLCBzdHlsZSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn07XG4vKiogQGlnbm9yZSAqL1xuX0V4dHJhY3RTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcImV4dHJhY3RcIlxufTtcbi8qKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGNyZWF0aW5nIGFuIGltYWdlLiAqL1xuX0V4dHJhY3RTeXN0ZW0uZGVmYXVsdEltYWdlT3B0aW9ucyA9IHtcbiAgLyoqIFRoZSBmb3JtYXQgb2YgdGhlIGltYWdlLiAqL1xuICBmb3JtYXQ6IFwicG5nXCIsXG4gIC8qKiBUaGUgcXVhbGl0eSBvZiB0aGUgaW1hZ2UuICovXG4gIHF1YWxpdHk6IDFcbn07XG5sZXQgRXh0cmFjdFN5c3RlbSA9IF9FeHRyYWN0U3lzdGVtO1xuXG5leHBvcnQgeyBFeHRyYWN0U3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRyYWN0U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmVTb3VyY2UgfSBmcm9tICcuL3NvdXJjZXMvVGV4dHVyZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFJlbmRlclRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcbiAgc3RhdGljIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJUZXh0dXJlKHtcbiAgICAgIHNvdXJjZTogbmV3IFRleHR1cmVTb3VyY2Uob3B0aW9ucylcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBuZXcgd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSBuZXcgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEByZXR1cm5zIFRoaXMgdGV4dHVyZS5cbiAgICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zb3VyY2UucmVzaXplKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmV4cG9ydCB7IFJlbmRlclRleHR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbmRlclRleHR1cmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgQm91bmRzIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9Cb3VuZHMubWpzJztcbmltcG9ydCB7IGdldExvY2FsQm91bmRzIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRMb2NhbEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgUmVuZGVyVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmUvUmVuZGVyVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBSZWN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuY29uc3QgdGVtcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbmNvbnN0IG5vQ29sb3IgPSBbMCwgMCwgMCwgMF07XG5jbGFzcyBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXG4gICAqIEEgVXNlZnVsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRleHR1cmUgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgY2FuIHRoZW4gYmUgdXNlZCB0byBjcmVhdGUgc3ByaXRlc1xuICAgKiBUaGlzIGNhbiBiZSBxdWl0ZSB1c2VmdWwgaWYgeW91ciBjb250YWluZXIgaXMgY29tcGxpY2F0ZWQgYW5kIG5lZWRzIHRvIGJlIHJldXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICogQHBhcmFtIHtHZW5lcmF0ZVRleHR1cmVPcHRpb25zIHwgQ29udGFpbmVyfSBvcHRpb25zIC0gR2VuZXJhdGUgdGV4dHVyZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NvbnRhaW5lcn0gW29wdGlvbnMuY29udGFpbmVyXSAtIElmIG5vdCBnaXZlbiwgdGhlIHJlbmRlcmVyJ3MgcmVzb2x1dGlvbiBpcyB1c2VkLlxuICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gb3B0aW9ucy5yZWdpb24gLSBUaGUgcmVnaW9uIG9mIHRoZSBjb250YWluZXIsIHRoYXQgc2hhbGwgYmUgcmVuZGVyZWQsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uXSAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlIGJlaW5nIGdlbmVyYXRlZC5cbiAgICogICAgICAgIGlmIG5vIHJlZ2lvbiBpcyBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHtHZW5lcmF0ZVRleHR1cmVTb3VyY2VPcHRpb25zfSBbb3B0aW9ucy50ZXh0dXJlU291cmNlT3B0aW9uc10gLSBUZXh0dXJlIG9wdGlvbnMgZm9yIEdQVS5cbiAgICogQHJldHVybnMgYSBzaGlueSBuZXcgdGV4dHVyZSBvZiB0aGUgY29udGFpbmVyIHBhc3NlZCBpblxuICAgKi9cbiAgZ2VuZXJhdGVUZXh0dXJlKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgdGFyZ2V0OiBvcHRpb25zLFxuICAgICAgICBmcmFtZTogdm9pZCAwLFxuICAgICAgICB0ZXh0dXJlU291cmNlT3B0aW9uczoge30sXG4gICAgICAgIHJlc29sdXRpb246IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbiB8fCB0aGlzLl9yZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IGFudGlhbGlhcyA9IG9wdGlvbnMuYW50aWFsaWFzIHx8IHRoaXMuX3JlbmRlcmVyLnZpZXcuYW50aWFsaWFzO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG9wdGlvbnMudGFyZ2V0O1xuICAgIGxldCBjbGVhckNvbG9yID0gb3B0aW9ucy5jbGVhckNvbG9yO1xuICAgIGlmIChjbGVhckNvbG9yKSB7XG4gICAgICBjb25zdCBpc1JHQkFBcnJheSA9IEFycmF5LmlzQXJyYXkoY2xlYXJDb2xvcikgJiYgY2xlYXJDb2xvci5sZW5ndGggPT09IDQ7XG4gICAgICBjbGVhckNvbG9yID0gaXNSR0JBQXJyYXkgPyBjbGVhckNvbG9yIDogQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNsZWFyQ29sb3IpLnRvQXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJDb2xvciA9IG5vQ29sb3I7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lvbiA9IG9wdGlvbnMuZnJhbWU/LmNvcHlUbyh0ZW1wUmVjdCkgfHwgZ2V0TG9jYWxCb3VuZHMoY29udGFpbmVyLCB0ZW1wQm91bmRzKS5yZWN0YW5nbGU7XG4gICAgcmVnaW9uLndpZHRoID0gTWF0aC5tYXgocmVnaW9uLndpZHRoLCAxIC8gcmVzb2x1dGlvbikgfCAwO1xuICAgIHJlZ2lvbi5oZWlnaHQgPSBNYXRoLm1heChyZWdpb24uaGVpZ2h0LCAxIC8gcmVzb2x1dGlvbikgfCAwO1xuICAgIGNvbnN0IHRhcmdldCA9IFJlbmRlclRleHR1cmUuY3JlYXRlKHtcbiAgICAgIC4uLm9wdGlvbnMudGV4dHVyZVNvdXJjZU9wdGlvbnMsXG4gICAgICB3aWR0aDogcmVnaW9uLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWdpb24uaGVpZ2h0LFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGFudGlhbGlhc1xuICAgIH0pO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IE1hdHJpeC5zaGFyZWQudHJhbnNsYXRlKC1yZWdpb24ueCwgLXJlZ2lvbi55KTtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXIoe1xuICAgICAgY29udGFpbmVyLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY2xlYXJDb2xvclxuICAgIH0pO1xuICAgIHRhcmdldC5zb3VyY2UudXBkYXRlTWlwbWFwcygpO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HZW5lcmF0ZVRleHR1cmVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcInRleHR1cmVHZW5lcmF0b3JcIlxufTtcblxuZXhwb3J0IHsgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9wb2ludC9Qb2ludC5tanMnO1xuaW1wb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSB9IGZyb20gJy4uLy4uLy4uLy4uL3NjZW5lL2dyYXBoaWNzL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vLi4vZ3B1L3NoYWRlci9CaW5kR3JvdXAubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR2xvYmFsVW5pZm9ybVN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fc3RhY2tJbmRleCA9IDA7XG4gICAgdGhpcy5fZ2xvYmFsVW5pZm9ybURhdGFTdGFjayA9IFtdO1xuICAgIHRoaXMuX3VuaWZvcm1zUG9vbCA9IFtdO1xuICAgIHRoaXMuX2FjdGl2ZVVuaWZvcm1zID0gW107XG4gICAgdGhpcy5fYmluZEdyb3VwUG9vbCA9IFtdO1xuICAgIHRoaXMuX2FjdGl2ZUJpbmRHcm91cHMgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3N0YWNrSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWN0aXZlVW5pZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3VuaWZvcm1zUG9vbC5wdXNoKHRoaXMuX2FjdGl2ZVVuaWZvcm1zW2ldKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY3RpdmVCaW5kR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9iaW5kR3JvdXBQb29sLnB1c2godGhpcy5fYWN0aXZlQmluZEdyb3Vwc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVVuaWZvcm1zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fYWN0aXZlQmluZEdyb3Vwcy5sZW5ndGggPSAwO1xuICB9XG4gIHN0YXJ0KG9wdGlvbnMpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5wdXNoKG9wdGlvbnMpO1xuICB9XG4gIGJpbmQoe1xuICAgIHNpemUsXG4gICAgcHJvamVjdGlvbk1hdHJpeCxcbiAgICB3b3JsZFRyYW5zZm9ybU1hdHJpeCxcbiAgICB3b3JsZENvbG9yLFxuICAgIG9mZnNldFxuICB9KSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlclRhcmdldDtcbiAgICBjb25zdCBjdXJyZW50R2xvYmFsVW5pZm9ybURhdGEgPSB0aGlzLl9zdGFja0luZGV4ID8gdGhpcy5fZ2xvYmFsVW5pZm9ybURhdGFTdGFja1t0aGlzLl9zdGFja0luZGV4IC0gMV0gOiB7XG4gICAgICBwcm9qZWN0aW9uRGF0YTogcmVuZGVyVGFyZ2V0LFxuICAgICAgd29ybGRUcmFuc2Zvcm1NYXRyaXg6IG5ldyBNYXRyaXgoKSxcbiAgICAgIHdvcmxkQ29sb3I6IDQyOTQ5NjcyOTUsXG4gICAgICBvZmZzZXQ6IG5ldyBQb2ludCgpXG4gICAgfTtcbiAgICBjb25zdCBnbG9iYWxVbmlmb3JtRGF0YSA9IHtcbiAgICAgIHByb2plY3Rpb25NYXRyaXg6IHByb2plY3Rpb25NYXRyaXggfHwgdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgsXG4gICAgICByZXNvbHV0aW9uOiBzaXplIHx8IHJlbmRlclRhcmdldC5zaXplLFxuICAgICAgd29ybGRUcmFuc2Zvcm1NYXRyaXg6IHdvcmxkVHJhbnNmb3JtTWF0cml4IHx8IGN1cnJlbnRHbG9iYWxVbmlmb3JtRGF0YS53b3JsZFRyYW5zZm9ybU1hdHJpeCxcbiAgICAgIHdvcmxkQ29sb3I6IHdvcmxkQ29sb3IgfHwgY3VycmVudEdsb2JhbFVuaWZvcm1EYXRhLndvcmxkQ29sb3IsXG4gICAgICBvZmZzZXQ6IG9mZnNldCB8fCBjdXJyZW50R2xvYmFsVW5pZm9ybURhdGEub2Zmc2V0LFxuICAgICAgYmluZEdyb3VwOiBudWxsXG4gICAgfTtcbiAgICBjb25zdCB1bmlmb3JtR3JvdXAgPSB0aGlzLl91bmlmb3Jtc1Bvb2wucG9wKCkgfHwgdGhpcy5fY3JlYXRlVW5pZm9ybXMoKTtcbiAgICB0aGlzLl9hY3RpdmVVbmlmb3Jtcy5wdXNoKHVuaWZvcm1Hcm91cCk7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB1bmlmb3JtR3JvdXAudW5pZm9ybXM7XG4gICAgdW5pZm9ybXMudVByb2plY3Rpb25NYXRyaXggPSBnbG9iYWxVbmlmb3JtRGF0YS5wcm9qZWN0aW9uTWF0cml4O1xuICAgIHVuaWZvcm1zLnVSZXNvbHV0aW9uID0gZ2xvYmFsVW5pZm9ybURhdGEucmVzb2x1dGlvbjtcbiAgICB1bmlmb3Jtcy51V29ybGRUcmFuc2Zvcm1NYXRyaXguY29weUZyb20oZ2xvYmFsVW5pZm9ybURhdGEud29ybGRUcmFuc2Zvcm1NYXRyaXgpO1xuICAgIHVuaWZvcm1zLnVXb3JsZFRyYW5zZm9ybU1hdHJpeC50eCAtPSBnbG9iYWxVbmlmb3JtRGF0YS5vZmZzZXQueDtcbiAgICB1bmlmb3Jtcy51V29ybGRUcmFuc2Zvcm1NYXRyaXgudHkgLT0gZ2xvYmFsVW5pZm9ybURhdGEub2Zmc2V0Lnk7XG4gICAgY29sb3IzMkJpdFRvVW5pZm9ybShcbiAgICAgIGdsb2JhbFVuaWZvcm1EYXRhLndvcmxkQ29sb3IsXG4gICAgICB1bmlmb3Jtcy51V29ybGRDb2xvckFscGhhLFxuICAgICAgMFxuICAgICk7XG4gICAgdW5pZm9ybUdyb3VwLnVwZGF0ZSgpO1xuICAgIGxldCBiaW5kR3JvdXA7XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLnVuaWZvcm1CYXRjaCkge1xuICAgICAgYmluZEdyb3VwID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMudW5pZm9ybUJhdGNoLmdldFVuaWZvcm1CaW5kR3JvdXAodW5pZm9ybUdyb3VwLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpbmRHcm91cCA9IHRoaXMuX2JpbmRHcm91cFBvb2wucG9wKCkgfHwgbmV3IEJpbmRHcm91cCgpO1xuICAgICAgdGhpcy5fYWN0aXZlQmluZEdyb3Vwcy5wdXNoKGJpbmRHcm91cCk7XG4gICAgICBiaW5kR3JvdXAuc2V0UmVzb3VyY2UodW5pZm9ybUdyb3VwLCAwKTtcbiAgICB9XG4gICAgZ2xvYmFsVW5pZm9ybURhdGEuYmluZEdyb3VwID0gYmluZEdyb3VwO1xuICAgIHRoaXMuX2N1cnJlbnRHbG9iYWxVbmlmb3JtRGF0YSA9IGdsb2JhbFVuaWZvcm1EYXRhO1xuICB9XG4gIHB1c2gob3B0aW9ucykge1xuICAgIHRoaXMuYmluZChvcHRpb25zKTtcbiAgICB0aGlzLl9nbG9iYWxVbmlmb3JtRGF0YVN0YWNrW3RoaXMuX3N0YWNrSW5kZXgrK10gPSB0aGlzLl9jdXJyZW50R2xvYmFsVW5pZm9ybURhdGE7XG4gIH1cbiAgcG9wKCkge1xuICAgIHRoaXMuX2N1cnJlbnRHbG9iYWxVbmlmb3JtRGF0YSA9IHRoaXMuX2dsb2JhbFVuaWZvcm1EYXRhU3RhY2tbLS10aGlzLl9zdGFja0luZGV4IC0gMV07XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyLnR5cGUgPT09IFJlbmRlcmVyVHlwZS5XRUJHTCkge1xuICAgICAgdGhpcy5fY3VycmVudEdsb2JhbFVuaWZvcm1EYXRhLmJpbmRHcm91cC5yZXNvdXJjZXNbMF0udXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGdldCBiaW5kR3JvdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRHbG9iYWxVbmlmb3JtRGF0YS5iaW5kR3JvdXA7XG4gIH1cbiAgZ2V0IHVuaWZvcm1Hcm91cCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEdsb2JhbFVuaWZvcm1EYXRhLmJpbmRHcm91cC5yZXNvdXJjZXNbMF07XG4gIH1cbiAgX2NyZWF0ZVVuaWZvcm1zKCkge1xuICAgIGNvbnN0IGdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1UHJvamVjdGlvbk1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVXb3JsZFRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIC8vIFRPRE8gLSBzb21lb25lIHNtYXJ0IC0gc2V0IHRoaXMgdG8gYmUgYSB1bm9ybTh4NCByYXRoZXIgdGhhbiBhIHZlYzQ8ZjMyPlxuICAgICAgdVdvcmxkQ29sb3JBbHBoYTogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdVJlc29sdXRpb246IHsgdmFsdWU6IFswLCAwXSwgdHlwZTogXCJ2ZWMyPGYzMj5cIiB9XG4gICAgfSwge1xuICAgICAgaXNTdGF0aWM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZ2xvYmFsVW5pZm9ybXM7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HbG9iYWxVbmlmb3JtU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJnbG9iYWxVbmlmb3Jtc1wiXG59O1xuXG5leHBvcnQgeyBHbG9iYWxVbmlmb3JtU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbG9iYWxVbmlmb3JtU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFRpY2tlciB9IGZyb20gJy4uLy4uLy4uL3RpY2tlci9UaWNrZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgdWlkID0gMTtcbmNsYXNzIFNjaGVkdWxlclN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3Rhc2tzID0gW107XG4gIH1cbiAgLyoqIEluaXRpYWxpemVzIHRoZSBzY2hlZHVsZXIgc3lzdGVtIGFuZCBzdGFydHMgdGhlIHRpY2tlci4gKi9cbiAgaW5pdCgpIHtcbiAgICBUaWNrZXIuc3lzdGVtLmFkZCh0aGlzLl91cGRhdGUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYSByZXBlYXRpbmcgdGFzay5cbiAgICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICogQHBhcmFtIGR1cmF0aW9uIC0gVGhlIGludGVydmFsIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHJldHVybnMgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc2NoZWR1bGVkIHRhc2suXG4gICAqL1xuICByZXBlYXQoZnVuYywgZHVyYXRpb24pIHtcbiAgICBjb25zdCBpZCA9IHVpZCsrO1xuICAgIHRoaXMuX3Rhc2tzLnB1c2goe1xuICAgICAgZnVuYyxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgc3RhcnQ6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgbGFzdDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICByZXBlYXQ6IHRydWUsXG4gICAgICBpZFxuICAgIH0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICAvKipcbiAgICogQ2FuY2VscyBhIHNjaGVkdWxlZCB0YXNrLlxuICAgKiBAcGFyYW0gaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRhc2sgdG8gY2FuY2VsLlxuICAgKi9cbiAgY2FuY2VsKGlkKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90YXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX3Rhc2tzW2ldLmlkID09PSBpZCkge1xuICAgICAgICB0aGlzLl90YXNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW5kIGV4ZWN1dGVzIHRoZSBzY2hlZHVsZWQgdGFza3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlKCkge1xuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLl90YXNrc1tpXTtcbiAgICAgIGlmIChub3cgLSB0YXNrLmxhc3QgPj0gdGFzay5kdXJhdGlvbikge1xuICAgICAgICBjb25zdCBlbGFwc2VkID0gbm93IC0gdGFzay5zdGFydDtcbiAgICAgICAgdGFzay5mdW5jKGVsYXBzZWQpO1xuICAgICAgICB0YXNrLmxhc3QgPSBub3c7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgc2NoZWR1bGVyIHN5c3RlbSBhbmQgcmVtb3ZlcyBhbGwgdGFza3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAaWdub3JlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIFRpY2tlci5zeXN0ZW0ucmVtb3ZlKHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gICAgdGhpcy5fdGFza3MubGVuZ3RoID0gMDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cblNjaGVkdWxlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwic2NoZWR1bGVyXCIsXG4gIHByaW9yaXR5OiAwXG59O1xuXG5leHBvcnQgeyBTY2hlZHVsZXJTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjaGVkdWxlclN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBzYXlIZWxsbyB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL3NheUhlbGxvLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuLi8uLi90eXBlcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEhlbGxvU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBJdCBhbGwgc3RhcnRzIGhlcmUhIFRoaXMgaW5pdGlhdGVzIGV2ZXJ5IHN5c3RlbSwgcGFzc2luZyBpbiB0aGUgb3B0aW9ucyBmb3IgYW55IHN5c3RlbSBieSBuYW1lLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBjb25maWcgZm9yIHRoZSByZW5kZXJlciBhbmQgYWxsIGl0cyBzeXN0ZW1zXG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oZWxsbykge1xuICAgICAgbGV0IG5hbWUgPSB0aGlzLl9yZW5kZXJlci5uYW1lO1xuICAgICAgaWYgKHRoaXMuX3JlbmRlcmVyLnR5cGUgPT09IFJlbmRlcmVyVHlwZS5XRUJHTCkge1xuICAgICAgICBuYW1lICs9IGAgJHt0aGlzLl9yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbn1gO1xuICAgICAgfVxuICAgICAgc2F5SGVsbG8obmFtZSk7XG4gICAgfVxuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuSGVsbG9TeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1N5c3RlbVxuICBdLFxuICBuYW1lOiBcImhlbGxvXCIsXG4gIHByaW9yaXR5OiAtMlxufTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgc3lzdGVtLiAqL1xuSGVsbG9TeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKiB7QGxpbmsgV2ViR0xPcHRpb25zLmhlbGxvfSAqL1xuICBoZWxsbzogZmFsc2Vcbn07XG5cbmV4cG9ydCB7IEhlbGxvU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZWxsb1N5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX1JlbmRlcmFibGVHQ1N5c3RlbSA9IGNsYXNzIF9SZW5kZXJhYmxlR0NTeXN0ZW0ge1xuICAvKiogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci4gKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9tYW5hZ2VkUmVuZGVyYWJsZXMgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLl9SZW5kZXJhYmxlR0NTeXN0ZW0uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLm1heFVudXNlZFRpbWUgPSBvcHRpb25zLnJlbmRlcmFibGVHQ01heFVudXNlZFRpbWU7XG4gICAgdGhpcy5fZnJlcXVlbmN5ID0gb3B0aW9ucy5yZW5kZXJhYmxlR0NGcmVxdWVuY3k7XG4gICAgdGhpcy5lbmFibGVkID0gb3B0aW9ucy5yZW5kZXJhYmxlR0NBY3RpdmU7XG4gIH1cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faGFuZGxlcjtcbiAgfVxuICBzZXQgZW5hYmxlZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IHZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5faGFuZGxlciA9IHRoaXMuX3JlbmRlcmVyLnNjaGVkdWxlci5yZXBlYXQoXG4gICAgICAgICgpID0+IHRoaXMucnVuKCksXG4gICAgICAgIHRoaXMuX2ZyZXF1ZW5jeVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2NoZWR1bGVyLmNhbmNlbCh0aGlzLl9oYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgcHJlcmVuZGVyKCkge1xuICAgIHRoaXMuX25vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICB9XG4gIGFkZFJlbmRlcmFibGUocmVuZGVyYWJsZSwgaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICByZW5kZXJhYmxlLl9sYXN0VXNlZCA9IHRoaXMuX25vdztcbiAgICBpZiAocmVuZGVyYWJsZS5fbGFzdEluc3RydWN0aW9uVGljayA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX21hbmFnZWRSZW5kZXJhYmxlcy5wdXNoKHJlbmRlcmFibGUpO1xuICAgICAgcmVuZGVyYWJsZS5vbmNlKFwiZGVzdHJveWVkXCIsIHRoaXMuX3JlbW92ZVJlbmRlcmFibGUsIHRoaXMpO1xuICAgIH1cbiAgICByZW5kZXJhYmxlLl9sYXN0SW5zdHJ1Y3Rpb25UaWNrID0gaW5zdHJ1Y3Rpb25TZXQudGljaztcbiAgfVxuICAvKiogUnVucyB0aGUgc2NoZWR1bGVkIGdhcmJhZ2UgY29sbGVjdGlvbiAqL1xuICBydW4oKSB7XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgbWFuYWdlZFJlbmRlcmFibGVzID0gdGhpcy5fbWFuYWdlZFJlbmRlcmFibGVzO1xuICAgIGNvbnN0IHJlbmRlclBpcGVzID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXM7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYW5hZ2VkUmVuZGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlbmRlcmFibGUgPSBtYW5hZ2VkUmVuZGVyYWJsZXNbaV07XG4gICAgICBpZiAocmVuZGVyYWJsZSA9PT0gbnVsbCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJHcm91cCA9IHJlbmRlcmFibGUucmVuZGVyR3JvdXAgPz8gcmVuZGVyYWJsZS5wYXJlbnRSZW5kZXJHcm91cDtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHJlbmRlckdyb3VwPy5pbnN0cnVjdGlvblNldD8udGljayA/PyAtMTtcbiAgICAgIGlmIChyZW5kZXJhYmxlLl9sYXN0SW5zdHJ1Y3Rpb25UaWNrICE9PSBjdXJyZW50SW5kZXggJiYgbm93IC0gcmVuZGVyYWJsZS5fbGFzdFVzZWQgPiB0aGlzLm1heFVudXNlZFRpbWUpIHtcbiAgICAgICAgaWYgKCFyZW5kZXJhYmxlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIGNvbnN0IHJwID0gcmVuZGVyUGlwZXM7XG4gICAgICAgICAgcnBbcmVuZGVyYWJsZS5yZW5kZXJQaXBlSWRdLmRlc3Ryb3lSZW5kZXJhYmxlKHJlbmRlcmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmFibGUuX2xhc3RJbnN0cnVjdGlvblRpY2sgPSAtMTtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIHJlbmRlcmFibGUub2ZmKFwiZGVzdHJveWVkXCIsIHRoaXMuX3JlbW92ZVJlbmRlcmFibGUsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFuYWdlZFJlbmRlcmFibGVzW2kgLSBvZmZzZXRdID0gcmVuZGVyYWJsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFuYWdlZFJlbmRlcmFibGVzLmxlbmd0aCA9IG1hbmFnZWRSZW5kZXJhYmxlcy5sZW5ndGggLSBvZmZzZXQ7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fbWFuYWdlZFJlbmRlcmFibGVzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX3JlbW92ZVJlbmRlcmFibGUocmVuZGVyYWJsZSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbWFuYWdlZFJlbmRlcmFibGVzLmluZGV4T2YocmVuZGVyYWJsZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHJlbmRlcmFibGUub2ZmKFwiZGVzdHJveWVkXCIsIHRoaXMuX3JlbW92ZVJlbmRlcmFibGUsIHRoaXMpO1xuICAgICAgdGhpcy5fbWFuYWdlZFJlbmRlcmFibGVzW2luZGV4XSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuLyoqIEBpZ25vcmUgKi9cbl9SZW5kZXJhYmxlR0NTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcInJlbmRlcmFibGVHQ1wiXG59O1xuLyoqIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIHJlbmRlcmFibGVHQ1N5c3RlbSAqL1xuX1JlbmRlcmFibGVHQ1N5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIElmIHNldCB0byB0cnVlLCB0aGlzIHdpbGwgZW5hYmxlIHRoZSBnYXJiYWdlIGNvbGxlY3RvciBvbiB0aGUgR1BVLlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZW5kZXJhYmxlR0NBY3RpdmU6IHRydWUsXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBpZGxlIGZyYW1lcyBiZWZvcmUgYSB0ZXh0dXJlIGlzIGRlc3Ryb3llZCBieSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAqIEBkZWZhdWx0IDYwICogNjBcbiAgICovXG4gIHJlbmRlcmFibGVHQ01heFVudXNlZFRpbWU6IDZlNCxcbiAgLyoqXG4gICAqIEZyYW1lcyBiZXR3ZWVuIHR3byBnYXJiYWdlIGNvbGxlY3Rpb25zLlxuICAgKiBAZGVmYXVsdCA2MDBcbiAgICovXG4gIHJlbmRlcmFibGVHQ0ZyZXF1ZW5jeTogM2U0XG59O1xubGV0IFJlbmRlcmFibGVHQ1N5c3RlbSA9IF9SZW5kZXJhYmxlR0NTeXN0ZW07XG5cbmV4cG9ydCB7IFJlbmRlcmFibGVHQ1N5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyYWJsZUdDU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfVGV4dHVyZUdDU3lzdGVtID0gY2xhc3MgX1RleHR1cmVHQ1N5c3RlbSB7XG4gIC8qKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLiAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gICAgdGhpcy5jaGVja0NvdW50ID0gMDtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgdGhpcy5jaGVja0NvdW50TWF4ID0gb3B0aW9ucy50ZXh0dXJlR0NDaGVja0NvdW50TWF4O1xuICAgIHRoaXMubWF4SWRsZSA9IG9wdGlvbnMudGV4dHVyZUdDQU1heElkbGUgPz8gb3B0aW9ucy50ZXh0dXJlR0NNYXhJZGxlO1xuICAgIHRoaXMuYWN0aXZlID0gb3B0aW9ucy50ZXh0dXJlR0NBY3RpdmU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgd2hlbiB0aGUgbGFzdCB0aW1lIGEgdGV4dHVyZSB3YXMgdXNlZC5cbiAgICogSWYgdGhlIHRleHR1cmUgaGFzIG5vdCBiZWVuIHVzZWQgZm9yIGEgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lLCBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR1BVLlxuICAgKi9cbiAgcG9zdHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY291bnQrKztcbiAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY2hlY2tDb3VudCsrO1xuICAgIGlmICh0aGlzLmNoZWNrQ291bnQgPiB0aGlzLmNoZWNrQ291bnRNYXgpIHtcbiAgICAgIHRoaXMuY2hlY2tDb3VudCA9IDA7XG4gICAgICB0aGlzLnJ1bigpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSB3aGVuIHRoZSBsYXN0IHRpbWUgYSB0ZXh0dXJlIHdhcyB1c2VkLlxuICAgKiBJZiB0aGUgdGV4dHVyZSBoYXMgbm90IGJlZW4gdXNlZCBmb3IgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUsIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBHUFUuXG4gICAqL1xuICBydW4oKSB7XG4gICAgY29uc3QgbWFuYWdlZFRleHR1cmVzID0gdGhpcy5fcmVuZGVyZXIudGV4dHVyZS5tYW5hZ2VkVGV4dHVyZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYW5hZ2VkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBtYW5hZ2VkVGV4dHVyZXNbaV07XG4gICAgICBpZiAodGV4dHVyZS5hdXRvR2FyYmFnZUNvbGxlY3QgJiYgdGV4dHVyZS5yZXNvdXJjZSAmJiB0ZXh0dXJlLl90b3VjaGVkID4gLTEgJiYgdGhpcy5jb3VudCAtIHRleHR1cmUuX3RvdWNoZWQgPiB0aGlzLm1heElkbGUpIHtcbiAgICAgICAgdGV4dHVyZS5fdG91Y2hlZCA9IC0xO1xuICAgICAgICB0ZXh0dXJlLnVubG9hZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufTtcbi8qKiBAaWdub3JlICovXG5fVGV4dHVyZUdDU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJ0ZXh0dXJlR0NcIlxufTtcbi8qKiBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBUZXh0dXJlR0NTeXN0ZW0gKi9cbl9UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhpcyB3aWxsIGVuYWJsZSB0aGUgZ2FyYmFnZSBjb2xsZWN0b3Igb24gdGhlIEdQVS5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgdGV4dHVyZUdDQWN0aXZlOiB0cnVlLFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4zLjBcbiAgICogQHNlZSB7QGxpbmsgVGV4dHVyZUdDU3lzdGVtLnRleHR1cmVHQ01heElkbGV9XG4gICAqL1xuICB0ZXh0dXJlR0NBTWF4SWRsZTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGlkbGUgZnJhbWVzIGJlZm9yZSBhIHRleHR1cmUgaXMgZGVzdHJveWVkIGJ5IGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICogQGRlZmF1bHQgNjAgKiA2MFxuICAgKi9cbiAgdGV4dHVyZUdDTWF4SWRsZTogNjAgKiA2MCxcbiAgLyoqXG4gICAqIEZyYW1lcyBiZXR3ZWVuIHR3byBnYXJiYWdlIGNvbGxlY3Rpb25zLlxuICAgKiBAZGVmYXVsdCA2MDBcbiAgICovXG4gIHRleHR1cmVHQ0NoZWNrQ291bnRNYXg6IDYwMFxufTtcbmxldCBUZXh0dXJlR0NTeXN0ZW0gPSBfVGV4dHVyZUdDU3lzdGVtO1xuXG5leHBvcnQgeyBUZXh0dXJlR0NTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVHQ1N5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gJy4uL3JlbmRlclRhcmdldC9SZW5kZXJUYXJnZXQubWpzJztcbmltcG9ydCB7IGdldENhbnZhc1RleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlL3V0aWxzL2dldENhbnZhc1RleHR1cmUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfVmlld1N5c3RlbSA9IGNsYXNzIF9WaWV3U3lzdGVtIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgQ1NTIGRpbWVuc2lvbnMgb2YgY2FudmFzIHZpZXcgc2hvdWxkIGJlIHJlc2l6ZWQgdG8gc2NyZWVuIGRpbWVuc2lvbnMgYXV0b21hdGljYWxseS5cbiAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBhdXRvRGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlLnNvdXJjZS5hdXRvRGVuc2l0eTtcbiAgfVxuICBzZXQgYXV0b0RlbnNpdHkodmFsdWUpIHtcbiAgICB0aGlzLnRleHR1cmUuc291cmNlLmF1dG9EZW5zaXR5ID0gdmFsdWU7XG4gIH1cbiAgLyoqIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlci4gKi9cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZS5zb3VyY2UuX3Jlc29sdXRpb247XG4gIH1cbiAgc2V0IHJlc29sdXRpb24odmFsdWUpIHtcbiAgICB0aGlzLnRleHR1cmUuc291cmNlLnJlc2l6ZShcbiAgICAgIHRoaXMudGV4dHVyZS5zb3VyY2Uud2lkdGgsXG4gICAgICB0aGlzLnRleHR1cmUuc291cmNlLmhlaWdodCxcbiAgICAgIHZhbHVlXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogaW5pdGlhdGVzIHRoZSB2aWV3IHN5c3RlbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBvcHRpb25zIGZvciB0aGUgdmlld1xuICAgKi9cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLl9WaWV3U3lzdGVtLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgaWYgKG9wdGlvbnMudmlldykge1xuICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIlZpZXdTeXN0ZW0udmlldyBoYXMgYmVlbiByZW5hbWVkIHRvIFZpZXdTeXN0ZW0uY2FudmFzXCIpO1xuICAgICAgb3B0aW9ucy5jYW52YXMgPSBvcHRpb25zLnZpZXc7XG4gICAgfVxuICAgIHRoaXMuc2NyZWVuID0gbmV3IFJlY3RhbmdsZSgwLCAwLCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCk7XG4gICAgdGhpcy5jYW52YXMgPSBvcHRpb25zLmNhbnZhcyB8fCBET01BZGFwdGVyLmdldCgpLmNyZWF0ZUNhbnZhcygpO1xuICAgIHRoaXMuYW50aWFsaWFzID0gISFvcHRpb25zLmFudGlhbGlhcztcbiAgICB0aGlzLnRleHR1cmUgPSBnZXRDYW52YXNUZXh0dXJlKHRoaXMuY2FudmFzLCBvcHRpb25zKTtcbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoe1xuICAgICAgY29sb3JUZXh0dXJlczogW3RoaXMudGV4dHVyZV0sXG4gICAgICBkZXB0aDogISFvcHRpb25zLmRlcHRoLFxuICAgICAgaXNSb290OiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0dXJlLnNvdXJjZS50cmFuc3BhcmVudCA9IG9wdGlvbnMuYmFja2dyb3VuZEFscGhhIDwgMTtcbiAgICB0aGlzLm11bHRpVmlldyA9ICEhb3B0aW9ucy5tdWx0aVZpZXc7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBzY3JlZW4gYW5kIGNhbnZhcyB0byB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvbnMuXG4gICAqIEBwYXJhbSBkZXNpcmVkU2NyZWVuV2lkdGggLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSBzY3JlZW4uXG4gICAqIEBwYXJhbSBkZXNpcmVkU2NyZWVuSGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHNjcmVlbi5cbiAgICogQHBhcmFtIHJlc29sdXRpb25cbiAgICovXG4gIHJlc2l6ZShkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnRleHR1cmUuc291cmNlLnJlc2l6ZShkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQsIHJlc29sdXRpb24pO1xuICAgIHRoaXMuc2NyZWVuLndpZHRoID0gdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgU3lzdGVtIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIGNhbnZhcyBmcm9tIHRoZSBkb20uXG4gICAqIEBwYXJhbSB7b3B0aW9ucyB8IGZhbHNlfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGRlc3Ryb3lpbmcgdGhlIHZpZXcsIG9yIFwiZmFsc2VcIi5cbiAgICogQHBhcmFtIG9wdGlvbnMucmVtb3ZlVmlldyAtIFdoZXRoZXIgdG8gcmVtb3ZlIHRoZSB2aWV3IGVsZW1lbnQgZnJvbSB0aGUgRE9NLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKi9cbiAgZGVzdHJveShvcHRpb25zID0gZmFsc2UpIHtcbiAgICBjb25zdCByZW1vdmVWaWV3ID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6ICEhb3B0aW9ucz8ucmVtb3ZlVmlldztcbiAgICBpZiAocmVtb3ZlVmlldyAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICB9XG4gIH1cbn07XG4vKiogQGlnbm9yZSAqL1xuX1ZpZXdTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1N5c3RlbVxuICBdLFxuICBuYW1lOiBcInZpZXdcIixcbiAgcHJpb3JpdHk6IDBcbn07XG4vKiogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIHZpZXcgc3lzdGVtLiAqL1xuX1ZpZXdTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgV2ViR0xPcHRpb25zLndpZHRofVxuICAgKiBAZGVmYXVsdCA4MDBcbiAgICovXG4gIHdpZHRoOiA4MDAsXG4gIC8qKlxuICAgKiB7QGxpbmsgV2ViR0xPcHRpb25zLmhlaWdodH1cbiAgICogQGRlZmF1bHQgNjAwXG4gICAqL1xuICBoZWlnaHQ6IDYwMCxcbiAgLyoqXG4gICAqIHtAbGluayBXZWJHTE9wdGlvbnMuYXV0b0RlbnNpdHl9XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhdXRvRGVuc2l0eTogZmFsc2UsXG4gIC8qKlxuICAgKiB7QGxpbmsgV2ViR0xPcHRpb25zLmFudGlhbGlhc31cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFudGlhbGlhczogZmFsc2Vcbn07XG5sZXQgVmlld1N5c3RlbSA9IF9WaWV3U3lzdGVtO1xuXG5leHBvcnQgeyBWaWV3U3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEN1c3RvbVJlbmRlclBpcGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvQ3VzdG9tUmVuZGVyUGlwZS5tanMnO1xuaW1wb3J0IHsgUmVuZGVyR3JvdXBQaXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL1JlbmRlckdyb3VwUGlwZS5tanMnO1xuaW1wb3J0IHsgUmVuZGVyR3JvdXBTeXN0ZW0gfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvUmVuZGVyR3JvdXBTeXN0ZW0ubWpzJztcbmltcG9ydCB7IFNwcml0ZVBpcGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9zcHJpdGUvU3ByaXRlUGlwZS5tanMnO1xuaW1wb3J0IHsgUmVuZGVyZXJJbml0SG9vayB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2dsb2JhbC9nbG9iYWxIb29rcy5tanMnO1xuaW1wb3J0IHsgQmF0Y2hlclBpcGUgfSBmcm9tICcuLi8uLi8uLi9iYXRjaGVyL3NoYXJlZC9CYXRjaGVyUGlwZS5tanMnO1xuaW1wb3J0IHsgQWxwaGFNYXNrUGlwZSB9IGZyb20gJy4uLy4uLy4uL21hc2svYWxwaGEvQWxwaGFNYXNrUGlwZS5tanMnO1xuaW1wb3J0IHsgQ29sb3JNYXNrUGlwZSB9IGZyb20gJy4uLy4uLy4uL21hc2svY29sb3IvQ29sb3JNYXNrUGlwZS5tanMnO1xuaW1wb3J0IHsgU3RlbmNpbE1hc2tQaXBlIH0gZnJvbSAnLi4vLi4vLi4vbWFzay9zdGVuY2lsL1N0ZW5jaWxNYXNrUGlwZS5tanMnO1xuaW1wb3J0IHsgQmFja2dyb3VuZFN5c3RlbSB9IGZyb20gJy4uL2JhY2tncm91bmQvQmFja2dyb3VuZFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgQmxlbmRNb2RlUGlwZSB9IGZyb20gJy4uL2JsZW5kTW9kZXMvQmxlbmRNb2RlUGlwZS5tanMnO1xuaW1wb3J0IHsgRXh0cmFjdFN5c3RlbSB9IGZyb20gJy4uL2V4dHJhY3QvRXh0cmFjdFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi4vZXh0cmFjdC9HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdsb2JhbFVuaWZvcm1TeXN0ZW0gfSBmcm9tICcuLi9yZW5kZXJUYXJnZXQvR2xvYmFsVW5pZm9ybVN5c3RlbS5tanMnO1xuaW1wb3J0IHsgU2NoZWR1bGVyU3lzdGVtIH0gZnJvbSAnLi4vU2NoZWR1bGVyU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBIZWxsb1N5c3RlbSB9IGZyb20gJy4uL3N0YXJ0dXAvSGVsbG9TeXN0ZW0ubWpzJztcbmltcG9ydCB7IFJlbmRlcmFibGVHQ1N5c3RlbSB9IGZyb20gJy4uL3RleHR1cmUvUmVuZGVyYWJsZUdDU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlR0NTeXN0ZW0gfSBmcm9tICcuLi90ZXh0dXJlL1RleHR1cmVHQ1N5c3RlbS5tanMnO1xuaW1wb3J0IHsgVmlld1N5c3RlbSB9IGZyb20gJy4uL3ZpZXcvVmlld1N5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IFNoYXJlZFN5c3RlbXMgPSBbXG4gIEJhY2tncm91bmRTeXN0ZW0sXG4gIEdsb2JhbFVuaWZvcm1TeXN0ZW0sXG4gIEhlbGxvU3lzdGVtLFxuICBWaWV3U3lzdGVtLFxuICBSZW5kZXJHcm91cFN5c3RlbSxcbiAgVGV4dHVyZUdDU3lzdGVtLFxuICBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0sXG4gIEV4dHJhY3RTeXN0ZW0sXG4gIFJlbmRlcmVySW5pdEhvb2ssXG4gIFJlbmRlcmFibGVHQ1N5c3RlbSxcbiAgU2NoZWR1bGVyU3lzdGVtXG5dO1xuY29uc3QgU2hhcmVkUmVuZGVyUGlwZXMgPSBbXG4gIEJsZW5kTW9kZVBpcGUsXG4gIEJhdGNoZXJQaXBlLFxuICBTcHJpdGVQaXBlLFxuICBSZW5kZXJHcm91cFBpcGUsXG4gIEFscGhhTWFza1BpcGUsXG4gIFN0ZW5jaWxNYXNrUGlwZSxcbiAgQ29sb3JNYXNrUGlwZSxcbiAgQ3VzdG9tUmVuZGVyUGlwZVxuXTtcblxuZXhwb3J0IHsgU2hhcmVkUmVuZGVyUGlwZXMsIFNoYXJlZFN5c3RlbXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYXJlZFN5c3RlbXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5411\n')},8725:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ getCanvasTexture)\n/* harmony export */ });\n/* unused harmony export hasCachedCanvasTexture */\n/* harmony import */ var _sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4884);\n/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4492);\n\n\n\n"use strict";\nconst canvasCache = /* @__PURE__ */ new Map();\nfunction getCanvasTexture(canvas, options) {\n  if (!canvasCache.has(canvas)) {\n    const texture = new _Texture_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Texture */ .g({\n      source: new _sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_1__/* .CanvasSource */ .q({\n        resource: canvas,\n        ...options\n      })\n    });\n    const onDestroy = () => {\n      if (canvasCache.get(canvas) === texture) {\n        canvasCache.delete(canvas);\n      }\n    };\n    texture.once("destroy", onDestroy);\n    texture.source.once("destroy", onDestroy);\n    canvasCache.set(canvas, texture);\n  }\n  return canvasCache.get(canvas);\n}\nfunction hasCachedCanvasTexture(canvas) {\n  return canvasCache.has(canvas);\n}\n\n\n//# sourceMappingURL=getCanvasTexture.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcyNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDbEI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFPO0FBQy9CLGtCQUFrQiw0RUFBWTtBQUM5QjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvRDtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy9nZXRDYW52YXNUZXh0dXJlLm1qcz8wMTUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhbnZhc1NvdXJjZSB9IGZyb20gJy4uL3NvdXJjZXMvQ2FudmFzU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNhbnZhc0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldENhbnZhc1RleHR1cmUoY2FudmFzLCBvcHRpb25zKSB7XG4gIGlmICghY2FudmFzQ2FjaGUuaGFzKGNhbnZhcykpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoe1xuICAgICAgc291cmNlOiBuZXcgQ2FudmFzU291cmNlKHtcbiAgICAgICAgcmVzb3VyY2U6IGNhbnZhcyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCBvbkRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICBpZiAoY2FudmFzQ2FjaGUuZ2V0KGNhbnZhcykgPT09IHRleHR1cmUpIHtcbiAgICAgICAgY2FudmFzQ2FjaGUuZGVsZXRlKGNhbnZhcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0ZXh0dXJlLm9uY2UoXCJkZXN0cm95XCIsIG9uRGVzdHJveSk7XG4gICAgdGV4dHVyZS5zb3VyY2Uub25jZShcImRlc3Ryb3lcIiwgb25EZXN0cm95KTtcbiAgICBjYW52YXNDYWNoZS5zZXQoY2FudmFzLCB0ZXh0dXJlKTtcbiAgfVxuICByZXR1cm4gY2FudmFzQ2FjaGUuZ2V0KGNhbnZhcyk7XG59XG5mdW5jdGlvbiBoYXNDYWNoZWRDYW52YXNUZXh0dXJlKGNhbnZhcykge1xuICByZXR1cm4gY2FudmFzQ2FjaGUuaGFzKGNhbnZhcyk7XG59XG5cbmV4cG9ydCB7IGdldENhbnZhc1RleHR1cmUsIGhhc0NhY2hlZENhbnZhc1RleHR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENhbnZhc1RleHR1cmUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8725\n')},7081:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   e: () => (/* binding */ sayHello)\n/* harmony export */ });\n/* unused harmony export VERSION */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1761);\n\n\n"use strict";\nlet saidHello = false;\nconst VERSION = "8.3.4";\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .e.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      "background: #E72264; padding:5px 0;",\n      "background: #6CA2EA; padding:5px 0;",\n      "background: #B5D33D; padding:5px 0;",\n      "background: #FED23F; padding:5px 0;",\n      "color: #FFFFFF; background: #E72264; padding:5px 0;",\n      "color: #E72264; background: #FFFFFF; padding:5px 0;"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\n\n//# sourceMappingURL=sayHello.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA4MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlFQUFVO0FBQ2hCO0FBQ0EsdUNBQXVDLFNBQVMsR0FBRyxLQUFLOztBQUV4RDtBQUNBLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDLHVCQUF1QixxQkFBcUIsY0FBYztBQUMxRCx1QkFBdUIscUJBQXFCLGNBQWM7QUFDMUQ7QUFDQTtBQUNBLElBQUk7QUFDSixxQ0FBcUMsU0FBUyxJQUFJLE1BQU07QUFDeEQ7QUFDQTtBQUNBOztBQUU2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvc2F5SGVsbG8ubWpzP2JhODUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgc2FpZEhlbGxvID0gZmFsc2U7XG5jb25zdCBWRVJTSU9OID0gXCI4LjMuNFwiO1xuZnVuY3Rpb24gc2F5SGVsbG8odHlwZSkge1xuICBpZiAoc2FpZEhlbGxvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChET01BZGFwdGVyLmdldCgpLmdldE5hdmlnYXRvcigpLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJjaHJvbWVcIikgPiAtMSkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICBgJWMgICVjICAlYyAgJWMgICVjIFBpeGlKUyAlYyB2JHtWRVJTSU9OfSAoJHt0eXBlfSkgaHR0cDovL3d3dy5waXhpanMuY29tL1xuXG5gLFxuICAgICAgXCJiYWNrZ3JvdW5kOiAjRTcyMjY0OyBwYWRkaW5nOjVweCAwO1wiLFxuICAgICAgXCJiYWNrZ3JvdW5kOiAjNkNBMkVBOyBwYWRkaW5nOjVweCAwO1wiLFxuICAgICAgXCJiYWNrZ3JvdW5kOiAjQjVEMzNEOyBwYWRkaW5nOjVweCAwO1wiLFxuICAgICAgXCJiYWNrZ3JvdW5kOiAjRkVEMjNGOyBwYWRkaW5nOjVweCAwO1wiLFxuICAgICAgXCJjb2xvcjogI0ZGRkZGRjsgYmFja2dyb3VuZDogI0U3MjI2NDsgcGFkZGluZzo1cHggMDtcIixcbiAgICAgIFwiY29sb3I6ICNFNzIyNjQ7IGJhY2tncm91bmQ6ICNGRkZGRkY7IHBhZGRpbmc6NXB4IDA7XCJcbiAgICBdO1xuICAgIGdsb2JhbFRoaXMuY29uc29sZS5sb2coLi4uYXJncyk7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5jb25zb2xlKSB7XG4gICAgZ2xvYmFsVGhpcy5jb25zb2xlLmxvZyhgUGl4aUpTICR7VkVSU0lPTn0gLSAke3R5cGV9IC0gaHR0cDovL3d3dy5waXhpanMuY29tL2ApO1xuICB9XG4gIHNhaWRIZWxsbyA9IHRydWU7XG59XG5cbmV4cG9ydCB7IFZFUlNJT04sIHNheUhlbGxvIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYXlIZWxsby5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7081\n')}}]);