"use strict";(self.webpackChunk_masatomakino_threejs_billboard=self.webpackChunk_masatomakino_threejs_billboard||[]).push([[751],{341:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   w: () => (/* binding */ getTextureBatchBindGroup)\n/* harmony export */ });\n/* harmony import */ var _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3513);\n/* harmony import */ var _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4492);\n/* harmony import */ var _gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6563);\n\n\n\n\n"use strict";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size) {\n  let uid = 2166136261;\n  for (let i = 0; i < size; i++) {\n    uid ^= textures[i].uid;\n    uid = Math.imul(uid, 16777619);\n    uid >>>= 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\nlet maxTextures = 0;\nfunction generateTextureBatchBindGroup(textures, size, key) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  if (!maxTextures)\n    maxTextures = (0,_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__/* .getMaxTexturesPerBatch */ .a)();\n  for (let i = 0; i < maxTextures; i++) {\n    const texture = i < size ? textures[i] : _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .g.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BindGroup */ .T(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\n\n//# sourceMappingURL=getTextureBatchBindGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRTtBQUNBO0FBQ1c7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxR0FBc0I7QUFDeEMsa0JBQWtCLGlCQUFpQjtBQUNuQyw2Q0FBNkMsbUZBQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1GQUFTO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFb0M7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9iYXRjaGVyL2dwdS9nZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAubWpzPzUwNGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2dwdS9zaGFkZXIvQmluZEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IGdldE1heFRleHR1cmVzUGVyQmF0Y2ggfSBmcm9tICcuLi9nbC91dGlscy9tYXhSZWNvbW1lbmRlZFRleHR1cmVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgY2FjaGVkR3JvdXBzID0ge307XG5mdW5jdGlvbiBnZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIHNpemUpIHtcbiAgbGV0IHVpZCA9IDIxNjYxMzYyNjE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgdWlkIF49IHRleHR1cmVzW2ldLnVpZDtcbiAgICB1aWQgPSBNYXRoLmltdWwodWlkLCAxNjc3NzYxOSk7XG4gICAgdWlkID4+Pj0gMDtcbiAgfVxuICByZXR1cm4gY2FjaGVkR3JvdXBzW3VpZF0gfHwgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIHNpemUsIHVpZCk7XG59XG5sZXQgbWF4VGV4dHVyZXMgPSAwO1xuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIHNpemUsIGtleSkge1xuICBjb25zdCBiaW5kR3JvdXBSZXNvdXJjZXMgPSB7fTtcbiAgbGV0IGJpbmRJbmRleCA9IDA7XG4gIGlmICghbWF4VGV4dHVyZXMpXG4gICAgbWF4VGV4dHVyZXMgPSBnZXRNYXhUZXh0dXJlc1BlckJhdGNoKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgIGNvbnN0IHRleHR1cmUgPSBpIDwgc2l6ZSA/IHRleHR1cmVzW2ldIDogVGV4dHVyZS5FTVBUWS5zb3VyY2U7XG4gICAgYmluZEdyb3VwUmVzb3VyY2VzW2JpbmRJbmRleCsrXSA9IHRleHR1cmUuc291cmNlO1xuICAgIGJpbmRHcm91cFJlc291cmNlc1tiaW5kSW5kZXgrK10gPSB0ZXh0dXJlLnN0eWxlO1xuICB9XG4gIGNvbnN0IGJpbmRHcm91cCA9IG5ldyBCaW5kR3JvdXAoYmluZEdyb3VwUmVzb3VyY2VzKTtcbiAgY2FjaGVkR3JvdXBzW2tleV0gPSBiaW5kR3JvdXA7XG4gIHJldHVybiBiaW5kR3JvdXA7XG59XG5cbmV4cG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///341\n')},4751:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  WebGPURenderer: () => (/* binding */ WebGPURenderer)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(8507);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(9313);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs + 1 modules\nvar maxRecommendedTextures = __webpack_require__(6563);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs\nvar getTextureBatchBindGroup = __webpack_require__(341);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(5611);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs\nvar colorBit = __webpack_require__(4459);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs\nvar generateTextureBatchBit = __webpack_require__(4000);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs\nvar localUniformBit = __webpack_require__(2067);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(6665);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(8475);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(5811);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuGraphicsAdaptor {\n  init() {\n    const localUniforms = new UniformGroup/* UniformGroup */.k({\n      uTransformMatrix: { value: new Matrix/* Matrix */.u(), type: "mat3x3<f32>" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uRound: { value: 0, type: "f32" }\n    });\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.v)({\n      name: "graphics",\n      bits: [\n        colorBit/* colorBit */.F,\n        (0,generateTextureBatchBit/* generateTextureBatchBit */._)((0,maxRecommendedTextures/* getMaxTexturesPerBatch */.a)()),\n        localUniformBit/* localUniformBitGroup2 */._Q,\n        roundPixelsBit/* roundPixelsBit */.b\n      ]\n    });\n    this.shader = new Shader/* Shader */.M({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      geometry,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setPipelineFromGeometryProgramAndState(\n      geometry,\n      shader.gpuProgram,\n      graphicsPipe.state\n    );\n    encoder.setGeometry(geometry, shader.gpuProgram);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = (0,getTextureBatchBindGroup/* getTextureBatchBindGroup */.w)(textureBatch.textures, textureBatch.count);\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n          batch.bindGroup,\n          shader.gpuProgram,\n          1\n        );\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUPipesAdaptor\n  ],\n  name: "graphics"\n};\n\n\n//# sourceMappingURL=GpuGraphicsAdaptor.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs\nvar textureBit = __webpack_require__(3391);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(4492);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(268);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuMeshAdapter {\n  init() {\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.v)({\n      name: "mesh",\n      bits: [\n        localUniformBit/* localUniformBit */.Ls,\n        textureBit/* textureBit */.R,\n        roundPixelsBit/* roundPixelsBit */.b\n      ]\n    });\n    this._shader = new Shader/* Shader */.M({\n      gpuProgram,\n      resources: {\n        uTexture: Texture/* Texture */.g.EMPTY._source,\n        uSampler: Texture/* Texture */.g.EMPTY._source.style,\n        textureUniforms: {\n          uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix/* Matrix */.u() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n    } else if (!shader.gpuProgram) {\n      (0,warn/* warn */.R)("Mesh shader has no gpuProgram", mesh.shader);\n      return;\n    }\n    const gpuProgram = shader.gpuProgram;\n    if (gpuProgram.autoAssignGlobalUniforms) {\n      shader.groups[0] = renderer.globalUniforms.bindGroup;\n    }\n    if (gpuProgram.autoAssignLocalUniforms) {\n      const localUniforms = meshPipe.localUniforms;\n      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n    }\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuMeshAdapter.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUPipesAdaptor\n  ],\n  name: "mesh"\n};\n\n\n//# sourceMappingURL=GpuMeshAdapter.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(7547);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempState = State/* State */.U.for2d();\nclass GpuBatchAdaptor {\n  init() {\n    const gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.v)({\n      name: "batch",\n      bits: [\n        colorBit/* colorBit */.F,\n        (0,generateTextureBatchBit/* generateTextureBatchBit */._)((0,maxRecommendedTextures/* getMaxTexturesPerBatch */.a)()),\n        roundPixelsBit/* roundPixelsBit */.b\n      ]\n    });\n    this._shader = new Shader/* Shader */.M({\n      gpuProgram,\n      groups: {\n        // these will be dynamically allocated\n      }\n    });\n  }\n  start(batchPipe, geometry) {\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    const program = this._shader.gpuProgram;\n    this._geometry = geometry;\n    encoder.setGeometry(geometry, program);\n    tempState.blendMode = "normal";\n    renderer.pipeline.getPipeline(\n      geometry,\n      program,\n      tempState\n    );\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.resetBindGroup(1);\n    encoder.setBindGroup(0, globalUniformsBindGroup, program);\n  }\n  execute(batchPipe, batch) {\n    const program = this._shader.gpuProgram;\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    if (!batch.bindGroup) {\n      const textureBatch = batch.textures;\n      batch.bindGroup = (0,getTextureBatchBindGroup/* getTextureBatchBindGroup */.w)(textureBatch.textures, textureBatch.count);\n    }\n    tempState.blendMode = batch.blendMode;\n    const gpuBindGroup = renderer.bindGroup.getBindGroup(\n      batch.bindGroup,\n      program,\n      1\n    );\n    const pipeline = renderer.pipeline.getPipeline(\n      this._geometry,\n      program,\n      tempState\n    );\n    batch.bindGroup._touch(renderer.textureGC.count);\n    encoder.setPipeline(pipeline);\n    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuBatchAdaptor.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUPipesAdaptor\n  ],\n  name: "batch"\n};\n\n\n//# sourceMappingURL=GpuBatchAdaptor.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs + 1 modules\nvar AbstractRenderer = __webpack_require__(800);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs + 32 modules\nvar SharedSystems = __webpack_require__(5411);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5099);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs\n\n\n"use strict";\nclass BindGroupSystem {\n  constructor(renderer) {\n    this._hash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getBindGroup(bindGroup, program, groupIndex) {\n    bindGroup._updateKey();\n    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n    return gpuBindGroup;\n  }\n  _createBindGroup(group, program, groupIndex) {\n    const device = this._gpu.device;\n    const groupLayout = program.layout[groupIndex];\n    const entries = [];\n    const renderer = this._renderer;\n    for (const j in groupLayout) {\n      const resource = group.resources[j] ?? group.resources[groupLayout[j]];\n      let gpuResource;\n      if (resource._resourceType === "uniformGroup") {\n        const uniformGroup = resource;\n        renderer.ubo.updateUniformGroup(uniformGroup);\n        const buffer = uniformGroup.buffer;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === "buffer") {\n        const buffer = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === "bufferResource") {\n        const bufferResource = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n          offset: bufferResource.offset,\n          size: bufferResource.size\n        };\n      } else if (resource._resourceType === "textureSampler") {\n        const sampler = resource;\n        gpuResource = renderer.texture.getGpuSampler(sampler);\n      } else if (resource._resourceType === "textureSource") {\n        const texture = resource;\n        gpuResource = renderer.texture.getGpuSource(texture).createView({});\n      }\n      entries.push({\n        binding: groupLayout[j],\n        resource: gpuResource\n      });\n    }\n    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n    const gpuBindGroup = device.createBindGroup({\n      layout,\n      entries\n    });\n    this._hash[group._key] = gpuBindGroup;\n    return gpuBindGroup;\n  }\n  destroy() {\n    for (const key of Object.keys(this._hash)) {\n      this._hash[key] = null;\n    }\n    this._hash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBindGroupSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "bindGroup"\n};\n\n\n//# sourceMappingURL=BindGroupSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs\nvar fastCopy = __webpack_require__(6736);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs\n\n\n\n"use strict";\nclass GpuBufferSystem {\n  constructor() {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    this._managedBuffers = [];\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getGPUBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n  }\n  updateBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    const data = buffer.data;\n    if (buffer._updateID && data) {\n      buffer._updateID = 0;\n      this._gpu.device.queue.writeBuffer(\n        gpuBuffer,\n        0,\n        data.buffer,\n        0,\n        // round to the nearest 4 bytes\n        (buffer._updateSize || data.byteLength) + 3 & ~3\n      );\n    }\n    return gpuBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    for (const id in this._gpuBuffers) {\n      this._gpuBuffers[id].destroy();\n    }\n    this._gpuBuffers = {};\n  }\n  createGPUBuffer(buffer) {\n    if (!this._gpuBuffers[buffer.uid]) {\n      buffer.on("update", this.updateBuffer, this);\n      buffer.on("change", this.onBufferChange, this);\n      buffer.on("destroy", this.onBufferDestroy, this);\n      this._managedBuffers.push(buffer);\n    }\n    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n    buffer._updateID = 0;\n    if (buffer.data) {\n      (0,fastCopy/* fastCopy */.W)(buffer.data.buffer, gpuBuffer.getMappedRange());\n      gpuBuffer.unmap();\n    }\n    this._gpuBuffers[buffer.uid] = gpuBuffer;\n    return gpuBuffer;\n  }\n  onBufferChange(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer._updateID = 0;\n    this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n  }\n  /**\n   * Disposes buffer\n   * @param buffer - buffer with data\n   */\n  onBufferDestroy(buffer) {\n    this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n    this._destroyBuffer(buffer);\n  }\n  destroy() {\n    this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n    this._managedBuffers = null;\n    this._gpuBuffers = null;\n  }\n  _destroyBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer.off("update", this.updateBuffer, this);\n    buffer.off("change", this.onBufferChange, this);\n    buffer.off("destroy", this.onBufferDestroy, this);\n    this._gpuBuffers[buffer.uid] = null;\n  }\n}\n/** @ignore */\nGpuBufferSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "buffer"\n};\n\n\n//# sourceMappingURL=GpuBufferSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs\n\n\n"use strict";\nclass GpuColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.pipeline.setColorMask(colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorMaskCache = null;\n  }\n}\n/** @ignore */\nGpuColorMaskSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "colorMask"\n};\n\n\n//# sourceMappingURL=GpuColorMaskSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar environment_adapter = __webpack_require__(1761);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs\n\n\n\n"use strict";\nclass GpuDeviceSystem {\n  /**\n   * @param {WebGPURenderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  async init(options) {\n    if (this._initPromise)\n      return this._initPromise;\n    this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {\n      this.gpu = gpu;\n      this._renderer.runners.contextChange.emit(this.gpu);\n    });\n    return this._initPromise;\n  }\n  /**\n   * Handle the context change event\n   * @param gpu\n   */\n  contextChange(gpu) {\n    this._renderer.gpu = gpu;\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param {object} options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  async _createDeviceAndAdaptor(options) {\n    const adapter = await environment_adapter/* DOMAdapter */.e.get().getNavigator().gpu.requestAdapter({\n      powerPreference: options.powerPreference,\n      forceFallbackAdapter: options.forceFallbackAdapter\n    });\n    const requiredFeatures = [\n      "texture-compression-bc",\n      "texture-compression-astc",\n      "texture-compression-etc2"\n    ].filter((feature) => adapter.features.has(feature));\n    const device = await adapter.requestDevice({\n      requiredFeatures\n    });\n    return { adapter, device };\n  }\n  destroy() {\n    this.gpu = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuDeviceSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "device"\n};\n/** The default options for the GpuDeviceSystem. */\nGpuDeviceSystem.defaultOptions = {\n  /**\n   * {@link WebGPUOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * Force the use of the fallback adapter\n   * @default false\n   */\n  forceFallbackAdapter: false\n};\n\n\n//# sourceMappingURL=GpuDeviceSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs\n\n\n"use strict";\nclass GpuEncoderSystem {\n  constructor(renderer) {\n    this._boundBindGroup = /* @__PURE__ */ Object.create(null);\n    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  renderStart() {\n    this.commandFinished = new Promise((resolve) => {\n      this._resolveCommandFinished = resolve;\n    });\n    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n  }\n  beginRenderPass(gpuRenderTarget) {\n    this.endRenderPass();\n    this._clearCache();\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n  }\n  endRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n    }\n    this.renderPassEncoder = null;\n  }\n  setViewport(viewport) {\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n  }\n  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n    this.setPipeline(pipeline);\n  }\n  setPipeline(pipeline) {\n    if (this._boundPipeline === pipeline)\n      return;\n    this._boundPipeline = pipeline;\n    this.renderPassEncoder.setPipeline(pipeline);\n  }\n  _setVertexBuffer(index, buffer) {\n    if (this._boundVertexBuffer[index] === buffer)\n      return;\n    this._boundVertexBuffer[index] = buffer;\n    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n  }\n  _setIndexBuffer(buffer) {\n    if (this._boundIndexBuffer === buffer)\n      return;\n    this._boundIndexBuffer = buffer;\n    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";\n    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n  }\n  resetBindGroup(index) {\n    this._boundBindGroup[index] = null;\n  }\n  setBindGroup(index, bindGroup, program) {\n    if (this._boundBindGroup[index] === bindGroup)\n      return;\n    this._boundBindGroup[index] = bindGroup;\n    bindGroup._touch(this._renderer.textureGC.count);\n    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n  }\n  setGeometry(geometry, program) {\n    const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n    for (const i in buffersToBind) {\n      this._setVertexBuffer(i, geometry.attributes[buffersToBind[i]].buffer);\n    }\n    if (geometry.indexBuffer) {\n      this._setIndexBuffer(geometry.indexBuffer);\n    }\n  }\n  _setShaderBindGroups(shader, skipSync) {\n    for (const i in shader.groups) {\n      const bindGroup = shader.groups[i];\n      if (!skipSync) {\n        this._syncBindGroup(bindGroup);\n      }\n      this.setBindGroup(i, bindGroup, shader.gpuProgram);\n    }\n  }\n  _syncBindGroup(bindGroup) {\n    for (const j in bindGroup.resources) {\n      const resource = bindGroup.resources[j];\n      if (resource.isUniformGroup) {\n        this._renderer.ubo.updateUniformGroup(resource);\n      }\n    }\n  }\n  draw(options) {\n    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n    this.setGeometry(geometry, shader.gpuProgram);\n    this._setShaderBindGroups(shader, skipSync);\n    if (geometry.indexBuffer) {\n      this.renderPassEncoder.drawIndexed(\n        size || geometry.indexBuffer.data.length,\n        instanceCount || geometry.instanceCount,\n        start || 0\n      );\n    } else {\n      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);\n    }\n  }\n  finishRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n      this.renderPassEncoder = null;\n    }\n  }\n  postrender() {\n    this.finishRenderPass();\n    this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n    this._resolveCommandFinished();\n    this.commandEncoder = null;\n  }\n  // restores a render pass if finishRenderPass was called\n  // not optimised as really used for debugging!\n  // used when we want to stop drawing and log a texture..\n  restoreRenderPass() {\n    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(\n      this._renderer.renderTarget.renderTarget,\n      false,\n      [0, 0, 0, 1]\n    );\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n    const boundPipeline = this._boundPipeline;\n    const boundVertexBuffer = { ...this._boundVertexBuffer };\n    const boundIndexBuffer = this._boundIndexBuffer;\n    const boundBindGroup = { ...this._boundBindGroup };\n    this._clearCache();\n    const viewport = this._renderer.renderTarget.viewport;\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    this.setPipeline(boundPipeline);\n    for (const i in boundVertexBuffer) {\n      this._setVertexBuffer(i, boundVertexBuffer[i]);\n    }\n    for (const i in boundBindGroup) {\n      this.setBindGroup(i, boundBindGroup[i], null);\n    }\n    this._setIndexBuffer(boundIndexBuffer);\n  }\n  _clearCache() {\n    for (let i = 0; i < 16; i++) {\n      this._boundBindGroup[i] = null;\n      this._boundVertexBuffer[i] = null;\n    }\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this._gpu = null;\n    this._boundBindGroup = null;\n    this._boundVertexBuffer = null;\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n}\n/** @ignore */\nGpuEncoderSystem.extension = {\n  type: [Extensions/* ExtensionType */.Ag.WebGPUSystem],\n  name: "encoder",\n  priority: 1\n};\n\n\n//# sourceMappingURL=GpuEncoderSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs\nvar state_const = __webpack_require__(1957);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs\n\n\n\n"use strict";\nclass GpuStencilSystem {\n  constructor(renderer) {\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  onRenderTargetChange(renderTarget) {\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: state_const/* STENCIL_MODES */.K.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this._activeRenderTarget = renderTarget;\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    const renderer = this._renderer;\n    renderer.pipeline.setStencilMode(stencilMode);\n    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n  }\n  destroy() {\n    this._renderer.renderTarget.onRenderTargetChange.remove(this);\n    this._renderer = null;\n    this._activeRenderTarget = null;\n    this._renderTargetStencilState = null;\n  }\n}\n/** @ignore */\nGpuStencilSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "stencil"\n};\n\n\n//# sourceMappingURL=GpuStencilSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs\nvar UboSystem = __webpack_require__(7047);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs\n\nconst WGSL_ALIGN_SIZE_DATA = {\n  i32: { align: 4, size: 4 },\n  u32: { align: 4, size: 4 },\n  f32: { align: 4, size: 4 },\n  f16: { align: 2, size: 2 },\n  "vec2<i32>": { align: 8, size: 8 },\n  "vec2<u32>": { align: 8, size: 8 },\n  "vec2<f32>": { align: 8, size: 8 },\n  "vec2<f16>": { align: 4, size: 4 },\n  "vec3<i32>": { align: 16, size: 12 },\n  "vec3<u32>": { align: 16, size: 12 },\n  "vec3<f32>": { align: 16, size: 12 },\n  "vec3<f16>": { align: 8, size: 6 },\n  "vec4<i32>": { align: 16, size: 16 },\n  "vec4<u32>": { align: 16, size: 16 },\n  "vec4<f32>": { align: 16, size: 16 },\n  "vec4<f16>": { align: 8, size: 8 },\n  "mat2x2<f32>": { align: 8, size: 16 },\n  "mat2x2<f16>": { align: 4, size: 8 },\n  "mat3x2<f32>": { align: 8, size: 24 },\n  "mat3x2<f16>": { align: 4, size: 12 },\n  "mat4x2<f32>": { align: 8, size: 32 },\n  "mat4x2<f16>": { align: 4, size: 16 },\n  "mat2x3<f32>": { align: 16, size: 32 },\n  "mat2x3<f16>": { align: 8, size: 16 },\n  "mat3x3<f32>": { align: 16, size: 48 },\n  "mat3x3<f16>": { align: 8, size: 24 },\n  "mat4x3<f32>": { align: 16, size: 64 },\n  "mat4x3<f16>": { align: 8, size: 32 },\n  "mat2x4<f32>": { align: 16, size: 32 },\n  "mat2x4<f16>": { align: 8, size: 16 },\n  "mat3x4<f32>": { align: 16, size: 48 },\n  "mat3x4<f16>": { align: 8, size: 24 },\n  "mat4x4<f32>": { align: 16, size: 64 },\n  "mat4x4<f16>": { align: 8, size: 32 }\n};\nfunction createUboElementsWGSL(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {\n      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, align) * uboElement.data.size;\n    }\n    offset = Math.ceil(offset / align) * align;\n    uboElement.size = size;\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\n\n//# sourceMappingURL=createUboElementsWGSL.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs\nvar createUboSyncFunction = __webpack_require__(6423);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs\nvar uboSyncFunctions = __webpack_require__(1266);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs\n\n\n"use strict";\nfunction generateArraySyncWGSL(uboElement, offsetToAdd) {\n  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n  const remainder = (align - size) / 4;\n  return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 data[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}\n         }\n     `;\n}\n\n\n//# sourceMappingURL=generateArraySyncWGSL.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs\n\n\n\n\n"use strict";\nfunction createUboSyncFunctionWGSL(uboElements) {\n  return (0,createUboSyncFunction/* createUboSyncFunction */.E)(\n    uboElements,\n    "uboWgsl",\n    generateArraySyncWGSL,\n    uboSyncFunctions/* uboSyncFunctionsWGSL */._\n  );\n}\n\n\n//# sourceMappingURL=createUboSyncFunctionWGSL.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs\n\n\n\n\n\n"use strict";\nclass GpuUboSystem extends UboSystem/* UboSystem */.W {\n  constructor() {\n    super({\n      createUboElements: createUboElementsWGSL,\n      generateUboSync: createUboSyncFunctionWGSL\n    });\n  }\n}\n/** @ignore */\nGpuUboSystem.extension = {\n  type: [Extensions/* ExtensionType */.Ag.WebGPUSystem],\n  name: "ubo"\n};\n\n\n//# sourceMappingURL=GpuUboSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs\nvar Buffer = __webpack_require__(949);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs\nvar BufferResource = __webpack_require__(581);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs\nvar buffer_const = __webpack_require__(1132);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs\n\nclass UboBatch {\n  constructor({ minUniformOffsetAlignment }) {\n    this._minUniformOffsetAlignment = 256;\n    this.byteIndex = 0;\n    this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n    this.data = new Float32Array(65535);\n  }\n  clear() {\n    this.byteIndex = 0;\n  }\n  addEmptyGroup(size) {\n    if (size > this._minUniformOffsetAlignment / 4) {\n      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n    }\n    const start = this.byteIndex;\n    let newSize = start + size * 4;\n    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n    if (newSize > this.data.length * 4) {\n      throw new Error("UniformBufferBatch: ubo batch got too big");\n    }\n    this.byteIndex = newSize;\n    return start;\n  }\n  addGroup(array) {\n    const offset = this.addEmptyGroup(array.length);\n    for (let i = 0; i < array.length; i++) {\n      this.data[offset / 4 + i] = array[i];\n    }\n    return offset;\n  }\n  destroy() {\n    this._buffer.destroy();\n    this._buffer = null;\n    this.data = null;\n  }\n}\n\n\n//# sourceMappingURL=UboBatch.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(3513);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs\n\n\n\n\n\n\n\n"use strict";\nconst minUniformOffsetAlignment = 128;\nclass GpuUniformBatchPipe {\n  constructor(renderer) {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    // number of buffers..\n    this._buffers = [];\n    this._bindGroups = [];\n    this._bufferResources = [];\n    this._renderer = renderer;\n    this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n    const totalBuffers = 256 / minUniformOffsetAlignment;\n    for (let i = 0; i < totalBuffers; i++) {\n      let usage = buffer_const/* BufferUsage */.S.UNIFORM | buffer_const/* BufferUsage */.S.COPY_DST;\n      if (i === 0)\n        usage |= buffer_const/* BufferUsage */.S.COPY_SRC;\n      this._buffers.push(new Buffer/* Buffer */.h({\n        data: this._batchBuffer.data,\n        usage\n      }));\n    }\n  }\n  renderEnd() {\n    this._uploadBindGroups();\n    this._resetBindGroups();\n  }\n  _resetBindGroups() {\n    for (const i in this._bindGroupHash) {\n      this._bindGroupHash[i] = null;\n    }\n    this._batchBuffer.clear();\n  }\n  // just works for single bind groups for now\n  getUniformBindGroup(group, duplicate) {\n    if (!duplicate && this._bindGroupHash[group.uid]) {\n      return this._bindGroupHash[group.uid];\n    }\n    this._renderer.ubo.ensureUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addEmptyGroup(data.length);\n    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n    return this._bindGroupHash[group.uid];\n  }\n  getUboResource(group) {\n    this._renderer.ubo.updateUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBufferResource(offset / minUniformOffsetAlignment);\n  }\n  getArrayBindGroup(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBindGroup(offset / minUniformOffsetAlignment);\n  }\n  getArrayBufferResource(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    const index = offset / minUniformOffsetAlignment;\n    return this._getBufferResource(index);\n  }\n  _getBufferResource(index) {\n    if (!this._bufferResources[index]) {\n      const buffer = this._buffers[index % 2];\n      this._bufferResources[index] = new BufferResource/* BufferResource */.d({\n        buffer,\n        offset: (index / 2 | 0) * 256,\n        size: minUniformOffsetAlignment\n      });\n    }\n    return this._bufferResources[index];\n  }\n  _getBindGroup(index) {\n    if (!this._bindGroups[index]) {\n      const bindGroup = new BindGroup/* BindGroup */.T({\n        0: this._getBufferResource(index)\n      });\n      this._bindGroups[index] = bindGroup;\n    }\n    return this._bindGroups[index];\n  }\n  _uploadBindGroups() {\n    const bufferSystem = this._renderer.buffer;\n    const firstBuffer = this._buffers[0];\n    firstBuffer.update(this._batchBuffer.byteIndex);\n    bufferSystem.updateBuffer(firstBuffer);\n    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    for (let i = 1; i < this._buffers.length; i++) {\n      const buffer = this._buffers[i];\n      commandEncoder.copyBufferToBuffer(\n        bufferSystem.getGPUBuffer(firstBuffer),\n        minUniformOffsetAlignment,\n        bufferSystem.getGPUBuffer(buffer),\n        0,\n        this._batchBuffer.byteIndex\n      );\n    }\n    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n  }\n  destroy() {\n    for (let i = 0; i < this._bindGroups.length; i++) {\n      this._bindGroups[i].destroy();\n    }\n    this._bindGroups = null;\n    this._bindGroupHash = null;\n    for (let i = 0; i < this._buffers.length; i++) {\n      this._buffers[i].destroy();\n    }\n    this._buffers = null;\n    for (let i = 0; i < this._bufferResources.length; i++) {\n      this._bufferResources[i].destroy();\n    }\n    this._bufferResources = null;\n    this._batchBuffer.destroy();\n    this._bindGroupHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuUniformBatchPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUPipes\n  ],\n  name: "uniformBatch"\n};\n\n\n//# sourceMappingURL=GpuUniformBatchPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs\nvar ensureAttributes = __webpack_require__(7084);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs\nvar createIdFromString = __webpack_require__(7952);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs\nvar GpuStencilModesToPixi = __webpack_require__(1172);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs\n\n\n\n\n\n\n\n"use strict";\nconst topologyStringToId = {\n  "point-list": 0,\n  "line-list": 1,\n  "line-strip": 2,\n  "triangle-list": 3,\n  "triangle-strip": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {\n  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */ Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);\n    this._bindingNamesCache = /* @__PURE__ */ Object.create(null);\n    this._pipeCache = /* @__PURE__ */ Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(state_const/* STENCIL_MODES */.K.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount)\n      return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask)\n      return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode)\n      return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi/* GpuStencilModesToPixi */.g[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      (0,ensureAttributes/* ensureAttributes */.q)(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology = topology || geometry.topology;\n    const key = getGraphicsStateKey(\n      geometry._layoutKey,\n      program._layoutKey,\n      state.data,\n      state._blendModeId,\n      topologyStringToId[topology]\n    );\n    if (this._pipeCache[key])\n      return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry, program);\n    const blendModes = this._renderer.state.getColorTargets(state);\n    blendModes[0].writeMask = this._stencilMode === state_const/* STENCIL_MODES */.K.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: "depth24plus-stencil8",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? "less" : "always"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n      keyGen[index++] = attribute.instance;\n    }\n    const stringKey = keyGen.join("|");\n    geometry._layoutKey = (0,createIdFromString/* createIdFromString */.X)(stringKey, "geometry");\n    return geometry._layoutKey;\n  }\n  _generateAttributeLocationsKey(program) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(program.attributeData).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = program.attributeData[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n    }\n    const stringKey = keyGen.join("|");\n    program._attributeLocationsKey = (0,createIdFromString/* createIdFromString */.X)(stringKey, "programAttributes");\n    return program._attributeLocationsKey;\n  }\n  /**\n   * Returns a hash of buffer names mapped to bind locations.\n   * This is used to bind the correct buffer to the correct location in the shader.\n   * @param geometry - The geometry where to get the buffer names\n   * @param program - The program where to get the buffer names\n   * @returns An object of buffer names mapped to the bind location.\n   */\n  getBufferNamesToBind(geometry, program) {\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bindingNamesCache[key])\n      return this._bindingNamesCache[key];\n    const data = this._createVertexBufferLayouts(geometry, program);\n    const bufferNamesToBind = /* @__PURE__ */ Object.create(null);\n    const attributeData = program.attributeData;\n    for (let i = 0; i < data.length; i++) {\n      for (const j in attributeData) {\n        if (attributeData[j].location === i) {\n          bufferNamesToBind[i] = j;\n          break;\n        }\n      }\n    }\n    this._bindingNamesCache[key] = bufferNamesToBind;\n    return bufferNamesToBind;\n  }\n  _createVertexBufferLayouts(geometry, program) {\n    if (!program._attributeLocationsKey)\n      this._generateAttributeLocationsKey(program);\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bufferLayoutsCache[key]) {\n      return this._bufferLayoutsCache[key];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach((buffer) => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: "vertex",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in program.attributeData) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.divisor ?? 1) !== 1) {\n          (0,warn/* warn */.R)(`Attribute ${i} has an invalid divisor value of \'${attribute.divisor}\'. WebGPU only supports a divisor value of 1`);\n        }\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";\n          bufferEntryAttributes.push({\n            shaderLocation: program.attributeData[i].location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[key] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(\n      this._stencilMode,\n      this._multisampleCount,\n      this._colorMask,\n      this._depthStencilAttachment\n    );\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [Extensions/* ExtensionType */.Ag.WebGPUSystem],\n  name: "pipeline"\n};\n\n\n//# sourceMappingURL=PipelineSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs + 2 modules\nvar RenderTargetSystem = __webpack_require__(7238);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs\nvar gl_const = __webpack_require__(1257);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs\nvar CanvasSource = __webpack_require__(4884);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 2 modules\nvar TextureSource = __webpack_require__(6932);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs\n\nclass GpuRenderTarget {\n  constructor() {\n    this.contexts = [];\n    this.msaaTextures = [];\n    this.msaaSamples = 1;\n  }\n}\n\n\n//# sourceMappingURL=GpuRenderTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs\n\n\n\n\n\n"use strict";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(\n      sourceRenderSurfaceTexture\n    );\n    const backGpuTexture = renderer.texture.getGpuSource(\n      destinationTexture.source\n    );\n    renderer.encoder.commandEncoder.copyTextureToTexture(\n      {\n        texture: baseGpuTexture,\n        origin: originSrc\n      },\n      {\n        texture: backGpuTexture,\n        origin: originDest\n      },\n      size\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(\n      renderTarget.colorTextures[0].source\n    );\n  }\n  getDescriptor(renderTarget, clear, clearValue) {\n    if (typeof clear === "boolean") {\n      clear = clear ? gl_const/* CLEAR */.u.ALL : gl_const/* CLEAR */.u.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map(\n      (texture, i) => {\n        const context = gpuRenderTarget.contexts[i];\n        let view;\n        let resolveTarget;\n        if (context) {\n          const currentTexture = context.getCurrentTexture();\n          const canvasTextureView = currentTexture.createView();\n          view = canvasTextureView;\n        } else {\n          view = this._renderer.texture.getGpuSource(texture).createView({\n            mipLevelCount: 1\n          });\n        }\n        if (gpuRenderTarget.msaaTextures[i]) {\n          resolveTarget = view;\n          view = this._renderer.texture.getTextureView(\n            gpuRenderTarget.msaaTextures[i]\n          );\n        }\n        const loadOp = clear & gl_const/* CLEAR */.u.COLOR ? "clear" : "load";\n        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n        return {\n          view,\n          resolveTarget,\n          clearValue,\n          storeOp: "store",\n          loadOp\n        };\n      }\n    );\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & gl_const/* CLEAR */.u.STENCIL ? "clear" : "load";\n      const depthLoadOp = clear & gl_const/* CLEAR */.u.DEPTH ? "clear" : "load";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n        stencilStoreOp: "store",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: "store"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget, clear = true, clearColor, viewport) {\n    if (!clear)\n      return;\n    const { gpu, encoder } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget();\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (CanvasSource/* CanvasSource */.q.test(colorTexture.resource)) {\n        const context = colorTexture.resource.getContext(\n          "webgpu"\n        );\n        const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            // eslint-disable-next-line max-len\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: "bgra8unorm",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource/* TextureSource */.v({\n          width: 0,\n          height: 0,\n          sampleCount: 4\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach((context) => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach((texture) => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture?.resize(\n          colorTexture.source.width,\n          colorTexture.source.height,\n          colorTexture.source._resolution\n        );\n      });\n    }\n  }\n}\n\n\n//# sourceMappingURL=GpuRenderTargetAdaptor.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs\n\n\n\n\n"use strict";\nclass GpuRenderTargetSystem extends RenderTargetSystem/* RenderTargetSystem */.l {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GpuRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGpuRenderTargetSystem.extension = {\n  type: [Extensions/* ExtensionType */.Ag.WebGPUSystem],\n  name: "renderTarget"\n};\n\n\n//# sourceMappingURL=GpuRenderTargetSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs\n\n\n"use strict";\nclass GpuShaderSystem {\n  constructor() {\n    this._gpuProgramData = /* @__PURE__ */ Object.create(null);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.maxTextures = gpu.device.limits.maxSampledTexturesPerShaderStage;\n  }\n  getProgramData(program) {\n    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n  }\n  _createGPUProgramData(program) {\n    const device = this._gpu.device;\n    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n    this._gpuProgramData[program._layoutKey] = {\n      bindGroups,\n      pipeline: device.createPipelineLayout(pipelineLayoutDesc)\n    };\n    return this._gpuProgramData[program._layoutKey];\n  }\n  destroy() {\n    this._gpu = null;\n    this._gpuProgramData = null;\n  }\n}\n/** @ignore */\nGpuShaderSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "shader"\n};\n\n\n//# sourceMappingURL=GpuShaderSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs\n\nconst GpuBlendModesToPixi = {};\nGpuBlendModesToPixi.normal = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.add = {\n  alpha: {\n    srcFactor: "src-alpha",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.multiply = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "dst",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.screen = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.overlay = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.none = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "zero",\n    dstFactor: "zero",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi["normal-npm"] = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "src-alpha",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi["add-npm"] = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "src-alpha",\n    dstFactor: "one",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi["screen-npm"] = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "src-alpha",\n    dstFactor: "one-minus-src",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.erase = {\n  alpha: {\n    srcFactor: "zero",\n    dstFactor: "one-minus-src-alpha",\n    operation: "add"\n  },\n  color: {\n    srcFactor: "zero",\n    dstFactor: "one-minus-src",\n    operation: "add"\n  }\n};\nGpuBlendModesToPixi.min = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "min"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "min"\n  }\n};\nGpuBlendModesToPixi.max = {\n  alpha: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "max"\n  },\n  color: {\n    srcFactor: "one",\n    dstFactor: "one",\n    operation: "max"\n  }\n};\n\n\n//# sourceMappingURL=GpuBlendModesToPixi.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs\n\n\n\n\n"use strict";\nclass GpuStateSystem {\n  constructor() {\n    this.defaultState = new State/* State */.U();\n    this.defaultState.blend = true;\n  }\n  contextChange(gpu) {\n    this.gpu = gpu;\n  }\n  /**\n   * Gets the blend mode data for the current state\n   * @param state - The state to get the blend mode from\n   */\n  getColorTargets(state) {\n    const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n    return [\n      {\n        format: "bgra8unorm",\n        writeMask: 0,\n        blend\n      }\n    ];\n  }\n  destroy() {\n    this.gpu = null;\n  }\n}\n/** @ignore */\nGpuStateSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "state"\n};\n\n\n//# sourceMappingURL=GpuStateSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(7608);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs\n\nconst gpuUploadBufferImageResource = {\n  type: "image",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n    const bytesPerPixel = resource.byteLength / total;\n    gpu.device.queue.writeTexture(\n      { texture: gpuTexture },\n      resource,\n      {\n        offset: 0,\n        rowsPerImage: source.pixelHeight,\n        bytesPerRow: source.pixelHeight * bytesPerPixel\n      },\n      {\n        width: source.pixelWidth,\n        height: source.pixelHeight,\n        depthOrArrayLayers: 1\n      }\n    );\n  }\n};\n\n\n//# sourceMappingURL=gpuUploadBufferImageResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs\n\nconst blockDataMap = {\n  "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }\n};\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\nconst gpuUploadCompressedTextureResource = {\n  type: "compressed",\n  upload(source, gpuTexture, gpu) {\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const blockData = blockDataMap[source.format] || defaultBlockData;\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n      gpu.device.queue.writeTexture(\n        {\n          texture: gpuTexture,\n          mipLevel: i\n        },\n        levelBuffer,\n        {\n          offset: 0,\n          bytesPerRow\n        },\n        {\n          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n          depthOrArrayLayers: 1\n        }\n      );\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\n\n//# sourceMappingURL=gpuUploadCompressedTextureResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs\n\nconst gpuUploadImageResource = {\n  type: "image",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    if (!resource)\n      return;\n    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n    const premultipliedAlpha = source.alphaMode === "premultiply-alpha-on-upload";\n    gpu.device.queue.copyExternalImageToTexture(\n      { source: resource },\n      { texture: gpuTexture, premultipliedAlpha },\n      {\n        width,\n        height\n      }\n    );\n  }\n};\n\n\n//# sourceMappingURL=gpuUploadImageSource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs\n\n\n"use strict";\nconst gpuUploadVideoResource = {\n  type: "video",\n  upload(source, gpuTexture, gpu) {\n    gpuUploadImageResource.upload(source, gpuTexture, gpu);\n  }\n};\n\n\n//# sourceMappingURL=gpuUploadVideoSource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs\n\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({ minFilter: "linear" });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: (\n            /* wgsl */\n            `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n          )\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: "auto",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: "vertexMain"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: "fragmentMain",\n          targets: [{ format }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === "3d" || texture.dimension === "1d") {\n      throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: "2d",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: "2d",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: "store",\n            loadOp: "clear",\n            clearValue: { r: 0, g: 0, b: 0, a: 0 }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\n\n\n//# sourceMappingURL=GpuMipmapGenerator.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._gpuSources = /* @__PURE__ */ Object.create(null);\n    this._gpuSamplers = /* @__PURE__ */ Object.create(null);\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._textureViewHash = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: gpuUploadImageResource,\n      buffer: gpuUploadBufferImageResource,\n      video: gpuUploadVideoResource,\n      compressed: gpuUploadCompressedTextureResource\n    };\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  initSource(source) {\n    if (source.autoGenerateMipmaps) {\n      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (source.uploadMethodId !== "compressed") {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n      usage |= GPUTextureUsage.COPY_SRC;\n    }\n    const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n    const textureDescriptor = {\n      label: source.label,\n      size: { width, height },\n      format: source.format,\n      sampleCount: source.sampleCount,\n      mipLevelCount: source.mipLevelCount,\n      dimension: source.dimension,\n      usage\n    };\n    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n    this._gpuSources[source.uid] = gpuTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on("update", this.onSourceUpdate, this);\n      source.on("resize", this.onSourceResize, this);\n      source.on("destroy", this.onSourceDestroy, this);\n      source.on("unload", this.onSourceUnload, this);\n      source.on("updateMipmaps", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    return gpuTexture;\n  }\n  onSourceUpdate(source) {\n    const gpuTexture = this.getGpuSource(source);\n    if (!gpuTexture)\n      return;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source);\n    }\n  }\n  onSourceUnload(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (gpuTexture) {\n      this._gpuSources[source.uid] = null;\n      gpuTexture.destroy();\n    }\n  }\n  onUpdateMipmaps(source) {\n    if (!this._mipmapGenerator) {\n      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n    }\n    const gpuTexture = this.getGpuSource(source);\n    this._mipmapGenerator.generateMipmap(gpuTexture);\n  }\n  onSourceDestroy(source) {\n    source.off("update", this.onSourceUpdate, this);\n    source.off("unload", this.onSourceUnload, this);\n    source.off("destroy", this.onSourceDestroy, this);\n    source.off("resize", this.onSourceResize, this);\n    source.off("updateMipmaps", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  onSourceResize(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (!gpuTexture) {\n      this.initSource(source);\n    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n      this._textureViewHash[source.uid] = null;\n      this._bindGroupHash[source.uid] = null;\n      this.onSourceUnload(source);\n      this.initSource(source);\n    }\n  }\n  _initSampler(sampler) {\n    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n    return this._gpuSamplers[sampler._resourceId];\n  }\n  getGpuSampler(sampler) {\n    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGpuSource(source) {\n    return this._gpuSources[source.uid] || this.initSource(source);\n  }\n  /**\n   * this returns s bind group for a specific texture, the bind group contains\n   * - the texture source\n   * - the texture style\n   * - the texture matrix\n   * This is cached so the bind group should only be created once per texture\n   * @param texture - the texture you want the bindgroup for\n   * @returns the bind group for the texture\n   */\n  getTextureBindGroup(texture) {\n    return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n  }\n  _createTextureBindGroup(texture) {\n    const source = texture.source;\n    this._bindGroupHash[texture.uid] = new BindGroup/* BindGroup */.T({\n      0: source,\n      1: source.style,\n      2: new UniformGroup/* UniformGroup */.k({\n        uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }\n      })\n    });\n    return this._bindGroupHash[texture.uid];\n  }\n  getTextureView(texture) {\n    const source = texture.source;\n    return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n  }\n  _createTextureView(texture) {\n    this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n    return this._textureViewHash[texture.uid];\n  }\n  generateCanvas(texture) {\n    const renderer = this._renderer;\n    const commandEncoder = renderer.gpu.device.createCommandEncoder();\n    const canvas = environment_adapter/* DOMAdapter */.e.get().createCanvas();\n    canvas.width = texture.source.pixelWidth;\n    canvas.height = texture.source.pixelHeight;\n    const context = canvas.getContext("webgpu");\n    context.configure({\n      device: renderer.gpu.device,\n      // eslint-disable-next-line max-len\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      format: environment_adapter/* DOMAdapter */.e.get().getNavigator().gpu.getPreferredCanvasFormat(),\n      alphaMode: "premultiplied"\n    });\n    commandEncoder.copyTextureToTexture({\n      texture: renderer.texture.getGpuSource(texture.source),\n      origin: {\n        x: 0,\n        y: 0\n      }\n    }, {\n      texture: context.getCurrentTexture()\n    }, {\n      width: canvas.width,\n      height: canvas.height\n    });\n    renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    return canvas;\n  }\n  getPixels(texture) {\n    const webGPUCanvas = this.generateCanvas(texture);\n    const canvasAndContext = CanvasPool/* CanvasPool */.N.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n    const context = canvasAndContext.context;\n    context.drawImage(webGPUCanvas, 0, 0);\n    const { width, height } = webGPUCanvas;\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = new Uint8ClampedArray(imageData.data.buffer);\n    CanvasPool/* CanvasPool */.N.returnCanvasAndContext(canvasAndContext);\n    return { pixels, width, height };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    for (const k of Object.keys(this._bindGroupHash)) {\n      const key = Number(k);\n      const bindGroup = this._bindGroupHash[key];\n      bindGroup?.destroy();\n      this._bindGroupHash[key] = null;\n    }\n    this._gpu = null;\n    this._mipmapGenerator = null;\n    this._gpuSources = null;\n    this._bindGroupHash = null;\n    this._textureViewHash = null;\n    this._gpuSamplers = null;\n  }\n}\n/** @ignore */\nGpuTextureSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "texture"\n};\n\n\n//# sourceMappingURL=GpuTextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst DefaultWebGPUSystems = [\n  ...SharedSystems/* SharedSystems */.i,\n  GpuUboSystem,\n  GpuEncoderSystem,\n  GpuDeviceSystem,\n  GpuBufferSystem,\n  GpuTextureSystem,\n  GpuRenderTargetSystem,\n  GpuShaderSystem,\n  GpuStateSystem,\n  PipelineSystem,\n  GpuColorMaskSystem,\n  GpuStencilSystem,\n  BindGroupSystem\n];\nconst DefaultWebGPUPipes = [...SharedSystems/* SharedRenderPipes */.f, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nExtensions/* extensions */.XO.handleByNamedList(Extensions/* ExtensionType */.Ag.WebGPUSystem, systems);\nExtensions/* extensions */.XO.handleByNamedList(Extensions/* ExtensionType */.Ag.WebGPUPipes, renderPipes);\nExtensions/* extensions */.XO.handleByNamedList(Extensions/* ExtensionType */.Ag.WebGPUPipesAdaptor, renderPipeAdaptors);\nExtensions/* extensions */.XO.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\nclass WebGPURenderer extends AbstractRenderer/* AbstractRenderer */.k {\n  constructor() {\n    const systemConfig = {\n      name: "webgpu",\n      type: types/* RendererType */.W.WEBGPU,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\n\n//# sourceMappingURL=WebGPURenderer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQzNCOzs7Ozs7Ozs7QUNuRm1FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRTJCO0FBQzNCOzs7OztBQ3BGc0U7QUFDSjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0QkFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUUyQjtBQUMzQjs7O0FDM0ZtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUU4QjtBQUM5Qjs7Ozs7QUM1QjhEO0FBQ0s7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQSwwQkFBMEIscUNBQVU7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyQjtBQUMzQjs7O0FDNUVtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEVBQTBFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0NBQWE7QUFDdEI7QUFDQTtBQUNBOztBQUU0QjtBQUM1Qjs7Ozs7QUMxS21FO0FBQ1Q7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRWxFO0FBQ0E7QUFDQSxLQUFLLGtDQUFhO0FBQ2xCLEVBQUUsWUFBWTtBQUNkLEVBQUUsZ0JBQWdCO0FBQ2xCLEVBQUUsZUFBZTtBQUNqQixFQUFFLGVBQWU7QUFDakIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxxQkFBcUI7QUFDdkIsRUFBRSxlQUFlO0FBQ2pCLEVBQUUsY0FBYztBQUNoQixFQUFFLGNBQWM7QUFDaEIsRUFBRSxrQkFBa0I7QUFDcEIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxlQUFlO0FBQ2pCO0FBQ0EsK0JBQStCLHNDQUFpQixFQUFFLG1CQUFtQjtBQUNyRSwrQkFBK0IsZUFBZSxFQUFFLGNBQWMsRUFBRSxrQkFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsNkJBQVUsbUJBQW1CLGdDQUFhO0FBQzFDLDZCQUFVLG1CQUFtQixnQ0FBYTtBQUMxQyw2QkFBVSxtQkFBbUIsZ0NBQWE7QUFDMUMsNkJBQVU7QUFDViw2QkFBNkIsd0NBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9ncHUvR3B1R3JhcGhpY3NBZGFwdG9yLm1qcz81M2VhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvbWVzaC9ncHUvR3B1TWVzaEFkYXB0ZXIubWpzPzlmMmUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvR3B1QmF0Y2hBZGFwdG9yLm1qcz85NjExIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvQmluZEdyb3VwU3lzdGVtLm1qcz9iMWE0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvYnVmZmVyL0dwdUJ1ZmZlclN5c3RlbS5tanM/ODMyZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdUNvbG9yTWFza1N5c3RlbS5tanM/MjRjMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdURldmljZVN5c3RlbS5tanM/MmJhMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdUVuY29kZXJTeXN0ZW0ubWpzPzE0MTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9HcHVTdGVuY2lsU3lzdGVtLm1qcz83MzQwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib0VsZW1lbnRzV0dTTC5tanM/M2RmNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3NoYWRlci91dGlscy9nZW5lcmF0ZUFycmF5U3luY1dHU0wubWpzPzE2ZmUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvdXRpbHMvY3JlYXRlVWJvU3luY0Z1bmN0aW9uV0dTTC5tanM/ZmM4YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdVVib1N5c3RlbS5tanM/M2ZiNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L2J1ZmZlci9VYm9CYXRjaC5tanM/MzE4YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdVVuaWZvcm1CYXRjaFBpcGUubWpzPzViOTgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9waXBlbGluZS9QaXBlbGluZVN5c3RlbS5tanM/YTEwNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXQubWpzP2EzZDEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9yZW5kZXJUYXJnZXQvR3B1UmVuZGVyVGFyZ2V0QWRhcHRvci5tanM/YWRkMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXRTeXN0ZW0ubWpzPzg0MDIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvR3B1U2hhZGVyU3lzdGVtLm1qcz9lNDJiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc3RhdGUvR3B1QmxlbmRNb2Rlc1RvUGl4aS5tanM/MzBjNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3N0YXRlL0dwdVN0YXRlU3lzdGVtLm1qcz85MTgyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvdGV4dHVyZS91cGxvYWRlcnMvZ3B1VXBsb2FkQnVmZmVySW1hZ2VSZXNvdXJjZS5tanM/ZjlhYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UubWpzPzAwNjciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3VwbG9hZGVycy9ncHVVcGxvYWRJbWFnZVNvdXJjZS5tanM/MTMzYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZFZpZGVvU291cmNlLm1qcz82ZjE4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvdGV4dHVyZS91dGlscy9HcHVNaXBtYXBHZW5lcmF0b3IubWpzPzY4OWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL0dwdVRleHR1cmVTeXN0ZW0ubWpzP2Y3MjUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9XZWJHUFVSZW5kZXJlci5tanM/ZWZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBnZXRNYXhUZXh0dXJlc1BlckJhdGNoIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2JhdGNoZXIvZ2wvdXRpbHMvbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5tanMnO1xuaW1wb3J0IHsgZ2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L2dldFRleHR1cmVCYXRjaEJpbmRHcm91cC5tanMnO1xuaW1wb3J0IHsgY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL2NvbXBpbGVIaWdoU2hhZGVyVG9Qcm9ncmFtLm1qcyc7XG5pbXBvcnQgeyBjb2xvckJpdCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9jb2xvckJpdC5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQubWpzJztcbmltcG9ydCB7IGxvY2FsVW5pZm9ybUJpdEdyb3VwMiB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9sb2NhbFVuaWZvcm1CaXQubWpzJztcbmltcG9ydCB7IHJvdW5kUGl4ZWxzQml0IH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL3JvdW5kUGl4ZWxzQml0Lm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1R3JhcGhpY3NBZGFwdG9yIHtcbiAgaW5pdCgpIHtcbiAgICBjb25zdCBsb2NhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1VHJhbnNmb3JtTWF0cml4OiB7IHZhbHVlOiBuZXcgTWF0cml4KCksIHR5cGU6IFwibWF0M3gzPGYzMj5cIiB9LFxuICAgICAgdUNvbG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVSb3VuZDogeyB2YWx1ZTogMCwgdHlwZTogXCJmMzJcIiB9XG4gICAgfSk7XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSh7XG4gICAgICBuYW1lOiBcImdyYXBoaWNzXCIsXG4gICAgICBiaXRzOiBbXG4gICAgICAgIGNvbG9yQml0LFxuICAgICAgICBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdChnZXRNYXhUZXh0dXJlc1BlckJhdGNoKCkpLFxuICAgICAgICBsb2NhbFVuaWZvcm1CaXRHcm91cDIsXG4gICAgICAgIHJvdW5kUGl4ZWxzQml0XG4gICAgICBdXG4gICAgfSk7XG4gICAgdGhpcy5zaGFkZXIgPSBuZXcgU2hhZGVyKHtcbiAgICAgIGdwdVByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgLy8gYWRkZWQgb24gdGhlIGZseSFcbiAgICAgICAgbG9jYWxVbmlmb3Jtc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGV4ZWN1dGUoZ3JhcGhpY3NQaXBlLCByZW5kZXJhYmxlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHJlbmRlcmFibGUuY29udGV4dDtcbiAgICBjb25zdCBzaGFkZXIgPSBjb250ZXh0LmN1c3RvbVNoYWRlciB8fCB0aGlzLnNoYWRlcjtcbiAgICBjb25zdCByZW5kZXJlciA9IGdyYXBoaWNzUGlwZS5yZW5kZXJlcjtcbiAgICBjb25zdCBjb250ZXh0U3lzdGVtID0gcmVuZGVyZXIuZ3JhcGhpY3NDb250ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIGdlb21ldHJ5LFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfSA9IGNvbnRleHRTeXN0ZW0uZ2V0Q29udGV4dFJlbmRlckRhdGEoY29udGV4dCk7XG4gICAgY29uc3QgZW5jb2RlciA9IHJlbmRlcmVyLmVuY29kZXI7XG4gICAgZW5jb2Rlci5zZXRQaXBlbGluZUZyb21HZW9tZXRyeVByb2dyYW1BbmRTdGF0ZShcbiAgICAgIGdlb21ldHJ5LFxuICAgICAgc2hhZGVyLmdwdVByb2dyYW0sXG4gICAgICBncmFwaGljc1BpcGUuc3RhdGVcbiAgICApO1xuICAgIGVuY29kZXIuc2V0R2VvbWV0cnkoZ2VvbWV0cnksIHNoYWRlci5ncHVQcm9ncmFtKTtcbiAgICBjb25zdCBnbG9iYWxVbmlmb3Jtc0JpbmRHcm91cCA9IHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLmJpbmRHcm91cDtcbiAgICBlbmNvZGVyLnNldEJpbmRHcm91cCgwLCBnbG9iYWxVbmlmb3Jtc0JpbmRHcm91cCwgc2hhZGVyLmdwdVByb2dyYW0pO1xuICAgIGNvbnN0IGxvY2FsQmluZEdyb3VwID0gcmVuZGVyZXIucmVuZGVyUGlwZXMudW5pZm9ybUJhdGNoLmdldFVuaWZvcm1CaW5kR3JvdXAoc2hhZGVyLnJlc291cmNlcy5sb2NhbFVuaWZvcm1zLCB0cnVlKTtcbiAgICBlbmNvZGVyLnNldEJpbmRHcm91cCgyLCBsb2NhbEJpbmRHcm91cCwgc2hhZGVyLmdwdVByb2dyYW0pO1xuICAgIGNvbnN0IGJhdGNoZXMgPSBpbnN0cnVjdGlvbnMuaW5zdHJ1Y3Rpb25zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmluc3RydWN0aW9uU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICBzaGFkZXIuZ3JvdXBzWzFdID0gYmF0Y2guYmluZEdyb3VwO1xuICAgICAgaWYgKCFiYXRjaC5ncHVCaW5kR3JvdXApIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZUJhdGNoID0gYmF0Y2gudGV4dHVyZXM7XG4gICAgICAgIGJhdGNoLmJpbmRHcm91cCA9IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCh0ZXh0dXJlQmF0Y2gudGV4dHVyZXMsIHRleHR1cmVCYXRjaC5jb3VudCk7XG4gICAgICAgIGJhdGNoLmdwdUJpbmRHcm91cCA9IHJlbmRlcmVyLmJpbmRHcm91cC5nZXRCaW5kR3JvdXAoXG4gICAgICAgICAgYmF0Y2guYmluZEdyb3VwLFxuICAgICAgICAgIHNoYWRlci5ncHVQcm9ncmFtLFxuICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVuY29kZXIuc2V0QmluZEdyb3VwKDEsIGJhdGNoLmJpbmRHcm91cCwgc2hhZGVyLmdwdVByb2dyYW0pO1xuICAgICAgZW5jb2Rlci5yZW5kZXJQYXNzRW5jb2Rlci5kcmF3SW5kZXhlZChiYXRjaC5zaXplLCAxLCBiYXRjaC5zdGFydCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zaGFkZXIuZGVzdHJveSh0cnVlKTtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcHVHcmFwaGljc0FkYXB0b3IuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlc0FkYXB0b3JcbiAgXSxcbiAgbmFtZTogXCJncmFwaGljc1wiXG59O1xuXG5leHBvcnQgeyBHcHVHcmFwaGljc0FkYXB0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdUdyYXBoaWNzQWRhcHRvci5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBjb21waWxlSGlnaFNoYWRlckdwdVByb2dyYW0gfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IGxvY2FsVW5pZm9ybUJpdCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9sb2NhbFVuaWZvcm1CaXQubWpzJztcbmltcG9ydCB7IHJvdW5kUGl4ZWxzQml0IH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL3JvdW5kUGl4ZWxzQml0Lm1qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlQml0IH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL3RleHR1cmVCaXQubWpzJztcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9TaGFkZXIubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcHVNZXNoQWRhcHRlciB7XG4gIGluaXQoKSB7XG4gICAgY29uc3QgZ3B1UHJvZ3JhbSA9IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSh7XG4gICAgICBuYW1lOiBcIm1lc2hcIixcbiAgICAgIGJpdHM6IFtcbiAgICAgICAgbG9jYWxVbmlmb3JtQml0LFxuICAgICAgICB0ZXh0dXJlQml0LFxuICAgICAgICByb3VuZFBpeGVsc0JpdFxuICAgICAgXVxuICAgIH0pO1xuICAgIHRoaXMuX3NoYWRlciA9IG5ldyBTaGFkZXIoe1xuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICB1VGV4dHVyZTogVGV4dHVyZS5FTVBUWS5fc291cmNlLFxuICAgICAgICB1U2FtcGxlcjogVGV4dHVyZS5FTVBUWS5fc291cmNlLnN0eWxlLFxuICAgICAgICB0ZXh0dXJlVW5pZm9ybXM6IHtcbiAgICAgICAgICB1VGV4dHVyZU1hdHJpeDogeyB0eXBlOiBcIm1hdDN4MzxmMzI+XCIsIHZhbHVlOiBuZXcgTWF0cml4KCkgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZXhlY3V0ZShtZXNoUGlwZSwgbWVzaCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbWVzaFBpcGUucmVuZGVyZXI7XG4gICAgbGV0IHNoYWRlciA9IG1lc2guX3NoYWRlcjtcbiAgICBpZiAoIXNoYWRlcikge1xuICAgICAgc2hhZGVyID0gdGhpcy5fc2hhZGVyO1xuICAgICAgc2hhZGVyLmdyb3Vwc1syXSA9IHJlbmRlcmVyLnRleHR1cmUuZ2V0VGV4dHVyZUJpbmRHcm91cChtZXNoLnRleHR1cmUpO1xuICAgIH0gZWxzZSBpZiAoIXNoYWRlci5ncHVQcm9ncmFtKSB7XG4gICAgICB3YXJuKFwiTWVzaCBzaGFkZXIgaGFzIG5vIGdwdVByb2dyYW1cIiwgbWVzaC5zaGFkZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBncHVQcm9ncmFtID0gc2hhZGVyLmdwdVByb2dyYW07XG4gICAgaWYgKGdwdVByb2dyYW0uYXV0b0Fzc2lnbkdsb2JhbFVuaWZvcm1zKSB7XG4gICAgICBzaGFkZXIuZ3JvdXBzWzBdID0gcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMuYmluZEdyb3VwO1xuICAgIH1cbiAgICBpZiAoZ3B1UHJvZ3JhbS5hdXRvQXNzaWduTG9jYWxVbmlmb3Jtcykge1xuICAgICAgY29uc3QgbG9jYWxVbmlmb3JtcyA9IG1lc2hQaXBlLmxvY2FsVW5pZm9ybXM7XG4gICAgICBzaGFkZXIuZ3JvdXBzWzFdID0gcmVuZGVyZXIucmVuZGVyUGlwZXMudW5pZm9ybUJhdGNoLmdldFVuaWZvcm1CaW5kR3JvdXAobG9jYWxVbmlmb3JtcywgdHJ1ZSk7XG4gICAgfVxuICAgIHJlbmRlcmVyLmVuY29kZXIuZHJhdyh7XG4gICAgICBnZW9tZXRyeTogbWVzaC5fZ2VvbWV0cnksXG4gICAgICBzaGFkZXIsXG4gICAgICBzdGF0ZTogbWVzaC5zdGF0ZVxuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc2hhZGVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgdGhpcy5fc2hhZGVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdwdU1lc2hBZGFwdGVyLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXNBZGFwdG9yXG4gIF0sXG4gIG5hbWU6IFwibWVzaFwiXG59O1xuXG5leHBvcnQgeyBHcHVNZXNoQWRhcHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1TWVzaEFkYXB0ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtIH0gZnJvbSAnLi4vLi4vaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IGNvbG9yQml0IH0gZnJvbSAnLi4vLi4vaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvY29sb3JCaXQubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlVGV4dHVyZUJhdGNoQml0IH0gZnJvbSAnLi4vLi4vaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQubWpzJztcbmltcG9ydCB7IHJvdW5kUGl4ZWxzQml0IH0gZnJvbSAnLi4vLi4vaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvcm91bmRQaXhlbHNCaXQubWpzJztcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1NoYWRlci5tanMnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBnZXRNYXhUZXh0dXJlc1BlckJhdGNoIH0gZnJvbSAnLi4vZ2wvdXRpbHMvbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5tanMnO1xuaW1wb3J0IHsgZ2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwIH0gZnJvbSAnLi9nZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wU3RhdGUgPSBTdGF0ZS5mb3IyZCgpO1xuY2xhc3MgR3B1QmF0Y2hBZGFwdG9yIHtcbiAgaW5pdCgpIHtcbiAgICBjb25zdCBncHVQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwiYmF0Y2hcIixcbiAgICAgIGJpdHM6IFtcbiAgICAgICAgY29sb3JCaXQsXG4gICAgICAgIGdlbmVyYXRlVGV4dHVyZUJhdGNoQml0KGdldE1heFRleHR1cmVzUGVyQmF0Y2goKSksXG4gICAgICAgIHJvdW5kUGl4ZWxzQml0XG4gICAgICBdXG4gICAgfSk7XG4gICAgdGhpcy5fc2hhZGVyID0gbmV3IFNoYWRlcih7XG4gICAgICBncHVQcm9ncmFtLFxuICAgICAgZ3JvdXBzOiB7XG4gICAgICAgIC8vIHRoZXNlIHdpbGwgYmUgZHluYW1pY2FsbHkgYWxsb2NhdGVkXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhcnQoYmF0Y2hQaXBlLCBnZW9tZXRyeSkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gYmF0Y2hQaXBlLnJlbmRlcmVyO1xuICAgIGNvbnN0IGVuY29kZXIgPSByZW5kZXJlci5lbmNvZGVyO1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLl9zaGFkZXIuZ3B1UHJvZ3JhbTtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgIGVuY29kZXIuc2V0R2VvbWV0cnkoZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIHRlbXBTdGF0ZS5ibGVuZE1vZGUgPSBcIm5vcm1hbFwiO1xuICAgIHJlbmRlcmVyLnBpcGVsaW5lLmdldFBpcGVsaW5lKFxuICAgICAgZ2VvbWV0cnksXG4gICAgICBwcm9ncmFtLFxuICAgICAgdGVtcFN0YXRlXG4gICAgKTtcbiAgICBjb25zdCBnbG9iYWxVbmlmb3Jtc0JpbmRHcm91cCA9IHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLmJpbmRHcm91cDtcbiAgICBlbmNvZGVyLnJlc2V0QmluZEdyb3VwKDEpO1xuICAgIGVuY29kZXIuc2V0QmluZEdyb3VwKDAsIGdsb2JhbFVuaWZvcm1zQmluZEdyb3VwLCBwcm9ncmFtKTtcbiAgfVxuICBleGVjdXRlKGJhdGNoUGlwZSwgYmF0Y2gpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5fc2hhZGVyLmdwdVByb2dyYW07XG4gICAgY29uc3QgcmVuZGVyZXIgPSBiYXRjaFBpcGUucmVuZGVyZXI7XG4gICAgY29uc3QgZW5jb2RlciA9IHJlbmRlcmVyLmVuY29kZXI7XG4gICAgaWYgKCFiYXRjaC5iaW5kR3JvdXApIHtcbiAgICAgIGNvbnN0IHRleHR1cmVCYXRjaCA9IGJhdGNoLnRleHR1cmVzO1xuICAgICAgYmF0Y2guYmluZEdyb3VwID0gZ2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwKHRleHR1cmVCYXRjaC50ZXh0dXJlcywgdGV4dHVyZUJhdGNoLmNvdW50KTtcbiAgICB9XG4gICAgdGVtcFN0YXRlLmJsZW5kTW9kZSA9IGJhdGNoLmJsZW5kTW9kZTtcbiAgICBjb25zdCBncHVCaW5kR3JvdXAgPSByZW5kZXJlci5iaW5kR3JvdXAuZ2V0QmluZEdyb3VwKFxuICAgICAgYmF0Y2guYmluZEdyb3VwLFxuICAgICAgcHJvZ3JhbSxcbiAgICAgIDFcbiAgICApO1xuICAgIGNvbnN0IHBpcGVsaW5lID0gcmVuZGVyZXIucGlwZWxpbmUuZ2V0UGlwZWxpbmUoXG4gICAgICB0aGlzLl9nZW9tZXRyeSxcbiAgICAgIHByb2dyYW0sXG4gICAgICB0ZW1wU3RhdGVcbiAgICApO1xuICAgIGJhdGNoLmJpbmRHcm91cC5fdG91Y2gocmVuZGVyZXIudGV4dHVyZUdDLmNvdW50KTtcbiAgICBlbmNvZGVyLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcbiAgICBlbmNvZGVyLnJlbmRlclBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgxLCBncHVCaW5kR3JvdXApO1xuICAgIGVuY29kZXIucmVuZGVyUGFzc0VuY29kZXIuZHJhd0luZGV4ZWQoYmF0Y2guc2l6ZSwgMSwgYmF0Y2guc3RhcnQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc2hhZGVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgdGhpcy5fc2hhZGVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdwdUJhdGNoQWRhcHRvci5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzQWRhcHRvclxuICBdLFxuICBuYW1lOiBcImJhdGNoXCJcbn07XG5cbmV4cG9ydCB7IEdwdUJhdGNoQWRhcHRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1QmF0Y2hBZGFwdG9yLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCaW5kR3JvdXBTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2hhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ3B1KSB7XG4gICAgdGhpcy5fZ3B1ID0gZ3B1O1xuICB9XG4gIGdldEJpbmRHcm91cChiaW5kR3JvdXAsIHByb2dyYW0sIGdyb3VwSW5kZXgpIHtcbiAgICBiaW5kR3JvdXAuX3VwZGF0ZUtleSgpO1xuICAgIGNvbnN0IGdwdUJpbmRHcm91cCA9IHRoaXMuX2hhc2hbYmluZEdyb3VwLl9rZXldIHx8IHRoaXMuX2NyZWF0ZUJpbmRHcm91cChiaW5kR3JvdXAsIHByb2dyYW0sIGdyb3VwSW5kZXgpO1xuICAgIHJldHVybiBncHVCaW5kR3JvdXA7XG4gIH1cbiAgX2NyZWF0ZUJpbmRHcm91cChncm91cCwgcHJvZ3JhbSwgZ3JvdXBJbmRleCkge1xuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuX2dwdS5kZXZpY2U7XG4gICAgY29uc3QgZ3JvdXBMYXlvdXQgPSBwcm9ncmFtLmxheW91dFtncm91cEluZGV4XTtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICBmb3IgKGNvbnN0IGogaW4gZ3JvdXBMYXlvdXQpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gZ3JvdXAucmVzb3VyY2VzW2pdID8/IGdyb3VwLnJlc291cmNlc1tncm91cExheW91dFtqXV07XG4gICAgICBsZXQgZ3B1UmVzb3VyY2U7XG4gICAgICBpZiAocmVzb3VyY2UuX3Jlc291cmNlVHlwZSA9PT0gXCJ1bmlmb3JtR3JvdXBcIikge1xuICAgICAgICBjb25zdCB1bmlmb3JtR3JvdXAgPSByZXNvdXJjZTtcbiAgICAgICAgcmVuZGVyZXIudWJvLnVwZGF0ZVVuaWZvcm1Hcm91cCh1bmlmb3JtR3JvdXApO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1bmlmb3JtR3JvdXAuYnVmZmVyO1xuICAgICAgICBncHVSZXNvdXJjZSA9IHtcbiAgICAgICAgICBidWZmZXI6IHJlbmRlcmVyLmJ1ZmZlci5nZXRHUFVCdWZmZXIoYnVmZmVyKSxcbiAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgc2l6ZTogYnVmZmVyLmRlc2NyaXB0b3Iuc2l6ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZS5fcmVzb3VyY2VUeXBlID09PSBcImJ1ZmZlclwiKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHJlc291cmNlO1xuICAgICAgICBncHVSZXNvdXJjZSA9IHtcbiAgICAgICAgICBidWZmZXI6IHJlbmRlcmVyLmJ1ZmZlci5nZXRHUFVCdWZmZXIoYnVmZmVyKSxcbiAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgc2l6ZTogYnVmZmVyLmRlc2NyaXB0b3Iuc2l6ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZS5fcmVzb3VyY2VUeXBlID09PSBcImJ1ZmZlclJlc291cmNlXCIpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyUmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICAgICAgZ3B1UmVzb3VyY2UgPSB7XG4gICAgICAgICAgYnVmZmVyOiByZW5kZXJlci5idWZmZXIuZ2V0R1BVQnVmZmVyKGJ1ZmZlclJlc291cmNlLmJ1ZmZlciksXG4gICAgICAgICAgb2Zmc2V0OiBidWZmZXJSZXNvdXJjZS5vZmZzZXQsXG4gICAgICAgICAgc2l6ZTogYnVmZmVyUmVzb3VyY2Uuc2l6ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChyZXNvdXJjZS5fcmVzb3VyY2VUeXBlID09PSBcInRleHR1cmVTYW1wbGVyXCIpIHtcbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IHJlc291cmNlO1xuICAgICAgICBncHVSZXNvdXJjZSA9IHJlbmRlcmVyLnRleHR1cmUuZ2V0R3B1U2FtcGxlcihzYW1wbGVyKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UuX3Jlc291cmNlVHlwZSA9PT0gXCJ0ZXh0dXJlU291cmNlXCIpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHJlc291cmNlO1xuICAgICAgICBncHVSZXNvdXJjZSA9IHJlbmRlcmVyLnRleHR1cmUuZ2V0R3B1U291cmNlKHRleHR1cmUpLmNyZWF0ZVZpZXcoe30pO1xuICAgICAgfVxuICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgYmluZGluZzogZ3JvdXBMYXlvdXRbal0sXG4gICAgICAgIHJlc291cmNlOiBncHVSZXNvdXJjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGxheW91dCA9IHJlbmRlcmVyLnNoYWRlci5nZXRQcm9ncmFtRGF0YShwcm9ncmFtKS5iaW5kR3JvdXBzW2dyb3VwSW5kZXhdO1xuICAgIGNvbnN0IGdwdUJpbmRHcm91cCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xuICAgICAgbGF5b3V0LFxuICAgICAgZW50cmllc1xuICAgIH0pO1xuICAgIHRoaXMuX2hhc2hbZ3JvdXAuX2tleV0gPSBncHVCaW5kR3JvdXA7XG4gICAgcmV0dXJuIGdwdUJpbmRHcm91cDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX2hhc2gpKSB7XG4gICAgICB0aGlzLl9oYXNoW2tleV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9oYXNoID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5CaW5kR3JvdXBTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJiaW5kR3JvdXBcIlxufTtcblxuZXhwb3J0IHsgQmluZEdyb3VwU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaW5kR3JvdXBTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgZmFzdENvcHkgfSBmcm9tICcuLi8uLi9zaGFyZWQvYnVmZmVyL3V0aWxzL2Zhc3RDb3B5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1QnVmZmVyU3lzdGVtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZ3B1QnVmZmVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX21hbmFnZWRCdWZmZXJzID0gW107XG4gIH1cbiAgY29udGV4dENoYW5nZShncHUpIHtcbiAgICB0aGlzLl9ncHUgPSBncHU7XG4gIH1cbiAgZ2V0R1BVQnVmZmVyKGJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLl9ncHVCdWZmZXJzW2J1ZmZlci51aWRdIHx8IHRoaXMuY3JlYXRlR1BVQnVmZmVyKGJ1ZmZlcik7XG4gIH1cbiAgdXBkYXRlQnVmZmVyKGJ1ZmZlcikge1xuICAgIGNvbnN0IGdwdUJ1ZmZlciA9IHRoaXMuX2dwdUJ1ZmZlcnNbYnVmZmVyLnVpZF0gfHwgdGhpcy5jcmVhdGVHUFVCdWZmZXIoYnVmZmVyKTtcbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLmRhdGE7XG4gICAgaWYgKGJ1ZmZlci5fdXBkYXRlSUQgJiYgZGF0YSkge1xuICAgICAgYnVmZmVyLl91cGRhdGVJRCA9IDA7XG4gICAgICB0aGlzLl9ncHUuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFxuICAgICAgICBncHVCdWZmZXIsXG4gICAgICAgIDAsXG4gICAgICAgIGRhdGEuYnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICAvLyByb3VuZCB0byB0aGUgbmVhcmVzdCA0IGJ5dGVzXG4gICAgICAgIChidWZmZXIuX3VwZGF0ZVNpemUgfHwgZGF0YS5ieXRlTGVuZ3RoKSArIDMgJiB+M1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGdwdUJ1ZmZlcjtcbiAgfVxuICAvKiogZGlzcG9zZSBhbGwgV2ViR0wgcmVzb3VyY2VzIG9mIGFsbCBtYW5hZ2VkIGJ1ZmZlcnMgKi9cbiAgZGVzdHJveUFsbCgpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuX2dwdUJ1ZmZlcnMpIHtcbiAgICAgIHRoaXMuX2dwdUJ1ZmZlcnNbaWRdLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5fZ3B1QnVmZmVycyA9IHt9O1xuICB9XG4gIGNyZWF0ZUdQVUJ1ZmZlcihidWZmZXIpIHtcbiAgICBpZiAoIXRoaXMuX2dwdUJ1ZmZlcnNbYnVmZmVyLnVpZF0pIHtcbiAgICAgIGJ1ZmZlci5vbihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZUJ1ZmZlciwgdGhpcyk7XG4gICAgICBidWZmZXIub24oXCJjaGFuZ2VcIiwgdGhpcy5vbkJ1ZmZlckNoYW5nZSwgdGhpcyk7XG4gICAgICBidWZmZXIub24oXCJkZXN0cm95XCIsIHRoaXMub25CdWZmZXJEZXN0cm95LCB0aGlzKTtcbiAgICAgIHRoaXMuX21hbmFnZWRCdWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICB9XG4gICAgY29uc3QgZ3B1QnVmZmVyID0gdGhpcy5fZ3B1LmRldmljZS5jcmVhdGVCdWZmZXIoYnVmZmVyLmRlc2NyaXB0b3IpO1xuICAgIGJ1ZmZlci5fdXBkYXRlSUQgPSAwO1xuICAgIGlmIChidWZmZXIuZGF0YSkge1xuICAgICAgZmFzdENvcHkoYnVmZmVyLmRhdGEuYnVmZmVyLCBncHVCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSk7XG4gICAgICBncHVCdWZmZXIudW5tYXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZ3B1QnVmZmVyc1tidWZmZXIudWlkXSA9IGdwdUJ1ZmZlcjtcbiAgICByZXR1cm4gZ3B1QnVmZmVyO1xuICB9XG4gIG9uQnVmZmVyQ2hhbmdlKGJ1ZmZlcikge1xuICAgIGNvbnN0IGdwdUJ1ZmZlciA9IHRoaXMuX2dwdUJ1ZmZlcnNbYnVmZmVyLnVpZF07XG4gICAgZ3B1QnVmZmVyLmRlc3Ryb3koKTtcbiAgICBidWZmZXIuX3VwZGF0ZUlEID0gMDtcbiAgICB0aGlzLl9ncHVCdWZmZXJzW2J1ZmZlci51aWRdID0gdGhpcy5jcmVhdGVHUFVCdWZmZXIoYnVmZmVyKTtcbiAgfVxuICAvKipcbiAgICogRGlzcG9zZXMgYnVmZmVyXG4gICAqIEBwYXJhbSBidWZmZXIgLSBidWZmZXIgd2l0aCBkYXRhXG4gICAqL1xuICBvbkJ1ZmZlckRlc3Ryb3koYnVmZmVyKSB7XG4gICAgdGhpcy5fbWFuYWdlZEJ1ZmZlcnMuc3BsaWNlKHRoaXMuX21hbmFnZWRCdWZmZXJzLmluZGV4T2YoYnVmZmVyKSwgMSk7XG4gICAgdGhpcy5fZGVzdHJveUJ1ZmZlcihidWZmZXIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fbWFuYWdlZEJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB0aGlzLl9kZXN0cm95QnVmZmVyKGJ1ZmZlcikpO1xuICAgIHRoaXMuX21hbmFnZWRCdWZmZXJzID0gbnVsbDtcbiAgICB0aGlzLl9ncHVCdWZmZXJzID0gbnVsbDtcbiAgfVxuICBfZGVzdHJveUJ1ZmZlcihidWZmZXIpIHtcbiAgICBjb25zdCBncHVCdWZmZXIgPSB0aGlzLl9ncHVCdWZmZXJzW2J1ZmZlci51aWRdO1xuICAgIGdwdUJ1ZmZlci5kZXN0cm95KCk7XG4gICAgYnVmZmVyLm9mZihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZUJ1ZmZlciwgdGhpcyk7XG4gICAgYnVmZmVyLm9mZihcImNoYW5nZVwiLCB0aGlzLm9uQnVmZmVyQ2hhbmdlLCB0aGlzKTtcbiAgICBidWZmZXIub2ZmKFwiZGVzdHJveVwiLCB0aGlzLm9uQnVmZmVyRGVzdHJveSwgdGhpcyk7XG4gICAgdGhpcy5fZ3B1QnVmZmVyc1tidWZmZXIudWlkXSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcHVCdWZmZXJTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJidWZmZXJcIlxufTtcblxuZXhwb3J0IHsgR3B1QnVmZmVyU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVCdWZmZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdUNvbG9yTWFza1N5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fY29sb3JNYXNrQ2FjaGUgPSAxNTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHNldE1hc2soY29sb3JNYXNrKSB7XG4gICAgaWYgKHRoaXMuX2NvbG9yTWFza0NhY2hlID09PSBjb2xvck1hc2spXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY29sb3JNYXNrQ2FjaGUgPSBjb2xvck1hc2s7XG4gICAgdGhpcy5fcmVuZGVyZXIucGlwZWxpbmUuc2V0Q29sb3JNYXNrKGNvbG9yTWFzayk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fY29sb3JNYXNrQ2FjaGUgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3B1Q29sb3JNYXNrU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiY29sb3JNYXNrXCJcbn07XG5cbmV4cG9ydCB7IEdwdUNvbG9yTWFza1N5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1Q29sb3JNYXNrU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1RGV2aWNlU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2ViR1BVUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBhc3luYyBpbml0KG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5faW5pdFByb21pc2UpXG4gICAgICByZXR1cm4gdGhpcy5faW5pdFByb21pc2U7XG4gICAgdGhpcy5faW5pdFByb21pc2UgPSB0aGlzLl9jcmVhdGVEZXZpY2VBbmRBZGFwdG9yKG9wdGlvbnMpLnRoZW4oKGdwdSkgPT4ge1xuICAgICAgdGhpcy5ncHUgPSBncHU7XG4gICAgICB0aGlzLl9yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuZW1pdCh0aGlzLmdwdSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2luaXRQcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIGNvbnRleHQgY2hhbmdlIGV2ZW50XG4gICAqIEBwYXJhbSBncHVcbiAgICovXG4gIGNvbnRleHRDaGFuZ2UoZ3B1KSB7XG4gICAgdGhpcy5fcmVuZGVyZXIuZ3B1ID0gZ3B1O1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGEgV2ViR0wgQ29udGV4dFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRoYXQgZ2V0cyBwYXNzZWQgaW4gdG8gdGhlIGNhbnZhcyBlbGVtZW50IGNvbnRhaW5pbmcgdGhlXG4gICAqICAgIGNvbnRleHQgYXR0cmlidXRlc1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC9nZXRDb250ZXh0XG4gICAqIEByZXR1cm5zIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHRoZSBXZWJHTCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBfY3JlYXRlRGV2aWNlQW5kQWRhcHRvcihvcHRpb25zKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IGF3YWl0IERPTUFkYXB0ZXIuZ2V0KCkuZ2V0TmF2aWdhdG9yKCkuZ3B1LnJlcXVlc3RBZGFwdGVyKHtcbiAgICAgIHBvd2VyUHJlZmVyZW5jZTogb3B0aW9ucy5wb3dlclByZWZlcmVuY2UsXG4gICAgICBmb3JjZUZhbGxiYWNrQWRhcHRlcjogb3B0aW9ucy5mb3JjZUZhbGxiYWNrQWRhcHRlclxuICAgIH0pO1xuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZXMgPSBbXG4gICAgICBcInRleHR1cmUtY29tcHJlc3Npb24tYmNcIixcbiAgICAgIFwidGV4dHVyZS1jb21wcmVzc2lvbi1hc3RjXCIsXG4gICAgICBcInRleHR1cmUtY29tcHJlc3Npb24tZXRjMlwiXG4gICAgXS5maWx0ZXIoKGZlYXR1cmUpID0+IGFkYXB0ZXIuZmVhdHVyZXMuaGFzKGZlYXR1cmUpKTtcbiAgICBjb25zdCBkZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2Uoe1xuICAgICAgcmVxdWlyZWRGZWF0dXJlc1xuICAgIH0pO1xuICAgIHJldHVybiB7IGFkYXB0ZXIsIGRldmljZSB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ncHUgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdwdURldmljZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbVxuICBdLFxuICBuYW1lOiBcImRldmljZVwiXG59O1xuLyoqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBHcHVEZXZpY2VTeXN0ZW0uICovXG5HcHVEZXZpY2VTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgV2ViR1BVT3B0aW9ucy5wb3dlclByZWZlcmVuY2V9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICovXG4gIHBvd2VyUHJlZmVyZW5jZTogdm9pZCAwLFxuICAvKipcbiAgICogRm9yY2UgdGhlIHVzZSBvZiB0aGUgZmFsbGJhY2sgYWRhcHRlclxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZm9yY2VGYWxsYmFja0FkYXB0ZXI6IGZhbHNlXG59O1xuXG5leHBvcnQgeyBHcHVEZXZpY2VTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdURldmljZVN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1RW5jb2RlclN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fYm91bmRCaW5kR3JvdXAgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ib3VuZFZlcnRleEJ1ZmZlciA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgcmVuZGVyU3RhcnQoKSB7XG4gICAgdGhpcy5jb21tYW5kRmluaXNoZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZUNvbW1hbmRGaW5pc2hlZCA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgdGhpcy5jb21tYW5kRW5jb2RlciA9IHRoaXMuX3JlbmRlcmVyLmdwdS5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgfVxuICBiZWdpblJlbmRlclBhc3MoZ3B1UmVuZGVyVGFyZ2V0KSB7XG4gICAgdGhpcy5lbmRSZW5kZXJQYXNzKCk7XG4gICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgIHRoaXMucmVuZGVyUGFzc0VuY29kZXIgPSB0aGlzLmNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyhncHVSZW5kZXJUYXJnZXQuZGVzY3JpcHRvcik7XG4gIH1cbiAgZW5kUmVuZGVyUGFzcygpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJQYXNzRW5jb2Rlcikge1xuICAgICAgdGhpcy5yZW5kZXJQYXNzRW5jb2Rlci5lbmQoKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJQYXNzRW5jb2RlciA9IG51bGw7XG4gIH1cbiAgc2V0Vmlld3BvcnQodmlld3BvcnQpIHtcbiAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyLnNldFZpZXdwb3J0KHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQsIDAsIDEpO1xuICB9XG4gIHNldFBpcGVsaW5lRnJvbUdlb21ldHJ5UHJvZ3JhbUFuZFN0YXRlKGdlb21ldHJ5LCBwcm9ncmFtLCBzdGF0ZSwgdG9wb2xvZ3kpIHtcbiAgICBjb25zdCBwaXBlbGluZSA9IHRoaXMuX3JlbmRlcmVyLnBpcGVsaW5lLmdldFBpcGVsaW5lKGdlb21ldHJ5LCBwcm9ncmFtLCBzdGF0ZSwgdG9wb2xvZ3kpO1xuICAgIHRoaXMuc2V0UGlwZWxpbmUocGlwZWxpbmUpO1xuICB9XG4gIHNldFBpcGVsaW5lKHBpcGVsaW5lKSB7XG4gICAgaWYgKHRoaXMuX2JvdW5kUGlwZWxpbmUgPT09IHBpcGVsaW5lKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2JvdW5kUGlwZWxpbmUgPSBwaXBlbGluZTtcbiAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcbiAgfVxuICBfc2V0VmVydGV4QnVmZmVyKGluZGV4LCBidWZmZXIpIHtcbiAgICBpZiAodGhpcy5fYm91bmRWZXJ0ZXhCdWZmZXJbaW5kZXhdID09PSBidWZmZXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fYm91bmRWZXJ0ZXhCdWZmZXJbaW5kZXhdID0gYnVmZmVyO1xuICAgIHRoaXMucmVuZGVyUGFzc0VuY29kZXIuc2V0VmVydGV4QnVmZmVyKGluZGV4LCB0aGlzLl9yZW5kZXJlci5idWZmZXIudXBkYXRlQnVmZmVyKGJ1ZmZlcikpO1xuICB9XG4gIF9zZXRJbmRleEJ1ZmZlcihidWZmZXIpIHtcbiAgICBpZiAodGhpcy5fYm91bmRJbmRleEJ1ZmZlciA9PT0gYnVmZmVyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2JvdW5kSW5kZXhCdWZmZXIgPSBidWZmZXI7XG4gICAgY29uc3QgaW5kZXhGb3JtYXQgPSBidWZmZXIuZGF0YS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMiA/IFwidWludDE2XCIgOiBcInVpbnQzMlwiO1xuICAgIHRoaXMucmVuZGVyUGFzc0VuY29kZXIuc2V0SW5kZXhCdWZmZXIodGhpcy5fcmVuZGVyZXIuYnVmZmVyLnVwZGF0ZUJ1ZmZlcihidWZmZXIpLCBpbmRleEZvcm1hdCk7XG4gIH1cbiAgcmVzZXRCaW5kR3JvdXAoaW5kZXgpIHtcbiAgICB0aGlzLl9ib3VuZEJpbmRHcm91cFtpbmRleF0gPSBudWxsO1xuICB9XG4gIHNldEJpbmRHcm91cChpbmRleCwgYmluZEdyb3VwLCBwcm9ncmFtKSB7XG4gICAgaWYgKHRoaXMuX2JvdW5kQmluZEdyb3VwW2luZGV4XSA9PT0gYmluZEdyb3VwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2JvdW5kQmluZEdyb3VwW2luZGV4XSA9IGJpbmRHcm91cDtcbiAgICBiaW5kR3JvdXAuX3RvdWNoKHRoaXMuX3JlbmRlcmVyLnRleHR1cmVHQy5jb3VudCk7XG4gICAgY29uc3QgZ3B1QmluZEdyb3VwID0gdGhpcy5fcmVuZGVyZXIuYmluZEdyb3VwLmdldEJpbmRHcm91cChiaW5kR3JvdXAsIHByb2dyYW0sIGluZGV4KTtcbiAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyLnNldEJpbmRHcm91cChpbmRleCwgZ3B1QmluZEdyb3VwKTtcbiAgfVxuICBzZXRHZW9tZXRyeShnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGJ1ZmZlcnNUb0JpbmQgPSB0aGlzLl9yZW5kZXJlci5waXBlbGluZS5nZXRCdWZmZXJOYW1lc1RvQmluZChnZW9tZXRyeSwgcHJvZ3JhbSk7XG4gICAgZm9yIChjb25zdCBpIGluIGJ1ZmZlcnNUb0JpbmQpIHtcbiAgICAgIHRoaXMuX3NldFZlcnRleEJ1ZmZlcihpLCBnZW9tZXRyeS5hdHRyaWJ1dGVzW2J1ZmZlcnNUb0JpbmRbaV1dLmJ1ZmZlcik7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgdGhpcy5fc2V0SW5kZXhCdWZmZXIoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpO1xuICAgIH1cbiAgfVxuICBfc2V0U2hhZGVyQmluZEdyb3VwcyhzaGFkZXIsIHNraXBTeW5jKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHNoYWRlci5ncm91cHMpIHtcbiAgICAgIGNvbnN0IGJpbmRHcm91cCA9IHNoYWRlci5ncm91cHNbaV07XG4gICAgICBpZiAoIXNraXBTeW5jKSB7XG4gICAgICAgIHRoaXMuX3N5bmNCaW5kR3JvdXAoYmluZEdyb3VwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0QmluZEdyb3VwKGksIGJpbmRHcm91cCwgc2hhZGVyLmdwdVByb2dyYW0pO1xuICAgIH1cbiAgfVxuICBfc3luY0JpbmRHcm91cChiaW5kR3JvdXApIHtcbiAgICBmb3IgKGNvbnN0IGogaW4gYmluZEdyb3VwLnJlc291cmNlcykge1xuICAgICAgY29uc3QgcmVzb3VyY2UgPSBiaW5kR3JvdXAucmVzb3VyY2VzW2pdO1xuICAgICAgaWYgKHJlc291cmNlLmlzVW5pZm9ybUdyb3VwKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnViby51cGRhdGVVbmlmb3JtR3JvdXAocmVzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGdlb21ldHJ5LCBzaGFkZXIsIHN0YXRlLCB0b3BvbG9neSwgc2l6ZSwgc3RhcnQsIGluc3RhbmNlQ291bnQsIHNraXBTeW5jIH0gPSBvcHRpb25zO1xuICAgIHRoaXMuc2V0UGlwZWxpbmVGcm9tR2VvbWV0cnlQcm9ncmFtQW5kU3RhdGUoZ2VvbWV0cnksIHNoYWRlci5ncHVQcm9ncmFtLCBzdGF0ZSwgdG9wb2xvZ3kpO1xuICAgIHRoaXMuc2V0R2VvbWV0cnkoZ2VvbWV0cnksIHNoYWRlci5ncHVQcm9ncmFtKTtcbiAgICB0aGlzLl9zZXRTaGFkZXJCaW5kR3JvdXBzKHNoYWRlciwgc2tpcFN5bmMpO1xuICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgdGhpcy5yZW5kZXJQYXNzRW5jb2Rlci5kcmF3SW5kZXhlZChcbiAgICAgICAgc2l6ZSB8fCBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhLmxlbmd0aCxcbiAgICAgICAgaW5zdGFuY2VDb3VudCB8fCBnZW9tZXRyeS5pbnN0YW5jZUNvdW50LFxuICAgICAgICBzdGFydCB8fCAwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyLmRyYXcoc2l6ZSB8fCBnZW9tZXRyeS5nZXRTaXplKCksIGluc3RhbmNlQ291bnQgfHwgZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCwgc3RhcnQgfHwgMCk7XG4gICAgfVxuICB9XG4gIGZpbmlzaFJlbmRlclBhc3MoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyUGFzc0VuY29kZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyUGFzc0VuY29kZXIuZW5kKCk7XG4gICAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcG9zdHJlbmRlcigpIHtcbiAgICB0aGlzLmZpbmlzaFJlbmRlclBhc3MoKTtcbiAgICB0aGlzLl9ncHUuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbdGhpcy5jb21tYW5kRW5jb2Rlci5maW5pc2goKV0pO1xuICAgIHRoaXMuX3Jlc29sdmVDb21tYW5kRmluaXNoZWQoKTtcbiAgICB0aGlzLmNvbW1hbmRFbmNvZGVyID0gbnVsbDtcbiAgfVxuICAvLyByZXN0b3JlcyBhIHJlbmRlciBwYXNzIGlmIGZpbmlzaFJlbmRlclBhc3Mgd2FzIGNhbGxlZFxuICAvLyBub3Qgb3B0aW1pc2VkIGFzIHJlYWxseSB1c2VkIGZvciBkZWJ1Z2dpbmchXG4gIC8vIHVzZWQgd2hlbiB3ZSB3YW50IHRvIHN0b3AgZHJhd2luZyBhbmQgbG9nIGEgdGV4dHVyZS4uXG4gIHJlc3RvcmVSZW5kZXJQYXNzKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLl9yZW5kZXJlci5yZW5kZXJUYXJnZXQuYWRhcHRvci5nZXREZXNjcmlwdG9yKFxuICAgICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlclRhcmdldCxcbiAgICAgIGZhbHNlLFxuICAgICAgWzAsIDAsIDAsIDFdXG4gICAgKTtcbiAgICB0aGlzLnJlbmRlclBhc3NFbmNvZGVyID0gdGhpcy5jb21tYW5kRW5jb2Rlci5iZWdpblJlbmRlclBhc3MoZGVzY3JpcHRvcik7XG4gICAgY29uc3QgYm91bmRQaXBlbGluZSA9IHRoaXMuX2JvdW5kUGlwZWxpbmU7XG4gICAgY29uc3QgYm91bmRWZXJ0ZXhCdWZmZXIgPSB7IC4uLnRoaXMuX2JvdW5kVmVydGV4QnVmZmVyIH07XG4gICAgY29uc3QgYm91bmRJbmRleEJ1ZmZlciA9IHRoaXMuX2JvdW5kSW5kZXhCdWZmZXI7XG4gICAgY29uc3QgYm91bmRCaW5kR3JvdXAgPSB7IC4uLnRoaXMuX2JvdW5kQmluZEdyb3VwIH07XG4gICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnZpZXdwb3J0O1xuICAgIHRoaXMucmVuZGVyUGFzc0VuY29kZXIuc2V0Vmlld3BvcnQodmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCwgMCwgMSk7XG4gICAgdGhpcy5zZXRQaXBlbGluZShib3VuZFBpcGVsaW5lKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gYm91bmRWZXJ0ZXhCdWZmZXIpIHtcbiAgICAgIHRoaXMuX3NldFZlcnRleEJ1ZmZlcihpLCBib3VuZFZlcnRleEJ1ZmZlcltpXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaSBpbiBib3VuZEJpbmRHcm91cCkge1xuICAgICAgdGhpcy5zZXRCaW5kR3JvdXAoaSwgYm91bmRCaW5kR3JvdXBbaV0sIG51bGwpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRJbmRleEJ1ZmZlcihib3VuZEluZGV4QnVmZmVyKTtcbiAgfVxuICBfY2xlYXJDYWNoZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHRoaXMuX2JvdW5kQmluZEdyb3VwW2ldID0gbnVsbDtcbiAgICAgIHRoaXMuX2JvdW5kVmVydGV4QnVmZmVyW2ldID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fYm91bmRJbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRQaXBlbGluZSA9IG51bGw7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fZ3B1ID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZEJpbmRHcm91cCA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRWZXJ0ZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kSW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kUGlwZWxpbmUgPSBudWxsO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ3B1KSB7XG4gICAgdGhpcy5fZ3B1ID0gZ3B1O1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3B1RW5jb2RlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbV0sXG4gIG5hbWU6IFwiZW5jb2RlclwiLFxuICBwcmlvcml0eTogMVxufTtcblxuZXhwb3J0IHsgR3B1RW5jb2RlclN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1RW5jb2RlclN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBTVEVOQ0lMX01PREVTIH0gZnJvbSAnLi4vc2hhcmVkL3N0YXRlL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1U3RlbmNpbFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0U3RlbmNpbFN0YXRlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQub25SZW5kZXJUYXJnZXRDaGFuZ2UuYWRkKHRoaXMpO1xuICB9XG4gIG9uUmVuZGVyVGFyZ2V0Q2hhbmdlKHJlbmRlclRhcmdldCkge1xuICAgIGxldCBzdGVuY2lsU3RhdGUgPSB0aGlzLl9yZW5kZXJUYXJnZXRTdGVuY2lsU3RhdGVbcmVuZGVyVGFyZ2V0LnVpZF07XG4gICAgaWYgKCFzdGVuY2lsU3RhdGUpIHtcbiAgICAgIHN0ZW5jaWxTdGF0ZSA9IHRoaXMuX3JlbmRlclRhcmdldFN0ZW5jaWxTdGF0ZVtyZW5kZXJUYXJnZXQudWlkXSA9IHtcbiAgICAgICAgc3RlbmNpbE1vZGU6IFNURU5DSUxfTU9ERVMuRElTQUJMRUQsXG4gICAgICAgIHN0ZW5jaWxSZWZlcmVuY2U6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICB0aGlzLnNldFN0ZW5jaWxNb2RlKHN0ZW5jaWxTdGF0ZS5zdGVuY2lsTW9kZSwgc3RlbmNpbFN0YXRlLnN0ZW5jaWxSZWZlcmVuY2UpO1xuICB9XG4gIHNldFN0ZW5jaWxNb2RlKHN0ZW5jaWxNb2RlLCBzdGVuY2lsUmVmZXJlbmNlKSB7XG4gICAgY29uc3Qgc3RlbmNpbFN0YXRlID0gdGhpcy5fcmVuZGVyVGFyZ2V0U3RlbmNpbFN0YXRlW3RoaXMuX2FjdGl2ZVJlbmRlclRhcmdldC51aWRdO1xuICAgIHN0ZW5jaWxTdGF0ZS5zdGVuY2lsTW9kZSA9IHN0ZW5jaWxNb2RlO1xuICAgIHN0ZW5jaWxTdGF0ZS5zdGVuY2lsUmVmZXJlbmNlID0gc3RlbmNpbFJlZmVyZW5jZTtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHJlbmRlcmVyLnBpcGVsaW5lLnNldFN0ZW5jaWxNb2RlKHN0ZW5jaWxNb2RlKTtcbiAgICByZW5kZXJlci5lbmNvZGVyLnJlbmRlclBhc3NFbmNvZGVyLnNldFN0ZW5jaWxSZWZlcmVuY2Uoc3RlbmNpbFJlZmVyZW5jZSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJUYXJnZXQub25SZW5kZXJUYXJnZXRDaGFuZ2UucmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlclRhcmdldFN0ZW5jaWxTdGF0ZSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcHVTdGVuY2lsU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwic3RlbmNpbFwiXG59O1xuXG5leHBvcnQgeyBHcHVTdGVuY2lsU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVTdGVuY2lsU3lzdGVtLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgV0dTTF9BTElHTl9TSVpFX0RBVEEgPSB7XG4gIGkzMjogeyBhbGlnbjogNCwgc2l6ZTogNCB9LFxuICB1MzI6IHsgYWxpZ246IDQsIHNpemU6IDQgfSxcbiAgZjMyOiB7IGFsaWduOiA0LCBzaXplOiA0IH0sXG4gIGYxNjogeyBhbGlnbjogMiwgc2l6ZTogMiB9LFxuICBcInZlYzI8aTMyPlwiOiB7IGFsaWduOiA4LCBzaXplOiA4IH0sXG4gIFwidmVjMjx1MzI+XCI6IHsgYWxpZ246IDgsIHNpemU6IDggfSxcbiAgXCJ2ZWMyPGYzMj5cIjogeyBhbGlnbjogOCwgc2l6ZTogOCB9LFxuICBcInZlYzI8ZjE2PlwiOiB7IGFsaWduOiA0LCBzaXplOiA0IH0sXG4gIFwidmVjMzxpMzI+XCI6IHsgYWxpZ246IDE2LCBzaXplOiAxMiB9LFxuICBcInZlYzM8dTMyPlwiOiB7IGFsaWduOiAxNiwgc2l6ZTogMTIgfSxcbiAgXCJ2ZWMzPGYzMj5cIjogeyBhbGlnbjogMTYsIHNpemU6IDEyIH0sXG4gIFwidmVjMzxmMTY+XCI6IHsgYWxpZ246IDgsIHNpemU6IDYgfSxcbiAgXCJ2ZWM0PGkzMj5cIjogeyBhbGlnbjogMTYsIHNpemU6IDE2IH0sXG4gIFwidmVjNDx1MzI+XCI6IHsgYWxpZ246IDE2LCBzaXplOiAxNiB9LFxuICBcInZlYzQ8ZjMyPlwiOiB7IGFsaWduOiAxNiwgc2l6ZTogMTYgfSxcbiAgXCJ2ZWM0PGYxNj5cIjogeyBhbGlnbjogOCwgc2l6ZTogOCB9LFxuICBcIm1hdDJ4MjxmMzI+XCI6IHsgYWxpZ246IDgsIHNpemU6IDE2IH0sXG4gIFwibWF0MngyPGYxNj5cIjogeyBhbGlnbjogNCwgc2l6ZTogOCB9LFxuICBcIm1hdDN4MjxmMzI+XCI6IHsgYWxpZ246IDgsIHNpemU6IDI0IH0sXG4gIFwibWF0M3gyPGYxNj5cIjogeyBhbGlnbjogNCwgc2l6ZTogMTIgfSxcbiAgXCJtYXQ0eDI8ZjMyPlwiOiB7IGFsaWduOiA4LCBzaXplOiAzMiB9LFxuICBcIm1hdDR4MjxmMTY+XCI6IHsgYWxpZ246IDQsIHNpemU6IDE2IH0sXG4gIFwibWF0MngzPGYzMj5cIjogeyBhbGlnbjogMTYsIHNpemU6IDMyIH0sXG4gIFwibWF0MngzPGYxNj5cIjogeyBhbGlnbjogOCwgc2l6ZTogMTYgfSxcbiAgXCJtYXQzeDM8ZjMyPlwiOiB7IGFsaWduOiAxNiwgc2l6ZTogNDggfSxcbiAgXCJtYXQzeDM8ZjE2PlwiOiB7IGFsaWduOiA4LCBzaXplOiAyNCB9LFxuICBcIm1hdDR4MzxmMzI+XCI6IHsgYWxpZ246IDE2LCBzaXplOiA2NCB9LFxuICBcIm1hdDR4MzxmMTY+XCI6IHsgYWxpZ246IDgsIHNpemU6IDMyIH0sXG4gIFwibWF0Mng0PGYzMj5cIjogeyBhbGlnbjogMTYsIHNpemU6IDMyIH0sXG4gIFwibWF0Mng0PGYxNj5cIjogeyBhbGlnbjogOCwgc2l6ZTogMTYgfSxcbiAgXCJtYXQzeDQ8ZjMyPlwiOiB7IGFsaWduOiAxNiwgc2l6ZTogNDggfSxcbiAgXCJtYXQzeDQ8ZjE2PlwiOiB7IGFsaWduOiA4LCBzaXplOiAyNCB9LFxuICBcIm1hdDR4NDxmMzI+XCI6IHsgYWxpZ246IDE2LCBzaXplOiA2NCB9LFxuICBcIm1hdDR4NDxmMTY+XCI6IHsgYWxpZ246IDgsIHNpemU6IDMyIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVVYm9FbGVtZW50c1dHU0wodW5pZm9ybURhdGEpIHtcbiAgY29uc3QgdWJvRWxlbWVudHMgPSB1bmlmb3JtRGF0YS5tYXAoKGRhdGEpID0+ICh7XG4gICAgZGF0YSxcbiAgICBvZmZzZXQ6IDAsXG4gICAgc2l6ZTogMFxuICB9KSk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVib0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdWJvRWxlbWVudCA9IHVib0VsZW1lbnRzW2ldO1xuICAgIGxldCBzaXplID0gV0dTTF9BTElHTl9TSVpFX0RBVEFbdWJvRWxlbWVudC5kYXRhLnR5cGVdLnNpemU7XG4gICAgY29uc3QgYWxpZ24gPSBXR1NMX0FMSUdOX1NJWkVfREFUQVt1Ym9FbGVtZW50LmRhdGEudHlwZV0uYWxpZ247XG4gICAgaWYgKCFXR1NMX0FMSUdOX1NJWkVfREFUQVt1Ym9FbGVtZW50LmRhdGEudHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW1BpeGkuanNdIFdlYkdQVSBVbmlmb3JtQnVmZmVyOiBVbmtub3duIHR5cGUgJHt1Ym9FbGVtZW50LmRhdGEudHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKHVib0VsZW1lbnQuZGF0YS5zaXplID4gMSkge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIGFsaWduKSAqIHVib0VsZW1lbnQuZGF0YS5zaXplO1xuICAgIH1cbiAgICBvZmZzZXQgPSBNYXRoLmNlaWwob2Zmc2V0IC8gYWxpZ24pICogYWxpZ247XG4gICAgdWJvRWxlbWVudC5zaXplID0gc2l6ZTtcbiAgICB1Ym9FbGVtZW50Lm9mZnNldCA9IG9mZnNldDtcbiAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgfVxuICBvZmZzZXQgPSBNYXRoLmNlaWwob2Zmc2V0IC8gMTYpICogMTY7XG4gIHJldHVybiB7IHVib0VsZW1lbnRzLCBzaXplOiBvZmZzZXQgfTtcbn1cblxuZXhwb3J0IHsgV0dTTF9BTElHTl9TSVpFX0RBVEEsIGNyZWF0ZVVib0VsZW1lbnRzV0dTTCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlVWJvRWxlbWVudHNXR1NMLm1qcy5tYXBcbiIsImltcG9ydCB7IFdHU0xfQUxJR05fU0laRV9EQVRBIH0gZnJvbSAnLi9jcmVhdGVVYm9FbGVtZW50c1dHU0wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZW5lcmF0ZUFycmF5U3luY1dHU0wodWJvRWxlbWVudCwgb2Zmc2V0VG9BZGQpIHtcbiAgY29uc3QgeyBzaXplLCBhbGlnbiB9ID0gV0dTTF9BTElHTl9TSVpFX0RBVEFbdWJvRWxlbWVudC5kYXRhLnR5cGVdO1xuICBjb25zdCByZW1haW5kZXIgPSAoYWxpZ24gLSBzaXplKSAvIDQ7XG4gIHJldHVybiBgXG4gICAgICAgICB2ID0gdXYuJHt1Ym9FbGVtZW50LmRhdGEubmFtZX07XG4gICAgICAgICAke29mZnNldFRvQWRkICE9PSAwID8gYG9mZnNldCArPSAke29mZnNldFRvQWRkfTtgIDogXCJcIn1cblxuICAgICAgICAgYXJyYXlPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgICAgIHQgPSAwO1xuXG4gICAgICAgICBmb3IodmFyIGk9MDsgaSA8ICR7dWJvRWxlbWVudC5kYXRhLnNpemUgKiAoc2l6ZSAvIDQpfTsgaSsrKVxuICAgICAgICAge1xuICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCAke3NpemUgLyA0fTsgaisrKVxuICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgZGF0YVthcnJheU9mZnNldCsrXSA9IHZbdCsrXTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgJHtyZW1haW5kZXIgIT09IDAgPyBgYXJyYXlPZmZzZXQgKz0gJHtyZW1haW5kZXJ9O2AgOiBcIlwifVxuICAgICAgICAgfVxuICAgICBgO1xufVxuXG5leHBvcnQgeyBnZW5lcmF0ZUFycmF5U3luY1dHU0wgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlQXJyYXlTeW5jV0dTTC5tanMubWFwXG4iLCJpbXBvcnQgeyBjcmVhdGVVYm9TeW5jRnVuY3Rpb24gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib1N5bmNGdW5jdGlvbi5tanMnO1xuaW1wb3J0IHsgdWJvU3luY0Z1bmN0aW9uc1dHU0wgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvc2hhZGVyL3V0aWxzL3Vib1N5bmNGdW5jdGlvbnMubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlQXJyYXlTeW5jV0dTTCB9IGZyb20gJy4vZ2VuZXJhdGVBcnJheVN5bmNXR1NMLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY3JlYXRlVWJvU3luY0Z1bmN0aW9uV0dTTCh1Ym9FbGVtZW50cykge1xuICByZXR1cm4gY3JlYXRlVWJvU3luY0Z1bmN0aW9uKFxuICAgIHVib0VsZW1lbnRzLFxuICAgIFwidWJvV2dzbFwiLFxuICAgIGdlbmVyYXRlQXJyYXlTeW5jV0dTTCxcbiAgICB1Ym9TeW5jRnVuY3Rpb25zV0dTTFxuICApO1xufVxuXG5leHBvcnQgeyBjcmVhdGVVYm9TeW5jRnVuY3Rpb25XR1NMIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVVYm9TeW5jRnVuY3Rpb25XR1NMLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFVib1N5c3RlbSB9IGZyb20gJy4uL3NoYXJlZC9zaGFkZXIvVWJvU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVVYm9FbGVtZW50c1dHU0wgfSBmcm9tICcuL3NoYWRlci91dGlscy9jcmVhdGVVYm9FbGVtZW50c1dHU0wubWpzJztcbmltcG9ydCB7IGNyZWF0ZVVib1N5bmNGdW5jdGlvbldHU0wgfSBmcm9tICcuL3NoYWRlci91dGlscy9jcmVhdGVVYm9TeW5jRnVuY3Rpb25XR1NMLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1VWJvU3lzdGVtIGV4dGVuZHMgVWJvU3lzdGVtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgY3JlYXRlVWJvRWxlbWVudHM6IGNyZWF0ZVVib0VsZW1lbnRzV0dTTCxcbiAgICAgIGdlbmVyYXRlVWJvU3luYzogY3JlYXRlVWJvU3luY0Z1bmN0aW9uV0dTTFxuICAgIH0pO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3B1VWJvU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW0V4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXSxcbiAgbmFtZTogXCJ1Ym9cIlxufTtcblxuZXhwb3J0IHsgR3B1VWJvU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVVYm9TeXN0ZW0ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBVYm9CYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHsgbWluVW5pZm9ybU9mZnNldEFsaWdubWVudCB9KSB7XG4gICAgdGhpcy5fbWluVW5pZm9ybU9mZnNldEFsaWdubWVudCA9IDI1NjtcbiAgICB0aGlzLmJ5dGVJbmRleCA9IDA7XG4gICAgdGhpcy5fbWluVW5pZm9ybU9mZnNldEFsaWdubWVudCA9IG1pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQ7XG4gICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg2NTUzNSk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5ieXRlSW5kZXggPSAwO1xuICB9XG4gIGFkZEVtcHR5R3JvdXAoc2l6ZSkge1xuICAgIGlmIChzaXplID4gdGhpcy5fbWluVW5pZm9ybU9mZnNldEFsaWdubWVudCAvIDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5pZm9ybUJ1ZmZlckJhdGNoOiBhcnJheSBpcyB0b28gbGFyZ2U6ICR7c2l6ZSAqIDR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5ieXRlSW5kZXg7XG4gICAgbGV0IG5ld1NpemUgPSBzdGFydCArIHNpemUgKiA0O1xuICAgIG5ld1NpemUgPSBNYXRoLmNlaWwobmV3U2l6ZSAvIHRoaXMuX21pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQpICogdGhpcy5fbWluVW5pZm9ybU9mZnNldEFsaWdubWVudDtcbiAgICBpZiAobmV3U2l6ZSA+IHRoaXMuZGF0YS5sZW5ndGggKiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmlmb3JtQnVmZmVyQmF0Y2g6IHVibyBiYXRjaCBnb3QgdG9vIGJpZ1wiKTtcbiAgICB9XG4gICAgdGhpcy5ieXRlSW5kZXggPSBuZXdTaXplO1xuICAgIHJldHVybiBzdGFydDtcbiAgfVxuICBhZGRHcm91cChhcnJheSkge1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYWRkRW1wdHlHcm91cChhcnJheS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuZGF0YVtvZmZzZXQgLyA0ICsgaV0gPSBhcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2J1ZmZlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCB7IFVib0JhdGNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VYm9CYXRjaC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICcuLi9zaGFyZWQvYnVmZmVyL0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgQnVmZmVyUmVzb3VyY2UgfSBmcm9tICcuLi9zaGFyZWQvYnVmZmVyL0J1ZmZlclJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXJVc2FnZSB9IGZyb20gJy4uL3NoYXJlZC9idWZmZXIvY29uc3QubWpzJztcbmltcG9ydCB7IFVib0JhdGNoIH0gZnJvbSAnLi9idWZmZXIvVWJvQmF0Y2gubWpzJztcbmltcG9ydCB7IEJpbmRHcm91cCB9IGZyb20gJy4vc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IG1pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQgPSAxMjg7XG5jbGFzcyBHcHVVbmlmb3JtQmF0Y2hQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9iaW5kR3JvdXBIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLy8gbnVtYmVyIG9mIGJ1ZmZlcnMuLlxuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcbiAgICB0aGlzLl9iaW5kR3JvdXBzID0gW107XG4gICAgdGhpcy5fYnVmZmVyUmVzb3VyY2VzID0gW107XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl9iYXRjaEJ1ZmZlciA9IG5ldyBVYm9CYXRjaCh7IG1pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQgfSk7XG4gICAgY29uc3QgdG90YWxCdWZmZXJzID0gMjU2IC8gbWluVW5pZm9ybU9mZnNldEFsaWdubWVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQnVmZmVyczsgaSsrKSB7XG4gICAgICBsZXQgdXNhZ2UgPSBCdWZmZXJVc2FnZS5VTklGT1JNIHwgQnVmZmVyVXNhZ2UuQ09QWV9EU1Q7XG4gICAgICBpZiAoaSA9PT0gMClcbiAgICAgICAgdXNhZ2UgfD0gQnVmZmVyVXNhZ2UuQ09QWV9TUkM7XG4gICAgICB0aGlzLl9idWZmZXJzLnB1c2gobmV3IEJ1ZmZlcih7XG4gICAgICAgIGRhdGE6IHRoaXMuX2JhdGNoQnVmZmVyLmRhdGEsXG4gICAgICAgIHVzYWdlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIHJlbmRlckVuZCgpIHtcbiAgICB0aGlzLl91cGxvYWRCaW5kR3JvdXBzKCk7XG4gICAgdGhpcy5fcmVzZXRCaW5kR3JvdXBzKCk7XG4gIH1cbiAgX3Jlc2V0QmluZEdyb3VwcygpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fYmluZEdyb3VwSGFzaCkge1xuICAgICAgdGhpcy5fYmluZEdyb3VwSGFzaFtpXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2JhdGNoQnVmZmVyLmNsZWFyKCk7XG4gIH1cbiAgLy8ganVzdCB3b3JrcyBmb3Igc2luZ2xlIGJpbmQgZ3JvdXBzIGZvciBub3dcbiAgZ2V0VW5pZm9ybUJpbmRHcm91cChncm91cCwgZHVwbGljYXRlKSB7XG4gICAgaWYgKCFkdXBsaWNhdGUgJiYgdGhpcy5fYmluZEdyb3VwSGFzaFtncm91cC51aWRdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmluZEdyb3VwSGFzaFtncm91cC51aWRdO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci51Ym8uZW5zdXJlVW5pZm9ybUdyb3VwKGdyb3VwKTtcbiAgICBjb25zdCBkYXRhID0gZ3JvdXAuYnVmZmVyLmRhdGE7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fYmF0Y2hCdWZmZXIuYWRkRW1wdHlHcm91cChkYXRhLmxlbmd0aCk7XG4gICAgdGhpcy5fcmVuZGVyZXIudWJvLnN5bmNVbmlmb3JtR3JvdXAoZ3JvdXAsIHRoaXMuX2JhdGNoQnVmZmVyLmRhdGEsIG9mZnNldCAvIDQpO1xuICAgIHRoaXMuX2JpbmRHcm91cEhhc2hbZ3JvdXAudWlkXSA9IHRoaXMuX2dldEJpbmRHcm91cChvZmZzZXQgLyBtaW5Vbmlmb3JtT2Zmc2V0QWxpZ25tZW50KTtcbiAgICByZXR1cm4gdGhpcy5fYmluZEdyb3VwSGFzaFtncm91cC51aWRdO1xuICB9XG4gIGdldFVib1Jlc291cmNlKGdyb3VwKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIudWJvLnVwZGF0ZVVuaWZvcm1Hcm91cChncm91cCk7XG4gICAgY29uc3QgZGF0YSA9IGdyb3VwLmJ1ZmZlci5kYXRhO1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2JhdGNoQnVmZmVyLmFkZEdyb3VwKGRhdGEpO1xuICAgIHJldHVybiB0aGlzLl9nZXRCdWZmZXJSZXNvdXJjZShvZmZzZXQgLyBtaW5Vbmlmb3JtT2Zmc2V0QWxpZ25tZW50KTtcbiAgfVxuICBnZXRBcnJheUJpbmRHcm91cChkYXRhKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fYmF0Y2hCdWZmZXIuYWRkR3JvdXAoZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuX2dldEJpbmRHcm91cChvZmZzZXQgLyBtaW5Vbmlmb3JtT2Zmc2V0QWxpZ25tZW50KTtcbiAgfVxuICBnZXRBcnJheUJ1ZmZlclJlc291cmNlKGRhdGEpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9iYXRjaEJ1ZmZlci5hZGRHcm91cChkYXRhKTtcbiAgICBjb25zdCBpbmRleCA9IG9mZnNldCAvIG1pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQ7XG4gICAgcmV0dXJuIHRoaXMuX2dldEJ1ZmZlclJlc291cmNlKGluZGV4KTtcbiAgfVxuICBfZ2V0QnVmZmVyUmVzb3VyY2UoaW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX2J1ZmZlclJlc291cmNlc1tpbmRleF0pIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcnNbaW5kZXggJSAyXTtcbiAgICAgIHRoaXMuX2J1ZmZlclJlc291cmNlc1tpbmRleF0gPSBuZXcgQnVmZmVyUmVzb3VyY2Uoe1xuICAgICAgICBidWZmZXIsXG4gICAgICAgIG9mZnNldDogKGluZGV4IC8gMiB8IDApICogMjU2LFxuICAgICAgICBzaXplOiBtaW5Vbmlmb3JtT2Zmc2V0QWxpZ25tZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J1ZmZlclJlc291cmNlc1tpbmRleF07XG4gIH1cbiAgX2dldEJpbmRHcm91cChpbmRleCkge1xuICAgIGlmICghdGhpcy5fYmluZEdyb3Vwc1tpbmRleF0pIHtcbiAgICAgIGNvbnN0IGJpbmRHcm91cCA9IG5ldyBCaW5kR3JvdXAoe1xuICAgICAgICAwOiB0aGlzLl9nZXRCdWZmZXJSZXNvdXJjZShpbmRleClcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fYmluZEdyb3Vwc1tpbmRleF0gPSBiaW5kR3JvdXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9iaW5kR3JvdXBzW2luZGV4XTtcbiAgfVxuICBfdXBsb2FkQmluZEdyb3VwcygpIHtcbiAgICBjb25zdCBidWZmZXJTeXN0ZW0gPSB0aGlzLl9yZW5kZXJlci5idWZmZXI7XG4gICAgY29uc3QgZmlyc3RCdWZmZXIgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgIGZpcnN0QnVmZmVyLnVwZGF0ZSh0aGlzLl9iYXRjaEJ1ZmZlci5ieXRlSW5kZXgpO1xuICAgIGJ1ZmZlclN5c3RlbS51cGRhdGVCdWZmZXIoZmlyc3RCdWZmZXIpO1xuICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gdGhpcy5fcmVuZGVyZXIuZ3B1LmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5fYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fYnVmZmVyc1tpXTtcbiAgICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgICAgYnVmZmVyU3lzdGVtLmdldEdQVUJ1ZmZlcihmaXJzdEJ1ZmZlciksXG4gICAgICAgIG1pblVuaWZvcm1PZmZzZXRBbGlnbm1lbnQsXG4gICAgICAgIGJ1ZmZlclN5c3RlbS5nZXRHUFVCdWZmZXIoYnVmZmVyKSxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5fYmF0Y2hCdWZmZXIuYnl0ZUluZGV4XG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5ncHUuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYmluZEdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fYmluZEdyb3Vwc1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX2JpbmRHcm91cHMgPSBudWxsO1xuICAgIHRoaXMuX2JpbmRHcm91cEhhc2ggPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fYnVmZmVyc1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX2J1ZmZlcnMgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVyUmVzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9idWZmZXJSZXNvdXJjZXNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl9idWZmZXJSZXNvdXJjZXMgPSBudWxsO1xuICAgIHRoaXMuX2JhdGNoQnVmZmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iaW5kR3JvdXBIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcHVVbmlmb3JtQmF0Y2hQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJ1bmlmb3JtQmF0Y2hcIlxufTtcblxuZXhwb3J0IHsgR3B1VW5pZm9ybUJhdGNoUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1VW5pZm9ybUJhdGNoUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBlbnN1cmVBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vLi4vZ2wvc2hhZGVyL3Byb2dyYW0vZW5zdXJlQXR0cmlidXRlcy5tanMnO1xuaW1wb3J0IHsgU1RFTkNJTF9NT0RFUyB9IGZyb20gJy4uLy4uL3NoYXJlZC9zdGF0ZS9jb25zdC5tanMnO1xuaW1wb3J0IHsgY3JlYXRlSWRGcm9tU3RyaW5nIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL2NyZWF0ZUlkRnJvbVN0cmluZy5tanMnO1xuaW1wb3J0IHsgR3B1U3RlbmNpbE1vZGVzVG9QaXhpIH0gZnJvbSAnLi4vc3RhdGUvR3B1U3RlbmNpbE1vZGVzVG9QaXhpLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdG9wb2xvZ3lTdHJpbmdUb0lkID0ge1xuICBcInBvaW50LWxpc3RcIjogMCxcbiAgXCJsaW5lLWxpc3RcIjogMSxcbiAgXCJsaW5lLXN0cmlwXCI6IDIsXG4gIFwidHJpYW5nbGUtbGlzdFwiOiAzLFxuICBcInRyaWFuZ2xlLXN0cmlwXCI6IDRcbn07XG5mdW5jdGlvbiBnZXRHcmFwaGljc1N0YXRlS2V5KGdlb21ldHJ5TGF5b3V0LCBzaGFkZXJLZXksIHN0YXRlLCBibGVuZE1vZGUsIHRvcG9sb2d5KSB7XG4gIHJldHVybiBnZW9tZXRyeUxheW91dCA8PCAyNCB8IHNoYWRlcktleSA8PCAxNiB8IHN0YXRlIDw8IDEwIHwgYmxlbmRNb2RlIDw8IDUgfCB0b3BvbG9neTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbFN0YXRlS2V5KHN0ZW5jaWxTdGF0ZUlkLCBtdWx0aVNhbXBsZUNvdW50LCBjb2xvck1hc2ssIHJlbmRlclRhcmdldCkge1xuICByZXR1cm4gY29sb3JNYXNrIDw8IDYgfCBzdGVuY2lsU3RhdGVJZCA8PCAzIHwgcmVuZGVyVGFyZ2V0IDw8IDEgfCBtdWx0aVNhbXBsZUNvdW50O1xufVxuY2xhc3MgUGlwZWxpbmVTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX21vZHVsZUNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fYnVmZmVyTGF5b3V0c0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fYmluZGluZ05hbWVzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9waXBlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9waXBlU3RhdGVDYWNoZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9jb2xvck1hc2sgPSAxNTtcbiAgICB0aGlzLl9tdWx0aXNhbXBsZUNvdW50ID0gMTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ3B1KSB7XG4gICAgdGhpcy5fZ3B1ID0gZ3B1O1xuICAgIHRoaXMuc2V0U3RlbmNpbE1vZGUoU1RFTkNJTF9NT0RFUy5ESVNBQkxFRCk7XG4gICAgdGhpcy5fdXBkYXRlUGlwZUhhc2goKTtcbiAgfVxuICBzZXRNdWx0aXNhbXBsZUNvdW50KG11bHRpc2FtcGxlQ291bnQpIHtcbiAgICBpZiAodGhpcy5fbXVsdGlzYW1wbGVDb3VudCA9PT0gbXVsdGlzYW1wbGVDb3VudClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9tdWx0aXNhbXBsZUNvdW50ID0gbXVsdGlzYW1wbGVDb3VudDtcbiAgICB0aGlzLl91cGRhdGVQaXBlSGFzaCgpO1xuICB9XG4gIHNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpIHtcbiAgICB0aGlzLl9tdWx0aXNhbXBsZUNvdW50ID0gcmVuZGVyVGFyZ2V0Lm1zYWFTYW1wbGVzO1xuICAgIHRoaXMuX2RlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSByZW5kZXJUYXJnZXQuZGVzY3JpcHRvci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50ID8gMSA6IDA7XG4gICAgdGhpcy5fdXBkYXRlUGlwZUhhc2goKTtcbiAgfVxuICBzZXRDb2xvck1hc2soY29sb3JNYXNrKSB7XG4gICAgaWYgKHRoaXMuX2NvbG9yTWFzayA9PT0gY29sb3JNYXNrKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvbG9yTWFzayA9IGNvbG9yTWFzaztcbiAgICB0aGlzLl91cGRhdGVQaXBlSGFzaCgpO1xuICB9XG4gIHNldFN0ZW5jaWxNb2RlKHN0ZW5jaWxNb2RlKSB7XG4gICAgaWYgKHRoaXMuX3N0ZW5jaWxNb2RlID09PSBzdGVuY2lsTW9kZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zdGVuY2lsTW9kZSA9IHN0ZW5jaWxNb2RlO1xuICAgIHRoaXMuX3N0ZW5jaWxTdGF0ZSA9IEdwdVN0ZW5jaWxNb2Rlc1RvUGl4aVtzdGVuY2lsTW9kZV07XG4gICAgdGhpcy5fdXBkYXRlUGlwZUhhc2goKTtcbiAgfVxuICBzZXRQaXBlbGluZShnZW9tZXRyeSwgcHJvZ3JhbSwgc3RhdGUsIHBhc3NFbmNvZGVyKSB7XG4gICAgY29uc3QgcGlwZWxpbmUgPSB0aGlzLmdldFBpcGVsaW5lKGdlb21ldHJ5LCBwcm9ncmFtLCBzdGF0ZSk7XG4gICAgcGFzc0VuY29kZXIuc2V0UGlwZWxpbmUocGlwZWxpbmUpO1xuICB9XG4gIGdldFBpcGVsaW5lKGdlb21ldHJ5LCBwcm9ncmFtLCBzdGF0ZSwgdG9wb2xvZ3kpIHtcbiAgICBpZiAoIWdlb21ldHJ5Ll9sYXlvdXRLZXkpIHtcbiAgICAgIGVuc3VyZUF0dHJpYnV0ZXMoZ2VvbWV0cnksIHByb2dyYW0uYXR0cmlidXRlRGF0YSk7XG4gICAgICB0aGlzLl9nZW5lcmF0ZUJ1ZmZlcktleShnZW9tZXRyeSk7XG4gICAgfVxuICAgIHRvcG9sb2d5ID0gdG9wb2xvZ3kgfHwgZ2VvbWV0cnkudG9wb2xvZ3k7XG4gICAgY29uc3Qga2V5ID0gZ2V0R3JhcGhpY3NTdGF0ZUtleShcbiAgICAgIGdlb21ldHJ5Ll9sYXlvdXRLZXksXG4gICAgICBwcm9ncmFtLl9sYXlvdXRLZXksXG4gICAgICBzdGF0ZS5kYXRhLFxuICAgICAgc3RhdGUuX2JsZW5kTW9kZUlkLFxuICAgICAgdG9wb2xvZ3lTdHJpbmdUb0lkW3RvcG9sb2d5XVxuICAgICk7XG4gICAgaWYgKHRoaXMuX3BpcGVDYWNoZVtrZXldKVxuICAgICAgcmV0dXJuIHRoaXMuX3BpcGVDYWNoZVtrZXldO1xuICAgIHRoaXMuX3BpcGVDYWNoZVtrZXldID0gdGhpcy5fY3JlYXRlUGlwZWxpbmUoZ2VvbWV0cnksIHByb2dyYW0sIHN0YXRlLCB0b3BvbG9neSk7XG4gICAgcmV0dXJuIHRoaXMuX3BpcGVDYWNoZVtrZXldO1xuICB9XG4gIF9jcmVhdGVQaXBlbGluZShnZW9tZXRyeSwgcHJvZ3JhbSwgc3RhdGUsIHRvcG9sb2d5KSB7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5fZ3B1LmRldmljZTtcbiAgICBjb25zdCBidWZmZXJzID0gdGhpcy5fY3JlYXRlVmVydGV4QnVmZmVyTGF5b3V0cyhnZW9tZXRyeSwgcHJvZ3JhbSk7XG4gICAgY29uc3QgYmxlbmRNb2RlcyA9IHRoaXMuX3JlbmRlcmVyLnN0YXRlLmdldENvbG9yVGFyZ2V0cyhzdGF0ZSk7XG4gICAgYmxlbmRNb2Rlc1swXS53cml0ZU1hc2sgPSB0aGlzLl9zdGVuY2lsTW9kZSA9PT0gU1RFTkNJTF9NT0RFUy5SRU5ERVJJTkdfTUFTS19BREQgPyAwIDogdGhpcy5fY29sb3JNYXNrO1xuICAgIGNvbnN0IGxheW91dCA9IHRoaXMuX3JlbmRlcmVyLnNoYWRlci5nZXRQcm9ncmFtRGF0YShwcm9ncmFtKS5waXBlbGluZTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgICAgLy8gVE9ETyBsYXRlciBjaGVjayBpZiBpdHMgaGVscGZ1bCB0byBjcmVhdGUuLlxuICAgICAgLy8gbGF5b3V0LFxuICAgICAgdmVydGV4OiB7XG4gICAgICAgIG1vZHVsZTogdGhpcy5fZ2V0TW9kdWxlKHByb2dyYW0udmVydGV4LnNvdXJjZSksXG4gICAgICAgIGVudHJ5UG9pbnQ6IHByb2dyYW0udmVydGV4LmVudHJ5UG9pbnQsXG4gICAgICAgIC8vIGdlb21ldHJ5Li5cbiAgICAgICAgYnVmZmVyc1xuICAgICAgfSxcbiAgICAgIGZyYWdtZW50OiB7XG4gICAgICAgIG1vZHVsZTogdGhpcy5fZ2V0TW9kdWxlKHByb2dyYW0uZnJhZ21lbnQuc291cmNlKSxcbiAgICAgICAgZW50cnlQb2ludDogcHJvZ3JhbS5mcmFnbWVudC5lbnRyeVBvaW50LFxuICAgICAgICB0YXJnZXRzOiBibGVuZE1vZGVzXG4gICAgICB9LFxuICAgICAgcHJpbWl0aXZlOiB7XG4gICAgICAgIHRvcG9sb2d5LFxuICAgICAgICBjdWxsTW9kZTogc3RhdGUuY3VsbE1vZGVcbiAgICAgIH0sXG4gICAgICBsYXlvdXQsXG4gICAgICBtdWx0aXNhbXBsZToge1xuICAgICAgICBjb3VudDogdGhpcy5fbXVsdGlzYW1wbGVDb3VudFxuICAgICAgfSxcbiAgICAgIC8vIGRlcHRoU3RlbmNpbCxcbiAgICAgIGxhYmVsOiBgUElYSSBQaXBlbGluZWBcbiAgICB9O1xuICAgIGlmICh0aGlzLl9kZXB0aFN0ZW5jaWxBdHRhY2htZW50KSB7XG4gICAgICBkZXNjcmlwdG9yLmRlcHRoU3RlbmNpbCA9IHtcbiAgICAgICAgLi4udGhpcy5fc3RlbmNpbFN0YXRlLFxuICAgICAgICBmb3JtYXQ6IFwiZGVwdGgyNHBsdXMtc3RlbmNpbDhcIixcbiAgICAgICAgZGVwdGhXcml0ZUVuYWJsZWQ6IHN0YXRlLmRlcHRoVGVzdCxcbiAgICAgICAgZGVwdGhDb21wYXJlOiBzdGF0ZS5kZXB0aFRlc3QgPyBcImxlc3NcIiA6IFwiYWx3YXlzXCJcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKGRlc2NyaXB0b3IpO1xuICAgIHJldHVybiBwaXBlbGluZTtcbiAgfVxuICBfZ2V0TW9kdWxlKGNvZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kdWxlQ2FjaGVbY29kZV0gfHwgdGhpcy5fY3JlYXRlTW9kdWxlKGNvZGUpO1xuICB9XG4gIF9jcmVhdGVNb2R1bGUoY29kZSkge1xuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuX2dwdS5kZXZpY2U7XG4gICAgdGhpcy5fbW9kdWxlQ2FjaGVbY29kZV0gPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtcbiAgICAgIGNvZGVcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fbW9kdWxlQ2FjaGVbY29kZV07XG4gIH1cbiAgX2dlbmVyYXRlQnVmZmVyS2V5KGdlb21ldHJ5KSB7XG4gICAgY29uc3Qga2V5R2VuID0gW107XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBhdHRyaWJ1dGVLZXlzID0gT2JqZWN0LmtleXMoZ2VvbWV0cnkuYXR0cmlidXRlcykuc29ydCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1thdHRyaWJ1dGVLZXlzW2ldXTtcbiAgICAgIGtleUdlbltpbmRleCsrXSA9IGF0dHJpYnV0ZS5vZmZzZXQ7XG4gICAgICBrZXlHZW5baW5kZXgrK10gPSBhdHRyaWJ1dGUuZm9ybWF0O1xuICAgICAga2V5R2VuW2luZGV4KytdID0gYXR0cmlidXRlLnN0cmlkZTtcbiAgICAgIGtleUdlbltpbmRleCsrXSA9IGF0dHJpYnV0ZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nS2V5ID0ga2V5R2VuLmpvaW4oXCJ8XCIpO1xuICAgIGdlb21ldHJ5Ll9sYXlvdXRLZXkgPSBjcmVhdGVJZEZyb21TdHJpbmcoc3RyaW5nS2V5LCBcImdlb21ldHJ5XCIpO1xuICAgIHJldHVybiBnZW9tZXRyeS5fbGF5b3V0S2V5O1xuICB9XG4gIF9nZW5lcmF0ZUF0dHJpYnV0ZUxvY2F0aW9uc0tleShwcm9ncmFtKSB7XG4gICAgY29uc3Qga2V5R2VuID0gW107XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBhdHRyaWJ1dGVLZXlzID0gT2JqZWN0LmtleXMocHJvZ3JhbS5hdHRyaWJ1dGVEYXRhKS5zb3J0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGFbYXR0cmlidXRlS2V5c1tpXV07XG4gICAgICBrZXlHZW5baW5kZXgrK10gPSBhdHRyaWJ1dGUubG9jYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ0tleSA9IGtleUdlbi5qb2luKFwifFwiKTtcbiAgICBwcm9ncmFtLl9hdHRyaWJ1dGVMb2NhdGlvbnNLZXkgPSBjcmVhdGVJZEZyb21TdHJpbmcoc3RyaW5nS2V5LCBcInByb2dyYW1BdHRyaWJ1dGVzXCIpO1xuICAgIHJldHVybiBwcm9ncmFtLl9hdHRyaWJ1dGVMb2NhdGlvbnNLZXk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBoYXNoIG9mIGJ1ZmZlciBuYW1lcyBtYXBwZWQgdG8gYmluZCBsb2NhdGlvbnMuXG4gICAqIFRoaXMgaXMgdXNlZCB0byBiaW5kIHRoZSBjb3JyZWN0IGJ1ZmZlciB0byB0aGUgY29ycmVjdCBsb2NhdGlvbiBpbiB0aGUgc2hhZGVyLlxuICAgKiBAcGFyYW0gZ2VvbWV0cnkgLSBUaGUgZ2VvbWV0cnkgd2hlcmUgdG8gZ2V0IHRoZSBidWZmZXIgbmFtZXNcbiAgICogQHBhcmFtIHByb2dyYW0gLSBUaGUgcHJvZ3JhbSB3aGVyZSB0byBnZXQgdGhlIGJ1ZmZlciBuYW1lc1xuICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgb2YgYnVmZmVyIG5hbWVzIG1hcHBlZCB0byB0aGUgYmluZCBsb2NhdGlvbi5cbiAgICovXG4gIGdldEJ1ZmZlck5hbWVzVG9CaW5kKGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgY29uc3Qga2V5ID0gZ2VvbWV0cnkuX2xheW91dEtleSA8PCAxNiB8IHByb2dyYW0uX2F0dHJpYnV0ZUxvY2F0aW9uc0tleTtcbiAgICBpZiAodGhpcy5fYmluZGluZ05hbWVzQ2FjaGVba2V5XSlcbiAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nTmFtZXNDYWNoZVtrZXldO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jcmVhdGVWZXJ0ZXhCdWZmZXJMYXlvdXRzKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICBjb25zdCBidWZmZXJOYW1lc1RvQmluZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZURhdGEgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGNvbnN0IGogaW4gYXR0cmlidXRlRGF0YSkge1xuICAgICAgICBpZiAoYXR0cmlidXRlRGF0YVtqXS5sb2NhdGlvbiA9PT0gaSkge1xuICAgICAgICAgIGJ1ZmZlck5hbWVzVG9CaW5kW2ldID0gajtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9iaW5kaW5nTmFtZXNDYWNoZVtrZXldID0gYnVmZmVyTmFtZXNUb0JpbmQ7XG4gICAgcmV0dXJuIGJ1ZmZlck5hbWVzVG9CaW5kO1xuICB9XG4gIF9jcmVhdGVWZXJ0ZXhCdWZmZXJMYXlvdXRzKGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgaWYgKCFwcm9ncmFtLl9hdHRyaWJ1dGVMb2NhdGlvbnNLZXkpXG4gICAgICB0aGlzLl9nZW5lcmF0ZUF0dHJpYnV0ZUxvY2F0aW9uc0tleShwcm9ncmFtKTtcbiAgICBjb25zdCBrZXkgPSBnZW9tZXRyeS5fbGF5b3V0S2V5IDw8IDE2IHwgcHJvZ3JhbS5fYXR0cmlidXRlTG9jYXRpb25zS2V5O1xuICAgIGlmICh0aGlzLl9idWZmZXJMYXlvdXRzQ2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlckxheW91dHNDYWNoZVtrZXldO1xuICAgIH1cbiAgICBjb25zdCB2ZXJ0ZXhCdWZmZXJzTGF5b3V0ID0gW107XG4gICAgZ2VvbWV0cnkuYnVmZmVycy5mb3JFYWNoKChidWZmZXIpID0+IHtcbiAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5ID0ge1xuICAgICAgICBhcnJheVN0cmlkZTogMCxcbiAgICAgICAgc3RlcE1vZGU6IFwidmVydGV4XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3QgYnVmZmVyRW50cnlBdHRyaWJ1dGVzID0gYnVmZmVyRW50cnkuYXR0cmlidXRlcztcbiAgICAgIGZvciAoY29uc3QgaSBpbiBwcm9ncmFtLmF0dHJpYnV0ZURhdGEpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgaWYgKChhdHRyaWJ1dGUuZGl2aXNvciA/PyAxKSAhPT0gMSkge1xuICAgICAgICAgIHdhcm4oYEF0dHJpYnV0ZSAke2l9IGhhcyBhbiBpbnZhbGlkIGRpdmlzb3IgdmFsdWUgb2YgJyR7YXR0cmlidXRlLmRpdmlzb3J9Jy4gV2ViR1BVIG9ubHkgc3VwcG9ydHMgYSBkaXZpc29yIHZhbHVlIG9mIDFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLmJ1ZmZlciA9PT0gYnVmZmVyKSB7XG4gICAgICAgICAgYnVmZmVyRW50cnkuYXJyYXlTdHJpZGUgPSBhdHRyaWJ1dGUuc3RyaWRlO1xuICAgICAgICAgIGJ1ZmZlckVudHJ5LnN0ZXBNb2RlID0gYXR0cmlidXRlLmluc3RhbmNlID8gXCJpbnN0YW5jZVwiIDogXCJ2ZXJ0ZXhcIjtcbiAgICAgICAgICBidWZmZXJFbnRyeUF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgICAgICBzaGFkZXJMb2NhdGlvbjogcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2ldLmxvY2F0aW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiBhdHRyaWJ1dGUub2Zmc2V0LFxuICAgICAgICAgICAgZm9ybWF0OiBhdHRyaWJ1dGUuZm9ybWF0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChidWZmZXJFbnRyeUF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHZlcnRleEJ1ZmZlcnNMYXlvdXQucHVzaChidWZmZXJFbnRyeSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fYnVmZmVyTGF5b3V0c0NhY2hlW2tleV0gPSB2ZXJ0ZXhCdWZmZXJzTGF5b3V0O1xuICAgIHJldHVybiB2ZXJ0ZXhCdWZmZXJzTGF5b3V0O1xuICB9XG4gIF91cGRhdGVQaXBlSGFzaCgpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRHbG9iYWxTdGF0ZUtleShcbiAgICAgIHRoaXMuX3N0ZW5jaWxNb2RlLFxuICAgICAgdGhpcy5fbXVsdGlzYW1wbGVDb3VudCxcbiAgICAgIHRoaXMuX2NvbG9yTWFzayxcbiAgICAgIHRoaXMuX2RlcHRoU3RlbmNpbEF0dGFjaG1lbnRcbiAgICApO1xuICAgIGlmICghdGhpcy5fcGlwZVN0YXRlQ2FjaGVzW2tleV0pIHtcbiAgICAgIHRoaXMuX3BpcGVTdGF0ZUNhY2hlc1trZXldID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIHRoaXMuX3BpcGVDYWNoZSA9IHRoaXMuX3BpcGVTdGF0ZUNhY2hlc1trZXldO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuX2J1ZmZlckxheW91dHNDYWNoZSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5QaXBlbGluZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbV0sXG4gIG5hbWU6IFwicGlwZWxpbmVcIlxufTtcblxuZXhwb3J0IHsgUGlwZWxpbmVTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBpcGVsaW5lU3lzdGVtLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1UmVuZGVyVGFyZ2V0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgIHRoaXMubXNhYVRleHR1cmVzID0gW107XG4gICAgdGhpcy5tc2FhU2FtcGxlcyA9IDE7XG4gIH1cbn1cblxuZXhwb3J0IHsgR3B1UmVuZGVyVGFyZ2V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVSZW5kZXJUYXJnZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ0xFQVIgfSBmcm9tICcuLi8uLi9nbC9jb25zdC5tanMnO1xuaW1wb3J0IHsgQ2FudmFzU291cmNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3RleHR1cmUvc291cmNlcy9DYW52YXNTb3VyY2UubWpzJztcbmltcG9ydCB7IFRleHR1cmVTb3VyY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL1RleHR1cmVTb3VyY2UubWpzJztcbmltcG9ydCB7IEdwdVJlbmRlclRhcmdldCB9IGZyb20gJy4vR3B1UmVuZGVyVGFyZ2V0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR3B1UmVuZGVyVGFyZ2V0QWRhcHRvciB7XG4gIGluaXQocmVuZGVyZXIsIHJlbmRlclRhcmdldFN5c3RlbSkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0U3lzdGVtID0gcmVuZGVyVGFyZ2V0U3lzdGVtO1xuICB9XG4gIGNvcHlUb1RleHR1cmUoc291cmNlUmVuZGVyU3VyZmFjZVRleHR1cmUsIGRlc3RpbmF0aW9uVGV4dHVyZSwgb3JpZ2luU3JjLCBzaXplLCBvcmlnaW5EZXN0KSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICBjb25zdCBiYXNlR3B1VGV4dHVyZSA9IHRoaXMuX2dldEdwdUNvbG9yVGV4dHVyZShcbiAgICAgIHNvdXJjZVJlbmRlclN1cmZhY2VUZXh0dXJlXG4gICAgKTtcbiAgICBjb25zdCBiYWNrR3B1VGV4dHVyZSA9IHJlbmRlcmVyLnRleHR1cmUuZ2V0R3B1U291cmNlKFxuICAgICAgZGVzdGluYXRpb25UZXh0dXJlLnNvdXJjZVxuICAgICk7XG4gICAgcmVuZGVyZXIuZW5jb2Rlci5jb21tYW5kRW5jb2Rlci5jb3B5VGV4dHVyZVRvVGV4dHVyZShcbiAgICAgIHtcbiAgICAgICAgdGV4dHVyZTogYmFzZUdwdVRleHR1cmUsXG4gICAgICAgIG9yaWdpbjogb3JpZ2luU3JjXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0ZXh0dXJlOiBiYWNrR3B1VGV4dHVyZSxcbiAgICAgICAgb3JpZ2luOiBvcmlnaW5EZXN0XG4gICAgICB9LFxuICAgICAgc2l6ZVxuICAgICk7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uVGV4dHVyZTtcbiAgfVxuICBzdGFydFJlbmRlclBhc3MocmVuZGVyVGFyZ2V0LCBjbGVhciA9IHRydWUsIGNsZWFyQ29sb3IsIHZpZXdwb3J0KSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0U3lzdGVtID0gdGhpcy5fcmVuZGVyVGFyZ2V0U3lzdGVtO1xuICAgIGNvbnN0IGdwdVJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldFN5c3RlbS5nZXRHcHVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yKHJlbmRlclRhcmdldCwgY2xlYXIsIGNsZWFyQ29sb3IpO1xuICAgIGdwdVJlbmRlclRhcmdldC5kZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcbiAgICB0aGlzLl9yZW5kZXJlci5waXBlbGluZS5zZXRSZW5kZXJUYXJnZXQoZ3B1UmVuZGVyVGFyZ2V0KTtcbiAgICB0aGlzLl9yZW5kZXJlci5lbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyhncHVSZW5kZXJUYXJnZXQpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmVuY29kZXIuc2V0Vmlld3BvcnQodmlld3BvcnQpO1xuICB9XG4gIGZpbmlzaFJlbmRlclBhc3MoKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIuZW5jb2Rlci5lbmRSZW5kZXJQYXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIGdwdSB0ZXh0dXJlIGZvciB0aGUgZmlyc3QgY29sb3IgdGV4dHVyZSBpbiB0aGUgcmVuZGVyIHRhcmdldFxuICAgKiBtYWlubHkgdXNlZCBieSB0aGUgZmlsdGVyIG1hbmFnZXIgdG8gZ2V0IGNvcHkgdGhlIHRleHR1cmUgZm9yIGJsZW5kaW5nXG4gICAqIEBwYXJhbSByZW5kZXJUYXJnZXRcbiAgICogQHJldHVybnMgYSBncHUgdGV4dHVyZVxuICAgKi9cbiAgX2dldEdwdUNvbG9yVGV4dHVyZShyZW5kZXJUYXJnZXQpIHtcbiAgICBjb25zdCBncHVSZW5kZXJUYXJnZXQgPSB0aGlzLl9yZW5kZXJUYXJnZXRTeXN0ZW0uZ2V0R3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgaWYgKGdwdVJlbmRlclRhcmdldC5jb250ZXh0c1swXSkge1xuICAgICAgcmV0dXJuIGdwdVJlbmRlclRhcmdldC5jb250ZXh0c1swXS5nZXRDdXJyZW50VGV4dHVyZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIudGV4dHVyZS5nZXRHcHVTb3VyY2UoXG4gICAgICByZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlc1swXS5zb3VyY2VcbiAgICApO1xuICB9XG4gIGdldERlc2NyaXB0b3IocmVuZGVyVGFyZ2V0LCBjbGVhciwgY2xlYXJWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgY2xlYXIgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBjbGVhciA9IGNsZWFyID8gQ0xFQVIuQUxMIDogQ0xFQVIuTk9ORTtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0U3lzdGVtID0gdGhpcy5fcmVuZGVyVGFyZ2V0U3lzdGVtO1xuICAgIGNvbnN0IGdwdVJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldFN5c3RlbS5nZXRHcHVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICBjb25zdCBjb2xvckF0dGFjaG1lbnRzID0gcmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZXMubWFwKFxuICAgICAgKHRleHR1cmUsIGkpID0+IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGdwdVJlbmRlclRhcmdldC5jb250ZXh0c1tpXTtcbiAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgIGxldCByZXNvbHZlVGFyZ2V0O1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0dXJlID0gY29udGV4dC5nZXRDdXJyZW50VGV4dHVyZSgpO1xuICAgICAgICAgIGNvbnN0IGNhbnZhc1RleHR1cmVWaWV3ID0gY3VycmVudFRleHR1cmUuY3JlYXRlVmlldygpO1xuICAgICAgICAgIHZpZXcgPSBjYW52YXNUZXh0dXJlVmlldztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWV3ID0gdGhpcy5fcmVuZGVyZXIudGV4dHVyZS5nZXRHcHVTb3VyY2UodGV4dHVyZSkuY3JlYXRlVmlldyh7XG4gICAgICAgICAgICBtaXBMZXZlbENvdW50OiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdwdVJlbmRlclRhcmdldC5tc2FhVGV4dHVyZXNbaV0pIHtcbiAgICAgICAgICByZXNvbHZlVGFyZ2V0ID0gdmlldztcbiAgICAgICAgICB2aWV3ID0gdGhpcy5fcmVuZGVyZXIudGV4dHVyZS5nZXRUZXh0dXJlVmlldyhcbiAgICAgICAgICAgIGdwdVJlbmRlclRhcmdldC5tc2FhVGV4dHVyZXNbaV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvYWRPcCA9IGNsZWFyICYgQ0xFQVIuQ09MT1IgPyBcImNsZWFyXCIgOiBcImxvYWRcIjtcbiAgICAgICAgY2xlYXJWYWx1ZSA/PyAoY2xlYXJWYWx1ZSA9IHJlbmRlclRhcmdldFN5c3RlbS5kZWZhdWx0Q2xlYXJDb2xvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmlldyxcbiAgICAgICAgICByZXNvbHZlVGFyZ2V0LFxuICAgICAgICAgIGNsZWFyVmFsdWUsXG4gICAgICAgICAgc3RvcmVPcDogXCJzdG9yZVwiLFxuICAgICAgICAgIGxvYWRPcFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICk7XG4gICAgbGV0IGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQ7XG4gICAgaWYgKChyZW5kZXJUYXJnZXQuc3RlbmNpbCB8fCByZW5kZXJUYXJnZXQuZGVwdGgpICYmICFyZW5kZXJUYXJnZXQuZGVwdGhTdGVuY2lsVGV4dHVyZSkge1xuICAgICAgcmVuZGVyVGFyZ2V0LmVuc3VyZURlcHRoU3RlbmNpbFRleHR1cmUoKTtcbiAgICAgIHJlbmRlclRhcmdldC5kZXB0aFN0ZW5jaWxUZXh0dXJlLnNvdXJjZS5zYW1wbGVDb3VudCA9IGdwdVJlbmRlclRhcmdldC5tc2FhID8gNCA6IDE7XG4gICAgfVxuICAgIGlmIChyZW5kZXJUYXJnZXQuZGVwdGhTdGVuY2lsVGV4dHVyZSkge1xuICAgICAgY29uc3Qgc3RlbmNpbExvYWRPcCA9IGNsZWFyICYgQ0xFQVIuU1RFTkNJTCA/IFwiY2xlYXJcIiA6IFwibG9hZFwiO1xuICAgICAgY29uc3QgZGVwdGhMb2FkT3AgPSBjbGVhciAmIENMRUFSLkRFUFRIID8gXCJjbGVhclwiIDogXCJsb2FkXCI7XG4gICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0ge1xuICAgICAgICB2aWV3OiB0aGlzLl9yZW5kZXJlci50ZXh0dXJlLmdldEdwdVNvdXJjZShyZW5kZXJUYXJnZXQuZGVwdGhTdGVuY2lsVGV4dHVyZS5zb3VyY2UpLmNyZWF0ZVZpZXcoKSxcbiAgICAgICAgc3RlbmNpbFN0b3JlT3A6IFwic3RvcmVcIixcbiAgICAgICAgc3RlbmNpbExvYWRPcCxcbiAgICAgICAgZGVwdGhDbGVhclZhbHVlOiAxLFxuICAgICAgICBkZXB0aExvYWRPcCxcbiAgICAgICAgZGVwdGhTdG9yZU9wOiBcInN0b3JlXCJcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgICBjb2xvckF0dGFjaG1lbnRzLFxuICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudFxuICAgIH07XG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH1cbiAgY2xlYXIocmVuZGVyVGFyZ2V0LCBjbGVhciA9IHRydWUsIGNsZWFyQ29sb3IsIHZpZXdwb3J0KSB7XG4gICAgaWYgKCFjbGVhcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGdwdSwgZW5jb2RlciB9ID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgY29uc3QgZGV2aWNlID0gZ3B1LmRldmljZTtcbiAgICBjb25zdCBzdGFuZEFsb25lID0gZW5jb2Rlci5jb21tYW5kRW5jb2RlciA9PT0gbnVsbDtcbiAgICBpZiAoc3RhbmRBbG9uZSkge1xuICAgICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICAgIGNvbnN0IHJlbmRlclBhc3NEZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yKHJlbmRlclRhcmdldCwgY2xlYXIsIGNsZWFyQ29sb3IpO1xuICAgICAgY29uc3QgcGFzc0VuY29kZXIgPSBjb21tYW5kRW5jb2Rlci5iZWdpblJlbmRlclBhc3MocmVuZGVyUGFzc0Rlc2NyaXB0b3IpO1xuICAgICAgcGFzc0VuY29kZXIuc2V0Vmlld3BvcnQodmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCwgMCwgMSk7XG4gICAgICBwYXNzRW5jb2Rlci5lbmQoKTtcbiAgICAgIGNvbnN0IGdwdUNvbW1hbmRzID0gY29tbWFuZEVuY29kZXIuZmluaXNoKCk7XG4gICAgICBkZXZpY2UucXVldWUuc3VibWl0KFtncHVDb21tYW5kc10pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0UmVuZGVyUGFzcyhyZW5kZXJUYXJnZXQsIGNsZWFyLCBjbGVhckNvbG9yLCB2aWV3cG9ydCk7XG4gICAgfVxuICB9XG4gIGluaXRHcHVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KSB7XG4gICAgcmVuZGVyVGFyZ2V0LmlzUm9vdCA9IHRydWU7XG4gICAgY29uc3QgZ3B1UmVuZGVyVGFyZ2V0ID0gbmV3IEdwdVJlbmRlclRhcmdldCgpO1xuICAgIHJlbmRlclRhcmdldC5jb2xvclRleHR1cmVzLmZvckVhY2goKGNvbG9yVGV4dHVyZSwgaSkgPT4ge1xuICAgICAgaWYgKENhbnZhc1NvdXJjZS50ZXN0KGNvbG9yVGV4dHVyZS5yZXNvdXJjZSkpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNvbG9yVGV4dHVyZS5yZXNvdXJjZS5nZXRDb250ZXh0KFxuICAgICAgICAgIFwid2ViZ3B1XCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgYWxwaGFNb2RlID0gY29sb3JUZXh0dXJlLnRyYW5zcGFyZW50ID8gXCJwcmVtdWx0aXBsaWVkXCIgOiBcIm9wYXF1ZVwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnRleHQuY29uZmlndXJlKHtcbiAgICAgICAgICAgIGRldmljZTogdGhpcy5fcmVuZGVyZXIuZ3B1LmRldmljZSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCB8IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQyxcbiAgICAgICAgICAgIGZvcm1hdDogXCJiZ3JhOHVub3JtXCIsXG4gICAgICAgICAgICBhbHBoYU1vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3B1UmVuZGVyVGFyZ2V0LmNvbnRleHRzW2ldID0gY29udGV4dDtcbiAgICAgIH1cbiAgICAgIGdwdVJlbmRlclRhcmdldC5tc2FhID0gY29sb3JUZXh0dXJlLnNvdXJjZS5hbnRpYWxpYXM7XG4gICAgICBpZiAoY29sb3JUZXh0dXJlLnNvdXJjZS5hbnRpYWxpYXMpIHtcbiAgICAgICAgY29uc3QgbXNhYVRleHR1cmUgPSBuZXcgVGV4dHVyZVNvdXJjZSh7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIHNhbXBsZUNvdW50OiA0XG4gICAgICAgIH0pO1xuICAgICAgICBncHVSZW5kZXJUYXJnZXQubXNhYVRleHR1cmVzW2ldID0gbXNhYVRleHR1cmU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGdwdVJlbmRlclRhcmdldC5tc2FhKSB7XG4gICAgICBncHVSZW5kZXJUYXJnZXQubXNhYVNhbXBsZXMgPSA0O1xuICAgICAgaWYgKHJlbmRlclRhcmdldC5kZXB0aFN0ZW5jaWxUZXh0dXJlKSB7XG4gICAgICAgIHJlbmRlclRhcmdldC5kZXB0aFN0ZW5jaWxUZXh0dXJlLnNvdXJjZS5zYW1wbGVDb3VudCA9IDQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncHVSZW5kZXJUYXJnZXQ7XG4gIH1cbiAgZGVzdHJveUdwdVJlbmRlclRhcmdldChncHVSZW5kZXJUYXJnZXQpIHtcbiAgICBncHVSZW5kZXJUYXJnZXQuY29udGV4dHMuZm9yRWFjaCgoY29udGV4dCkgPT4ge1xuICAgICAgY29udGV4dC51bmNvbmZpZ3VyZSgpO1xuICAgIH0pO1xuICAgIGdwdVJlbmRlclRhcmdldC5tc2FhVGV4dHVyZXMuZm9yRWFjaCgodGV4dHVyZSkgPT4ge1xuICAgICAgdGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgZ3B1UmVuZGVyVGFyZ2V0Lm1zYWFUZXh0dXJlcy5sZW5ndGggPSAwO1xuICAgIGdwdVJlbmRlclRhcmdldC5jb250ZXh0cy5sZW5ndGggPSAwO1xuICB9XG4gIGVuc3VyZURlcHRoU3RlbmNpbFRleHR1cmUocmVuZGVyVGFyZ2V0KSB7XG4gICAgY29uc3QgZ3B1UmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyVGFyZ2V0U3lzdGVtLmdldEdwdVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgIGlmIChyZW5kZXJUYXJnZXQuZGVwdGhTdGVuY2lsVGV4dHVyZSAmJiBncHVSZW5kZXJUYXJnZXQubXNhYSkge1xuICAgICAgcmVuZGVyVGFyZ2V0LmRlcHRoU3RlbmNpbFRleHR1cmUuc291cmNlLnNhbXBsZUNvdW50ID0gNDtcbiAgICB9XG4gIH1cbiAgcmVzaXplR3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkge1xuICAgIGNvbnN0IGdwdVJlbmRlclRhcmdldCA9IHRoaXMuX3JlbmRlclRhcmdldFN5c3RlbS5nZXRHcHVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICBncHVSZW5kZXJUYXJnZXQud2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG4gICAgZ3B1UmVuZGVyVGFyZ2V0LmhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XG4gICAgaWYgKGdwdVJlbmRlclRhcmdldC5tc2FhKSB7XG4gICAgICByZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlcy5mb3JFYWNoKChjb2xvclRleHR1cmUsIGkpID0+IHtcbiAgICAgICAgY29uc3QgbXNhYVRleHR1cmUgPSBncHVSZW5kZXJUYXJnZXQubXNhYVRleHR1cmVzW2ldO1xuICAgICAgICBtc2FhVGV4dHVyZT8ucmVzaXplKFxuICAgICAgICAgIGNvbG9yVGV4dHVyZS5zb3VyY2Uud2lkdGgsXG4gICAgICAgICAgY29sb3JUZXh0dXJlLnNvdXJjZS5oZWlnaHQsXG4gICAgICAgICAgY29sb3JUZXh0dXJlLnNvdXJjZS5fcmVzb2x1dGlvblxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEdwdVJlbmRlclRhcmdldEFkYXB0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdVJlbmRlclRhcmdldEFkYXB0b3IubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0U3lzdGVtIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3JlbmRlclRhcmdldC9SZW5kZXJUYXJnZXRTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdwdVJlbmRlclRhcmdldEFkYXB0b3IgfSBmcm9tICcuL0dwdVJlbmRlclRhcmdldEFkYXB0b3IubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcHVSZW5kZXJUYXJnZXRTeXN0ZW0gZXh0ZW5kcyBSZW5kZXJUYXJnZXRTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICB0aGlzLmFkYXB0b3IgPSBuZXcgR3B1UmVuZGVyVGFyZ2V0QWRhcHRvcigpO1xuICAgIHRoaXMuYWRhcHRvci5pbml0KHJlbmRlcmVyLCB0aGlzKTtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdwdVJlbmRlclRhcmdldFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtFeHRlbnNpb25UeXBlLldlYkdQVVN5c3RlbV0sXG4gIG5hbWU6IFwicmVuZGVyVGFyZ2V0XCJcbn07XG5cbmV4cG9ydCB7IEdwdVJlbmRlclRhcmdldFN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1UmVuZGVyVGFyZ2V0U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcHVTaGFkZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ncHVQcm9ncmFtRGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ3B1KSB7XG4gICAgdGhpcy5fZ3B1ID0gZ3B1O1xuICAgIHRoaXMubWF4VGV4dHVyZXMgPSBncHUuZGV2aWNlLmxpbWl0cy5tYXhTYW1wbGVkVGV4dHVyZXNQZXJTaGFkZXJTdGFnZTtcbiAgfVxuICBnZXRQcm9ncmFtRGF0YShwcm9ncmFtKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVByb2dyYW1EYXRhW3Byb2dyYW0uX2xheW91dEtleV0gfHwgdGhpcy5fY3JlYXRlR1BVUHJvZ3JhbURhdGEocHJvZ3JhbSk7XG4gIH1cbiAgX2NyZWF0ZUdQVVByb2dyYW1EYXRhKHByb2dyYW0pIHtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLl9ncHUuZGV2aWNlO1xuICAgIGNvbnN0IGJpbmRHcm91cHMgPSBwcm9ncmFtLmdwdUxheW91dC5tYXAoKGdyb3VwKSA9PiBkZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHsgZW50cmllczogZ3JvdXAgfSkpO1xuICAgIGNvbnN0IHBpcGVsaW5lTGF5b3V0RGVzYyA9IHsgYmluZEdyb3VwTGF5b3V0czogYmluZEdyb3VwcyB9O1xuICAgIHRoaXMuX2dwdVByb2dyYW1EYXRhW3Byb2dyYW0uX2xheW91dEtleV0gPSB7XG4gICAgICBiaW5kR3JvdXBzLFxuICAgICAgcGlwZWxpbmU6IGRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dChwaXBlbGluZUxheW91dERlc2MpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fZ3B1UHJvZ3JhbURhdGFbcHJvZ3JhbS5fbGF5b3V0S2V5XTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2dwdSA9IG51bGw7XG4gICAgdGhpcy5fZ3B1UHJvZ3JhbURhdGEgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR3B1U2hhZGVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwic2hhZGVyXCJcbn07XG5cbmV4cG9ydCB7IEdwdVNoYWRlclN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1U2hhZGVyU3lzdGVtLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgR3B1QmxlbmRNb2Rlc1RvUGl4aSA9IHt9O1xuR3B1QmxlbmRNb2Rlc1RvUGl4aS5ub3JtYWwgPSB7XG4gIGFscGhhOiB7XG4gICAgc3JjRmFjdG9yOiBcIm9uZVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmUtbWludXMtc3JjLWFscGhhXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgc3JjRmFjdG9yOiBcIm9uZVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmUtbWludXMtc3JjLWFscGhhXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH1cbn07XG5HcHVCbGVuZE1vZGVzVG9QaXhpLmFkZCA9IHtcbiAgYWxwaGE6IHtcbiAgICBzcmNGYWN0b3I6IFwic3JjLWFscGhhXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmMtYWxwaGFcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZVwiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9XG59O1xuR3B1QmxlbmRNb2Rlc1RvUGl4aS5tdWx0aXBseSA9IHtcbiAgYWxwaGE6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmMtYWxwaGFcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBzcmNGYWN0b3I6IFwiZHN0XCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmMtYWxwaGFcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfVxufTtcbkdwdUJsZW5kTW9kZXNUb1BpeGkuc2NyZWVuID0ge1xuICBhbHBoYToge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyYy1hbHBoYVwiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9LFxuICBjb2xvcjoge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyY1wiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9XG59O1xuR3B1QmxlbmRNb2Rlc1RvUGl4aS5vdmVybGF5ID0ge1xuICBhbHBoYToge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyYy1hbHBoYVwiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9LFxuICBjb2xvcjoge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyY1wiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9XG59O1xuR3B1QmxlbmRNb2Rlc1RvUGl4aS5ub25lID0ge1xuICBhbHBoYToge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyYy1hbHBoYVwiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9LFxuICBjb2xvcjoge1xuICAgIHNyY0ZhY3RvcjogXCJ6ZXJvXCIsXG4gICAgZHN0RmFjdG9yOiBcInplcm9cIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfVxufTtcbkdwdUJsZW5kTW9kZXNUb1BpeGlbXCJub3JtYWwtbnBtXCJdID0ge1xuICBhbHBoYToge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyYy1hbHBoYVwiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9LFxuICBjb2xvcjoge1xuICAgIHNyY0ZhY3RvcjogXCJzcmMtYWxwaGFcIixcbiAgICBkc3RGYWN0b3I6IFwib25lLW1pbnVzLXNyYy1hbHBoYVwiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9XG59O1xuR3B1QmxlbmRNb2Rlc1RvUGl4aVtcImFkZC1ucG1cIl0gPSB7XG4gIGFscGhhOiB7XG4gICAgc3JjRmFjdG9yOiBcIm9uZVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmVcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBzcmNGYWN0b3I6IFwic3JjLWFscGhhXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZVwiLFxuICAgIG9wZXJhdGlvbjogXCJhZGRcIlxuICB9XG59O1xuR3B1QmxlbmRNb2Rlc1RvUGl4aVtcInNjcmVlbi1ucG1cIl0gPSB7XG4gIGFscGhhOiB7XG4gICAgc3JjRmFjdG9yOiBcIm9uZVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmUtbWludXMtc3JjLWFscGhhXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgc3JjRmFjdG9yOiBcInNyYy1hbHBoYVwiLFxuICAgIGRzdEZhY3RvcjogXCJvbmUtbWludXMtc3JjXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH1cbn07XG5HcHVCbGVuZE1vZGVzVG9QaXhpLmVyYXNlID0ge1xuICBhbHBoYToge1xuICAgIHNyY0ZhY3RvcjogXCJ6ZXJvXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZS1taW51cy1zcmMtYWxwaGFcIixcbiAgICBvcGVyYXRpb246IFwiYWRkXCJcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBzcmNGYWN0b3I6IFwiemVyb1wiLFxuICAgIGRzdEZhY3RvcjogXCJvbmUtbWludXMtc3JjXCIsXG4gICAgb3BlcmF0aW9uOiBcImFkZFwiXG4gIH1cbn07XG5HcHVCbGVuZE1vZGVzVG9QaXhpLm1pbiA9IHtcbiAgYWxwaGE6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZVwiLFxuICAgIG9wZXJhdGlvbjogXCJtaW5cIlxuICB9LFxuICBjb2xvcjoge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lXCIsXG4gICAgb3BlcmF0aW9uOiBcIm1pblwiXG4gIH1cbn07XG5HcHVCbGVuZE1vZGVzVG9QaXhpLm1heCA9IHtcbiAgYWxwaGE6IHtcbiAgICBzcmNGYWN0b3I6IFwib25lXCIsXG4gICAgZHN0RmFjdG9yOiBcIm9uZVwiLFxuICAgIG9wZXJhdGlvbjogXCJtYXhcIlxuICB9LFxuICBjb2xvcjoge1xuICAgIHNyY0ZhY3RvcjogXCJvbmVcIixcbiAgICBkc3RGYWN0b3I6IFwib25lXCIsXG4gICAgb3BlcmF0aW9uOiBcIm1heFwiXG4gIH1cbn07XG5cbmV4cG9ydCB7IEdwdUJsZW5kTW9kZXNUb1BpeGkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdUJsZW5kTW9kZXNUb1BpeGkubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvc3RhdGUvU3RhdGUubWpzJztcbmltcG9ydCB7IEdwdUJsZW5kTW9kZXNUb1BpeGkgfSBmcm9tICcuL0dwdUJsZW5kTW9kZXNUb1BpeGkubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcHVTdGF0ZVN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUuYmxlbmQgPSB0cnVlO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ3B1KSB7XG4gICAgdGhpcy5ncHUgPSBncHU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGJsZW5kIG1vZGUgZGF0YSBmb3IgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICogQHBhcmFtIHN0YXRlIC0gVGhlIHN0YXRlIHRvIGdldCB0aGUgYmxlbmQgbW9kZSBmcm9tXG4gICAqL1xuICBnZXRDb2xvclRhcmdldHMoc3RhdGUpIHtcbiAgICBjb25zdCBibGVuZCA9IEdwdUJsZW5kTW9kZXNUb1BpeGlbc3RhdGUuYmxlbmRNb2RlXSB8fCBHcHVCbGVuZE1vZGVzVG9QaXhpLm5vcm1hbDtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBmb3JtYXQ6IFwiYmdyYTh1bm9ybVwiLFxuICAgICAgICB3cml0ZU1hc2s6IDAsXG4gICAgICAgIGJsZW5kXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZ3B1ID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdwdVN0YXRlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwic3RhdGVcIlxufTtcblxuZXhwb3J0IHsgR3B1U3RhdGVTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdwdVN0YXRlU3lzdGVtLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgZ3B1VXBsb2FkQnVmZmVySW1hZ2VSZXNvdXJjZSA9IHtcbiAgdHlwZTogXCJpbWFnZVwiLFxuICB1cGxvYWQoc291cmNlLCBncHVUZXh0dXJlLCBncHUpIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IHNvdXJjZS5yZXNvdXJjZTtcbiAgICBjb25zdCB0b3RhbCA9IChzb3VyY2UucGl4ZWxXaWR0aCB8IDApICogKHNvdXJjZS5waXhlbEhlaWdodCB8IDApO1xuICAgIGNvbnN0IGJ5dGVzUGVyUGl4ZWwgPSByZXNvdXJjZS5ieXRlTGVuZ3RoIC8gdG90YWw7XG4gICAgZ3B1LmRldmljZS5xdWV1ZS53cml0ZVRleHR1cmUoXG4gICAgICB7IHRleHR1cmU6IGdwdVRleHR1cmUgfSxcbiAgICAgIHJlc291cmNlLFxuICAgICAge1xuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIHJvd3NQZXJJbWFnZTogc291cmNlLnBpeGVsSGVpZ2h0LFxuICAgICAgICBieXRlc1BlclJvdzogc291cmNlLnBpeGVsSGVpZ2h0ICogYnl0ZXNQZXJQaXhlbFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgd2lkdGg6IHNvdXJjZS5waXhlbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNvdXJjZS5waXhlbEhlaWdodCxcbiAgICAgICAgZGVwdGhPckFycmF5TGF5ZXJzOiAxXG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZ3B1VXBsb2FkQnVmZmVySW1hZ2VSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3B1VXBsb2FkQnVmZmVySW1hZ2VSZXNvdXJjZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJsb2NrRGF0YU1hcCA9IHtcbiAgXCJiYzEtcmdiYS11bm9ybVwiOiB7IGJsb2NrQnl0ZXM6IDgsIGJsb2NrV2lkdGg6IDQsIGJsb2NrSGVpZ2h0OiA0IH0sXG4gIFwiYmMyLXJnYmEtdW5vcm1cIjogeyBibG9ja0J5dGVzOiAxNiwgYmxvY2tXaWR0aDogNCwgYmxvY2tIZWlnaHQ6IDQgfSxcbiAgXCJiYzMtcmdiYS11bm9ybVwiOiB7IGJsb2NrQnl0ZXM6IDE2LCBibG9ja1dpZHRoOiA0LCBibG9ja0hlaWdodDogNCB9LFxuICBcImJjNy1yZ2JhLXVub3JtXCI6IHsgYmxvY2tCeXRlczogMTYsIGJsb2NrV2lkdGg6IDQsIGJsb2NrSGVpZ2h0OiA0IH0sXG4gIFwiZXRjMS1yZ2ItdW5vcm1cIjogeyBibG9ja0J5dGVzOiA4LCBibG9ja1dpZHRoOiA0LCBibG9ja0hlaWdodDogNCB9LFxuICBcImV0YzItcmdiYTh1bm9ybVwiOiB7IGJsb2NrQnl0ZXM6IDE2LCBibG9ja1dpZHRoOiA0LCBibG9ja0hlaWdodDogNCB9LFxuICBcImFzdGMtNHg0LXVub3JtXCI6IHsgYmxvY2tCeXRlczogMTYsIGJsb2NrV2lkdGg6IDQsIGJsb2NrSGVpZ2h0OiA0IH1cbn07XG5jb25zdCBkZWZhdWx0QmxvY2tEYXRhID0geyBibG9ja0J5dGVzOiA0LCBibG9ja1dpZHRoOiAxLCBibG9ja0hlaWdodDogMSB9O1xuY29uc3QgZ3B1VXBsb2FkQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSA9IHtcbiAgdHlwZTogXCJjb21wcmVzc2VkXCIsXG4gIHVwbG9hZChzb3VyY2UsIGdwdVRleHR1cmUsIGdwdSkge1xuICAgIGxldCBtaXBXaWR0aCA9IHNvdXJjZS5waXhlbFdpZHRoO1xuICAgIGxldCBtaXBIZWlnaHQgPSBzb3VyY2UucGl4ZWxIZWlnaHQ7XG4gICAgY29uc3QgYmxvY2tEYXRhID0gYmxvY2tEYXRhTWFwW3NvdXJjZS5mb3JtYXRdIHx8IGRlZmF1bHRCbG9ja0RhdGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UucmVzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxldmVsQnVmZmVyID0gc291cmNlLnJlc291cmNlW2ldO1xuICAgICAgY29uc3QgYnl0ZXNQZXJSb3cgPSBNYXRoLmNlaWwobWlwV2lkdGggLyBibG9ja0RhdGEuYmxvY2tXaWR0aCkgKiBibG9ja0RhdGEuYmxvY2tCeXRlcztcbiAgICAgIGdwdS5kZXZpY2UucXVldWUud3JpdGVUZXh0dXJlKFxuICAgICAgICB7XG4gICAgICAgICAgdGV4dHVyZTogZ3B1VGV4dHVyZSxcbiAgICAgICAgICBtaXBMZXZlbDogaVxuICAgICAgICB9LFxuICAgICAgICBsZXZlbEJ1ZmZlcixcbiAgICAgICAge1xuICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICBieXRlc1BlclJvd1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgd2lkdGg6IE1hdGguY2VpbChtaXBXaWR0aCAvIGJsb2NrRGF0YS5ibG9ja1dpZHRoKSAqIGJsb2NrRGF0YS5ibG9ja1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5jZWlsKG1pcEhlaWdodCAvIGJsb2NrRGF0YS5ibG9ja0hlaWdodCkgKiBibG9ja0RhdGEuYmxvY2tIZWlnaHQsXG4gICAgICAgICAgZGVwdGhPckFycmF5TGF5ZXJzOiAxXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBtaXBXaWR0aCA9IE1hdGgubWF4KG1pcFdpZHRoID4+IDEsIDEpO1xuICAgICAgbWlwSGVpZ2h0ID0gTWF0aC5tYXgobWlwSGVpZ2h0ID4+IDEsIDEpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IHsgYmxvY2tEYXRhTWFwLCBncHVVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncHVVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgZ3B1VXBsb2FkSW1hZ2VSZXNvdXJjZSA9IHtcbiAgdHlwZTogXCJpbWFnZVwiLFxuICB1cGxvYWQoc291cmNlLCBncHVUZXh0dXJlLCBncHUpIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IHNvdXJjZS5yZXNvdXJjZTtcbiAgICBpZiAoIXJlc291cmNlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4oZ3B1VGV4dHVyZS53aWR0aCwgc291cmNlLnJlc291cmNlV2lkdGggfHwgc291cmNlLnBpeGVsV2lkdGgpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKGdwdVRleHR1cmUuaGVpZ2h0LCBzb3VyY2UucmVzb3VyY2VIZWlnaHQgfHwgc291cmNlLnBpeGVsSGVpZ2h0KTtcbiAgICBjb25zdCBwcmVtdWx0aXBsaWVkQWxwaGEgPSBzb3VyY2UuYWxwaGFNb2RlID09PSBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiO1xuICAgIGdwdS5kZXZpY2UucXVldWUuY29weUV4dGVybmFsSW1hZ2VUb1RleHR1cmUoXG4gICAgICB7IHNvdXJjZTogcmVzb3VyY2UgfSxcbiAgICAgIHsgdGV4dHVyZTogZ3B1VGV4dHVyZSwgcHJlbXVsdGlwbGllZEFscGhhIH0sXG4gICAgICB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH1cbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgeyBncHVVcGxvYWRJbWFnZVJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncHVVcGxvYWRJbWFnZVNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBncHVVcGxvYWRJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9ncHVVcGxvYWRJbWFnZVNvdXJjZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGdwdVVwbG9hZFZpZGVvUmVzb3VyY2UgPSB7XG4gIHR5cGU6IFwidmlkZW9cIixcbiAgdXBsb2FkKHNvdXJjZSwgZ3B1VGV4dHVyZSwgZ3B1KSB7XG4gICAgZ3B1VXBsb2FkSW1hZ2VSZXNvdXJjZS51cGxvYWQoc291cmNlLCBncHVUZXh0dXJlLCBncHUpO1xuICB9XG59O1xuXG5leHBvcnQgeyBncHVVcGxvYWRWaWRlb1Jlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncHVVcGxvYWRWaWRlb1NvdXJjZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdU1pcG1hcEdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKGRldmljZSkge1xuICAgIHRoaXMuZGV2aWNlID0gZGV2aWNlO1xuICAgIHRoaXMuc2FtcGxlciA9IGRldmljZS5jcmVhdGVTYW1wbGVyKHsgbWluRmlsdGVyOiBcImxpbmVhclwiIH0pO1xuICAgIHRoaXMucGlwZWxpbmVzID0ge307XG4gIH1cbiAgX2dldE1pcG1hcFBpcGVsaW5lKGZvcm1hdCkge1xuICAgIGxldCBwaXBlbGluZSA9IHRoaXMucGlwZWxpbmVzW2Zvcm1hdF07XG4gICAgaWYgKCFwaXBlbGluZSkge1xuICAgICAgaWYgKCF0aGlzLm1pcG1hcFNoYWRlck1vZHVsZSkge1xuICAgICAgICB0aGlzLm1pcG1hcFNoYWRlck1vZHVsZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7XG4gICAgICAgICAgY29kZTogKFxuICAgICAgICAgICAgLyogd2dzbCAqL1xuICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyPHByaXZhdGU+IHBvcyA6IGFycmF5PHZlYzI8ZjMyPiwgMz4gPSBhcnJheTx2ZWMyPGYzMj4sIDM+KFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMjxmMzI+KC0xLjAsIC0xLjApLCB2ZWMyPGYzMj4oLTEuMCwgMy4wKSwgdmVjMjxmMzI+KDMuMCwgLTEuMCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3QgVmVydGV4T3V0cHV0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbiA6IHZlYzQ8ZjMyPixcbiAgICAgICAgICAgICAgICAgICAgICAgIEBsb2NhdGlvbigwKSB0ZXhDb29yZCA6IHZlYzI8ZjMyPixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIEB2ZXJ0ZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuIHZlcnRleE1haW4oQGJ1aWx0aW4odmVydGV4X2luZGV4KSB2ZXJ0ZXhJbmRleCA6IHUzMikgLT4gVmVydGV4T3V0cHV0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgOiBWZXJ0ZXhPdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudGV4Q29vcmQgPSBwb3NbdmVydGV4SW5kZXhdICogdmVjMjxmMzI+KDAuNSwgLTAuNSkgKyB2ZWMyPGYzMj4oMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wb3NpdGlvbiA9IHZlYzQ8ZjMyPihwb3NbdmVydGV4SW5kZXhdLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyIGltZ1NhbXBsZXIgOiBzYW1wbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhciBpbWcgOiB0ZXh0dXJlXzJkPGYzMj47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIEBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZm4gZnJhZ21lbnRNYWluKEBsb2NhdGlvbigwKSB0ZXhDb29yZCA6IHZlYzI8ZjMyPikgLT4gQGxvY2F0aW9uKDApIHZlYzQ8ZjMyPiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZVNhbXBsZShpbWcsIGltZ1NhbXBsZXIsIHRleENvb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwaXBlbGluZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcbiAgICAgICAgbGF5b3V0OiBcImF1dG9cIixcbiAgICAgICAgdmVydGV4OiB7XG4gICAgICAgICAgbW9kdWxlOiB0aGlzLm1pcG1hcFNoYWRlck1vZHVsZSxcbiAgICAgICAgICBlbnRyeVBvaW50OiBcInZlcnRleE1haW5cIlxuICAgICAgICB9LFxuICAgICAgICBmcmFnbWVudDoge1xuICAgICAgICAgIG1vZHVsZTogdGhpcy5taXBtYXBTaGFkZXJNb2R1bGUsXG4gICAgICAgICAgZW50cnlQb2ludDogXCJmcmFnbWVudE1haW5cIixcbiAgICAgICAgICB0YXJnZXRzOiBbeyBmb3JtYXQgfV1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBpcGVsaW5lc1tmb3JtYXRdID0gcGlwZWxpbmU7XG4gICAgfVxuICAgIHJldHVybiBwaXBlbGluZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIG1pcG1hcHMgZm9yIHRoZSBnaXZlbiBHUFVUZXh0dXJlIGZyb20gdGhlIGRhdGEgaW4gbGV2ZWwgMC5cbiAgICogQHBhcmFtIHttb2R1bGU6RXh0ZXJuYWwuR1BVVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gZ2VuZXJhdGUgbWlwbWFwcyBmb3IuXG4gICAqIEByZXR1cm5zIHttb2R1bGU6RXh0ZXJuYWwuR1BVVGV4dHVyZX0gLSBUaGUgb3JpZ2luYWxseSBwYXNzZWQgdGV4dHVyZVxuICAgKi9cbiAgZ2VuZXJhdGVNaXBtYXAodGV4dHVyZSkge1xuICAgIGNvbnN0IHBpcGVsaW5lID0gdGhpcy5fZ2V0TWlwbWFwUGlwZWxpbmUodGV4dHVyZS5mb3JtYXQpO1xuICAgIGlmICh0ZXh0dXJlLmRpbWVuc2lvbiA9PT0gXCIzZFwiIHx8IHRleHR1cmUuZGltZW5zaW9uID09PSBcIjFkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRpbmcgbWlwbWFwcyBmb3Igbm9uLTJkIHRleHR1cmVzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZCFcIik7XG4gICAgfVxuICAgIGxldCBtaXBUZXh0dXJlID0gdGV4dHVyZTtcbiAgICBjb25zdCBhcnJheUxheWVyQ291bnQgPSB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycyB8fCAxO1xuICAgIGNvbnN0IHJlbmRlclRvU291cmNlID0gdGV4dHVyZS51c2FnZSAmIEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVDtcbiAgICBpZiAoIXJlbmRlclRvU291cmNlKSB7XG4gICAgICBjb25zdCBtaXBUZXh0dXJlRGVzY3JpcHRvciA9IHtcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHdpZHRoOiBNYXRoLmNlaWwodGV4dHVyZS53aWR0aCAvIDIpLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5jZWlsKHRleHR1cmUuaGVpZ2h0IC8gMiksXG4gICAgICAgICAgZGVwdGhPckFycmF5TGF5ZXJzOiBhcnJheUxheWVyQ291bnRcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9TUkMgfCBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQsXG4gICAgICAgIG1pcExldmVsQ291bnQ6IHRleHR1cmUubWlwTGV2ZWxDb3VudCAtIDFcbiAgICAgIH07XG4gICAgICBtaXBUZXh0dXJlID0gdGhpcy5kZXZpY2UuY3JlYXRlVGV4dHVyZShtaXBUZXh0dXJlRGVzY3JpcHRvcik7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoe30pO1xuICAgIGNvbnN0IGJpbmRHcm91cExheW91dCA9IHBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKTtcbiAgICBmb3IgKGxldCBhcnJheUxheWVyID0gMDsgYXJyYXlMYXllciA8IGFycmF5TGF5ZXJDb3VudDsgKythcnJheUxheWVyKSB7XG4gICAgICBsZXQgc3JjVmlldyA9IHRleHR1cmUuY3JlYXRlVmlldyh7XG4gICAgICAgIGJhc2VNaXBMZXZlbDogMCxcbiAgICAgICAgbWlwTGV2ZWxDb3VudDogMSxcbiAgICAgICAgZGltZW5zaW9uOiBcIjJkXCIsXG4gICAgICAgIGJhc2VBcnJheUxheWVyOiBhcnJheUxheWVyLFxuICAgICAgICBhcnJheUxheWVyQ291bnQ6IDFcbiAgICAgIH0pO1xuICAgICAgbGV0IGRzdE1pcExldmVsID0gcmVuZGVyVG9Tb3VyY2UgPyAxIDogMDtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGV4dHVyZS5taXBMZXZlbENvdW50OyArK2kpIHtcbiAgICAgICAgY29uc3QgZHN0VmlldyA9IG1pcFRleHR1cmUuY3JlYXRlVmlldyh7XG4gICAgICAgICAgYmFzZU1pcExldmVsOiBkc3RNaXBMZXZlbCsrLFxuICAgICAgICAgIG1pcExldmVsQ291bnQ6IDEsXG4gICAgICAgICAgZGltZW5zaW9uOiBcIjJkXCIsXG4gICAgICAgICAgYmFzZUFycmF5TGF5ZXI6IGFycmF5TGF5ZXIsXG4gICAgICAgICAgYXJyYXlMYXllckNvdW50OiAxXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyh7XG4gICAgICAgICAgY29sb3JBdHRhY2htZW50czogW3tcbiAgICAgICAgICAgIHZpZXc6IGRzdFZpZXcsXG4gICAgICAgICAgICBzdG9yZU9wOiBcInN0b3JlXCIsXG4gICAgICAgICAgICBsb2FkT3A6IFwiY2xlYXJcIixcbiAgICAgICAgICAgIGNsZWFyVmFsdWU6IHsgcjogMCwgZzogMCwgYjogMCwgYTogMCB9XG4gICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJpbmRHcm91cCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XG4gICAgICAgICAgbGF5b3V0OiBiaW5kR3JvdXBMYXlvdXQsXG4gICAgICAgICAgZW50cmllczogW3tcbiAgICAgICAgICAgIGJpbmRpbmc6IDAsXG4gICAgICAgICAgICByZXNvdXJjZTogdGhpcy5zYW1wbGVyXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYmluZGluZzogMSxcbiAgICAgICAgICAgIHJlc291cmNlOiBzcmNWaWV3XG4gICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcbiAgICAgICAgcGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIGJpbmRHcm91cCk7XG4gICAgICAgIHBhc3NFbmNvZGVyLmRyYXcoMywgMSwgMCwgMCk7XG4gICAgICAgIHBhc3NFbmNvZGVyLmVuZCgpO1xuICAgICAgICBzcmNWaWV3ID0gZHN0VmlldztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZW5kZXJUb1NvdXJjZSkge1xuICAgICAgY29uc3QgbWlwTGV2ZWxTaXplID0ge1xuICAgICAgICB3aWR0aDogTWF0aC5jZWlsKHRleHR1cmUud2lkdGggLyAyKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmNlaWwodGV4dHVyZS5oZWlnaHQgLyAyKSxcbiAgICAgICAgZGVwdGhPckFycmF5TGF5ZXJzOiBhcnJheUxheWVyQ291bnRcbiAgICAgIH07XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRleHR1cmUubWlwTGV2ZWxDb3VudDsgKytpKSB7XG4gICAgICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlKHtcbiAgICAgICAgICB0ZXh0dXJlOiBtaXBUZXh0dXJlLFxuICAgICAgICAgIG1pcExldmVsOiBpIC0gMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgICBtaXBMZXZlbDogaVxuICAgICAgICB9LCBtaXBMZXZlbFNpemUpO1xuICAgICAgICBtaXBMZXZlbFNpemUud2lkdGggPSBNYXRoLmNlaWwobWlwTGV2ZWxTaXplLndpZHRoIC8gMik7XG4gICAgICAgIG1pcExldmVsU2l6ZS5oZWlnaHQgPSBNYXRoLmNlaWwobWlwTGV2ZWxTaXplLmhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW2NvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSk7XG4gICAgaWYgKCFyZW5kZXJUb1NvdXJjZSkge1xuICAgICAgbWlwVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG59XG5cbmV4cG9ydCB7IEdwdU1pcG1hcEdlbmVyYXRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3B1TWlwbWFwR2VuZXJhdG9yLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgQ2FudmFzUG9vbCB9IGZyb20gJy4uLy4uL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzJztcbmltcG9ydCB7IEJpbmRHcm91cCB9IGZyb20gJy4uL3NoYWRlci9CaW5kR3JvdXAubWpzJztcbmltcG9ydCB7IGdwdVVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3VwbG9hZGVycy9ncHVVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBncHVVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLCBibG9ja0RhdGFNYXAgfSBmcm9tICcuL3VwbG9hZGVycy9ncHVVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBncHVVcGxvYWRJbWFnZVJlc291cmNlIH0gZnJvbSAnLi91cGxvYWRlcnMvZ3B1VXBsb2FkSW1hZ2VTb3VyY2UubWpzJztcbmltcG9ydCB7IGdwdVVwbG9hZFZpZGVvUmVzb3VyY2UgfSBmcm9tICcuL3VwbG9hZGVycy9ncHVVcGxvYWRWaWRlb1NvdXJjZS5tanMnO1xuaW1wb3J0IHsgR3B1TWlwbWFwR2VuZXJhdG9yIH0gZnJvbSAnLi91dGlscy9HcHVNaXBtYXBHZW5lcmF0b3IubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcHVUZXh0dXJlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLm1hbmFnZWRUZXh0dXJlcyA9IFtdO1xuICAgIHRoaXMuX2dwdVNvdXJjZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ncHVTYW1wbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2JpbmRHcm91cEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl90ZXh0dXJlVmlld0hhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl91cGxvYWRzID0ge1xuICAgICAgaW1hZ2U6IGdwdVVwbG9hZEltYWdlUmVzb3VyY2UsXG4gICAgICBidWZmZXI6IGdwdVVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UsXG4gICAgICB2aWRlbzogZ3B1VXBsb2FkVmlkZW9SZXNvdXJjZSxcbiAgICAgIGNvbXByZXNzZWQ6IGdwdVVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2VcbiAgICB9O1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gIH1cbiAgY29udGV4dENoYW5nZShncHUpIHtcbiAgICB0aGlzLl9ncHUgPSBncHU7XG4gIH1cbiAgaW5pdFNvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmF1dG9HZW5lcmF0ZU1pcG1hcHMpIHtcbiAgICAgIGNvbnN0IGJpZ2dlc3REaW1lbnNpb24gPSBNYXRoLm1heChzb3VyY2UucGl4ZWxXaWR0aCwgc291cmNlLnBpeGVsSGVpZ2h0KTtcbiAgICAgIHNvdXJjZS5taXBMZXZlbENvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIoYmlnZ2VzdERpbWVuc2lvbikpICsgMTtcbiAgICB9XG4gICAgbGV0IHVzYWdlID0gR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVDtcbiAgICBpZiAoc291cmNlLnVwbG9hZE1ldGhvZElkICE9PSBcImNvbXByZXNzZWRcIikge1xuICAgICAgdXNhZ2UgfD0gR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UO1xuICAgICAgdXNhZ2UgfD0gR1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDO1xuICAgIH1cbiAgICBjb25zdCBibG9ja0RhdGEgPSBibG9ja0RhdGFNYXBbc291cmNlLmZvcm1hdF0gfHwgeyBibG9ja0J5dGVzOiA0LCBibG9ja1dpZHRoOiAxLCBibG9ja0hlaWdodDogMSB9O1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKHNvdXJjZS5waXhlbFdpZHRoIC8gYmxvY2tEYXRhLmJsb2NrV2lkdGgpICogYmxvY2tEYXRhLmJsb2NrV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKHNvdXJjZS5waXhlbEhlaWdodCAvIGJsb2NrRGF0YS5ibG9ja0hlaWdodCkgKiBibG9ja0RhdGEuYmxvY2tIZWlnaHQ7XG4gICAgY29uc3QgdGV4dHVyZURlc2NyaXB0b3IgPSB7XG4gICAgICBsYWJlbDogc291cmNlLmxhYmVsLFxuICAgICAgc2l6ZTogeyB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgICBmb3JtYXQ6IHNvdXJjZS5mb3JtYXQsXG4gICAgICBzYW1wbGVDb3VudDogc291cmNlLnNhbXBsZUNvdW50LFxuICAgICAgbWlwTGV2ZWxDb3VudDogc291cmNlLm1pcExldmVsQ291bnQsXG4gICAgICBkaW1lbnNpb246IHNvdXJjZS5kaW1lbnNpb24sXG4gICAgICB1c2FnZVxuICAgIH07XG4gICAgY29uc3QgZ3B1VGV4dHVyZSA9IHRoaXMuX2dwdS5kZXZpY2UuY3JlYXRlVGV4dHVyZSh0ZXh0dXJlRGVzY3JpcHRvcik7XG4gICAgdGhpcy5fZ3B1U291cmNlc1tzb3VyY2UudWlkXSA9IGdwdVRleHR1cmU7XG4gICAgaWYgKCF0aGlzLm1hbmFnZWRUZXh0dXJlcy5pbmNsdWRlcyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2Uub24oXCJ1cGRhdGVcIiwgdGhpcy5vblNvdXJjZVVwZGF0ZSwgdGhpcyk7XG4gICAgICBzb3VyY2Uub24oXCJyZXNpemVcIiwgdGhpcy5vblNvdXJjZVJlc2l6ZSwgdGhpcyk7XG4gICAgICBzb3VyY2Uub24oXCJkZXN0cm95XCIsIHRoaXMub25Tb3VyY2VEZXN0cm95LCB0aGlzKTtcbiAgICAgIHNvdXJjZS5vbihcInVubG9hZFwiLCB0aGlzLm9uU291cmNlVW5sb2FkLCB0aGlzKTtcbiAgICAgIHNvdXJjZS5vbihcInVwZGF0ZU1pcG1hcHNcIiwgdGhpcy5vblVwZGF0ZU1pcG1hcHMsIHRoaXMpO1xuICAgICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMucHVzaChzb3VyY2UpO1xuICAgIH1cbiAgICB0aGlzLm9uU291cmNlVXBkYXRlKHNvdXJjZSk7XG4gICAgcmV0dXJuIGdwdVRleHR1cmU7XG4gIH1cbiAgb25Tb3VyY2VVcGRhdGUoc291cmNlKSB7XG4gICAgY29uc3QgZ3B1VGV4dHVyZSA9IHRoaXMuZ2V0R3B1U291cmNlKHNvdXJjZSk7XG4gICAgaWYgKCFncHVUZXh0dXJlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLl91cGxvYWRzW3NvdXJjZS51cGxvYWRNZXRob2RJZF0pIHtcbiAgICAgIHRoaXMuX3VwbG9hZHNbc291cmNlLnVwbG9hZE1ldGhvZElkXS51cGxvYWQoc291cmNlLCBncHVUZXh0dXJlLCB0aGlzLl9ncHUpO1xuICAgIH1cbiAgICBpZiAoc291cmNlLmF1dG9HZW5lcmF0ZU1pcG1hcHMgJiYgc291cmNlLm1pcExldmVsQ291bnQgPiAxKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlTWlwbWFwcyhzb3VyY2UpO1xuICAgIH1cbiAgfVxuICBvblNvdXJjZVVubG9hZChzb3VyY2UpIHtcbiAgICBjb25zdCBncHVUZXh0dXJlID0gdGhpcy5fZ3B1U291cmNlc1tzb3VyY2UudWlkXTtcbiAgICBpZiAoZ3B1VGV4dHVyZSkge1xuICAgICAgdGhpcy5fZ3B1U291cmNlc1tzb3VyY2UudWlkXSA9IG51bGw7XG4gICAgICBncHVUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgb25VcGRhdGVNaXBtYXBzKHNvdXJjZSkge1xuICAgIGlmICghdGhpcy5fbWlwbWFwR2VuZXJhdG9yKSB7XG4gICAgICB0aGlzLl9taXBtYXBHZW5lcmF0b3IgPSBuZXcgR3B1TWlwbWFwR2VuZXJhdG9yKHRoaXMuX2dwdS5kZXZpY2UpO1xuICAgIH1cbiAgICBjb25zdCBncHVUZXh0dXJlID0gdGhpcy5nZXRHcHVTb3VyY2Uoc291cmNlKTtcbiAgICB0aGlzLl9taXBtYXBHZW5lcmF0b3IuZ2VuZXJhdGVNaXBtYXAoZ3B1VGV4dHVyZSk7XG4gIH1cbiAgb25Tb3VyY2VEZXN0cm95KHNvdXJjZSkge1xuICAgIHNvdXJjZS5vZmYoXCJ1cGRhdGVcIiwgdGhpcy5vblNvdXJjZVVwZGF0ZSwgdGhpcyk7XG4gICAgc291cmNlLm9mZihcInVubG9hZFwiLCB0aGlzLm9uU291cmNlVW5sb2FkLCB0aGlzKTtcbiAgICBzb3VyY2Uub2ZmKFwiZGVzdHJveVwiLCB0aGlzLm9uU291cmNlRGVzdHJveSwgdGhpcyk7XG4gICAgc291cmNlLm9mZihcInJlc2l6ZVwiLCB0aGlzLm9uU291cmNlUmVzaXplLCB0aGlzKTtcbiAgICBzb3VyY2Uub2ZmKFwidXBkYXRlTWlwbWFwc1wiLCB0aGlzLm9uVXBkYXRlTWlwbWFwcywgdGhpcyk7XG4gICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMuc3BsaWNlKHRoaXMubWFuYWdlZFRleHR1cmVzLmluZGV4T2Yoc291cmNlKSwgMSk7XG4gICAgdGhpcy5vblNvdXJjZVVubG9hZChzb3VyY2UpO1xuICB9XG4gIG9uU291cmNlUmVzaXplKHNvdXJjZSkge1xuICAgIGNvbnN0IGdwdVRleHR1cmUgPSB0aGlzLl9ncHVTb3VyY2VzW3NvdXJjZS51aWRdO1xuICAgIGlmICghZ3B1VGV4dHVyZSkge1xuICAgICAgdGhpcy5pbml0U291cmNlKHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmIChncHVUZXh0dXJlLndpZHRoICE9PSBzb3VyY2UucGl4ZWxXaWR0aCB8fCBncHVUZXh0dXJlLmhlaWdodCAhPT0gc291cmNlLnBpeGVsSGVpZ2h0KSB7XG4gICAgICB0aGlzLl90ZXh0dXJlVmlld0hhc2hbc291cmNlLnVpZF0gPSBudWxsO1xuICAgICAgdGhpcy5fYmluZEdyb3VwSGFzaFtzb3VyY2UudWlkXSA9IG51bGw7XG4gICAgICB0aGlzLm9uU291cmNlVW5sb2FkKHNvdXJjZSk7XG4gICAgICB0aGlzLmluaXRTb3VyY2Uoc291cmNlKTtcbiAgICB9XG4gIH1cbiAgX2luaXRTYW1wbGVyKHNhbXBsZXIpIHtcbiAgICB0aGlzLl9ncHVTYW1wbGVyc1tzYW1wbGVyLl9yZXNvdXJjZUlkXSA9IHRoaXMuX2dwdS5kZXZpY2UuY3JlYXRlU2FtcGxlcihzYW1wbGVyKTtcbiAgICByZXR1cm4gdGhpcy5fZ3B1U2FtcGxlcnNbc2FtcGxlci5fcmVzb3VyY2VJZF07XG4gIH1cbiAgZ2V0R3B1U2FtcGxlcihzYW1wbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dwdVNhbXBsZXJzW3NhbXBsZXIuX3Jlc291cmNlSWRdIHx8IHRoaXMuX2luaXRTYW1wbGVyKHNhbXBsZXIpO1xuICB9XG4gIGdldEdwdVNvdXJjZShzb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1U291cmNlc1tzb3VyY2UudWlkXSB8fCB0aGlzLmluaXRTb3VyY2Uoc291cmNlKTtcbiAgfVxuICAvKipcbiAgICogdGhpcyByZXR1cm5zIHMgYmluZCBncm91cCBmb3IgYSBzcGVjaWZpYyB0ZXh0dXJlLCB0aGUgYmluZCBncm91cCBjb250YWluc1xuICAgKiAtIHRoZSB0ZXh0dXJlIHNvdXJjZVxuICAgKiAtIHRoZSB0ZXh0dXJlIHN0eWxlXG4gICAqIC0gdGhlIHRleHR1cmUgbWF0cml4XG4gICAqIFRoaXMgaXMgY2FjaGVkIHNvIHRoZSBiaW5kIGdyb3VwIHNob3VsZCBvbmx5IGJlIGNyZWF0ZWQgb25jZSBwZXIgdGV4dHVyZVxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIHRoZSB0ZXh0dXJlIHlvdSB3YW50IHRoZSBiaW5kZ3JvdXAgZm9yXG4gICAqIEByZXR1cm5zIHRoZSBiaW5kIGdyb3VwIGZvciB0aGUgdGV4dHVyZVxuICAgKi9cbiAgZ2V0VGV4dHVyZUJpbmRHcm91cCh0ZXh0dXJlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmRHcm91cEhhc2hbdGV4dHVyZS51aWRdID8/IHRoaXMuX2NyZWF0ZVRleHR1cmVCaW5kR3JvdXAodGV4dHVyZSk7XG4gIH1cbiAgX2NyZWF0ZVRleHR1cmVCaW5kR3JvdXAodGV4dHVyZSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRleHR1cmUuc291cmNlO1xuICAgIHRoaXMuX2JpbmRHcm91cEhhc2hbdGV4dHVyZS51aWRdID0gbmV3IEJpbmRHcm91cCh7XG4gICAgICAwOiBzb3VyY2UsXG4gICAgICAxOiBzb3VyY2Uuc3R5bGUsXG4gICAgICAyOiBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgICAgdVRleHR1cmVNYXRyaXg6IHsgdHlwZTogXCJtYXQzeDM8ZjMyPlwiLCB2YWx1ZTogdGV4dHVyZS50ZXh0dXJlTWF0cml4Lm1hcENvb3JkIH1cbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmRHcm91cEhhc2hbdGV4dHVyZS51aWRdO1xuICB9XG4gIGdldFRleHR1cmVWaWV3KHRleHR1cmUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVZpZXdIYXNoW3NvdXJjZS51aWRdID8/IHRoaXMuX2NyZWF0ZVRleHR1cmVWaWV3KHNvdXJjZSk7XG4gIH1cbiAgX2NyZWF0ZVRleHR1cmVWaWV3KHRleHR1cmUpIHtcbiAgICB0aGlzLl90ZXh0dXJlVmlld0hhc2hbdGV4dHVyZS51aWRdID0gdGhpcy5nZXRHcHVTb3VyY2UodGV4dHVyZSkuY3JlYXRlVmlldygpO1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlVmlld0hhc2hbdGV4dHVyZS51aWRdO1xuICB9XG4gIGdlbmVyYXRlQ2FudmFzKHRleHR1cmUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gcmVuZGVyZXIuZ3B1LmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgIGNvbnN0IGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gdGV4dHVyZS5zb3VyY2UucGl4ZWxXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gdGV4dHVyZS5zb3VyY2UucGl4ZWxIZWlnaHQ7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ3B1XCIpO1xuICAgIGNvbnRleHQuY29uZmlndXJlKHtcbiAgICAgIGRldmljZTogcmVuZGVyZXIuZ3B1LmRldmljZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICB1c2FnZTogR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfU1JDLFxuICAgICAgZm9ybWF0OiBET01BZGFwdGVyLmdldCgpLmdldE5hdmlnYXRvcigpLmdwdS5nZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKSxcbiAgICAgIGFscGhhTW9kZTogXCJwcmVtdWx0aXBsaWVkXCJcbiAgICB9KTtcbiAgICBjb21tYW5kRW5jb2Rlci5jb3B5VGV4dHVyZVRvVGV4dHVyZSh7XG4gICAgICB0ZXh0dXJlOiByZW5kZXJlci50ZXh0dXJlLmdldEdwdVNvdXJjZSh0ZXh0dXJlLnNvdXJjZSksXG4gICAgICBvcmlnaW46IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHRleHR1cmU6IGNvbnRleHQuZ2V0Q3VycmVudFRleHR1cmUoKVxuICAgIH0sIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICB9KTtcbiAgICByZW5kZXJlci5ncHUuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG4gIGdldFBpeGVscyh0ZXh0dXJlKSB7XG4gICAgY29uc3Qgd2ViR1BVQ2FudmFzID0gdGhpcy5nZW5lcmF0ZUNhbnZhcyh0ZXh0dXJlKTtcbiAgICBjb25zdCBjYW52YXNBbmRDb250ZXh0ID0gQ2FudmFzUG9vbC5nZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dCh3ZWJHUFVDYW52YXMud2lkdGgsIHdlYkdQVUNhbnZhcy5oZWlnaHQpO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQ7XG4gICAgY29udGV4dC5kcmF3SW1hZ2Uod2ViR1BVQ2FudmFzLCAwLCAwKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHdlYkdQVUNhbnZhcztcbiAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoaW1hZ2VEYXRhLmRhdGEuYnVmZmVyKTtcbiAgICBDYW52YXNQb29sLnJldHVybkNhbnZhc0FuZENvbnRleHQoY2FudmFzQW5kQ29udGV4dCk7XG4gICAgcmV0dXJuIHsgcGl4ZWxzLCB3aWR0aCwgaGVpZ2h0IH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1hbmFnZWRUZXh0dXJlcy5zbGljZSgpLmZvckVhY2goKHNvdXJjZSkgPT4gdGhpcy5vblNvdXJjZURlc3Ryb3koc291cmNlKSk7XG4gICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMgPSBudWxsO1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLl9iaW5kR3JvdXBIYXNoKSkge1xuICAgICAgY29uc3Qga2V5ID0gTnVtYmVyKGspO1xuICAgICAgY29uc3QgYmluZEdyb3VwID0gdGhpcy5fYmluZEdyb3VwSGFzaFtrZXldO1xuICAgICAgYmluZEdyb3VwPy5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9iaW5kR3JvdXBIYXNoW2tleV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9ncHUgPSBudWxsO1xuICAgIHRoaXMuX21pcG1hcEdlbmVyYXRvciA9IG51bGw7XG4gICAgdGhpcy5fZ3B1U291cmNlcyA9IG51bGw7XG4gICAgdGhpcy5fYmluZEdyb3VwSGFzaCA9IG51bGw7XG4gICAgdGhpcy5fdGV4dHVyZVZpZXdIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9ncHVTYW1wbGVycyA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HcHVUZXh0dXJlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwidGV4dHVyZVwiXG59O1xuXG5leHBvcnQgeyBHcHVUZXh0dXJlU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcHVUZXh0dXJlU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEdwdUdyYXBoaWNzQWRhcHRvciB9IGZyb20gJy4uLy4uLy4uL3NjZW5lL2dyYXBoaWNzL2dwdS9HcHVHcmFwaGljc0FkYXB0b3IubWpzJztcbmltcG9ydCB7IEdwdU1lc2hBZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvbWVzaC9ncHUvR3B1TWVzaEFkYXB0ZXIubWpzJztcbmltcG9ydCB7IEdwdUJhdGNoQWRhcHRvciB9IGZyb20gJy4uLy4uL2JhdGNoZXIvZ3B1L0dwdUJhdGNoQWRhcHRvci5tanMnO1xuaW1wb3J0IHsgQWJzdHJhY3RSZW5kZXJlciB9IGZyb20gJy4uL3NoYXJlZC9zeXN0ZW0vQWJzdHJhY3RSZW5kZXJlci5tanMnO1xuaW1wb3J0IHsgU2hhcmVkU3lzdGVtcywgU2hhcmVkUmVuZGVyUGlwZXMgfSBmcm9tICcuLi9zaGFyZWQvc3lzdGVtL1NoYXJlZFN5c3RlbXMubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBCaW5kR3JvdXBTeXN0ZW0gfSBmcm9tICcuL0JpbmRHcm91cFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR3B1QnVmZmVyU3lzdGVtIH0gZnJvbSAnLi9idWZmZXIvR3B1QnVmZmVyU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHcHVDb2xvck1hc2tTeXN0ZW0gfSBmcm9tICcuL0dwdUNvbG9yTWFza1N5c3RlbS5tanMnO1xuaW1wb3J0IHsgR3B1RGV2aWNlU3lzdGVtIH0gZnJvbSAnLi9HcHVEZXZpY2VTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdwdUVuY29kZXJTeXN0ZW0gfSBmcm9tICcuL0dwdUVuY29kZXJTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdwdVN0ZW5jaWxTeXN0ZW0gfSBmcm9tICcuL0dwdVN0ZW5jaWxTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdwdVVib1N5c3RlbSB9IGZyb20gJy4vR3B1VWJvU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHcHVVbmlmb3JtQmF0Y2hQaXBlIH0gZnJvbSAnLi9HcHVVbmlmb3JtQmF0Y2hQaXBlLm1qcyc7XG5pbXBvcnQgeyBQaXBlbGluZVN5c3RlbSB9IGZyb20gJy4vcGlwZWxpbmUvUGlwZWxpbmVTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdwdVJlbmRlclRhcmdldFN5c3RlbSB9IGZyb20gJy4vcmVuZGVyVGFyZ2V0L0dwdVJlbmRlclRhcmdldFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR3B1U2hhZGVyU3lzdGVtIH0gZnJvbSAnLi9zaGFkZXIvR3B1U2hhZGVyU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHcHVTdGF0ZVN5c3RlbSB9IGZyb20gJy4vc3RhdGUvR3B1U3RhdGVTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdwdVRleHR1cmVTeXN0ZW0gfSBmcm9tICcuL3RleHR1cmUvR3B1VGV4dHVyZVN5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IERlZmF1bHRXZWJHUFVTeXN0ZW1zID0gW1xuICAuLi5TaGFyZWRTeXN0ZW1zLFxuICBHcHVVYm9TeXN0ZW0sXG4gIEdwdUVuY29kZXJTeXN0ZW0sXG4gIEdwdURldmljZVN5c3RlbSxcbiAgR3B1QnVmZmVyU3lzdGVtLFxuICBHcHVUZXh0dXJlU3lzdGVtLFxuICBHcHVSZW5kZXJUYXJnZXRTeXN0ZW0sXG4gIEdwdVNoYWRlclN5c3RlbSxcbiAgR3B1U3RhdGVTeXN0ZW0sXG4gIFBpcGVsaW5lU3lzdGVtLFxuICBHcHVDb2xvck1hc2tTeXN0ZW0sXG4gIEdwdVN0ZW5jaWxTeXN0ZW0sXG4gIEJpbmRHcm91cFN5c3RlbVxuXTtcbmNvbnN0IERlZmF1bHRXZWJHUFVQaXBlcyA9IFsuLi5TaGFyZWRSZW5kZXJQaXBlcywgR3B1VW5pZm9ybUJhdGNoUGlwZV07XG5jb25zdCBEZWZhdWx0V2ViR1BVQWRhcHRlcnMgPSBbR3B1QmF0Y2hBZGFwdG9yLCBHcHVNZXNoQWRhcHRlciwgR3B1R3JhcGhpY3NBZGFwdG9yXTtcbmNvbnN0IHN5c3RlbXMgPSBbXTtcbmNvbnN0IHJlbmRlclBpcGVzID0gW107XG5jb25zdCByZW5kZXJQaXBlQWRhcHRvcnMgPSBbXTtcbmV4dGVuc2lvbnMuaGFuZGxlQnlOYW1lZExpc3QoRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sIHN5c3RlbXMpO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeU5hbWVkTGlzdChFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLCByZW5kZXJQaXBlcyk7XG5leHRlbnNpb25zLmhhbmRsZUJ5TmFtZWRMaXN0KEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXNBZGFwdG9yLCByZW5kZXJQaXBlQWRhcHRvcnMpO1xuZXh0ZW5zaW9ucy5hZGQoLi4uRGVmYXVsdFdlYkdQVVN5c3RlbXMsIC4uLkRlZmF1bHRXZWJHUFVQaXBlcywgLi4uRGVmYXVsdFdlYkdQVUFkYXB0ZXJzKTtcbmNsYXNzIFdlYkdQVVJlbmRlcmVyIGV4dGVuZHMgQWJzdHJhY3RSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHN5c3RlbUNvbmZpZyA9IHtcbiAgICAgIG5hbWU6IFwid2ViZ3B1XCIsXG4gICAgICB0eXBlOiBSZW5kZXJlclR5cGUuV0VCR1BVLFxuICAgICAgc3lzdGVtcyxcbiAgICAgIHJlbmRlclBpcGVzLFxuICAgICAgcmVuZGVyUGlwZUFkYXB0b3JzXG4gICAgfTtcbiAgICBzdXBlcihzeXN0ZW1Db25maWcpO1xuICB9XG59XG5cbmV4cG9ydCB7IFdlYkdQVVJlbmRlcmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJHUFVSZW5kZXJlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4751\n')},7608:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N: () => (/* binding */ CanvasPool)\n/* harmony export */ });\n/* unused harmony export CanvasPoolClass */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1761);\n/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9939);\n\n\n\n"use strict";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .e.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext("2d");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .U5)(minWidth);\n    minHeight = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .U5)(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const canvas = canvasAndContext.canvas;\n    const { width, height } = canvas;\n    const key = (width << 17) + (height << 1);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\n\n//# sourceMappingURL=CanvasPool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYwOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUU7QUFDTjs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdFQUFRO0FBQ3ZCLGdCQUFnQix3RUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzPzg3ODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IG5leHRQb3cyIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWlzYy9wb3cyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ2FudmFzUG9vbENsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzT3B0aW9ucykge1xuICAgIHRoaXMuX2NhbnZhc1Bvb2wgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNhbnZhc09wdGlvbnMgPSBjYW52YXNPcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZW5hYmxlRnVsbFNjcmVlbiA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHR1cmUgd2l0aCBwYXJhbXMgdGhhdCB3ZXJlIHNwZWNpZmllZCBpbiBwb29sIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gcGl4ZWxXaWR0aCAtIFdpZHRoIG9mIHRleHR1cmUgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0gcGl4ZWxIZWlnaHQgLSBIZWlnaHQgb2YgdGV4dHVyZSBpbiBwaXhlbHMuXG4gICAqL1xuICBfY3JlYXRlQ2FudmFzQW5kQ29udGV4dChwaXhlbFdpZHRoLCBwaXhlbEhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gcGl4ZWxXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcGl4ZWxIZWlnaHQ7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgcmV0dXJuIHsgY2FudmFzLCBjb250ZXh0IH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBQb3dlci1vZi1Ud28gcmVuZGVyIHRleHR1cmUgb3IgZnVsbFNjcmVlbiB0ZXh0dXJlXG4gICAqIEBwYXJhbSBtaW5XaWR0aCAtIFRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIG1pbkhlaWdodCAtIFRoZSBtaW5pbXVtIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcmV0dXJucyBUaGUgbmV3IHJlbmRlciB0ZXh0dXJlLlxuICAgKi9cbiAgZ2V0T3B0aW1hbENhbnZhc0FuZENvbnRleHQobWluV2lkdGgsIG1pbkhlaWdodCwgcmVzb2x1dGlvbiA9IDEpIHtcbiAgICBtaW5XaWR0aCA9IE1hdGguY2VpbChtaW5XaWR0aCAqIHJlc29sdXRpb24gLSAxZS02KTtcbiAgICBtaW5IZWlnaHQgPSBNYXRoLmNlaWwobWluSGVpZ2h0ICogcmVzb2x1dGlvbiAtIDFlLTYpO1xuICAgIG1pbldpZHRoID0gbmV4dFBvdzIobWluV2lkdGgpO1xuICAgIG1pbkhlaWdodCA9IG5leHRQb3cyKG1pbkhlaWdodCk7XG4gICAgY29uc3Qga2V5ID0gKG1pbldpZHRoIDw8IDE3KSArIChtaW5IZWlnaHQgPDwgMSk7XG4gICAgaWYgKCF0aGlzLl9jYW52YXNQb29sW2tleV0pIHtcbiAgICAgIHRoaXMuX2NhbnZhc1Bvb2xba2V5XSA9IFtdO1xuICAgIH1cbiAgICBsZXQgY2FudmFzQW5kQ29udGV4dCA9IHRoaXMuX2NhbnZhc1Bvb2xba2V5XS5wb3AoKTtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQpIHtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQgPSB0aGlzLl9jcmVhdGVDYW52YXNBbmRDb250ZXh0KG1pbldpZHRoLCBtaW5IZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzQW5kQ29udGV4dDtcbiAgfVxuICAvKipcbiAgICogUGxhY2UgYSByZW5kZXIgdGV4dHVyZSBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSBjYW52YXNBbmRDb250ZXh0XG4gICAqL1xuICByZXR1cm5DYW52YXNBbmRDb250ZXh0KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNBbmRDb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNhbnZhcztcbiAgICBjb25zdCBrZXkgPSAod2lkdGggPDwgMTcpICsgKGhlaWdodCA8PCAxKTtcbiAgICB0aGlzLl9jYW52YXNQb29sW2tleV0ucHVzaChjYW52YXNBbmRDb250ZXh0KTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jYW52YXNQb29sID0ge307XG4gIH1cbn1cbmNvbnN0IENhbnZhc1Bvb2wgPSBuZXcgQ2FudmFzUG9vbENsYXNzKCk7XG5cbmV4cG9ydCB7IENhbnZhc1Bvb2wsIENhbnZhc1Bvb2xDbGFzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzUG9vbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7608\n')}}]);