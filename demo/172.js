"use strict";(self.webpackChunk_masatomakino_threejs_billboard=self.webpackChunk_masatomakino_threejs_billboard||[]).push([[172],{2172:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  WebGLRenderer: () => (/* binding */ WebGLRenderer)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs + 1 modules\nvar maxRecommendedTextures = __webpack_require__(5267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(8157);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs\nvar colorBit = __webpack_require__(2110);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs\nvar generateTextureBatchBit = __webpack_require__(6600);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs\nvar localUniformBit = __webpack_require__(8070);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(9637);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs\nvar getBatchSamplersUniformGroup = __webpack_require__(2189);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(2267);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(4537);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass GlGraphicsAdaptor {\n  init() {\n    const uniforms = new UniformGroup/* UniformGroup */.o({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uTransformMatrix: { value: new Matrix/* Matrix */.y(), type: "mat3x3<f32>" },\n      uRound: { value: 0, type: "f32" }\n    });\n    const maxTextures = (0,maxRecommendedTextures/* getMaxTexturesPerBatch */.N)();\n    const glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "graphics",\n      bits: [\n        colorBit/* colorBitGl */.T,\n        (0,generateTextureBatchBit/* generateTextureBatchBitGl */.h)(maxTextures),\n        localUniformBit/* localUniformBitGl */.$g,\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    });\n    this.shader = new Shader/* Shader */.e({\n      glProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: (0,getBatchSamplersUniformGroup/* getBatchSamplersUniformGroup */.O)(maxTextures)\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      geometry,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    shader.groups[0] = renderer.globalUniforms.bindGroup;\n    renderer.state.set(graphicsPipe.state);\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(geometry, shader.glProgram);\n    const batches = instructions.instructions;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.size) {\n        for (let j = 0; j < batch.textures.count; j++) {\n          renderer.texture.bind(batch.textures.textures[j], j);\n        }\n        renderer.geometry.draw("triangle-list", batch.size, batch.start);\n      }\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGlGraphicsAdaptor.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipesAdaptor\n  ],\n  name: "graphics"\n};\n\n\n//# sourceMappingURL=GlGraphicsAdaptor.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs\nvar textureBit = __webpack_require__(9054);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass GlMeshAdaptor {\n  init() {\n    const glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "mesh",\n      bits: [\n        localUniformBit/* localUniformBitGl */.$g,\n        textureBit/* textureBitGl */.e,\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    });\n    this._shader = new Shader/* Shader */.e({\n      glProgram,\n      resources: {\n        uTexture: Texture/* Texture */.x.EMPTY.source,\n        textureUniforms: {\n          uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix/* Matrix */.y() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      const texture = mesh.texture;\n      const source = texture.source;\n      shader.resources.uTexture = source;\n      shader.resources.uSampler = source.style;\n      shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;\n    } else if (!shader.glProgram) {\n      (0,warn/* warn */.Z)("Mesh shader has no glProgram", mesh.shader);\n      return;\n    }\n    shader.groups[100] = renderer.globalUniforms.bindGroup;\n    shader.groups[101] = meshPipe.localUniformsBindGroup;\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\nGlMeshAdaptor.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipesAdaptor\n  ],\n  name: "mesh"\n};\n\n\n//# sourceMappingURL=GlMeshAdaptor.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(6798);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass GlBatchAdaptor {\n  constructor() {\n    this._didUpload = false;\n    this._tempState = State/* State */.Z.for2d();\n  }\n  init(batcherPipe) {\n    const maxTextures = (0,maxRecommendedTextures/* getMaxTexturesPerBatch */.N)();\n    const glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "batch",\n      bits: [\n        colorBit/* colorBitGl */.T,\n        (0,generateTextureBatchBit/* generateTextureBatchBitGl */.h)(maxTextures),\n        roundPixelsBit/* roundPixelsBitGl */.X\n      ]\n    });\n    this._shader = new Shader/* Shader */.e({\n      glProgram,\n      resources: {\n        batchSamplers: (0,getBatchSamplersUniformGroup/* getBatchSamplersUniformGroup */.O)(maxTextures)\n      }\n    });\n    batcherPipe.renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._didUpload = false;\n  }\n  start(batchPipe, geometry) {\n    const renderer = batchPipe.renderer;\n    renderer.shader.bind(this._shader, this._didUpload);\n    renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n    renderer.geometry.bind(geometry, this._shader.glProgram);\n  }\n  execute(batchPipe, batch) {\n    const renderer = batchPipe.renderer;\n    this._didUpload = true;\n    this._tempState.blendMode = batch.blendMode;\n    renderer.state.set(this._tempState);\n    const textures = batch.textures.textures;\n    for (let i = 0; i < batch.textures.count; i++) {\n      renderer.texture.bind(textures[i], i);\n    }\n    renderer.geometry.draw("triangle-list", batch.size, batch.start);\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGlBatchAdaptor.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLPipesAdaptor\n  ],\n  name: "batch"\n};\n\n\n//# sourceMappingURL=GlBatchAdaptor.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs + 1 modules\nvar AbstractRenderer = __webpack_require__(7400);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs + 30 modules\nvar SharedSystems = __webpack_require__(6338);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(5765);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs\nvar buffer_const = __webpack_require__(5324);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs\n\nvar BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {\n  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";\n  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";\n  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";\n  return BUFFER_TYPE2;\n})(BUFFER_TYPE || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs\n\nclass GlBuffer {\n  constructor(buffer, type) {\n    this.buffer = buffer || null;\n    this.updateID = -1;\n    this.byteLength = -1;\n    this.type = type;\n  }\n}\n\n\n//# sourceMappingURL=GlBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs\n\n\n\n\n\n"use strict";\nclass GlBufferSystem {\n  /**\n   * @param {Renderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    /** Cache keeping track of the base bound buffer bases */\n    this._boundBufferBases = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this._renderer = null;\n    this._gl = null;\n    this._gpuBuffers = null;\n    this._boundBufferBases = null;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    this._gl = this._renderer.gl;\n  }\n  getGlBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n  }\n  /**\n   * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n   * @param buffer - the buffer to bind to the renderer\n   */\n  bind(buffer) {\n    const { _gl: gl } = this;\n    const glBuffer = this.getGlBuffer(buffer);\n    gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n  }\n  /**\n   * Binds an uniform buffer to at the given index.\n   *\n   * A cache is used so a buffer will not be bound again if already bound.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind it to.\n   */\n  bindBufferBase(buffer, index) {\n    const { _gl: gl } = this;\n    if (this._boundBufferBases[index] !== buffer) {\n      const glBuffer = this.getGlBuffer(buffer);\n      this._boundBufferBases[index] = buffer;\n      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  /**\n   * Binds a buffer whilst also binding its range.\n   * This will make the buffer start from the offset supplied rather than 0 when it is read.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind at, defaults to 0\n   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n   */\n  bindBufferRange(buffer, index, offset) {\n    const { _gl: gl } = this;\n    offset = offset || 0;\n    const glBuffer = this.getGlBuffer(buffer);\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n  }\n  /**\n   * Will ensure the data in the buffer is uploaded to the GPU.\n   * @param {Buffer} buffer - the buffer to update\n   */\n  updateBuffer(buffer) {\n    const { _gl: gl } = this;\n    const glBuffer = this.getGlBuffer(buffer);\n    if (buffer._updateID === glBuffer.updateID) {\n      return glBuffer;\n    }\n    glBuffer.updateID = buffer._updateID;\n    gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    const data = buffer.data;\n    if (glBuffer.byteLength >= buffer.data.byteLength) {\n      gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n    } else {\n      const drawType = buffer.descriptor.usage & buffer_const/* BufferUsage */.F.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n      glBuffer.byteLength = data.byteLength;\n      gl.bufferData(glBuffer.type, data, drawType);\n    }\n    return glBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    const gl = this._gl;\n    for (const id in this._gpuBuffers) {\n      gl.deleteBuffer(this._gpuBuffers[id].buffer);\n    }\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Disposes buffer\n   * @param {Buffer} buffer - buffer with data\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  onBufferDestroy(buffer, contextLost) {\n    const glBuffer = this._gpuBuffers[buffer.uid];\n    const gl = this._gl;\n    if (!contextLost) {\n      gl.deleteBuffer(glBuffer.buffer);\n    }\n    this._gpuBuffers[buffer.uid] = null;\n  }\n  /**\n   * creates and attaches a GLBuffer object tied to the current context.\n   * @param buffer\n   * @protected\n   */\n  createGLBuffer(buffer) {\n    const { _gl: gl } = this;\n    let type = BUFFER_TYPE.ARRAY_BUFFER;\n    if (buffer.descriptor.usage & buffer_const/* BufferUsage */.F.INDEX) {\n      type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n    } else if (buffer.descriptor.usage & buffer_const/* BufferUsage */.F.UNIFORM) {\n      type = BUFFER_TYPE.UNIFORM_BUFFER;\n    }\n    const glBuffer = new GlBuffer(gl.createBuffer(), type);\n    this._gpuBuffers[buffer.uid] = glBuffer;\n    buffer.on("destroy", this.onBufferDestroy, this);\n    return glBuffer;\n  }\n}\n/** @ignore */\nGlBufferSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "buffer"\n};\n\n\n//# sourceMappingURL=GlBufferSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs\n\n\n\n\n"use strict";\nconst _GlContextSystem = class _GlContextSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    /**\n     * Features supported by current renderer.\n     * @type {object}\n     * @readonly\n     */\n    this.supports = {\n      /** Support for 32-bit indices buffer. */\n      uint32Indices: true,\n      /** Support for UniformBufferObjects */\n      uniformBufferObject: true,\n      /** Support for VertexArrayObjects */\n      vertexArrayObject: true,\n      /** Support for SRGB texture format */\n      srgbTextures: true,\n      /** Support for wrapping modes if a texture is non-power of two */\n      nonPowOf2wrapping: true,\n      /** Support for MSAA (antialiasing of dynamic textures) */\n      msaa: true,\n      /** Support for mipmaps if a texture is non-power of two */\n      nonPowOf2mipmaps: true\n    };\n    this._renderer = renderer;\n    this.extensions = /* @__PURE__ */ Object.create(null);\n    this.handleContextLost = this.handleContextLost.bind(this);\n    this.handleContextRestored = this.handleContextRestored.bind(this);\n  }\n  /**\n   * `true` if the context is lost\n   * @readonly\n   */\n  get isLost() {\n    return !this.gl || this.gl.isContextLost();\n  }\n  /**\n   * Handles the context change event.\n   * @param {WebGLRenderingContext} gl - New WebGL context.\n   */\n  contextChange(gl) {\n    this.gl = gl;\n    this._renderer.gl = gl;\n  }\n  init(options) {\n    options = { ..._GlContextSystem.defaultOptions, ...options };\n    if (options.context) {\n      this.initFromContext(options.context);\n    } else {\n      const alpha = this._renderer.background.alpha < 1;\n      const premultipliedAlpha = options.premultipliedAlpha ?? true;\n      const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;\n      this.createContext(options.preferWebGLVersion, {\n        alpha,\n        premultipliedAlpha,\n        antialias,\n        stencil: true,\n        preserveDrawingBuffer: options.preserveDrawingBuffer,\n        powerPreference: options.powerPreference ?? "default"\n      });\n    }\n  }\n  /**\n   * Initializes the context.\n   * @protected\n   * @param {WebGLRenderingContext} gl - WebGL context\n   */\n  initFromContext(gl) {\n    this.gl = gl;\n    this.webGLVersion = gl instanceof adapter/* DOMAdapter */.z.get().getWebGLRenderingContext() ? 1 : 2;\n    this.getExtensions();\n    this.validateContext(gl);\n    this._renderer.runners.contextChange.emit(gl);\n    const element = this._renderer.view.canvas;\n    element.addEventListener("webglcontextlost", this.handleContextLost, false);\n    element.addEventListener("webglcontextrestored", this.handleContextRestored, false);\n  }\n  /**\n   * Initialize from context options\n   * @protected\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n   * @param preferWebGLVersion\n   * @param {object} options - context attributes\n   */\n  createContext(preferWebGLVersion, options) {\n    let gl;\n    const canvas = this._renderer.view.canvas;\n    if (preferWebGLVersion === 2) {\n      gl = canvas.getContext("webgl2", options);\n    }\n    if (!gl) {\n      gl = canvas.getContext("webgl", options);\n      if (!gl) {\n        throw new Error("This browser does not support WebGL. Try using the canvas renderer");\n      }\n    }\n    this.gl = gl;\n    this.initFromContext(this.gl);\n  }\n  /** Auto-populate the {@link GlContextSystem.extensions extensions}. */\n  getExtensions() {\n    const { gl } = this;\n    const common = {\n      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),\n      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),\n      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),\n      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),\n      // eslint-disable-line camelcase\n      etc: gl.getExtension("WEBGL_compressed_texture_etc"),\n      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),\n      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),\n      atc: gl.getExtension("WEBGL_compressed_texture_atc"),\n      astc: gl.getExtension("WEBGL_compressed_texture_astc"),\n      bptc: gl.getExtension("EXT_texture_compression_bptc"),\n      rgtc: gl.getExtension("EXT_texture_compression_rgtc"),\n      loseContext: gl.getExtension("WEBGL_lose_context")\n    };\n    if (this.webGLVersion === 1) {\n      this.extensions = {\n        ...common,\n        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),\n        depthTexture: gl.getExtension("WEBGL_depth_texture"),\n        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),\n        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),\n        // Floats and half-floats\n        floatTexture: gl.getExtension("OES_texture_float"),\n        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),\n        textureHalfFloat: gl.getExtension("OES_texture_half_float"),\n        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),\n        vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),\n        srgb: gl.getExtension("EXT_sRGB")\n      };\n    } else {\n      this.extensions = {\n        ...common,\n        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")\n      };\n      const provokeExt = gl.getExtension("WEBGL_provoking_vertex");\n      if (provokeExt) {\n        provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);\n      }\n    }\n  }\n  /**\n   * Handles a lost webgl context\n   * @param {WebGLContextEvent} event - The context lost event.\n   */\n  handleContextLost(event) {\n    event.preventDefault();\n    if (this._contextLossForced) {\n      this._contextLossForced = false;\n      setTimeout(() => {\n        if (this.gl.isContextLost()) {\n          this.extensions.loseContext?.restoreContext();\n        }\n      }, 0);\n    }\n  }\n  /** Handles a restored webgl context. */\n  handleContextRestored() {\n    this._renderer.runners.contextChange.emit(this.gl);\n  }\n  destroy() {\n    const element = this._renderer.view.canvas;\n    this._renderer = null;\n    element.removeEventListener("webglcontextlost", this.handleContextLost);\n    element.removeEventListener("webglcontextrestored", this.handleContextRestored);\n    this.gl.useProgram(null);\n    this.extensions.loseContext?.loseContext();\n  }\n  /**\n   * this function can be called to force a webGL context loss\n   * this will release all resources on the GPU.\n   * Useful if you need to put Pixi to sleep, and save some GPU memory\n   *\n   * As soon as render is called - all resources will be created again.\n   */\n  forceContextLoss() {\n    this.extensions.loseContext?.loseContext();\n    this._contextLossForced = true;\n  }\n  /**\n   * Validate context.\n   * @param {WebGLRenderingContext} gl - Render context.\n   */\n  validateContext(gl) {\n    const attributes = gl.getContextAttributes();\n    if (attributes && !attributes.stencil) {\n      (0,warn/* warn */.Z)("Provided WebGL context does not have a stencil buffer, masks may not render correctly");\n    }\n    const supports = this.supports;\n    const isWebGl2 = this.webGLVersion === 2;\n    const extensions = this.extensions;\n    supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;\n    supports.uniformBufferObject = isWebGl2;\n    supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;\n    supports.srgbTextures = isWebGl2 || !!extensions.srgb;\n    supports.nonPowOf2wrapping = isWebGl2;\n    supports.nonPowOf2mipmaps = isWebGl2;\n    supports.msaa = isWebGl2;\n    if (!supports.uint32Indices) {\n      (0,warn/* warn */.Z)("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");\n    }\n  }\n};\n/** @ignore */\n_GlContextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "context"\n};\n/** The default options for the system. */\n_GlContextSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.context}\n   * @default null\n   */\n  context: null,\n  /**\n   * {@link WebGLOptions.premultipliedAlpha}\n   * @default true\n   */\n  premultipliedAlpha: true,\n  /**\n   * {@link WebGLOptions.preserveDrawingBuffer}\n   * @default false\n   */\n  preserveDrawingBuffer: false,\n  /**\n   * {@link WebGLOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * {@link WebGLOptions.webGLVersion}\n   * @default 2\n   */\n  preferWebGLVersion: 2\n};\nlet GlContextSystem = _GlContextSystem;\n\n\n//# sourceMappingURL=GlContextSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs\nvar getAttributeInfoFromFormat = __webpack_require__(9824);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs\nvar ensureAttributes = __webpack_require__(6546);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs\n\nvar GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {\n  GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";\n  GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";\n  GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";\n  GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";\n  GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";\n  GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";\n  GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";\n  GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";\n  GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";\n  GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";\n  GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";\n  GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";\n  GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";\n  return GL_FORMATS2;\n})(GL_FORMATS || {});\nvar GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {\n  GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";\n  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";\n  GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";\n  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";\n  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";\n  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";\n  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";\n  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";\n  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";\n  return GL_TARGETS2;\n})(GL_TARGETS || {});\nvar GL_WRAP_MODES = /* @__PURE__ */ ((GL_WRAP_MODES2) => {\n  GL_WRAP_MODES2[GL_WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";\n  GL_WRAP_MODES2[GL_WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";\n  GL_WRAP_MODES2[GL_WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";\n  return GL_WRAP_MODES2;\n})(GL_WRAP_MODES || {});\nvar GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {\n  GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";\n  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";\n  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";\n  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";\n  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";\n  GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";\n  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";\n  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";\n  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";\n  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";\n  GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";\n  GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";\n  GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";\n  GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";\n  GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";\n  GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";\n  return GL_TYPES2;\n})(GL_TYPES || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs\n\n\n"use strict";\nconst infoMap = {\n  uint8x2: GL_TYPES.UNSIGNED_BYTE,\n  uint8x4: GL_TYPES.UNSIGNED_BYTE,\n  sint8x2: GL_TYPES.BYTE,\n  sint8x4: GL_TYPES.BYTE,\n  unorm8x2: GL_TYPES.UNSIGNED_BYTE,\n  unorm8x4: GL_TYPES.UNSIGNED_BYTE,\n  snorm8x2: GL_TYPES.BYTE,\n  snorm8x4: GL_TYPES.BYTE,\n  uint16x2: GL_TYPES.UNSIGNED_SHORT,\n  uint16x4: GL_TYPES.UNSIGNED_SHORT,\n  sint16x2: GL_TYPES.SHORT,\n  sint16x4: GL_TYPES.SHORT,\n  unorm16x2: GL_TYPES.UNSIGNED_SHORT,\n  unorm16x4: GL_TYPES.UNSIGNED_SHORT,\n  snorm16x2: GL_TYPES.SHORT,\n  snorm16x4: GL_TYPES.SHORT,\n  float16x2: GL_TYPES.HALF_FLOAT,\n  float16x4: GL_TYPES.HALF_FLOAT,\n  float32: GL_TYPES.FLOAT,\n  float32x2: GL_TYPES.FLOAT,\n  float32x3: GL_TYPES.FLOAT,\n  float32x4: GL_TYPES.FLOAT,\n  uint32: GL_TYPES.UNSIGNED_INT,\n  uint32x2: GL_TYPES.UNSIGNED_INT,\n  uint32x3: GL_TYPES.UNSIGNED_INT,\n  uint32x4: GL_TYPES.UNSIGNED_INT,\n  sint32: GL_TYPES.INT,\n  sint32x2: GL_TYPES.INT,\n  sint32x3: GL_TYPES.INT,\n  sint32x4: GL_TYPES.INT\n};\nfunction getGlTypeFromFormat(format) {\n  return infoMap[format] ?? infoMap.float32;\n}\n\n\n//# sourceMappingURL=getGlTypeFromFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs\n\n\n\n\n\n"use strict";\nconst topologyToGlMap = {\n  "point-list": 0,\n  "line-list": 1,\n  "line-strip": 3,\n  "triangle-list": 4,\n  "triangle-strip": 5\n};\nclass GlGeometrySystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._geometryVaoHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    const gl = this.gl = this._renderer.gl;\n    if (!this._renderer.context.supports.vertexArrayObject) {\n      throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");\n    }\n    const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n    if (nativeVaoExtension) {\n      gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();\n      gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);\n      gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);\n    }\n    const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n    if (nativeInstancedExtension) {\n      gl.drawArraysInstanced = (a, b, c, d) => {\n        nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n      };\n      gl.drawElementsInstanced = (a, b, c, d, e) => {\n        nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n      };\n      gl.vertexAttribDivisor = (a, b) => nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n    }\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this._geometryVaoHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Binds geometry so that is can be drawn. Creating a Vao if required\n   * @param geometry - Instance of geometry to bind.\n   * @param program - Instance of program to use vao for.\n   */\n  bind(geometry, program) {\n    const gl = this.gl;\n    this._activeGeometry = geometry;\n    const vao = this.getVao(geometry, program);\n    if (this._activeVao !== vao) {\n      this._activeVao = vao;\n      gl.bindVertexArray(vao);\n    }\n    this.updateBuffers();\n  }\n  /** Reset and unbind any active VAO and geometry. */\n  reset() {\n    this.unbind();\n  }\n  /** Update buffers of the currently bound geometry. */\n  updateBuffers() {\n    const geometry = this._activeGeometry;\n    const bufferSystem = this._renderer.buffer;\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      const buffer = geometry.buffers[i];\n      bufferSystem.updateBuffer(buffer);\n    }\n  }\n  /**\n   * Check compatibility between a geometry and a program\n   * @param geometry - Geometry instance.\n   * @param program - Program instance.\n   */\n  checkCompatibility(geometry, program) {\n    const geometryAttributes = geometry.attributes;\n    const shaderAttributes = program._attributeData;\n    for (const j in shaderAttributes) {\n      if (!geometryAttributes[j]) {\n        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);\n      }\n    }\n  }\n  /**\n   * Takes a geometry and program and generates a unique signature for them.\n   * @param geometry - To get signature from.\n   * @param program - To test geometry against.\n   * @returns - Unique signature of the geometry and program\n   */\n  getSignature(geometry, program) {\n    const attribs = geometry.attributes;\n    const shaderAttributes = program._attributeData;\n    const strings = ["g", geometry.uid];\n    for (const i in attribs) {\n      if (shaderAttributes[i]) {\n        strings.push(i, shaderAttributes[i].location);\n      }\n    }\n    return strings.join("-");\n  }\n  getVao(geometry, program) {\n    return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n  }\n  /**\n   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n   * attribute locations.\n   * @param geometry - Instance of geometry to to generate Vao for.\n   * @param program\n   * @param _incRefCount - Increment refCount of all geometry buffers.\n   */\n  initGeometryVao(geometry, program, _incRefCount = true) {\n    const gl = this._renderer.gl;\n    const bufferSystem = this._renderer.buffer;\n    this._renderer.shader._getProgramData(program);\n    this.checkCompatibility(geometry, program);\n    const signature = this.getSignature(geometry, program);\n    if (!this._geometryVaoHash[geometry.uid]) {\n      this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);\n      geometry.on("destroy", this.onGeometryDestroy, this);\n    }\n    const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n    let vao = vaoObjectHash[signature];\n    if (vao) {\n      vaoObjectHash[program._key] = vao;\n      return vao;\n    }\n    (0,ensureAttributes/* ensureAttributes */.B)(geometry, program._attributeData);\n    const buffers = geometry.buffers;\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      bufferSystem.bind(buffer);\n    }\n    this.activateVao(geometry, program);\n    vaoObjectHash[program._key] = vao;\n    vaoObjectHash[signature] = vao;\n    gl.bindVertexArray(null);\n    return vao;\n  }\n  /**\n   * Disposes geometry.\n   * @param geometry - Geometry with buffers. Only VAO will be disposed\n   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  onGeometryDestroy(geometry, contextLost) {\n    const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n    const gl = this.gl;\n    if (vaoObjectHash) {\n      if (contextLost) {\n        for (const i in vaoObjectHash) {\n          if (this._activeVao !== vaoObjectHash[i]) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vaoObjectHash[i]);\n        }\n      }\n      this._geometryVaoHash[geometry.uid] = null;\n    }\n  }\n  /**\n   * Dispose all WebGL resources of all managed geometries.\n   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n   */\n  destroyAll(contextLost = false) {\n    const gl = this.gl;\n    for (const i in this._geometryVaoHash) {\n      if (contextLost) {\n        for (const j in this._geometryVaoHash[i]) {\n          const vaoObjectHash = this._geometryVaoHash[i];\n          if (this._activeVao !== vaoObjectHash) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vaoObjectHash[j]);\n        }\n      }\n      this._geometryVaoHash[i] = null;\n    }\n  }\n  /**\n   * Activate vertex array object.\n   * @param geometry - Geometry instance.\n   * @param program - Shader program instance.\n   */\n  activateVao(geometry, program) {\n    const gl = this._renderer.gl;\n    const bufferSystem = this._renderer.buffer;\n    const attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      bufferSystem.bind(geometry.indexBuffer);\n    }\n    let lastBuffer = null;\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const buffer = attribute.buffer;\n      const glBuffer = bufferSystem.getGlBuffer(buffer);\n      const programAttrib = program._attributeData[j];\n      if (programAttrib) {\n        if (lastBuffer !== glBuffer) {\n          bufferSystem.bind(buffer);\n          lastBuffer = glBuffer;\n        }\n        const location = attribute.location;\n        gl.enableVertexAttribArray(location);\n        const attributeInfo = (0,getAttributeInfoFromFormat/* getAttributeInfoFromFormat */.v)(attribute.format);\n        const type = getGlTypeFromFormat(attribute.format);\n        if (programAttrib.format?.substring(1, 4) === "int") {\n          gl.vertexAttribIPointer(\n            location,\n            attributeInfo.size,\n            type,\n            attribute.stride,\n            attribute.offset\n          );\n        } else {\n          gl.vertexAttribPointer(\n            location,\n            attributeInfo.size,\n            type,\n            attributeInfo.normalised,\n            attribute.stride,\n            attribute.offset\n          );\n        }\n        if (attribute.instance) {\n          if (this.hasInstance) {\n            const divisor = attribute.divisor ?? 1;\n            gl.vertexAttribDivisor(location, divisor);\n          } else {\n            throw new Error("geometry error, GPU Instancing is not supported on this device");\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Draws the currently bound geometry.\n   * @param topology - The type primitive to render.\n   * @param size - The number of elements to be rendered. If not specified, all vertices after the\n   *  starting vertex will be drawn.\n   * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n   *  drawing will start from the first vertex.\n   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n   *  all instances will be drawn.\n   */\n  draw(topology, size, start, instanceCount) {\n    const { gl } = this._renderer;\n    const geometry = this._activeGeometry;\n    const glTopology = topologyToGlMap[geometry.topology || topology];\n    instanceCount || (instanceCount = geometry.instanceCount);\n    if (geometry.indexBuffer) {\n      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      if (instanceCount > 1) {\n        gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n      } else {\n        gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n      }\n    } else if (instanceCount > 1) {\n      gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n    } else {\n      gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n    }\n    return this;\n  }\n  /** Unbind/reset everything. */\n  unbind() {\n    this.gl.bindVertexArray(null);\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this.gl = null;\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n}\n/** @ignore */\nGlGeometrySystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "geometry"\n};\n\n\n//# sourceMappingURL=GlGeometrySystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs + 2 modules\nvar Geometry = __webpack_require__(1980);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 2 modules\nvar TextureSource = __webpack_require__(5206);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs + 6 modules\nvar GlProgram = __webpack_require__(749);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nconst bigTriangleGeometry = new Geometry/* Geometry */.Z({\n  attributes: {\n    aPosition: [\n      -1,\n      -1,\n      // Bottom left corner\n      3,\n      -1,\n      // Bottom right corner, extending beyond right edge\n      -1,\n      3\n      // Top left corner, extending beyond top edge\n    ]\n  }\n});\nconst _GlBackBufferSystem = class _GlBackBufferSystem {\n  constructor(renderer) {\n    /** if true, the back buffer is used */\n    this.useBackBuffer = false;\n    this._useBackBufferThisRender = false;\n    this._renderer = renderer;\n  }\n  init(options = {}) {\n    const { useBackBuffer, antialias } = { ..._GlBackBufferSystem.defaultOptions, ...options };\n    this.useBackBuffer = useBackBuffer;\n    this._antialias = antialias;\n    if (!this._renderer.context.supports.msaa) {\n      (0,warn/* warn */.Z)("antialiasing, is not supported on when using the back buffer");\n      this._antialias = false;\n    }\n    this._state = State/* State */.Z.for2d();\n    const bigTriangleProgram = new GlProgram/* GlProgram */.J({\n      vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n      fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n      name: "big-triangle"\n    });\n    this._bigTriangleShader = new Shader/* Shader */.e({\n      glProgram: bigTriangleProgram,\n      resources: {\n        uTexture: Texture/* Texture */.x.WHITE.source\n      }\n    });\n  }\n  /**\n   * This is called before the RenderTargetSystem is started. This is where\n   * we replace the target with the back buffer if required.\n   * @param options - The options for this render.\n   */\n  renderStart(options) {\n    const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n    this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n    if (this._useBackBufferThisRender) {\n      const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);\n      this._targetTexture = renderTarget2.colorTexture;\n      options.target = this._getBackBufferTexture(renderTarget2.colorTexture);\n    }\n  }\n  renderEnd() {\n    this._presentBackBuffer();\n  }\n  _presentBackBuffer() {\n    const renderer = this._renderer;\n    renderer.renderTarget.finishRenderPass();\n    if (!this._useBackBufferThisRender)\n      return;\n    renderer.renderTarget.bind(this._targetTexture, false);\n    this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n    renderer.encoder.draw({\n      geometry: bigTriangleGeometry,\n      shader: this._bigTriangleShader,\n      state: this._state\n    });\n  }\n  _getBackBufferTexture(targetSourceTexture) {\n    this._backBufferTexture = this._backBufferTexture || new Texture/* Texture */.x({\n      source: new TextureSource/* TextureSource */.p({\n        width: targetSourceTexture.width,\n        height: targetSourceTexture.height,\n        resolution: targetSourceTexture._resolution,\n        antialias: this._antialias\n      })\n    });\n    this._backBufferTexture.source.resize(\n      targetSourceTexture.width,\n      targetSourceTexture.height,\n      targetSourceTexture._resolution\n    );\n    return this._backBufferTexture;\n  }\n  /** destroys the back buffer */\n  destroy() {\n    if (this._backBufferTexture) {\n      this._backBufferTexture.destroy();\n      this._backBufferTexture = null;\n    }\n  }\n};\n/** @ignore */\n_GlBackBufferSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "backBuffer",\n  priority: 1\n};\n/** default options for the back buffer system */\n_GlBackBufferSystem.defaultOptions = {\n  /** if true will use the back buffer where required */\n  useBackBuffer: false\n};\nlet GlBackBufferSystem = _GlBackBufferSystem;\n\n\n//# sourceMappingURL=GlBackBufferSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs\n\n\n"use strict";\nclass GlColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.gl.colorMask(\n      !!(colorMask & 8),\n      !!(colorMask & 4),\n      !!(colorMask & 2),\n      !!(colorMask & 1)\n    );\n  }\n}\n/** @ignore */\nGlColorMaskSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "colorMask"\n};\n\n\n//# sourceMappingURL=GlColorMaskSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs\n\n\n"use strict";\nclass GlEncoderSystem {\n  constructor(renderer) {\n    this.commandFinished = Promise.resolve();\n    this._renderer = renderer;\n  }\n  setGeometry(geometry, shader) {\n    this._renderer.geometry.bind(geometry, shader.glProgram);\n  }\n  finishRenderPass() {\n  }\n  draw(options) {\n    const renderer = this._renderer;\n    const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;\n    renderer.shader.bind(shader, skipSync);\n    renderer.geometry.bind(geometry, renderer.shader._activeProgram);\n    if (state) {\n      renderer.state.set(state);\n    }\n    renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlEncoderSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "encoder"\n};\n\n\n//# sourceMappingURL=GlEncoderSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs\nvar GpuStencilModesToPixi = __webpack_require__(647);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs\nvar state_const = __webpack_require__(2475);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs\n\n\n\n\n"use strict";\nclass GlStencilSystem {\n  constructor(renderer) {\n    this._stencilCache = {\n      enabled: false,\n      stencilReference: 0,\n      stencilMode: state_const/* STENCIL_MODES */.D.NONE\n    };\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    this._comparisonFuncMapping = {\n      always: gl.ALWAYS,\n      never: gl.NEVER,\n      equal: gl.EQUAL,\n      "not-equal": gl.NOTEQUAL,\n      less: gl.LESS,\n      "less-equal": gl.LEQUAL,\n      greater: gl.GREATER,\n      "greater-equal": gl.GEQUAL\n    };\n    this._stencilOpsMapping = {\n      keep: gl.KEEP,\n      zero: gl.ZERO,\n      replace: gl.REPLACE,\n      invert: gl.INVERT,\n      "increment-clamp": gl.INCR,\n      "decrement-clamp": gl.DECR,\n      "increment-wrap": gl.INCR_WRAP,\n      "decrement-wrap": gl.DECR_WRAP\n    };\n    this._stencilCache.enabled = false;\n    this._stencilCache.stencilMode = state_const/* STENCIL_MODES */.D.NONE;\n    this._stencilCache.stencilReference = 0;\n  }\n  onRenderTargetChange(renderTarget) {\n    if (this._activeRenderTarget === renderTarget)\n      return;\n    this._activeRenderTarget = renderTarget;\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: state_const/* STENCIL_MODES */.D.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    const gl = this._gl;\n    const mode = GpuStencilModesToPixi/* GpuStencilModesToPixi */.L[stencilMode];\n    const _stencilCache = this._stencilCache;\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    if (stencilMode === state_const/* STENCIL_MODES */.D.DISABLED) {\n      if (this._stencilCache.enabled) {\n        this._stencilCache.enabled = false;\n        gl.disable(gl.STENCIL_TEST);\n      }\n      return;\n    }\n    if (!this._stencilCache.enabled) {\n      this._stencilCache.enabled = true;\n      gl.enable(gl.STENCIL_TEST);\n    }\n    if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {\n      _stencilCache.stencilMode = stencilMode;\n      _stencilCache.stencilReference = stencilReference;\n      gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);\n      gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);\n    }\n  }\n}\n/** @ignore */\nGlStencilSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "stencil"\n};\n\n\n//# sourceMappingURL=GlStencilSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs\nvar UboSystem = __webpack_require__(8809);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs\n\nconst WGSL_TO_STD40_SIZE = {\n  f32: 4,\n  "vec2<f32>": 8,\n  "vec3<f32>": 12,\n  "vec4<f32>": 16,\n  "mat2x2<f32>": 16 * 2,\n  "mat3x3<f32>": 16 * 3,\n  "mat4x4<f32>": 16 * 4\n  // TODO - not essential for now but support these in the future\n  // int:      4,\n  // ivec2:    8,\n  // ivec3:    12,\n  // ivec4:    16,\n  // uint:     4,\n  // uvec2:    8,\n  // uvec3:    12,\n  // uvec4:    16,\n  // bool:     4,\n  // bvec2:    8,\n  // bvec3:    12,\n  // bvec4:    16,\n  // mat2:     16 * 2,\n  // mat3:     16 * 3,\n  // mat4:     16 * 4,\n};\nfunction createUboElementsSTD40(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let size = 0;\n  let chunkSize = 0;\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n    if (!size) {\n      throw new Error(`Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, 16) * uboElement.data.size;\n    }\n    uboElement.size = size;\n    if (chunkSize % size !== 0 && chunkSize < 16) {\n      const lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue;\n      offset += lineUpValue;\n    }\n    if (chunkSize + size > 16) {\n      offset = Math.ceil(offset / 16) * 16;\n      uboElement.offset = offset;\n      offset += size;\n      chunkSize = size;\n    } else {\n      uboElement.offset = offset;\n      chunkSize += size;\n      offset += size;\n    }\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\n\n//# sourceMappingURL=createUboElementsSTD40.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs\nvar createUboSyncFunction = __webpack_require__(9758);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs\nvar uboSyncFunctions = __webpack_require__(5746);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs\n\n\n"use strict";\nfunction generateArraySyncSTD40(uboElement, offsetToAdd) {\n  const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n  const elementSize = uboElement.data.value.length / uboElement.data.size;\n  const remainder = (4 - elementSize % 4) % 4;\n  return `\n        v = uv.${uboElement.data.name};\n        offset += ${offsetToAdd};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n        {\n            for(var j = 0; j < ${elementSize}; j++)\n            {\n                data[arrayOffset++] = v[t++];\n            }\n            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}\n        }\n    `;\n}\n\n\n//# sourceMappingURL=generateArraySyncSTD40.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs\n\n\n\n\n"use strict";\nfunction createUboSyncFunctionSTD40(uboElements) {\n  return (0,createUboSyncFunction/* createUboSyncFunction */.S)(\n    uboElements,\n    "uboStd40",\n    generateArraySyncSTD40,\n    uboSyncFunctions/* uboSyncFunctionsSTD40 */.d\n  );\n}\n\n\n//# sourceMappingURL=createUboSyncSTD40.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs\n\n\n\n\n\n"use strict";\nclass GlUboSystem extends UboSystem/* UboSystem */.L {\n  constructor() {\n    super({\n      createUboElements: createUboElementsSTD40,\n      generateUboSync: createUboSyncFunctionSTD40\n    });\n  }\n}\n/** @ignore */\nGlUboSystem.extension = {\n  type: [Extensions/* ExtensionType */.nw.WebGLSystem],\n  name: "ubo"\n};\n\n\n//# sourceMappingURL=GlUboSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs + 2 modules\nvar RenderTargetSystem = __webpack_require__(2028);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs\nvar gl_const = __webpack_require__(6582);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs\n\nclass GlRenderTarget {\n  constructor() {\n    this.width = -1;\n    this.height = -1;\n    this.msaa = false;\n    this.msaaRenderBuffer = [];\n  }\n}\n\n\n//# sourceMappingURL=GlRenderTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs\n\n\n\n\n\n"use strict";\nclass GlRenderTargetAdaptor {\n  constructor() {\n    this._clearColorCache = [0, 0, 0, 0];\n    this._viewPortCache = new Rectangle/* Rectangle */.A();\n  }\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n    renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._clearColorCache = [0, 0, 0, 0];\n    this._viewPortCache = new Rectangle/* Rectangle */.A();\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const renderer = this._renderer;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n    const gl = renderer.gl;\n    this.finishRenderPass(sourceRenderSurfaceTexture);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n    renderer.texture.bind(destinationTexture, 0);\n    gl.copyTexSubImage2D(\n      gl.TEXTURE_2D,\n      0,\n      originDest.x,\n      originDest.y,\n      originSrc.x,\n      originSrc.y,\n      size.width,\n      size.height\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const source = renderTarget.colorTexture;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    let viewPortY = viewport.y;\n    if (renderTarget.isRoot) {\n      viewPortY = source.pixelHeight - viewport.height;\n    }\n    renderTarget.colorTextures.forEach((texture) => {\n      this._renderer.texture.unbind(texture);\n    });\n    const gl = this._renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n    const viewPortCache = this._viewPortCache;\n    if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {\n      viewPortCache.x = viewport.x;\n      viewPortCache.y = viewPortY;\n      viewPortCache.width = viewport.width;\n      viewPortCache.height = viewport.height;\n      gl.viewport(\n        viewport.x,\n        viewPortY,\n        viewport.width,\n        viewport.height\n      );\n    }\n    if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {\n      this._initStencil(gpuRenderTarget);\n    }\n    this.clear(renderTarget, clear, clearColor);\n  }\n  finishRenderPass(renderTarget) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (!glRenderTarget.msaa)\n      return;\n    const gl = this._renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n    gl.blitFramebuffer(\n      0,\n      0,\n      glRenderTarget.width,\n      glRenderTarget.height,\n      0,\n      0,\n      glRenderTarget.width,\n      glRenderTarget.height,\n      gl.COLOR_BUFFER_BIT,\n      gl.NEAREST\n    );\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n  }\n  initGpuRenderTarget(renderTarget) {\n    const renderer = this._renderer;\n    const gl = renderer.gl;\n    const glRenderTarget = new GlRenderTarget();\n    if (renderTarget.colorTexture.resource === renderer.gl.canvas) {\n      glRenderTarget.framebuffer = null;\n      return glRenderTarget;\n    }\n    this._initColor(renderTarget, glRenderTarget);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return glRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    const gl = this._renderer.gl;\n    if (gpuRenderTarget.framebuffer) {\n      gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n      gpuRenderTarget.framebuffer = null;\n    }\n    if (gpuRenderTarget.resolveTargetFramebuffer) {\n      gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n      gpuRenderTarget.resolveTargetFramebuffer = null;\n    }\n    if (gpuRenderTarget.depthStencilRenderBuffer) {\n      gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n      gpuRenderTarget.depthStencilRenderBuffer = null;\n    }\n    gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {\n      gl.deleteRenderbuffer(renderBuffer);\n    });\n    gpuRenderTarget.msaaRenderBuffer = null;\n  }\n  clear(_renderTarget, clear, clearColor) {\n    if (!clear)\n      return;\n    const renderTargetSystem = this._renderTargetSystem;\n    if (typeof clear === "boolean") {\n      clear = clear ? gl_const/* CLEAR */.E.ALL : gl_const/* CLEAR */.E.NONE;\n    }\n    const gl = this._renderer.gl;\n    if (clear & gl_const/* CLEAR */.E.COLOR) {\n      clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);\n      const clearColorCache = this._clearColorCache;\n      const clearColorArray = clearColor;\n      if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {\n        clearColorCache[0] = clearColorArray[0];\n        clearColorCache[1] = clearColorArray[1];\n        clearColorCache[2] = clearColorArray[2];\n        clearColorCache[3] = clearColorArray[3];\n        gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n      }\n    }\n    gl.clear(clear);\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    if (renderTarget.isRoot)\n      return;\n    const renderTargetSystem = this._renderTargetSystem;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    this._resizeColor(renderTarget, glRenderTarget);\n    if (renderTarget.stencil || renderTarget.depth) {\n      this._resizeStencil(glRenderTarget);\n    }\n  }\n  _initColor(renderTarget, glRenderTarget) {\n    const renderer = this._renderer;\n    const gl = renderer.gl;\n    const resolveTargetFramebuffer = gl.createFramebuffer();\n    glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n    glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n    glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      const source = colorTexture.source;\n      if (source.antialias) {\n        if (renderer.context.supports.msaa) {\n          glRenderTarget.msaa = true;\n        } else {\n          (0,warn/* warn */.Z)("[RenderTexture] Antialiasing on textures is not supported in WebGL1");\n        }\n      }\n      renderer.texture.bindSource(source, 0);\n      const glSource = renderer.texture.getGlSource(source);\n      const glTexture = glSource.texture;\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0 + i,\n        3553,\n        // texture.target,\n        glTexture,\n        0\n      );\n    });\n    if (glRenderTarget.msaa) {\n      const viewFramebuffer = gl.createFramebuffer();\n      glRenderTarget.framebuffer = viewFramebuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n      renderTarget.colorTextures.forEach((_, i) => {\n        const msaaRenderBuffer = gl.createRenderbuffer();\n        glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n      });\n    } else {\n      glRenderTarget.framebuffer = resolveTargetFramebuffer;\n    }\n    this._resizeColor(renderTarget, glRenderTarget);\n  }\n  _resizeColor(renderTarget, glRenderTarget) {\n    const source = renderTarget.colorTexture.source;\n    glRenderTarget.width = source.pixelWidth;\n    glRenderTarget.height = source.pixelHeight;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (i === 0)\n        return;\n      colorTexture.source.resize(source.width, source.height, source._resolution);\n    });\n    if (glRenderTarget.msaa) {\n      const renderer = this._renderer;\n      const gl = renderer.gl;\n      const viewFramebuffer = glRenderTarget.framebuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const source2 = colorTexture.source;\n        renderer.texture.bindSource(source2, 0);\n        const glSource = renderer.texture.getGlSource(source2);\n        const glInternalFormat = glSource.internalFormat;\n        const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n        gl.bindRenderbuffer(\n          gl.RENDERBUFFER,\n          msaaRenderBuffer\n        );\n        gl.renderbufferStorageMultisample(\n          gl.RENDERBUFFER,\n          4,\n          glInternalFormat,\n          source2.pixelWidth,\n          source2.pixelHeight\n        );\n        gl.framebufferRenderbuffer(\n          gl.FRAMEBUFFER,\n          gl.COLOR_ATTACHMENT0 + i,\n          gl.RENDERBUFFER,\n          msaaRenderBuffer\n        );\n      });\n    }\n  }\n  _initStencil(glRenderTarget) {\n    if (glRenderTarget.framebuffer === null)\n      return;\n    const gl = this._renderer.gl;\n    const depthStencilRenderBuffer = gl.createRenderbuffer();\n    glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n    gl.bindRenderbuffer(\n      gl.RENDERBUFFER,\n      depthStencilRenderBuffer\n    );\n    gl.framebufferRenderbuffer(\n      gl.FRAMEBUFFER,\n      gl.DEPTH_STENCIL_ATTACHMENT,\n      gl.RENDERBUFFER,\n      depthStencilRenderBuffer\n    );\n    this._resizeStencil(glRenderTarget);\n  }\n  _resizeStencil(glRenderTarget) {\n    const gl = this._renderer.gl;\n    gl.bindRenderbuffer(\n      gl.RENDERBUFFER,\n      glRenderTarget.depthStencilRenderBuffer\n    );\n    if (glRenderTarget.msaa) {\n      gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        4,\n        gl.DEPTH24_STENCIL8,\n        glRenderTarget.width,\n        glRenderTarget.height\n      );\n    } else {\n      gl.renderbufferStorage(\n        gl.RENDERBUFFER,\n        this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,\n        glRenderTarget.width,\n        glRenderTarget.height\n      );\n    }\n  }\n}\n\n\n//# sourceMappingURL=GlRenderTargetAdaptor.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs\n\n\n\n\n"use strict";\nclass GlRenderTargetSystem extends RenderTargetSystem/* RenderTargetSystem */.l {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GlRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGlRenderTargetSystem.extension = {\n  type: [Extensions/* ExtensionType */.nw.WebGLSystem],\n  name: "renderTarget"\n};\n\n\n//# sourceMappingURL=GlRenderTargetSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs\nvar BufferResource = __webpack_require__(6496);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs\n\n\n\n\n"use strict";\nfunction generateShaderSyncCode(shader, shaderSystem) {\n  const funcFragments = [];\n  const headerFragments = [`\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `];\n  let addedTextreSystem = false;\n  let blockIndex = 0;\n  let textureCount = 0;\n  const programData = shaderSystem._getProgramData(shader.glProgram);\n  for (const i in shader.groups) {\n    const group = shader.groups[i];\n    funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n    for (const j in group.resources) {\n      const resource = group.resources[j];\n      if (resource instanceof UniformGroup/* UniformGroup */.o) {\n        if (resource.ubo) {\n          funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            sS._uniformBindMap[${i}[${j}],\n                            ${blockIndex++}\n                        );\n                    `);\n        } else {\n          funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n        }\n      } else if (resource instanceof BufferResource/* BufferResource */.q) {\n        funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        sS._uniformBindMap[${i}[${j}],\n                        ${blockIndex++}\n                    );\n                `);\n      } else if (resource instanceof TextureSource/* TextureSource */.p) {\n        const uniformName = shader._uniformBindMap[i][j];\n        const uniformData = programData.uniformData[uniformName];\n        if (uniformData) {\n          if (!addedTextreSystem) {\n            addedTextreSystem = true;\n            headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n          }\n          shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n          funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n          textureCount++;\n        }\n      }\n    }\n  }\n  const functionSource = [...headerFragments, ...funcFragments].join("\\n");\n  return new Function("r", "s", "sD", functionSource);\n}\n\n\n//# sourceMappingURL=GenerateShaderSyncCode.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs\n\nclass IGLUniformData {\n}\nclass GlProgramData {\n  /**\n   * Makes a new Pixi program.\n   * @param program - webgl program\n   * @param uniformData - uniforms\n   */\n  constructor(program, uniformData) {\n    this.program = program;\n    this.uniformData = uniformData;\n    this.uniformGroups = {};\n    this.uniformDirtyGroups = {};\n    this.uniformBlockBindings = {};\n  }\n  /** Destroys this program. */\n  destroy() {\n    this.uniformData = null;\n    this.uniformGroups = null;\n    this.uniformDirtyGroups = null;\n    this.uniformBlockBindings = null;\n    this.program = null;\n  }\n}\n\n\n//# sourceMappingURL=GlProgramData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs\n\nfunction compileShader(gl, type, src) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, src);\n  gl.compileShader(shader);\n  return shader;\n}\n\n\n//# sourceMappingURL=compileShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs\n\nfunction booleanArray(size) {\n  const array = new Array(size);\n  for (let i = 0; i < array.length; i++) {\n    array[i] = false;\n  }\n  return array;\n}\nfunction defaultValue(type, size) {\n  switch (type) {\n    case "float":\n      return 0;\n    case "vec2":\n      return new Float32Array(2 * size);\n    case "vec3":\n      return new Float32Array(3 * size);\n    case "vec4":\n      return new Float32Array(4 * size);\n    case "int":\n    case "uint":\n    case "sampler2D":\n    case "sampler2DArray":\n      return 0;\n    case "ivec2":\n      return new Int32Array(2 * size);\n    case "ivec3":\n      return new Int32Array(3 * size);\n    case "ivec4":\n      return new Int32Array(4 * size);\n    case "uvec2":\n      return new Uint32Array(2 * size);\n    case "uvec3":\n      return new Uint32Array(3 * size);\n    case "uvec4":\n      return new Uint32Array(4 * size);\n    case "bool":\n      return false;\n    case "bvec2":\n      return booleanArray(2 * size);\n    case "bvec3":\n      return booleanArray(3 * size);\n    case "bvec4":\n      return booleanArray(4 * size);\n    case "mat2":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case "mat3":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case "mat4":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\n\n//# sourceMappingURL=defaultValue.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs\n\nlet GL_TABLE = null;\nconst GL_TO_GLSL_TYPES = {\n  FLOAT: "float",\n  FLOAT_VEC2: "vec2",\n  FLOAT_VEC3: "vec3",\n  FLOAT_VEC4: "vec4",\n  INT: "int",\n  INT_VEC2: "ivec2",\n  INT_VEC3: "ivec3",\n  INT_VEC4: "ivec4",\n  UNSIGNED_INT: "uint",\n  UNSIGNED_INT_VEC2: "uvec2",\n  UNSIGNED_INT_VEC3: "uvec3",\n  UNSIGNED_INT_VEC4: "uvec4",\n  BOOL: "bool",\n  BOOL_VEC2: "bvec2",\n  BOOL_VEC3: "bvec3",\n  BOOL_VEC4: "bvec4",\n  FLOAT_MAT2: "mat2",\n  FLOAT_MAT3: "mat3",\n  FLOAT_MAT4: "mat4",\n  SAMPLER_2D: "sampler2D",\n  INT_SAMPLER_2D: "sampler2D",\n  UNSIGNED_INT_SAMPLER_2D: "sampler2D",\n  SAMPLER_CUBE: "samplerCube",\n  INT_SAMPLER_CUBE: "samplerCube",\n  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",\n  SAMPLER_2D_ARRAY: "sampler2DArray",\n  INT_SAMPLER_2D_ARRAY: "sampler2DArray",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"\n};\nconst GLSL_TO_VERTEX_TYPES = {\n  float: "float32",\n  vec2: "float32x2",\n  vec3: "float32x3",\n  vec4: "float32x4",\n  int: "sint32",\n  ivec2: "sint32x2",\n  ivec3: "sint32x3",\n  ivec4: "sint32x4",\n  uint: "uint32",\n  uvec2: "uint32x2",\n  uvec3: "uint32x3",\n  uvec4: "uint32x4",\n  bool: "uint32",\n  bvec2: "uint32x2",\n  bvec3: "uint32x3",\n  bvec4: "uint32x4"\n};\nfunction mapType(gl, type) {\n  if (!GL_TABLE) {\n    const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (let i = 0; i < typeNames.length; ++i) {\n      const tn = typeNames[i];\n      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n    }\n  }\n  return GL_TABLE[type];\n}\nfunction mapGlToVertexFormat(gl, type) {\n  const typeValue = mapType(gl, type);\n  return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";\n}\n\n\n//# sourceMappingURL=mapType.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs\n\n\n\n"use strict";\nfunction extractAttributesFromGlProgram(program, gl, sortAttributes = false) {\n  const attributes = {};\n  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let i = 0; i < totalAttributes; i++) {\n    const attribData = gl.getActiveAttrib(program, i);\n    if (attribData.name.startsWith("gl_")) {\n      continue;\n    }\n    const format = mapGlToVertexFormat(gl, attribData.type);\n    attributes[attribData.name] = {\n      location: 0,\n      // set further down..\n      format,\n      stride: (0,getAttributeInfoFromFormat/* getAttributeInfoFromFormat */.v)(format).stride,\n      offset: 0,\n      instance: false,\n      start: 0\n    };\n  }\n  const keys = Object.keys(attributes);\n  if (sortAttributes) {\n    keys.sort((a, b) => a > b ? 1 : -1);\n    for (let i = 0; i < keys.length; i++) {\n      attributes[keys[i]].location = i;\n      gl.bindAttribLocation(program, i, keys[i]);\n    }\n    gl.linkProgram(program);\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);\n    }\n  }\n  return attributes;\n}\n\n\n//# sourceMappingURL=extractAttributesFromGlProgram.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs\n\nfunction getUboData(program, gl) {\n  if (!gl.ACTIVE_UNIFORM_BLOCKS)\n    return {};\n  const uniformBlocks = {};\n  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n  for (let i = 0; i < totalUniformsBlocks; i++) {\n    const name = gl.getActiveUniformBlockName(program, i);\n    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);\n    const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);\n    uniformBlocks[name] = {\n      name,\n      index: uniformBlockIndex,\n      size\n    };\n  }\n  return uniformBlocks;\n}\n\n\n//# sourceMappingURL=getUboData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs\n\n\n\n"use strict";\nfunction getUniformData(program, gl) {\n  const uniforms = {};\n  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  for (let i = 0; i < totalUniforms; i++) {\n    const uniformData = gl.getActiveUniform(program, i);\n    const name = uniformData.name.replace(/\\[.*?\\]$/, "");\n    const isArray = !!uniformData.name.match(/\\[.*?\\]$/);\n    const type = mapType(gl, uniformData.type);\n    uniforms[name] = {\n      name,\n      index: i,\n      type,\n      size: uniformData.size,\n      isArray,\n      value: defaultValue(type, uniformData.size)\n    };\n  }\n  return uniforms;\n}\n\n\n//# sourceMappingURL=getUniformData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs\n\nfunction logPrettyShaderError(gl, shader) {\n  const shaderSrc = gl.getShaderSource(shader).split("\\n").map((line, index) => `${index}: ${line}`);\n  const shaderLog = gl.getShaderInfoLog(shader);\n  const splitShader = shaderLog.split("\\n");\n  const dedupe = {};\n  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, "$1"))).filter((n) => {\n    if (n && !dedupe[n]) {\n      dedupe[n] = true;\n      return true;\n    }\n    return false;\n  });\n  const logArgs = [""];\n  lineNumbers.forEach((number) => {\n    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");\n  });\n  const fragmentSourceToLog = shaderSrc.join("\\n");\n  logArgs[0] = fragmentSourceToLog;\n  console.error(shaderLog);\n  console.groupCollapsed("click to view full shader code");\n  console.warn(...logArgs);\n  console.groupEnd();\n}\nfunction logProgramError(gl, program, vertexShader, fragmentShader) {\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, vertexShader);\n    }\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, fragmentShader);\n    }\n    console.error("PixiJS Error: Could not initialize shader.");\n    if (gl.getProgramInfoLog(program) !== "") {\n      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));\n    }\n  }\n}\n\n\n//# sourceMappingURL=logProgramError.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nfunction generateProgram(gl, program) {\n  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);\n  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);\n  const webGLProgram = gl.createProgram();\n  gl.attachShader(webGLProgram, glVertShader);\n  gl.attachShader(webGLProgram, glFragShader);\n  const transformFeedbackVaryings = program.transformFeedbackVaryings;\n  if (transformFeedbackVaryings) {\n    if (typeof gl.transformFeedbackVaryings !== "function") {\n      (0,warn/* warn */.Z)(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n    } else {\n      gl.transformFeedbackVaryings(\n        webGLProgram,\n        transformFeedbackVaryings.names,\n        transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS\n      );\n    }\n  }\n  gl.linkProgram(webGLProgram);\n  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {\n    logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n  }\n  program._attributeData = extractAttributesFromGlProgram(\n    webGLProgram,\n    gl,\n    !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(program.vertex)\n  );\n  program._uniformData = getUniformData(webGLProgram, gl);\n  program._uniformBlockData = getUboData(webGLProgram, gl);\n  gl.deleteShader(glVertShader);\n  gl.deleteShader(glFragShader);\n  const uniformData = {};\n  for (const i in program._uniformData) {\n    const data = program._uniformData[i];\n    uniformData[i] = {\n      location: gl.getUniformLocation(webGLProgram, i),\n      value: defaultValue(data.type, data.size)\n    };\n  }\n  const glProgram = new GlProgramData(webGLProgram, uniformData);\n  return glProgram;\n}\n\n\n//# sourceMappingURL=generateProgram.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs\n\n\n\n\n"use strict";\nconst defaultSyncData = {\n  textureCount: 0,\n  blockIndex: 0\n};\nclass GlShaderSystem {\n  constructor(renderer) {\n    /**\n     * @internal\n     * @private\n     */\n    this._activeProgram = null;\n    this._programDataHash = /* @__PURE__ */ Object.create(null);\n    this._nextIndex = 0;\n    this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);\n    this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);\n    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;\n    this._programDataHash = /* @__PURE__ */ Object.create(null);\n    this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);\n    this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);\n    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);\n    this._activeProgram = null;\n  }\n  /**\n   * Changes the current shader to the one given in parameter.\n   * @param shader - the new shader\n   * @param skipSync - false if the shader should automatically sync its uniforms.\n   * @returns the glProgram that belongs to the shader.\n   */\n  bind(shader, skipSync) {\n    this._setProgram(shader.glProgram);\n    if (skipSync)\n      return;\n    defaultSyncData.textureCount = 0;\n    defaultSyncData.blockIndex = 0;\n    let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n    if (!syncFunction) {\n      syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n    }\n    syncFunction(this._renderer, shader, defaultSyncData);\n  }\n  /**\n   * Updates the uniform group.\n   * @param uniformGroup - the uniform group to update\n   */\n  updateUniformGroup(uniformGroup) {\n    this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n  }\n  /**\n   * Binds a uniform block to the shader.\n   * @param uniformGroup - the uniform group to bind\n   * @param name - the name of the uniform block\n   * @param index - the index of the uniform block\n   */\n  bindUniformBlock(uniformGroup, name, index = 0) {\n    const bufferSystem = this._renderer.buffer;\n    const programData = this._getProgramData(this._activeProgram);\n    const isBufferResource = uniformGroup._bufferResource;\n    if (isBufferResource) {\n      this._renderer.ubo.updateUniformGroup(uniformGroup);\n    }\n    bufferSystem.updateBuffer(uniformGroup.buffer);\n    let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];\n    if (boundIndex === void 0) {\n      const nextIndex = this._nextIndex++ % this._maxBindings;\n      const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];\n      if (currentBoundUniformGroup) {\n        this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;\n      }\n      boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;\n      this._boundIndexToUniformsHash[nextIndex] = uniformGroup;\n      if (isBufferResource) {\n        bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);\n      } else {\n        bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);\n      }\n    }\n    const gl = this._gl;\n    const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n    if (programData.uniformBlockBindings[index] === boundIndex)\n      return;\n    programData.uniformBlockBindings[index] = boundIndex;\n    gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);\n  }\n  _setProgram(program) {\n    if (this._activeProgram === program)\n      return;\n    this._activeProgram = program;\n    const programData = this._getProgramData(program);\n    this._gl.useProgram(programData.program);\n  }\n  /**\n   * @param program - the program to get the data for\n   * @internal\n   * @private\n   */\n  _getProgramData(program) {\n    return this._programDataHash[program._key] || this._createProgramData(program);\n  }\n  _createProgramData(program) {\n    const key = program._key;\n    this._programDataHash[key] = generateProgram(this._gl, program);\n    return this._programDataHash[key];\n  }\n  destroy() {\n    for (const key of Object.keys(this._programDataHash)) {\n      const programData = this._programDataHash[key];\n      programData.destroy();\n      this._programDataHash[key] = null;\n    }\n    this._programDataHash = null;\n    this._boundUniformsIdsToIndexHash = null;\n  }\n  /**\n   * Creates a function that can be executed that will sync the shader as efficiently as possible.\n   * Overridden by the unsafe eval package if you don\'t want eval used in your project.\n   * @param shader - the shader to generate the sync function for\n   * @param shaderSystem - the shader system to use\n   * @returns - the generated sync function\n   * @ignore\n   */\n  _generateShaderSync(shader, shaderSystem) {\n    return generateShaderSyncCode(shader, shaderSystem);\n  }\n}\n/** @ignore */\nGlShaderSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "shader"\n};\n\n\n//# sourceMappingURL=GlShaderSystem.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs\nvar uniformParsers = __webpack_require__(6602);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs\n\nconst UNIFORM_TO_SINGLE_SETTERS = {\n  f32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }`,\n  "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }`,\n  "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }`,\n  "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }`,\n  i32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n  "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n  "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n  "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n  u32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }`,\n  "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }`,\n  "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }`,\n  "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }`,\n  bool: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n  "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n  "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n  "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n  "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,\n  "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,\n  "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`\n};\nconst UNIFORM_TO_ARRAY_SETTERS = {\n  f32: `gl.uniform1fv(location, v);`,\n  "vec2<f32>": `gl.uniform2fv(location, v);`,\n  "vec3<f32>": `gl.uniform3fv(location, v);`,\n  "vec4<f32>": `gl.uniform4fv(location, v);`,\n  "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,\n  "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,\n  "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,\n  i32: `gl.uniform1iv(location, v);`,\n  "vec2<i32>": `gl.uniform2iv(location, v);`,\n  "vec3<i32>": `gl.uniform3iv(location, v);`,\n  "vec4<i32>": `gl.uniform4iv(location, v);`,\n  u32: `gl.uniform1iv(location, v);`,\n  "vec2<u32>": `gl.uniform2iv(location, v);`,\n  "vec3<u32>": `gl.uniform3iv(location, v);`,\n  "vec4<u32>": `gl.uniform4iv(location, v);`,\n  bool: `gl.uniform1iv(location, v);`,\n  "vec2<bool>": `gl.uniform2iv(location, v);`,\n  "vec3<bool>": `gl.uniform3iv(location, v);`,\n  "vec4<bool>": `gl.uniform4iv(location, v);`\n};\n\n\n//# sourceMappingURL=generateUniformsSyncTypes.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs\n\n\n\n\n\n"use strict";\nfunction generateUniformsSync(group, uniformData) {\n  const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n  for (const i in group.uniforms) {\n    if (!uniformData[i]) {\n      if (group.uniforms[i] instanceof UniformGroup/* UniformGroup */.o) {\n        if (group.uniforms[i].ubo) {\n          funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, "${i}");\n                    `);\n        } else {\n          funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n        }\n      } else if (group.uniforms[i] instanceof BufferResource/* BufferResource */.q) {\n        funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, "${i}");\n                    `);\n      }\n      continue;\n    }\n    const uniform = group.uniformStructures[i];\n    let parsed = false;\n    for (let j = 0; j < uniformParsers/* uniformParsers */.s.length; j++) {\n      const parser = uniformParsers/* uniformParsers */.s[j];\n      if (uniform.type === parser.type && parser.test(uniform)) {\n        funcFragments.push(`name = "${i}";`, uniformParsers/* uniformParsers */.s[j].uniform);\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n      const template = templateType[uniform.type].replace("location", `ud["${i}"].location`);\n      funcFragments.push(`\n            cu = ud["${i}"];\n            cv = cu.value;\n            v = uv["${i}"];\n            ${template};`);\n    }\n  }\n  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\\n"));\n}\n\n\n//# sourceMappingURL=generateUniformsSync.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs\n\n\n\n"use strict";\nclass GlUniformGroupSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */\n    this._cache = {};\n    this._uniformGroupSyncHash = {};\n    this._renderer = renderer;\n    this.gl = null;\n    this._cache = {};\n  }\n  contextChange(gl) {\n    this.gl = gl;\n  }\n  /**\n   * Uploads the uniforms values to the currently bound shader.\n   * @param group - the uniforms values that be applied to the current shader\n   * @param program\n   * @param syncData\n   * @param syncData.textureCount\n   */\n  updateUniformGroup(group, program, syncData) {\n    const programData = this._renderer.shader._getProgramData(program);\n    if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {\n      programData.uniformDirtyGroups[group.uid] = group._dirtyId;\n      const syncFunc = this._getUniformSyncFunction(group, program);\n      syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);\n    }\n  }\n  /**\n   * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n   * @param group\n   * @param program\n   */\n  _getUniformSyncFunction(group, program) {\n    return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);\n  }\n  _createUniformSyncFunction(group, program) {\n    const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});\n    const id = this._getSignature(group, program._uniformData, "u");\n    if (!this._cache[id]) {\n      this._cache[id] = this._generateUniformsSync(group, program._uniformData);\n    }\n    uniformGroupSyncHash[program._key] = this._cache[id];\n    return uniformGroupSyncHash[program._key];\n  }\n  _generateUniformsSync(group, uniformData) {\n    return generateUniformsSync(group, uniformData);\n  }\n  /**\n   * Takes a uniform group and data and generates a unique signature for them.\n   * @param group - The uniform group to get signature of\n   * @param group.uniforms\n   * @param uniformData - Uniform information generated by the shader\n   * @param preFix\n   * @returns Unique signature of the uniform group\n   */\n  _getSignature(group, uniformData, preFix) {\n    const uniforms = group.uniforms;\n    const strings = [`${preFix}-`];\n    for (const i in uniforms) {\n      strings.push(i);\n      if (uniformData[i]) {\n        strings.push(uniformData[i].type);\n      }\n    }\n    return strings.join("-");\n  }\n  /** Destroys this System and removes all its textures. */\n  destroy() {\n    this._renderer = null;\n    this._cache = null;\n  }\n}\n/** @ignore */\nGlUniformGroupSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "uniformGroup"\n};\n\n\n//# sourceMappingURL=GlUniformGroupSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs\n\nfunction mapWebGLBlendModesToPixi(gl) {\n  const blendMap = {};\n  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.add = [gl.ONE, gl.ONE];\n  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.none = [0, 0];\n  blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n  blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n  return blendMap;\n}\n\n\n//# sourceMappingURL=mapWebGLBlendModesToPixi.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs\n\n\n\n\n"use strict";\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _GlStateSystem = class _GlStateSystem {\n  constructor() {\n    this.gl = null;\n    this.stateId = 0;\n    this.polygonOffset = 0;\n    this.blendMode = "none";\n    this._blendEq = false;\n    this.map = [];\n    this.map[BLEND] = this.setBlend;\n    this.map[OFFSET] = this.setOffset;\n    this.map[CULLING] = this.setCullFace;\n    this.map[DEPTH_TEST] = this.setDepthTest;\n    this.map[WINDING] = this.setFrontFace;\n    this.map[DEPTH_MASK] = this.setDepthMask;\n    this.checks = [];\n    this.defaultState = State/* State */.Z.for2d();\n  }\n  contextChange(gl) {\n    this.gl = gl;\n    this.blendModesMap = mapWebGLBlendModesToPixi(gl);\n    this.reset();\n  }\n  /**\n   * Sets the current state\n   * @param {*} state - The state to set.\n   */\n  set(state) {\n    state = state || this.defaultState;\n    if (this.stateId !== state.data) {\n      let diff = this.stateId ^ state.data;\n      let i = 0;\n      while (diff) {\n        if (diff & 1) {\n          this.map[i].call(this, !!(state.data & 1 << i));\n        }\n        diff = diff >> 1;\n        i++;\n      }\n      this.stateId = state.data;\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n  }\n  /**\n   * Sets the state, when previous state is unknown.\n   * @param {*} state - The state to set\n   */\n  forceState(state) {\n    state = state || this.defaultState;\n    for (let i = 0; i < this.map.length; i++) {\n      this.map[i].call(this, !!(state.data & 1 << i));\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n    this.stateId = state.data;\n  }\n  /**\n   * Sets whether to enable or disable blending.\n   * @param value - Turn on or off WebGl blending.\n   */\n  setBlend(value) {\n    this._updateCheck(_GlStateSystem._checkBlendMode, value);\n    this.gl[value ? "enable" : "disable"](this.gl.BLEND);\n  }\n  /**\n   * Sets whether to enable or disable polygon offset fill.\n   * @param value - Turn on or off webgl polygon offset testing.\n   */\n  setOffset(value) {\n    this._updateCheck(_GlStateSystem._checkPolygonOffset, value);\n    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);\n  }\n  /**\n   * Sets whether to enable or disable depth test.\n   * @param value - Turn on or off webgl depth testing.\n   */\n  setDepthTest(value) {\n    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);\n  }\n  /**\n   * Sets whether to enable or disable depth mask.\n   * @param value - Turn on or off webgl depth mask.\n   */\n  setDepthMask(value) {\n    this.gl.depthMask(value);\n  }\n  /**\n   * Sets whether to enable or disable cull face.\n   * @param {boolean} value - Turn on or off webgl cull face.\n   */\n  setCullFace(value) {\n    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);\n  }\n  /**\n   * Sets the gl front face.\n   * @param {boolean} value - true is clockwise and false is counter-clockwise\n   */\n  setFrontFace(value) {\n    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);\n  }\n  /**\n   * Sets the blend mode.\n   * @param {number} value - The blend mode to set to.\n   */\n  setBlendMode(value) {\n    if (!this.blendModesMap[value]) {\n      value = "normal";\n    }\n    if (value === this.blendMode) {\n      return;\n    }\n    this.blendMode = value;\n    const mode = this.blendModesMap[value];\n    const gl = this.gl;\n    if (mode.length === 2) {\n      gl.blendFunc(mode[0], mode[1]);\n    } else {\n      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n    }\n    if (mode.length === 6) {\n      this._blendEq = true;\n      gl.blendEquationSeparate(mode[4], mode[5]);\n    } else if (this._blendEq) {\n      this._blendEq = false;\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n    }\n  }\n  /**\n   * Sets the polygon offset.\n   * @param {number} value - the polygon offset\n   * @param {number} scale - the polygon offset scale\n   */\n  setPolygonOffset(value, scale) {\n    this.gl.polygonOffset(value, scale);\n  }\n  // used\n  /** Resets all the logic and disables the VAOs. */\n  reset() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n    this.forceState(this.defaultState);\n    this._blendEq = true;\n    this.blendMode = "";\n    this.setBlendMode("normal");\n  }\n  /**\n   * Checks to see which updates should be checked based on which settings have been activated.\n   *\n   * For example, if blend is enabled then we should check the blend modes each time the state is changed\n   * or if polygon fill is activated then we need to check if the polygon offset changes.\n   * The idea is that we only check what we have too.\n   * @param func - the checking function to add or remove\n   * @param value - should the check function be added or removed.\n   */\n  _updateCheck(func, value) {\n    const index = this.checks.indexOf(func);\n    if (value && index === -1) {\n      this.checks.push(func);\n    } else if (!value && index !== -1) {\n      this.checks.splice(index, 1);\n    }\n  }\n  /**\n   * A private little wrapper function that we call to check the blend mode.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */\n  static _checkBlendMode(system, state) {\n    system.setBlendMode(state.blendMode);\n  }\n  /**\n   * A private little wrapper function that we call to check the polygon offset.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */\n  static _checkPolygonOffset(system, state) {\n    system.setPolygonOffset(1, state.polygonOffset);\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this.gl = null;\n    this.checks.length = 0;\n  }\n};\n/** @ignore */\n_GlStateSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "state"\n};\nlet GlStateSystem = _GlStateSystem;\n\n\n//# sourceMappingURL=GlStateSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs\n\n\n"use strict";\nclass GlTexture {\n  constructor(texture) {\n    this.target = GL_TARGETS.TEXTURE_2D;\n    this.texture = texture;\n    this.width = -1;\n    this.height = -1;\n    this.type = GL_TYPES.UNSIGNED_BYTE;\n    this.internalFormat = GL_FORMATS.RGBA;\n    this.format = GL_FORMATS.RGBA;\n    this.samplerType = 0;\n  }\n}\n\n\n//# sourceMappingURL=GlTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs\n\nconst glUploadBufferImageResource = {\n  id: "buffer",\n  upload(source, glTexture, gl) {\n    if (glTexture.width === source.width || glTexture.height === source.height) {\n      gl.texSubImage2D(\n        gl.TEXTURE_2D,\n        0,\n        0,\n        0,\n        source.width,\n        source.height,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    } else {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        source.width,\n        source.height,\n        0,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    }\n    glTexture.width = source.width;\n    glTexture.height = source.height;\n  }\n};\n\n\n//# sourceMappingURL=glUploadBufferImageResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs\n\nconst compressedFormatMap = {\n  "bc1-rgba-unorm": true,\n  "bc1-rgba-unorm-srgb": true,\n  "bc2-rgba-unorm": true,\n  "bc2-rgba-unorm-srgb": true,\n  "bc3-rgba-unorm": true,\n  "bc3-rgba-unorm-srgb": true,\n  "bc4-r-unorm": true,\n  "bc4-r-snorm": true,\n  "bc5-rg-unorm": true,\n  "bc5-rg-snorm": true,\n  "bc6h-rgb-ufloat": true,\n  "bc6h-rgb-float": true,\n  "bc7-rgba-unorm": true,\n  "bc7-rgba-unorm-srgb": true,\n  // ETC2 compressed formats usable if "texture-compression-etc2" is both\n  // supported by the device/user agent and enabled in requestDevice.\n  "etc2-rgb8unorm": true,\n  "etc2-rgb8unorm-srgb": true,\n  "etc2-rgb8a1unorm": true,\n  "etc2-rgb8a1unorm-srgb": true,\n  "etc2-rgba8unorm": true,\n  "etc2-rgba8unorm-srgb": true,\n  "eac-r11unorm": true,\n  "eac-r11snorm": true,\n  "eac-rg11unorm": true,\n  "eac-rg11snorm": true,\n  // ASTC compressed formats usable if "texture-compression-astc" is both\n  // supported by the device/user agent and enabled in requestDevice.\n  "astc-4x4-unorm": true,\n  "astc-4x4-unorm-srgb": true,\n  "astc-5x4-unorm": true,\n  "astc-5x4-unorm-srgb": true,\n  "astc-5x5-unorm": true,\n  "astc-5x5-unorm-srgb": true,\n  "astc-6x5-unorm": true,\n  "astc-6x5-unorm-srgb": true,\n  "astc-6x6-unorm": true,\n  "astc-6x6-unorm-srgb": true,\n  "astc-8x5-unorm": true,\n  "astc-8x5-unorm-srgb": true,\n  "astc-8x6-unorm": true,\n  "astc-8x6-unorm-srgb": true,\n  "astc-8x8-unorm": true,\n  "astc-8x8-unorm-srgb": true,\n  "astc-10x5-unorm": true,\n  "astc-10x5-unorm-srgb": true,\n  "astc-10x6-unorm": true,\n  "astc-10x6-unorm-srgb": true,\n  "astc-10x8-unorm": true,\n  "astc-10x8-unorm-srgb": true,\n  "astc-10x10-unorm": true,\n  "astc-10x10-unorm-srgb": true,\n  "astc-12x10-unorm": true,\n  "astc-12x10-unorm-srgb": true,\n  "astc-12x12-unorm": true,\n  "astc-12x12-unorm-srgb": true\n};\nconst glUploadCompressedTextureResource = {\n  id: "compressed",\n  upload(source, glTexture, gl) {\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const compressed = !!compressedFormatMap[source.format];\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      if (compressed) {\n        gl.compressedTexImage2D(\n          gl.TEXTURE_2D,\n          i,\n          glTexture.internalFormat,\n          mipWidth,\n          mipHeight,\n          0,\n          levelBuffer\n        );\n      } else {\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          i,\n          glTexture.internalFormat,\n          mipWidth,\n          mipHeight,\n          0,\n          glTexture.format,\n          glTexture.type,\n          levelBuffer\n        );\n      }\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\n\n//# sourceMappingURL=glUploadCompressedTextureResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs\n\nconst glUploadImageResource = {\n  id: "image",\n  upload(source, glTexture, gl, webGLVersion) {\n    const premultipliedAlpha = source.alphaMode === "premultiply-alpha-on-upload";\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n    const glWidth = glTexture.width;\n    const glHeight = glTexture.height;\n    const textureWidth = source.pixelWidth;\n    const textureHeight = source.pixelHeight;\n    const resourceWidth = source.resourceWidth;\n    const resourceHeight = source.resourceHeight;\n    if (resourceWidth < textureWidth || resourceHeight < textureHeight) {\n      if (glWidth !== textureWidth || glHeight !== textureHeight) {\n        gl.texImage2D(\n          glTexture.target,\n          0,\n          glTexture.internalFormat,\n          textureWidth,\n          textureHeight,\n          0,\n          glTexture.format,\n          glTexture.type,\n          null\n        );\n      }\n      if (webGLVersion === 2) {\n        gl.texSubImage2D(\n          gl.TEXTURE_2D,\n          0,\n          0,\n          0,\n          resourceWidth,\n          resourceHeight,\n          glTexture.format,\n          glTexture.type,\n          source.resource\n        );\n      } else {\n        gl.texSubImage2D(\n          gl.TEXTURE_2D,\n          0,\n          0,\n          0,\n          glTexture.format,\n          glTexture.type,\n          source.resource\n        );\n      }\n    } else if (glWidth === textureWidth || glHeight === textureHeight) {\n      gl.texSubImage2D(\n        gl.TEXTURE_2D,\n        0,\n        0,\n        0,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    } else if (webGLVersion === 2) {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        textureWidth,\n        textureHeight,\n        0,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    } else {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    }\n    glTexture.width = textureWidth;\n    glTexture.height = textureHeight;\n  }\n};\n\n\n//# sourceMappingURL=glUploadImageResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs\n\n\n"use strict";\nconst glUploadVideoResource = {\n  id: "video",\n  upload(source, glTexture, gl, webGLVersion) {\n    if (!source.isValid) {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        1,\n        1,\n        0,\n        glTexture.format,\n        glTexture.type,\n        null\n      );\n      return;\n    }\n    glUploadImageResource.upload(source, glTexture, gl, webGLVersion);\n  }\n};\n\n\n//# sourceMappingURL=glUploadVideoResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs\n\nconst scaleModeToGlFilter = {\n  linear: 9729,\n  nearest: 9728\n};\nconst mipmapScaleModeToGlFilter = {\n  linear: {\n    linear: 9987,\n    nearest: 9985\n  },\n  nearest: {\n    linear: 9986,\n    nearest: 9984\n  }\n};\nconst wrapModeToGlAddress = {\n  "clamp-to-edge": 33071,\n  repeat: 10497,\n  "mirror-repeat": 33648\n};\nconst compareModeToGlCompare = {\n  never: 512,\n  less: 513,\n  equal: 514,\n  "less-equal": 515,\n  greater: 516,\n  "not-equal": 517,\n  "greater-equal": 518,\n  always: 519\n};\n\n\n//# sourceMappingURL=pixiToGlMaps.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs\n\n\n"use strict";\nfunction applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {\n  const castParam = firstParam;\n  if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {\n    const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];\n    const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];\n    const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];\n    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n    if (gl.TEXTURE_WRAP_R)\n      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n  }\n  if (!firstCreation || style.magFilter !== "linear") {\n    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n  }\n  if (mipmaps) {\n    if (!firstCreation || style.mipmapFilter !== "linear") {\n      const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n    }\n  } else {\n    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n  }\n  if (anisotropicExt && style.maxAnisotropy > 1) {\n    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n  }\n  if (style.compare) {\n    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n  }\n}\n\n\n//# sourceMappingURL=applyStyleParams.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs\n\nfunction mapFormatToGlFormat(gl) {\n  return {\n    // 8-bit formats\n    r8unorm: gl.RED,\n    r8snorm: gl.RED,\n    r8uint: gl.RED,\n    r8sint: gl.RED,\n    // 16-bit formats\n    r16uint: gl.RED,\n    r16sint: gl.RED,\n    r16float: gl.RED,\n    rg8unorm: gl.RG,\n    rg8snorm: gl.RG,\n    rg8uint: gl.RG,\n    rg8sint: gl.RG,\n    // 32-bit formats\n    r32uint: gl.RED,\n    r32sint: gl.RED,\n    r32float: gl.RED,\n    rg16uint: gl.RG,\n    rg16sint: gl.RG,\n    rg16float: gl.RG,\n    rgba8unorm: gl.RGBA,\n    "rgba8unorm-srgb": gl.RGBA,\n    // Packed 32-bit formats\n    rgba8snorm: gl.RGBA,\n    rgba8uint: gl.RGBA,\n    rgba8sint: gl.RGBA,\n    bgra8unorm: gl.RGBA,\n    "bgra8unorm-srgb": gl.RGBA,\n    rgb9e5ufloat: gl.RGB,\n    rgb10a2unorm: gl.RGBA,\n    rg11b10ufloat: gl.RGB,\n    // 64-bit formats\n    rg32uint: gl.RG,\n    rg32sint: gl.RG,\n    rg32float: gl.RG,\n    rgba16uint: gl.RGBA,\n    rgba16sint: gl.RGBA,\n    rgba16float: gl.RGBA,\n    // 128-bit formats\n    rgba32uint: gl.RGBA,\n    rgba32sint: gl.RGBA,\n    rgba32float: gl.RGBA,\n    // Depth/stencil formats\n    stencil8: gl.STENCIL_INDEX8,\n    depth16unorm: gl.DEPTH_COMPONENT,\n    depth24plus: gl.DEPTH_COMPONENT,\n    "depth24plus-stencil8": gl.DEPTH_STENCIL,\n    depth32float: gl.DEPTH_COMPONENT,\n    "depth32float-stencil8": gl.DEPTH_STENCIL\n  };\n}\n\n\n//# sourceMappingURL=mapFormatToGlFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs\n\n\n"use strict";\nfunction mapFormatToGlInternalFormat(gl, extensions) {\n  let srgb = {};\n  let bgra8unorm = gl.RGBA;\n  if (!(gl instanceof adapter/* DOMAdapter */.z.get().getWebGLRenderingContext())) {\n    srgb = {\n      "rgba8unorm-srgb": gl.SRGB8_ALPHA8,\n      "bgra8unorm-srgb": gl.SRGB8_ALPHA8\n    };\n    bgra8unorm = gl.RGBA8;\n  } else if (extensions.srgb) {\n    srgb = {\n      "rgba8unorm-srgb": extensions.srgb.SRGB8_ALPHA8_EXT,\n      "bgra8unorm-srgb": extensions.srgb.SRGB8_ALPHA8_EXT\n    };\n  }\n  return {\n    // 8-bit formats\n    r8unorm: gl.R8,\n    r8snorm: gl.R8_SNORM,\n    r8uint: gl.R8UI,\n    r8sint: gl.R8I,\n    // 16-bit formats\n    r16uint: gl.R16UI,\n    r16sint: gl.R16I,\n    r16float: gl.R16F,\n    rg8unorm: gl.RG8,\n    rg8snorm: gl.RG8_SNORM,\n    rg8uint: gl.RG8UI,\n    rg8sint: gl.RG8I,\n    // 32-bit formats\n    r32uint: gl.R32UI,\n    r32sint: gl.R32I,\n    r32float: gl.R32F,\n    rg16uint: gl.RG16UI,\n    rg16sint: gl.RG16I,\n    rg16float: gl.RG16F,\n    rgba8unorm: gl.RGBA,\n    ...srgb,\n    // Packed 32-bit formats\n    rgba8snorm: gl.RGBA8_SNORM,\n    rgba8uint: gl.RGBA8UI,\n    rgba8sint: gl.RGBA8I,\n    bgra8unorm,\n    rgb9e5ufloat: gl.RGB9_E5,\n    rgb10a2unorm: gl.RGB10_A2,\n    rg11b10ufloat: gl.R11F_G11F_B10F,\n    // 64-bit formats\n    rg32uint: gl.RG32UI,\n    rg32sint: gl.RG32I,\n    rg32float: gl.RG32F,\n    rgba16uint: gl.RGBA16UI,\n    rgba16sint: gl.RGBA16I,\n    rgba16float: gl.RGBA16F,\n    // 128-bit formats\n    rgba32uint: gl.RGBA32UI,\n    rgba32sint: gl.RGBA32I,\n    rgba32float: gl.RGBA32F,\n    // Depth/stencil formats\n    stencil8: gl.STENCIL_INDEX8,\n    depth16unorm: gl.DEPTH_COMPONENT16,\n    depth24plus: gl.DEPTH_COMPONENT24,\n    "depth24plus-stencil8": gl.DEPTH24_STENCIL8,\n    depth32float: gl.DEPTH_COMPONENT32F,\n    "depth32float-stencil8": gl.DEPTH32F_STENCIL8,\n    // Compressed formats\n    ...extensions.s3tc ? {\n      "bc1-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n      "bc2-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n      "bc3-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT\n    } : {},\n    ...extensions.s3tc_sRGB ? {\n      "bc1-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n      "bc2-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n      "bc3-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\n    } : {},\n    ...extensions.rgtc ? {\n      "bc4-r-unorm": extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,\n      "bc4-r-snorm": extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n      "bc5-rg-unorm": extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,\n      "bc5-rg-snorm": extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT\n    } : {},\n    ...extensions.bptc ? {\n      "bc6h-rgb-float": extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,\n      "bc6h-rgb-ufloat": extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,\n      "bc7-rgba-unorm": extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n      "bc7-rgba-unorm-srgb": extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT\n    } : {},\n    ...extensions.etc ? {\n      "etc2-rgb8unorm": extensions.etc.COMPRESSED_RGB8_ETC2,\n      "etc2-rgb8unorm-srgb": extensions.etc.COMPRESSED_SRGB8_ETC2,\n      "etc2-rgb8a1unorm": extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n      "etc2-rgb8a1unorm-srgb": extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n      "etc2-rgba8unorm": extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,\n      "etc2-rgba8unorm-srgb": extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n      "eac-r11unorm": extensions.etc.COMPRESSED_R11_EAC,\n      // \'eac-r11snorm\'\n      "eac-rg11unorm": extensions.etc.COMPRESSED_SIGNED_RG11_EAC\n      // \'eac-rg11snorm\'\n    } : {},\n    ...extensions.astc ? {\n      "astc-4x4-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,\n      "astc-4x4-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n      "astc-5x4-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,\n      "astc-5x4-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,\n      "astc-5x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,\n      "astc-5x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n      "astc-6x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,\n      "astc-6x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n      "astc-6x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,\n      "astc-6x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n      "astc-8x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,\n      "astc-8x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n      "astc-8x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,\n      "astc-8x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n      "astc-8x8-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,\n      "astc-8x8-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n      "astc-10x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,\n      "astc-10x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n      "astc-10x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,\n      "astc-10x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n      "astc-10x8-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,\n      "astc-10x8-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n      "astc-10x10-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,\n      "astc-10x10-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n      "astc-12x10-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,\n      "astc-12x10-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n      "astc-12x12-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,\n      "astc-12x12-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR\n    } : {}\n  };\n}\n\n\n//# sourceMappingURL=mapFormatToGlInternalFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs\n\nfunction mapFormatToGlType(gl) {\n  return {\n    // 8-bit formats\n    r8unorm: gl.UNSIGNED_BYTE,\n    r8snorm: gl.BYTE,\n    r8uint: gl.UNSIGNED_BYTE,\n    r8sint: gl.BYTE,\n    // 16-bit formats\n    r16uint: gl.UNSIGNED_SHORT,\n    r16sint: gl.SHORT,\n    r16float: gl.HALF_FLOAT,\n    rg8unorm: gl.UNSIGNED_BYTE,\n    rg8snorm: gl.BYTE,\n    rg8uint: gl.UNSIGNED_BYTE,\n    rg8sint: gl.BYTE,\n    // 32-bit formats\n    r32uint: gl.UNSIGNED_INT,\n    r32sint: gl.INT,\n    r32float: gl.FLOAT,\n    rg16uint: gl.UNSIGNED_SHORT,\n    rg16sint: gl.SHORT,\n    rg16float: gl.HALF_FLOAT,\n    rgba8unorm: gl.UNSIGNED_BYTE,\n    "rgba8unorm-srgb": gl.UNSIGNED_BYTE,\n    // Packed 32-bit formats\n    rgba8snorm: gl.BYTE,\n    rgba8uint: gl.UNSIGNED_BYTE,\n    rgba8sint: gl.BYTE,\n    bgra8unorm: gl.UNSIGNED_BYTE,\n    "bgra8unorm-srgb": gl.UNSIGNED_BYTE,\n    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,\n    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,\n    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,\n    // 64-bit formats\n    rg32uint: gl.UNSIGNED_INT,\n    rg32sint: gl.INT,\n    rg32float: gl.FLOAT,\n    rgba16uint: gl.UNSIGNED_SHORT,\n    rgba16sint: gl.SHORT,\n    rgba16float: gl.HALF_FLOAT,\n    // 128-bit formats\n    rgba32uint: gl.UNSIGNED_INT,\n    rgba32sint: gl.INT,\n    rgba32float: gl.FLOAT,\n    // Depth/stencil formats\n    stencil8: gl.UNSIGNED_BYTE,\n    depth16unorm: gl.UNSIGNED_SHORT,\n    depth24plus: gl.UNSIGNED_INT,\n    "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,\n    depth32float: gl.FLOAT,\n    "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV\n  };\n}\n\n\n//# sourceMappingURL=mapFormatToGlType.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst BYTES_PER_PIXEL = 4;\nclass GlTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._glTextures = /* @__PURE__ */ Object.create(null);\n    this._glSamplers = /* @__PURE__ */ Object.create(null);\n    this._boundTextures = [];\n    this._activeTextureLocation = -1;\n    this._boundSamplers = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: glUploadImageResource,\n      buffer: glUploadBufferImageResource,\n      video: glUploadVideoResource,\n      compressed: glUploadCompressedTextureResource\n    };\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    this._useSeparateSamplers = false;\n    this._renderer = renderer;\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    if (!this._mapFormatToInternalFormat) {\n      this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n      this._mapFormatToType = mapFormatToGlType(gl);\n      this._mapFormatToFormat = mapFormatToGlFormat(gl);\n    }\n    this._glTextures = /* @__PURE__ */ Object.create(null);\n    this._glSamplers = /* @__PURE__ */ Object.create(null);\n    this._boundSamplers = /* @__PURE__ */ Object.create(null);\n    for (let i = 0; i < 16; i++) {\n      this.bind(Texture/* Texture */.x.EMPTY, i);\n    }\n  }\n  initSource(source) {\n    this.bind(source);\n  }\n  bind(texture, location = 0) {\n    const source = texture.source;\n    if (texture) {\n      this.bindSource(source, location);\n      if (this._useSeparateSamplers) {\n        this._bindSampler(source.style, location);\n      }\n    } else {\n      this.bindSource(null, location);\n      if (this._useSeparateSamplers) {\n        this._bindSampler(null, location);\n      }\n    }\n  }\n  bindSource(source, location = 0) {\n    const gl = this._gl;\n    source._touched = this._renderer.textureGC.count;\n    if (this._boundTextures[location] !== source) {\n      this._boundTextures[location] = source;\n      this._activateLocation(location);\n      source = source || Texture/* Texture */.x.EMPTY.source;\n      const glTexture = this.getGlSource(source);\n      gl.bindTexture(glTexture.target, glTexture.texture);\n    }\n  }\n  _bindSampler(style, location = 0) {\n    const gl = this._gl;\n    if (!style) {\n      this._boundSamplers[location] = null;\n      gl.bindSampler(location, null);\n      return;\n    }\n    const sampler = this._getGlSampler(style);\n    if (this._boundSamplers[location] !== sampler) {\n      this._boundSamplers[location] = sampler;\n      gl.bindSampler(location, sampler);\n    }\n  }\n  unbind(texture) {\n    const source = texture.source;\n    const boundTextures = this._boundTextures;\n    const gl = this._gl;\n    for (let i = 0; i < boundTextures.length; i++) {\n      if (boundTextures[i] === source) {\n        this._activateLocation(i);\n        const glTexture = this.getGlSource(source);\n        gl.bindTexture(glTexture.target, null);\n        boundTextures[i] = null;\n      }\n    }\n  }\n  _activateLocation(location) {\n    if (this._activeTextureLocation !== location) {\n      this._activeTextureLocation = location;\n      this._gl.activeTexture(this._gl.TEXTURE0 + location);\n    }\n  }\n  _initSource(source) {\n    const gl = this._gl;\n    const glTexture = new GlTexture(gl.createTexture());\n    glTexture.type = this._mapFormatToType[source.format];\n    glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n    glTexture.format = this._mapFormatToFormat[source.format];\n    if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo)) {\n      const biggestDimension = Math.max(source.width, source.height);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    this._glTextures[source.uid] = glTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on("update", this.onSourceUpdate, this);\n      source.on("resize", this.onSourceUpdate, this);\n      source.on("styleChange", this.onStyleChange, this);\n      source.on("destroy", this.onSourceDestroy, this);\n      source.on("unload", this.onSourceUnload, this);\n      source.on("updateMipmaps", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    this.updateStyle(source, false);\n    return glTexture;\n  }\n  onStyleChange(source) {\n    this.updateStyle(source, false);\n  }\n  updateStyle(source, firstCreation) {\n    const gl = this._gl;\n    const glTexture = this.getGlSource(source);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    this._boundTextures[this._activeTextureLocation] = source;\n    applyStyleParams(\n      source.style,\n      gl,\n      source.mipLevelCount > 1,\n      this._renderer.context.extensions.anisotropicFiltering,\n      "texParameteri",\n      gl.TEXTURE_2D,\n      // will force a clamp to edge if the texture is not a power of two\n      !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n      firstCreation\n    );\n  }\n  onSourceUnload(source) {\n    const glTexture = this._glTextures[source.uid];\n    if (!glTexture)\n      return;\n    this.unbind(source);\n    this._glTextures[source.uid] = null;\n    this._gl.deleteTexture(glTexture.texture);\n  }\n  onSourceUpdate(source) {\n    const gl = this._gl;\n    const glTexture = this.getGlSource(source);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    this._boundTextures[this._activeTextureLocation] = source;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source, false);\n    }\n  }\n  onUpdateMipmaps(source, bind = true) {\n    if (bind)\n      this.bindSource(source, 0);\n    const glTexture = this.getGlSource(source);\n    this._gl.generateMipmap(glTexture.target);\n  }\n  onSourceDestroy(source) {\n    source.off("destroy", this.onSourceDestroy, this);\n    source.off("update", this.onSourceUpdate, this);\n    source.off("resize", this.onSourceUpdate, this);\n    source.off("unload", this.onSourceUnload, this);\n    source.off("styleChange", this.onStyleChange, this);\n    source.off("updateMipmaps", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  _initSampler(style) {\n    const gl = this._gl;\n    const glSampler = this._gl.createSampler();\n    this._glSamplers[style._resourceId] = glSampler;\n    applyStyleParams(\n      style,\n      gl,\n      this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n      this._renderer.context.extensions.anisotropicFiltering,\n      "samplerParameteri",\n      glSampler,\n      false,\n      true\n    );\n    return this._glSamplers[style._resourceId];\n  }\n  _getGlSampler(sampler) {\n    return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGlSource(source) {\n    return this._glTextures[source.uid] || this._initSource(source);\n  }\n  generateCanvas(texture) {\n    const { pixels, width, height } = this.getPixels(texture);\n    const canvas = adapter/* DOMAdapter */.z.get().createCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext("2d");\n    if (ctx) {\n      const imageData = ctx.createImageData(width, height);\n      imageData.data.set(pixels);\n      ctx.putImageData(imageData, 0, 0);\n    }\n    return canvas;\n  }\n  getPixels(texture) {\n    const resolution = texture.source.resolution;\n    const frame = texture.frame;\n    const width = Math.max(Math.round(frame.width * resolution), 1);\n    const height = Math.max(Math.round(frame.height * resolution), 1);\n    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    const renderer = this._renderer;\n    const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n    const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n    const gl = renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n    gl.readPixels(\n      Math.round(frame.x * resolution),\n      Math.round(frame.y * resolution),\n      width,\n      height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    );\n    if (false) {}\n    return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlTextureSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem\n  ],\n  name: "texture"\n};\n\n\n//# sourceMappingURL=GlTextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst DefaultWebGLSystems = [\n  ...SharedSystems/* SharedSystems */.N,\n  GlUboSystem,\n  GlBackBufferSystem,\n  GlContextSystem,\n  GlBufferSystem,\n  GlTextureSystem,\n  GlRenderTargetSystem,\n  GlGeometrySystem,\n  GlUniformGroupSystem,\n  GlShaderSystem,\n  GlEncoderSystem,\n  GlStateSystem,\n  GlStencilSystem,\n  GlColorMaskSystem\n];\nconst DefaultWebGLPipes = [...SharedSystems/* SharedRenderPipes */.U];\nconst DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nExtensions/* extensions */.Rw.handleByNamedList(Extensions/* ExtensionType */.nw.WebGLSystem, systems);\nExtensions/* extensions */.Rw.handleByNamedList(Extensions/* ExtensionType */.nw.WebGLPipes, renderPipes);\nExtensions/* extensions */.Rw.handleByNamedList(Extensions/* ExtensionType */.nw.WebGLPipesAdaptor, renderPipeAdaptors);\nExtensions/* extensions */.Rw.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);\nclass WebGLRenderer extends AbstractRenderer/* AbstractRenderer */.I {\n  constructor() {\n    const systemConfig = {\n      name: "webgl",\n      type: types/* RendererType */.g.WEBGL,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\n\n//# sourceMappingURL=WebGLRenderer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBSyxPQUFPLHFCQUFLO0FBQ3ZDO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFVBQVUsb0JBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUM7QUFDakM7OztBQzFSc0U7QUFDZ0I7QUFDbEI7O0FBRXBFO0FBQ0EsbUNBQW1DLDRDQUFrQjtBQUNyRDtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBYTtBQUN0QjtBQUNBOztBQUVnQztBQUNoQzs7Ozs7QUNuQndFO0FBQ0o7QUFDVzs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQ0FBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsRUFBRTtBQUMxQyxpREFBaUQsRUFBRSxHQUFHLEVBQUU7QUFDeEQsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwyREFBMkQsRUFBRTtBQUM3RDtBQUNBO0FBQ0EsUUFBUSw2QkFBNkIsb0NBQWM7QUFDbkQ7QUFDQTtBQUNBLG9DQUFvQyxFQUFFO0FBQ3RDLDZDQUE2QyxFQUFFLEdBQUcsRUFBRTtBQUNwRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLFFBQVEsNkJBQTZCLGtDQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRSxLQUFLLGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQztBQUNsQzs7O0FDdkVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QztBQUN6Qzs7O0FDM0JhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QjtBQUN6Qjs7O0FDVGE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QjtBQUN4Qjs7O0FDdEZhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixz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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7Ozs7O0FDL0lhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDJD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ3ZDOzs7QUNuQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZDO0FBQzdDOzs7QUNsR2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUM7QUFDakM7OztBQ3ZGb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7O0FBRWlDO0FBQ2pDOzs7QUN6QmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVHO0FBQ3ZHOzs7QUNoQ2lJOztBQUVqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekMsc0JBQXNCLG1CQUFtQjtBQUN6QyxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxtQkFBbUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0EsSUFBSTtBQUNKLHlEQUF5RCxtQkFBbUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHNCQUFzQjtBQUNqRjtBQUNBOztBQUU0QjtBQUM1Qjs7O0FDbkNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7OztBQ3hEb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUV1QztBQUN2Qzs7O0FDeElhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDN0I7OztBQ3hEaUU7QUFDSztBQUNYO0FBQ2Y7QUFDOEM7QUFDWTtBQUN4QjtBQUNBO0FBQ2Q7QUFDTTtBQUNnQjtBQUNwQjtBQUMxQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGNBQWMsMkJBQTJCO0FBQ3pDLGFBQWEscUJBQXFCO0FBQ2xDLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkUsOEJBQThCLGlCQUFpQjtBQUMvQyxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsZ0JBQWdCLHNCQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQyxtQkFBbUIseUJBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLLEVBQUUsRUFFVjtBQUNMLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUUyQjtBQUMzQjs7O0FDelErRTtBQUNNO0FBQ1o7QUFDSjtBQUNJO0FBQ2E7QUFDMUM7QUFDaUI7QUFDRztBQUNHO0FBQ0w7QUFDRjtBQUNKO0FBQ0E7QUFDUjtBQUMrQjtBQUNsQjtBQUNZO0FBQ2Y7QUFDTTs7QUFFaEU7QUFDQTtBQUNBLEtBQUssa0NBQWE7QUFDbEIsRUFBRSxXQUFXO0FBQ2IsRUFBRSxrQkFBa0I7QUFDcEIsRUFBRSxlQUFlO0FBQ2pCLEVBQUUsY0FBYztBQUNoQixFQUFFLGVBQWU7QUFDakIsRUFBRSxvQkFBb0I7QUFDdEIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxvQkFBb0I7QUFDdEIsRUFBRSxjQUFjO0FBQ2hCLEVBQUUsZUFBZTtBQUNqQixFQUFFLGFBQWE7QUFDZixFQUFFLGVBQWU7QUFDakIsRUFBRSxpQkFBaUI7QUFDbkI7QUFDQSw4QkFBOEIsc0NBQWlCO0FBQy9DLDhCQUE4QixjQUFjLEVBQUUsYUFBYSxFQUFFLGlCQUFpQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSw2QkFBVSxtQkFBbUIsZ0NBQWE7QUFDMUMsNkJBQVUsbUJBQW1CLGdDQUFhO0FBQzFDLDZCQUFVLG1CQUFtQixnQ0FBYTtBQUMxQyw2QkFBVTtBQUNWLDRCQUE0Qix3Q0FBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL2dsL0dsR3JhcGhpY3NBZGFwdG9yLm1qcz9kYjZkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvbWVzaC9nbC9HbE1lc2hBZGFwdG9yLm1qcz9jNWJmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL2JhdGNoZXIvZ2wvR2xCYXRjaEFkYXB0b3IubWpzPzY5NGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL2J1ZmZlci9jb25zdC5tanM/MGM4MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvYnVmZmVyL0dsQnVmZmVyLm1qcz81YjQxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9idWZmZXIvR2xCdWZmZXJTeXN0ZW0ubWpzPzBiNDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL2NvbnRleHQvR2xDb250ZXh0U3lzdGVtLm1qcz8xMGMyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL2NvbnN0Lm1qcz84ZDUyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9nZW9tZXRyeS91dGlscy9nZXRHbFR5cGVGcm9tRm9ybWF0Lm1qcz9mNmIyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9nZW9tZXRyeS9HbEdlb21ldHJ5U3lzdGVtLm1qcz9jZDYwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9HbEJhY2tCdWZmZXJTeXN0ZW0ubWpzP2I1YTkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL0dsQ29sb3JNYXNrU3lzdGVtLm1qcz9hNjA4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9HbEVuY29kZXJTeXN0ZW0ubWpzPzhjY2UiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL0dsU3RlbmNpbFN5c3RlbS5tanM/NDczYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib0VsZW1lbnRzU1RENDAubWpzPzM3MWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9nZW5lcmF0ZUFycmF5U3luY1NURDQwLm1qcz9iNjFhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvdXRpbHMvY3JlYXRlVWJvU3luY1NURDQwLm1qcz83MTlmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9HbFVib1N5c3RlbS5tanM/Y2IwNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvR2xSZW5kZXJUYXJnZXQubWpzP2E4NzQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3JlbmRlclRhcmdldC9HbFJlbmRlclRhcmdldEFkYXB0b3IubWpzP2RiYzYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3JlbmRlclRhcmdldC9HbFJlbmRlclRhcmdldFN5c3RlbS5tanM/MTA0NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dlbmVyYXRlU2hhZGVyU3luY0NvZGUubWpzPzlhMmMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9HbFByb2dyYW1EYXRhLm1qcz8zNjNjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvcHJvZ3JhbS9jb21waWxlU2hhZGVyLm1qcz9jYmQzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvcHJvZ3JhbS9kZWZhdWx0VmFsdWUubWpzPzc0OTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL21hcFR5cGUubWpzPzUxN2MiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2V4dHJhY3RBdHRyaWJ1dGVzRnJvbUdsUHJvZ3JhbS5tanM/MmY2NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vZ2V0VWJvRGF0YS5tanM/Yjg1NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vZ2V0VW5pZm9ybURhdGEubWpzPzM4YjQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2xvZ1Byb2dyYW1FcnJvci5tanM/NWY5MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vZ2VuZXJhdGVQcm9ncmFtLm1qcz82ZDE4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvR2xTaGFkZXJTeXN0ZW0ubWpzPzA5OGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1zU3luY1R5cGVzLm1qcz81NjkzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVVbmlmb3Jtc1N5bmMubWpzPzU3NmUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9HbFVuaWZvcm1Hcm91cFN5c3RlbS5tanM/OTUyNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc3RhdGUvbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpLm1qcz80M2M2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zdGF0ZS9HbFN0YXRlU3lzdGVtLm1qcz80M2FlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL0dsVGV4dHVyZS5tanM/N2NhNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlLm1qcz81NTRkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3VwbG9hZGVycy9nbFVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UubWpzPzhhZTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvdXBsb2FkZXJzL2dsVXBsb2FkSW1hZ2VSZXNvdXJjZS5tanM/ZTQ0OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRWaWRlb1Jlc291cmNlLm1qcz8wMjZiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL3BpeGlUb0dsTWFwcy5tanM/YTIwMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91dGlscy9hcHBseVN0eWxlUGFyYW1zLm1qcz8wYWJhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL21hcEZvcm1hdFRvR2xGb3JtYXQubWpzPzEzN2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvdXRpbHMvbWFwRm9ybWF0VG9HbEludGVybmFsRm9ybWF0Lm1qcz9mMjc4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL21hcEZvcm1hdFRvR2xUeXBlLm1qcz82ODlkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL0dsVGV4dHVyZVN5c3RlbS5tanM/Yjg0NiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvV2ViR0xSZW5kZXJlci5tanM/NDk1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBnZXRNYXhUZXh0dXJlc1BlckJhdGNoIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2JhdGNoZXIvZ2wvdXRpbHMvbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5tanMnO1xuaW1wb3J0IHsgY29tcGlsZUhpZ2hTaGFkZXJHbFByb2dyYW0gfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IGNvbG9yQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvY29sb3JCaXQubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlVGV4dHVyZUJhdGNoQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQubWpzJztcbmltcG9ydCB7IGxvY2FsVW5pZm9ybUJpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybUJpdC5tanMnO1xuaW1wb3J0IHsgcm91bmRQaXhlbHNCaXRHbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9yb3VuZFBpeGVsc0JpdC5tanMnO1xuaW1wb3J0IHsgZ2V0QmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL2dldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9TaGFkZXIubWpzJztcbmltcG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHbEdyYXBoaWNzQWRhcHRvciB7XG4gIGluaXQoKSB7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1VHJhbnNmb3JtTWF0cml4OiB7IHZhbHVlOiBuZXcgTWF0cml4KCksIHR5cGU6IFwibWF0M3gzPGYzMj5cIiB9LFxuICAgICAgdVJvdW5kOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICB9KTtcbiAgICBjb25zdCBtYXhUZXh0dXJlcyA9IGdldE1heFRleHR1cmVzUGVyQmF0Y2goKTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSh7XG4gICAgICBuYW1lOiBcImdyYXBoaWNzXCIsXG4gICAgICBiaXRzOiBbXG4gICAgICAgIGNvbG9yQml0R2wsXG4gICAgICAgIGdlbmVyYXRlVGV4dHVyZUJhdGNoQml0R2wobWF4VGV4dHVyZXMpLFxuICAgICAgICBsb2NhbFVuaWZvcm1CaXRHbCxcbiAgICAgICAgcm91bmRQaXhlbHNCaXRHbFxuICAgICAgXVxuICAgIH0pO1xuICAgIHRoaXMuc2hhZGVyID0gbmV3IFNoYWRlcih7XG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgbG9jYWxVbmlmb3JtczogdW5pZm9ybXMsXG4gICAgICAgIGJhdGNoU2FtcGxlcnM6IGdldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAobWF4VGV4dHVyZXMpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZXhlY3V0ZShncmFwaGljc1BpcGUsIHJlbmRlcmFibGUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gcmVuZGVyYWJsZS5jb250ZXh0O1xuICAgIGNvbnN0IHNoYWRlciA9IGNvbnRleHQuY3VzdG9tU2hhZGVyIHx8IHRoaXMuc2hhZGVyO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ3JhcGhpY3NQaXBlLnJlbmRlcmVyO1xuICAgIGNvbnN0IGNvbnRleHRTeXN0ZW0gPSByZW5kZXJlci5ncmFwaGljc0NvbnRleHQ7XG4gICAgY29uc3Qge1xuICAgICAgZ2VvbWV0cnksXG4gICAgICBpbnN0cnVjdGlvbnNcbiAgICB9ID0gY29udGV4dFN5c3RlbS5nZXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KTtcbiAgICBzaGFkZXIuZ3JvdXBzWzBdID0gcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMuYmluZEdyb3VwO1xuICAgIHJlbmRlcmVyLnN0YXRlLnNldChncmFwaGljc1BpcGUuc3RhdGUpO1xuICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlcik7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChnZW9tZXRyeSwgc2hhZGVyLmdsUHJvZ3JhbSk7XG4gICAgY29uc3QgYmF0Y2hlcyA9IGluc3RydWN0aW9ucy5pbnN0cnVjdGlvbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMuaW5zdHJ1Y3Rpb25TaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgIGlmIChiYXRjaC5zaXplKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmF0Y2gudGV4dHVyZXMuY291bnQ7IGorKykge1xuICAgICAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZChiYXRjaC50ZXh0dXJlcy50ZXh0dXJlc1tqXSwgaik7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyhcInRyaWFuZ2xlLWxpc3RcIiwgYmF0Y2guc2l6ZSwgYmF0Y2guc3RhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc2hhZGVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR2xHcmFwaGljc0FkYXB0b3IuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzQWRhcHRvclxuICBdLFxuICBuYW1lOiBcImdyYXBoaWNzXCJcbn07XG5cbmV4cG9ydCB7IEdsR3JhcGhpY3NBZGFwdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbEdyYXBoaWNzQWRhcHRvci5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlSGlnaFNoYWRlclRvUHJvZ3JhbS5tanMnO1xuaW1wb3J0IHsgbG9jYWxVbmlmb3JtQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvbG9jYWxVbmlmb3JtQml0Lm1qcyc7XG5pbXBvcnQgeyByb3VuZFBpeGVsc0JpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL3JvdW5kUGl4ZWxzQml0Lm1qcyc7XG5pbXBvcnQgeyB0ZXh0dXJlQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvdGV4dHVyZUJpdC5tanMnO1xuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1NoYWRlci5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdsTWVzaEFkYXB0b3Ige1xuICBpbml0KCkge1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IGNvbXBpbGVIaWdoU2hhZGVyR2xQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwibWVzaFwiLFxuICAgICAgYml0czogW1xuICAgICAgICBsb2NhbFVuaWZvcm1CaXRHbCxcbiAgICAgICAgdGV4dHVyZUJpdEdsLFxuICAgICAgICByb3VuZFBpeGVsc0JpdEdsXG4gICAgICBdXG4gICAgfSk7XG4gICAgdGhpcy5fc2hhZGVyID0gbmV3IFNoYWRlcih7XG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgdVRleHR1cmU6IFRleHR1cmUuRU1QVFkuc291cmNlLFxuICAgICAgICB0ZXh0dXJlVW5pZm9ybXM6IHtcbiAgICAgICAgICB1VGV4dHVyZU1hdHJpeDogeyB0eXBlOiBcIm1hdDN4MzxmMzI+XCIsIHZhbHVlOiBuZXcgTWF0cml4KCkgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZXhlY3V0ZShtZXNoUGlwZSwgbWVzaCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbWVzaFBpcGUucmVuZGVyZXI7XG4gICAgbGV0IHNoYWRlciA9IG1lc2guX3NoYWRlcjtcbiAgICBpZiAoIXNoYWRlcikge1xuICAgICAgc2hhZGVyID0gdGhpcy5fc2hhZGVyO1xuICAgICAgY29uc3QgdGV4dHVyZSA9IG1lc2gudGV4dHVyZTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRleHR1cmUuc291cmNlO1xuICAgICAgc2hhZGVyLnJlc291cmNlcy51VGV4dHVyZSA9IHNvdXJjZTtcbiAgICAgIHNoYWRlci5yZXNvdXJjZXMudVNhbXBsZXIgPSBzb3VyY2Uuc3R5bGU7XG4gICAgICBzaGFkZXIucmVzb3VyY2VzLnRleHR1cmVVbmlmb3Jtcy51bmlmb3Jtcy51VGV4dHVyZU1hdHJpeCA9IHRleHR1cmUudGV4dHVyZU1hdHJpeC5tYXBDb29yZDtcbiAgICB9IGVsc2UgaWYgKCFzaGFkZXIuZ2xQcm9ncmFtKSB7XG4gICAgICB3YXJuKFwiTWVzaCBzaGFkZXIgaGFzIG5vIGdsUHJvZ3JhbVwiLCBtZXNoLnNoYWRlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNoYWRlci5ncm91cHNbMTAwXSA9IHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLmJpbmRHcm91cDtcbiAgICBzaGFkZXIuZ3JvdXBzWzEwMV0gPSBtZXNoUGlwZS5sb2NhbFVuaWZvcm1zQmluZEdyb3VwO1xuICAgIHJlbmRlcmVyLmVuY29kZXIuZHJhdyh7XG4gICAgICBnZW9tZXRyeTogbWVzaC5fZ2VvbWV0cnksXG4gICAgICBzaGFkZXIsXG4gICAgICBzdGF0ZTogbWVzaC5zdGF0ZVxuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc2hhZGVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgdGhpcy5fc2hhZGVyID0gbnVsbDtcbiAgfVxufVxuR2xNZXNoQWRhcHRvci5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXNBZGFwdG9yXG4gIF0sXG4gIG5hbWU6IFwibWVzaFwiXG59O1xuXG5leHBvcnQgeyBHbE1lc2hBZGFwdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbE1lc2hBZGFwdG9yLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyR2xQcm9ncmFtIH0gZnJvbSAnLi4vLi4vaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IGNvbG9yQml0R2wgfSBmcm9tICcuLi8uLi9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9jb2xvckJpdC5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXRHbCB9IGZyb20gJy4uLy4uL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2dlbmVyYXRlVGV4dHVyZUJhdGNoQml0Lm1qcyc7XG5pbXBvcnQgeyByb3VuZFBpeGVsc0JpdEdsIH0gZnJvbSAnLi4vLi4vaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvcm91bmRQaXhlbHNCaXQubWpzJztcbmltcG9ydCB7IGdldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvZ2wvc2hhZGVyL2dldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1NoYWRlci5tanMnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBnZXRNYXhUZXh0dXJlc1BlckJhdGNoIH0gZnJvbSAnLi91dGlscy9tYXhSZWNvbW1lbmRlZFRleHR1cmVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR2xCYXRjaEFkYXB0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9kaWRVcGxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLl90ZW1wU3RhdGUgPSBTdGF0ZS5mb3IyZCgpO1xuICB9XG4gIGluaXQoYmF0Y2hlclBpcGUpIHtcbiAgICBjb25zdCBtYXhUZXh0dXJlcyA9IGdldE1heFRleHR1cmVzUGVyQmF0Y2goKTtcbiAgICBjb25zdCBnbFByb2dyYW0gPSBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSh7XG4gICAgICBuYW1lOiBcImJhdGNoXCIsXG4gICAgICBiaXRzOiBbXG4gICAgICAgIGNvbG9yQml0R2wsXG4gICAgICAgIGdlbmVyYXRlVGV4dHVyZUJhdGNoQml0R2wobWF4VGV4dHVyZXMpLFxuICAgICAgICByb3VuZFBpeGVsc0JpdEdsXG4gICAgICBdXG4gICAgfSk7XG4gICAgdGhpcy5fc2hhZGVyID0gbmV3IFNoYWRlcih7XG4gICAgICBnbFByb2dyYW0sXG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgYmF0Y2hTYW1wbGVyczogZ2V0QmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cChtYXhUZXh0dXJlcylcbiAgICAgIH1cbiAgICB9KTtcbiAgICBiYXRjaGVyUGlwZS5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuYWRkKHRoaXMpO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5fZGlkVXBsb2FkID0gZmFsc2U7XG4gIH1cbiAgc3RhcnQoYmF0Y2hQaXBlLCBnZW9tZXRyeSkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gYmF0Y2hQaXBlLnJlbmRlcmVyO1xuICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuX3NoYWRlciwgdGhpcy5fZGlkVXBsb2FkKTtcbiAgICByZW5kZXJlci5zaGFkZXIudXBkYXRlVW5pZm9ybUdyb3VwKHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnVuaWZvcm1Hcm91cCk7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChnZW9tZXRyeSwgdGhpcy5fc2hhZGVyLmdsUHJvZ3JhbSk7XG4gIH1cbiAgZXhlY3V0ZShiYXRjaFBpcGUsIGJhdGNoKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBiYXRjaFBpcGUucmVuZGVyZXI7XG4gICAgdGhpcy5fZGlkVXBsb2FkID0gdHJ1ZTtcbiAgICB0aGlzLl90ZW1wU3RhdGUuYmxlbmRNb2RlID0gYmF0Y2guYmxlbmRNb2RlO1xuICAgIHJlbmRlcmVyLnN0YXRlLnNldCh0aGlzLl90ZW1wU3RhdGUpO1xuICAgIGNvbnN0IHRleHR1cmVzID0gYmF0Y2gudGV4dHVyZXMudGV4dHVyZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaC50ZXh0dXJlcy5jb3VudDsgaSsrKSB7XG4gICAgICByZW5kZXJlci50ZXh0dXJlLmJpbmQodGV4dHVyZXNbaV0sIGkpO1xuICAgIH1cbiAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KFwidHJpYW5nbGUtbGlzdFwiLCBiYXRjaC5zaXplLCBiYXRjaC5zdGFydCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9zaGFkZXIuZGVzdHJveSh0cnVlKTtcbiAgICB0aGlzLl9zaGFkZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR2xCYXRjaEFkYXB0b3IuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzQWRhcHRvclxuICBdLFxuICBuYW1lOiBcImJhdGNoXCJcbn07XG5cbmV4cG9ydCB7IEdsQmF0Y2hBZGFwdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbEJhdGNoQWRhcHRvci5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBCVUZGRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKEJVRkZFUl9UWVBFMikgPT4ge1xuICBCVUZGRVJfVFlQRTJbQlVGRkVSX1RZUEUyW1wiRUxFTUVOVF9BUlJBWV9CVUZGRVJcIl0gPSAzNDk2M10gPSBcIkVMRU1FTlRfQVJSQVlfQlVGRkVSXCI7XG4gIEJVRkZFUl9UWVBFMltCVUZGRVJfVFlQRTJbXCJBUlJBWV9CVUZGRVJcIl0gPSAzNDk2Ml0gPSBcIkFSUkFZX0JVRkZFUlwiO1xuICBCVUZGRVJfVFlQRTJbQlVGRkVSX1RZUEUyW1wiVU5JRk9STV9CVUZGRVJcIl0gPSAzNTM0NV0gPSBcIlVOSUZPUk1fQlVGRkVSXCI7XG4gIHJldHVybiBCVUZGRVJfVFlQRTI7XG59KShCVUZGRVJfVFlQRSB8fCB7fSk7XG5cbmV4cG9ydCB7IEJVRkZFUl9UWVBFIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdsQnVmZmVyIHtcbiAgY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlKSB7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXIgfHwgbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUlEID0gLTE7XG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gLTE7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxufVxuXG5leHBvcnQgeyBHbEJ1ZmZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2xCdWZmZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQnVmZmVyVXNhZ2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvYnVmZmVyL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBCVUZGRVJfVFlQRSB9IGZyb20gJy4vY29uc3QubWpzJztcbmltcG9ydCB7IEdsQnVmZmVyIH0gZnJvbSAnLi9HbEJ1ZmZlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdsQnVmZmVyU3lzdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZ3B1QnVmZmVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8qKiBDYWNoZSBrZWVwaW5nIHRyYWNrIG9mIHRoZSBiYXNlIGJvdW5kIGJ1ZmZlciBiYXNlcyAqL1xuICAgIHRoaXMuX2JvdW5kQnVmZmVyQmFzZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLl9nbCA9IG51bGw7XG4gICAgdGhpcy5fZ3B1QnVmZmVycyA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRCdWZmZXJCYXNlcyA9IG51bGw7XG4gIH1cbiAgLyoqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLiAqL1xuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIHRoaXMuX2dwdUJ1ZmZlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9nbCA9IHRoaXMuX3JlbmRlcmVyLmdsO1xuICB9XG4gIGdldEdsQnVmZmVyKGJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLl9ncHVCdWZmZXJzW2J1ZmZlci51aWRdIHx8IHRoaXMuY3JlYXRlR0xCdWZmZXIoYnVmZmVyKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBiaW5kcyBzcGVjaWZpZWQgYnVmZmVyLiBPbiBmaXJzdCBydW4sIGl0IHdpbGwgY3JlYXRlIHRoZSB3ZWJHTCBidWZmZXJzIGZvciB0aGUgY29udGV4dCB0b29cbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBidWZmZXIgdG8gYmluZCB0byB0aGUgcmVuZGVyZXJcbiAgICovXG4gIGJpbmQoYnVmZmVyKSB7XG4gICAgY29uc3QgeyBfZ2w6IGdsIH0gPSB0aGlzO1xuICAgIGNvbnN0IGdsQnVmZmVyID0gdGhpcy5nZXRHbEJ1ZmZlcihidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2xCdWZmZXIudHlwZSwgZ2xCdWZmZXIuYnVmZmVyKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgYW4gdW5pZm9ybSBidWZmZXIgdG8gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKlxuICAgKiBBIGNhY2hlIGlzIHVzZWQgc28gYSBidWZmZXIgd2lsbCBub3QgYmUgYm91bmQgYWdhaW4gaWYgYWxyZWFkeSBib3VuZC5cbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBidWZmZXIgdG8gYmluZFxuICAgKiBAcGFyYW0gaW5kZXggLSB0aGUgYmFzZSBpbmRleCB0byBiaW5kIGl0IHRvLlxuICAgKi9cbiAgYmluZEJ1ZmZlckJhc2UoYnVmZmVyLCBpbmRleCkge1xuICAgIGNvbnN0IHsgX2dsOiBnbCB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5fYm91bmRCdWZmZXJCYXNlc1tpbmRleF0gIT09IGJ1ZmZlcikge1xuICAgICAgY29uc3QgZ2xCdWZmZXIgPSB0aGlzLmdldEdsQnVmZmVyKGJ1ZmZlcik7XG4gICAgICB0aGlzLl9ib3VuZEJ1ZmZlckJhc2VzW2luZGV4XSA9IGJ1ZmZlcjtcbiAgICAgIGdsLmJpbmRCdWZmZXJCYXNlKGdsLlVOSUZPUk1fQlVGRkVSLCBpbmRleCwgZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIGEgYnVmZmVyIHdoaWxzdCBhbHNvIGJpbmRpbmcgaXRzIHJhbmdlLlxuICAgKiBUaGlzIHdpbGwgbWFrZSB0aGUgYnVmZmVyIHN0YXJ0IGZyb20gdGhlIG9mZnNldCBzdXBwbGllZCByYXRoZXIgdGhhbiAwIHdoZW4gaXQgaXMgcmVhZC5cbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBidWZmZXIgdG8gYmluZFxuICAgKiBAcGFyYW0gaW5kZXggLSB0aGUgYmFzZSBpbmRleCB0byBiaW5kIGF0LCBkZWZhdWx0cyB0byAwXG4gICAqIEBwYXJhbSBvZmZzZXQgLSB0aGUgb2Zmc2V0IHRvIGJpbmQgYXQgKHRoaXMgaXMgYmxvY2tzIG9mIDI1NikuIDAgPSAwLCAxID0gMjU2LCAyID0gNTEyIGV0Y1xuICAgKi9cbiAgYmluZEJ1ZmZlclJhbmdlKGJ1ZmZlciwgaW5kZXgsIG9mZnNldCkge1xuICAgIGNvbnN0IHsgX2dsOiBnbCB9ID0gdGhpcztcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICBjb25zdCBnbEJ1ZmZlciA9IHRoaXMuZ2V0R2xCdWZmZXIoYnVmZmVyKTtcbiAgICBnbC5iaW5kQnVmZmVyUmFuZ2UoZ2wuVU5JRk9STV9CVUZGRVIsIGluZGV4IHx8IDAsIGdsQnVmZmVyLmJ1ZmZlciwgb2Zmc2V0ICogMjU2LCAyNTYpO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIGVuc3VyZSB0aGUgZGF0YSBpbiB0aGUgYnVmZmVyIGlzIHVwbG9hZGVkIHRvIHRoZSBHUFUuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgLSB0aGUgYnVmZmVyIHRvIHVwZGF0ZVxuICAgKi9cbiAgdXBkYXRlQnVmZmVyKGJ1ZmZlcikge1xuICAgIGNvbnN0IHsgX2dsOiBnbCB9ID0gdGhpcztcbiAgICBjb25zdCBnbEJ1ZmZlciA9IHRoaXMuZ2V0R2xCdWZmZXIoYnVmZmVyKTtcbiAgICBpZiAoYnVmZmVyLl91cGRhdGVJRCA9PT0gZ2xCdWZmZXIudXBkYXRlSUQpIHtcbiAgICAgIHJldHVybiBnbEJ1ZmZlcjtcbiAgICB9XG4gICAgZ2xCdWZmZXIudXBkYXRlSUQgPSBidWZmZXIuX3VwZGF0ZUlEO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2xCdWZmZXIudHlwZSwgZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLmRhdGE7XG4gICAgaWYgKGdsQnVmZmVyLmJ5dGVMZW5ndGggPj0gYnVmZmVyLmRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbEJ1ZmZlci50eXBlLCAwLCBkYXRhLCAwLCBidWZmZXIuX3VwZGF0ZVNpemUgLyBkYXRhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZHJhd1R5cGUgPSBidWZmZXIuZGVzY3JpcHRvci51c2FnZSAmIEJ1ZmZlclVzYWdlLlNUQVRJQyA/IGdsLlNUQVRJQ19EUkFXIDogZ2wuRFlOQU1JQ19EUkFXO1xuICAgICAgZ2xCdWZmZXIuYnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2xCdWZmZXIudHlwZSwgZGF0YSwgZHJhd1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gZ2xCdWZmZXI7XG4gIH1cbiAgLyoqIGRpc3Bvc2UgYWxsIFdlYkdMIHJlc291cmNlcyBvZiBhbGwgbWFuYWdlZCBidWZmZXJzICovXG4gIGRlc3Ryb3lBbGwoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuX2dwdUJ1ZmZlcnMpIHtcbiAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl9ncHVCdWZmZXJzW2lkXS5idWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLl9ncHVCdWZmZXJzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2VzIGJ1ZmZlclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIC0gYnVmZmVyIHdpdGggZGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb250ZXh0TG9zdD1mYWxzZV0gLSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBkZWxldGVWZXJ0ZXhBcnJheVxuICAgKi9cbiAgb25CdWZmZXJEZXN0cm95KGJ1ZmZlciwgY29udGV4dExvc3QpIHtcbiAgICBjb25zdCBnbEJ1ZmZlciA9IHRoaXMuX2dwdUJ1ZmZlcnNbYnVmZmVyLnVpZF07XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICBnbC5kZWxldGVCdWZmZXIoZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy5fZ3B1QnVmZmVyc1tidWZmZXIudWlkXSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIGNyZWF0ZXMgYW5kIGF0dGFjaGVzIGEgR0xCdWZmZXIgb2JqZWN0IHRpZWQgdG8gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICogQHBhcmFtIGJ1ZmZlclxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjcmVhdGVHTEJ1ZmZlcihidWZmZXIpIHtcbiAgICBjb25zdCB7IF9nbDogZ2wgfSA9IHRoaXM7XG4gICAgbGV0IHR5cGUgPSBCVUZGRVJfVFlQRS5BUlJBWV9CVUZGRVI7XG4gICAgaWYgKGJ1ZmZlci5kZXNjcmlwdG9yLnVzYWdlICYgQnVmZmVyVXNhZ2UuSU5ERVgpIHtcbiAgICAgIHR5cGUgPSBCVUZGRVJfVFlQRS5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKGJ1ZmZlci5kZXNjcmlwdG9yLnVzYWdlICYgQnVmZmVyVXNhZ2UuVU5JRk9STSkge1xuICAgICAgdHlwZSA9IEJVRkZFUl9UWVBFLlVOSUZPUk1fQlVGRkVSO1xuICAgIH1cbiAgICBjb25zdCBnbEJ1ZmZlciA9IG5ldyBHbEJ1ZmZlcihnbC5jcmVhdGVCdWZmZXIoKSwgdHlwZSk7XG4gICAgdGhpcy5fZ3B1QnVmZmVyc1tidWZmZXIudWlkXSA9IGdsQnVmZmVyO1xuICAgIGJ1ZmZlci5vbihcImRlc3Ryb3lcIiwgdGhpcy5vbkJ1ZmZlckRlc3Ryb3ksIHRoaXMpO1xuICAgIHJldHVybiBnbEJ1ZmZlcjtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdsQnVmZmVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJidWZmZXJcIlxufTtcblxuZXhwb3J0IHsgR2xCdWZmZXJTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsQnVmZmVyU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX0dsQ29udGV4dFN5c3RlbSA9IGNsYXNzIF9HbENvbnRleHRTeXN0ZW0ge1xuICAvKiogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoaXMgU3lzdGVtIHdvcmtzIGZvci4gKi9cbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAvKipcbiAgICAgKiBGZWF0dXJlcyBzdXBwb3J0ZWQgYnkgY3VycmVudCByZW5kZXJlci5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuc3VwcG9ydHMgPSB7XG4gICAgICAvKiogU3VwcG9ydCBmb3IgMzItYml0IGluZGljZXMgYnVmZmVyLiAqL1xuICAgICAgdWludDMySW5kaWNlczogdHJ1ZSxcbiAgICAgIC8qKiBTdXBwb3J0IGZvciBVbmlmb3JtQnVmZmVyT2JqZWN0cyAqL1xuICAgICAgdW5pZm9ybUJ1ZmZlck9iamVjdDogdHJ1ZSxcbiAgICAgIC8qKiBTdXBwb3J0IGZvciBWZXJ0ZXhBcnJheU9iamVjdHMgKi9cbiAgICAgIHZlcnRleEFycmF5T2JqZWN0OiB0cnVlLFxuICAgICAgLyoqIFN1cHBvcnQgZm9yIFNSR0IgdGV4dHVyZSBmb3JtYXQgKi9cbiAgICAgIHNyZ2JUZXh0dXJlczogdHJ1ZSxcbiAgICAgIC8qKiBTdXBwb3J0IGZvciB3cmFwcGluZyBtb2RlcyBpZiBhIHRleHR1cmUgaXMgbm9uLXBvd2VyIG9mIHR3byAqL1xuICAgICAgbm9uUG93T2Yyd3JhcHBpbmc6IHRydWUsXG4gICAgICAvKiogU3VwcG9ydCBmb3IgTVNBQSAoYW50aWFsaWFzaW5nIG9mIGR5bmFtaWMgdGV4dHVyZXMpICovXG4gICAgICBtc2FhOiB0cnVlLFxuICAgICAgLyoqIFN1cHBvcnQgZm9yIG1pcG1hcHMgaWYgYSB0ZXh0dXJlIGlzIG5vbi1wb3dlciBvZiB0d28gKi9cbiAgICAgIG5vblBvd09mMm1pcG1hcHM6IHRydWVcbiAgICB9O1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5leHRlbnNpb25zID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCA9IHRoaXMuaGFuZGxlQ29udGV4dExvc3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLmJpbmQodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIGB0cnVlYCBpZiB0aGUgY29udGV4dCBpcyBsb3N0XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlzTG9zdCgpIHtcbiAgICByZXR1cm4gIXRoaXMuZ2wgfHwgdGhpcy5nbC5pc0NvbnRleHRMb3N0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGNvbnRleHQgY2hhbmdlIGV2ZW50LlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBOZXcgV2ViR0wgY29udGV4dC5cbiAgICovXG4gIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5fcmVuZGVyZXIuZ2wgPSBnbDtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0geyAuLi5fR2xDb250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgaWYgKG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgdGhpcy5pbml0RnJvbUNvbnRleHQob3B0aW9ucy5jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWxwaGEgPSB0aGlzLl9yZW5kZXJlci5iYWNrZ3JvdW5kLmFscGhhIDwgMTtcbiAgICAgIGNvbnN0IHByZW11bHRpcGxpZWRBbHBoYSA9IG9wdGlvbnMucHJlbXVsdGlwbGllZEFscGhhID8/IHRydWU7XG4gICAgICBjb25zdCBhbnRpYWxpYXMgPSBvcHRpb25zLmFudGlhbGlhcyAmJiAhdGhpcy5fcmVuZGVyZXIuYmFja0J1ZmZlci51c2VCYWNrQnVmZmVyO1xuICAgICAgdGhpcy5jcmVhdGVDb250ZXh0KG9wdGlvbnMucHJlZmVyV2ViR0xWZXJzaW9uLCB7XG4gICAgICAgIGFscGhhLFxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGEsXG4gICAgICAgIGFudGlhbGlhcyxcbiAgICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcixcbiAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiBvcHRpb25zLnBvd2VyUHJlZmVyZW5jZSA/PyBcImRlZmF1bHRcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29udGV4dC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBXZWJHTCBjb250ZXh0XG4gICAqL1xuICBpbml0RnJvbUNvbnRleHQoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy53ZWJHTFZlcnNpb24gPSBnbCBpbnN0YW5jZW9mIERPTUFkYXB0ZXIuZ2V0KCkuZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KCkgPyAxIDogMjtcbiAgICB0aGlzLmdldEV4dGVuc2lvbnMoKTtcbiAgICB0aGlzLnZhbGlkYXRlQ29udGV4dChnbCk7XG4gICAgdGhpcy5fcmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLmVtaXQoZ2wpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9yZW5kZXJlci52aWV3LmNhbnZhcztcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QsIGZhbHNlKTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCwgZmFsc2UpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGZyb20gY29udGV4dCBvcHRpb25zXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvZ2V0Q29udGV4dFxuICAgKiBAcGFyYW0gcHJlZmVyV2ViR0xWZXJzaW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gY29udGV4dCBhdHRyaWJ1dGVzXG4gICAqL1xuICBjcmVhdGVDb250ZXh0KHByZWZlcldlYkdMVmVyc2lvbiwgb3B0aW9ucykge1xuICAgIGxldCBnbDtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9yZW5kZXJlci52aWV3LmNhbnZhcztcbiAgICBpZiAocHJlZmVyV2ViR0xWZXJzaW9uID09PSAyKSB7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIWdsKSB7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgb3B0aW9ucyk7XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuaW5pdEZyb21Db250ZXh0KHRoaXMuZ2wpO1xuICB9XG4gIC8qKiBBdXRvLXBvcHVsYXRlIHRoZSB7QGxpbmsgR2xDb250ZXh0U3lzdGVtLmV4dGVuc2lvbnMgZXh0ZW5zaW9uc30uICovXG4gIGdldEV4dGVuc2lvbnMoKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBjb25zdCBjb21tb24gPSB7XG4gICAgICBhbmlzb3Ryb3BpY0ZpbHRlcmluZzogZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpLFxuICAgICAgZmxvYXRUZXh0dXJlTGluZWFyOiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIiksXG4gICAgICBzM3RjOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKSxcbiAgICAgIHMzdGNfc1JHQjogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNfc3JnYlwiKSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICBldGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGNcIiksXG4gICAgICBldGMxOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMVwiKSxcbiAgICAgIHB2cnRjOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIikgfHwgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKSxcbiAgICAgIGF0YzogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2F0Y1wiKSxcbiAgICAgIGFzdGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjXCIpLFxuICAgICAgYnB0YzogZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfY29tcHJlc3Npb25fYnB0Y1wiKSxcbiAgICAgIHJndGM6IGdsLmdldEV4dGVuc2lvbihcIkVYVF90ZXh0dXJlX2NvbXByZXNzaW9uX3JndGNcIiksXG4gICAgICBsb3NlQ29udGV4dDogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpXG4gICAgfTtcbiAgICBpZiAodGhpcy53ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHtcbiAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICBkcmF3QnVmZmVyczogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZHJhd19idWZmZXJzXCIpLFxuICAgICAgICBkZXB0aFRleHR1cmU6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2RlcHRoX3RleHR1cmVcIiksXG4gICAgICAgIHZlcnRleEFycmF5T2JqZWN0OiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKSB8fCBnbC5nZXRFeHRlbnNpb24oXCJNT1pfT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIikgfHwgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpLFxuICAgICAgICB1aW50MzJFbGVtZW50SW5kZXg6IGdsLmdldEV4dGVuc2lvbihcIk9FU19lbGVtZW50X2luZGV4X3VpbnRcIiksXG4gICAgICAgIC8vIEZsb2F0cyBhbmQgaGFsZi1mbG9hdHNcbiAgICAgICAgZmxvYXRUZXh0dXJlOiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSxcbiAgICAgICAgZmxvYXRUZXh0dXJlTGluZWFyOiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIiksXG4gICAgICAgIHRleHR1cmVIYWxmRmxvYXQ6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIiksXG4gICAgICAgIHRleHR1cmVIYWxmRmxvYXRMaW5lYXI6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpLFxuICAgICAgICB2ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEU6IGdsLmdldEV4dGVuc2lvbihcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIiksXG4gICAgICAgIHNyZ2I6IGdsLmdldEV4dGVuc2lvbihcIkVYVF9zUkdCXCIpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgY29sb3JCdWZmZXJGbG9hdDogZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHByb3Zva2VFeHQgPSBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9wcm92b2tpbmdfdmVydGV4XCIpO1xuICAgICAgaWYgKHByb3Zva2VFeHQpIHtcbiAgICAgICAgcHJvdm9rZUV4dC5wcm92b2tpbmdWZXJ0ZXhXRUJHTChwcm92b2tlRXh0LkZJUlNUX1ZFUlRFWF9DT05WRU5USU9OX1dFQkdMKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBsb3N0IHdlYmdsIGNvbnRleHRcbiAgICogQHBhcmFtIHtXZWJHTENvbnRleHRFdmVudH0gZXZlbnQgLSBUaGUgY29udGV4dCBsb3N0IGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlQ29udGV4dExvc3QoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLl9jb250ZXh0TG9zc0ZvcmNlZCkge1xuICAgICAgdGhpcy5fY29udGV4dExvc3NGb3JjZWQgPSBmYWxzZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5nbC5pc0NvbnRleHRMb3N0KCkpIHtcbiAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQ/LnJlc3RvcmVDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICAvKiogSGFuZGxlcyBhIHJlc3RvcmVkIHdlYmdsIGNvbnRleHQuICovXG4gIGhhbmRsZUNvbnRleHRSZXN0b3JlZCgpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuZW1pdCh0aGlzLmdsKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9yZW5kZXJlci52aWV3LmNhbnZhcztcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0KTtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCk7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKG51bGwpO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5sb3NlQ29udGV4dD8ubG9zZUNvbnRleHQoKTtcbiAgfVxuICAvKipcbiAgICogdGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHRvIGZvcmNlIGEgd2ViR0wgY29udGV4dCBsb3NzXG4gICAqIHRoaXMgd2lsbCByZWxlYXNlIGFsbCByZXNvdXJjZXMgb24gdGhlIEdQVS5cbiAgICogVXNlZnVsIGlmIHlvdSBuZWVkIHRvIHB1dCBQaXhpIHRvIHNsZWVwLCBhbmQgc2F2ZSBzb21lIEdQVSBtZW1vcnlcbiAgICpcbiAgICogQXMgc29vbiBhcyByZW5kZXIgaXMgY2FsbGVkIC0gYWxsIHJlc291cmNlcyB3aWxsIGJlIGNyZWF0ZWQgYWdhaW4uXG4gICAqL1xuICBmb3JjZUNvbnRleHRMb3NzKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5sb3NlQ29udGV4dD8ubG9zZUNvbnRleHQoKTtcbiAgICB0aGlzLl9jb250ZXh0TG9zc0ZvcmNlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFJlbmRlciBjb250ZXh0LlxuICAgKi9cbiAgdmFsaWRhdGVDb250ZXh0KGdsKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG4gICAgaWYgKGF0dHJpYnV0ZXMgJiYgIWF0dHJpYnV0ZXMuc3RlbmNpbCkge1xuICAgICAgd2FybihcIlByb3ZpZGVkIFdlYkdMIGNvbnRleHQgZG9lcyBub3QgaGF2ZSBhIHN0ZW5jaWwgYnVmZmVyLCBtYXNrcyBtYXkgbm90IHJlbmRlciBjb3JyZWN0bHlcIik7XG4gICAgfVxuICAgIGNvbnN0IHN1cHBvcnRzID0gdGhpcy5zdXBwb3J0cztcbiAgICBjb25zdCBpc1dlYkdsMiA9IHRoaXMud2ViR0xWZXJzaW9uID09PSAyO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgc3VwcG9ydHMudWludDMySW5kaWNlcyA9IGlzV2ViR2wyIHx8ICEhZXh0ZW5zaW9ucy51aW50MzJFbGVtZW50SW5kZXg7XG4gICAgc3VwcG9ydHMudW5pZm9ybUJ1ZmZlck9iamVjdCA9IGlzV2ViR2wyO1xuICAgIHN1cHBvcnRzLnZlcnRleEFycmF5T2JqZWN0ID0gaXNXZWJHbDIgfHwgISFleHRlbnNpb25zLnZlcnRleEFycmF5T2JqZWN0O1xuICAgIHN1cHBvcnRzLnNyZ2JUZXh0dXJlcyA9IGlzV2ViR2wyIHx8ICEhZXh0ZW5zaW9ucy5zcmdiO1xuICAgIHN1cHBvcnRzLm5vblBvd09mMndyYXBwaW5nID0gaXNXZWJHbDI7XG4gICAgc3VwcG9ydHMubm9uUG93T2YybWlwbWFwcyA9IGlzV2ViR2wyO1xuICAgIHN1cHBvcnRzLm1zYWEgPSBpc1dlYkdsMjtcbiAgICBpZiAoIXN1cHBvcnRzLnVpbnQzMkluZGljZXMpIHtcbiAgICAgIHdhcm4oXCJQcm92aWRlZCBXZWJHTCBjb250ZXh0IGRvZXMgbm90IHN1cHBvcnQgMzIgaW5kZXggYnVmZmVyLCBsYXJnZSBzY2VuZXMgbWF5IG5vdCByZW5kZXIgY29ycmVjdGx5XCIpO1xuICAgIH1cbiAgfVxufTtcbi8qKiBAaWdub3JlICovXG5fR2xDb250ZXh0U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJjb250ZXh0XCJcbn07XG4vKiogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIHN5c3RlbS4gKi9cbl9HbENvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgV2ViR0xPcHRpb25zLmNvbnRleHR9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGNvbnRleHQ6IG51bGwsXG4gIC8qKlxuICAgKiB7QGxpbmsgV2ViR0xPcHRpb25zLnByZW11bHRpcGxpZWRBbHBoYX1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxuICAvKipcbiAgICoge0BsaW5rIFdlYkdMT3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXJ9XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICAvKipcbiAgICoge0BsaW5rIFdlYkdMT3B0aW9ucy5wb3dlclByZWZlcmVuY2V9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICovXG4gIHBvd2VyUHJlZmVyZW5jZTogdm9pZCAwLFxuICAvKipcbiAgICoge0BsaW5rIFdlYkdMT3B0aW9ucy53ZWJHTFZlcnNpb259XG4gICAqIEBkZWZhdWx0IDJcbiAgICovXG4gIHByZWZlcldlYkdMVmVyc2lvbjogMlxufTtcbmxldCBHbENvbnRleHRTeXN0ZW0gPSBfR2xDb250ZXh0U3lzdGVtO1xuXG5leHBvcnQgeyBHbENvbnRleHRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsQ29udGV4dFN5c3RlbS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBHTF9GT1JNQVRTID0gLyogQF9fUFVSRV9fICovICgoR0xfRk9STUFUUzIpID0+IHtcbiAgR0xfRk9STUFUUzJbR0xfRk9STUFUUzJbXCJSR0JBXCJdID0gNjQwOF0gPSBcIlJHQkFcIjtcbiAgR0xfRk9STUFUUzJbR0xfRk9STUFUUzJbXCJSR0JcIl0gPSA2NDA3XSA9IFwiUkdCXCI7XG4gIEdMX0ZPUk1BVFMyW0dMX0ZPUk1BVFMyW1wiUkdcIl0gPSAzMzMxOV0gPSBcIlJHXCI7XG4gIEdMX0ZPUk1BVFMyW0dMX0ZPUk1BVFMyW1wiUkVEXCJdID0gNjQwM10gPSBcIlJFRFwiO1xuICBHTF9GT1JNQVRTMltHTF9GT1JNQVRTMltcIlJHQkFfSU5URUdFUlwiXSA9IDM2MjQ5XSA9IFwiUkdCQV9JTlRFR0VSXCI7XG4gIEdMX0ZPUk1BVFMyW0dMX0ZPUk1BVFMyW1wiUkdCX0lOVEVHRVJcIl0gPSAzNjI0OF0gPSBcIlJHQl9JTlRFR0VSXCI7XG4gIEdMX0ZPUk1BVFMyW0dMX0ZPUk1BVFMyW1wiUkdfSU5URUdFUlwiXSA9IDMzMzIwXSA9IFwiUkdfSU5URUdFUlwiO1xuICBHTF9GT1JNQVRTMltHTF9GT1JNQVRTMltcIlJFRF9JTlRFR0VSXCJdID0gMzYyNDRdID0gXCJSRURfSU5URUdFUlwiO1xuICBHTF9GT1JNQVRTMltHTF9GT1JNQVRTMltcIkFMUEhBXCJdID0gNjQwNl0gPSBcIkFMUEhBXCI7XG4gIEdMX0ZPUk1BVFMyW0dMX0ZPUk1BVFMyW1wiTFVNSU5BTkNFXCJdID0gNjQwOV0gPSBcIkxVTUlOQU5DRVwiO1xuICBHTF9GT1JNQVRTMltHTF9GT1JNQVRTMltcIkxVTUlOQU5DRV9BTFBIQVwiXSA9IDY0MTBdID0gXCJMVU1JTkFOQ0VfQUxQSEFcIjtcbiAgR0xfRk9STUFUUzJbR0xfRk9STUFUUzJbXCJERVBUSF9DT01QT05FTlRcIl0gPSA2NDAyXSA9IFwiREVQVEhfQ09NUE9ORU5UXCI7XG4gIEdMX0ZPUk1BVFMyW0dMX0ZPUk1BVFMyW1wiREVQVEhfU1RFTkNJTFwiXSA9IDM0MDQxXSA9IFwiREVQVEhfU1RFTkNJTFwiO1xuICByZXR1cm4gR0xfRk9STUFUUzI7XG59KShHTF9GT1JNQVRTIHx8IHt9KTtcbnZhciBHTF9UQVJHRVRTID0gLyogQF9fUFVSRV9fICovICgoR0xfVEFSR0VUUzIpID0+IHtcbiAgR0xfVEFSR0VUUzJbR0xfVEFSR0VUUzJbXCJURVhUVVJFXzJEXCJdID0gMzU1M10gPSBcIlRFWFRVUkVfMkRcIjtcbiAgR0xfVEFSR0VUUzJbR0xfVEFSR0VUUzJbXCJURVhUVVJFX0NVQkVfTUFQXCJdID0gMzQwNjddID0gXCJURVhUVVJFX0NVQkVfTUFQXCI7XG4gIEdMX1RBUkdFVFMyW0dMX1RBUkdFVFMyW1wiVEVYVFVSRV8yRF9BUlJBWVwiXSA9IDM1ODY2XSA9IFwiVEVYVFVSRV8yRF9BUlJBWVwiO1xuICBHTF9UQVJHRVRTMltHTF9UQVJHRVRTMltcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWFwiXSA9IDM0MDY5XSA9IFwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YXCI7XG4gIEdMX1RBUkdFVFMyW0dMX1RBUkdFVFMyW1wiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YXCJdID0gMzQwNzBdID0gXCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1hcIjtcbiAgR0xfVEFSR0VUUzJbR0xfVEFSR0VUUzJbXCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1lcIl0gPSAzNDA3MV0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWVwiO1xuICBHTF9UQVJHRVRTMltHTF9UQVJHRVRTMltcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWVwiXSA9IDM0MDcyXSA9IFwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZXCI7XG4gIEdMX1RBUkdFVFMyW0dMX1RBUkdFVFMyW1wiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aXCJdID0gMzQwNzNdID0gXCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1pcIjtcbiAgR0xfVEFSR0VUUzJbR0xfVEFSR0VUUzJbXCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pcIl0gPSAzNDA3NF0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWlwiO1xuICByZXR1cm4gR0xfVEFSR0VUUzI7XG59KShHTF9UQVJHRVRTIHx8IHt9KTtcbnZhciBHTF9XUkFQX01PREVTID0gLyogQF9fUFVSRV9fICovICgoR0xfV1JBUF9NT0RFUzIpID0+IHtcbiAgR0xfV1JBUF9NT0RFUzJbR0xfV1JBUF9NT0RFUzJbXCJDTEFNUFwiXSA9IDMzMDcxXSA9IFwiQ0xBTVBcIjtcbiAgR0xfV1JBUF9NT0RFUzJbR0xfV1JBUF9NT0RFUzJbXCJSRVBFQVRcIl0gPSAxMDQ5N10gPSBcIlJFUEVBVFwiO1xuICBHTF9XUkFQX01PREVTMltHTF9XUkFQX01PREVTMltcIk1JUlJPUkVEX1JFUEVBVFwiXSA9IDMzNjQ4XSA9IFwiTUlSUk9SRURfUkVQRUFUXCI7XG4gIHJldHVybiBHTF9XUkFQX01PREVTMjtcbn0pKEdMX1dSQVBfTU9ERVMgfHwge30pO1xudmFyIEdMX1RZUEVTID0gLyogQF9fUFVSRV9fICovICgoR0xfVFlQRVMyKSA9PiB7XG4gIEdMX1RZUEVTMltHTF9UWVBFUzJbXCJVTlNJR05FRF9CWVRFXCJdID0gNTEyMV0gPSBcIlVOU0lHTkVEX0JZVEVcIjtcbiAgR0xfVFlQRVMyW0dMX1RZUEVTMltcIlVOU0lHTkVEX1NIT1JUXCJdID0gNTEyM10gPSBcIlVOU0lHTkVEX1NIT1JUXCI7XG4gIEdMX1RZUEVTMltHTF9UWVBFUzJbXCJVTlNJR05FRF9TSE9SVF81XzZfNVwiXSA9IDMzNjM1XSA9IFwiVU5TSUdORURfU0hPUlRfNV82XzVcIjtcbiAgR0xfVFlQRVMyW0dMX1RZUEVTMltcIlVOU0lHTkVEX1NIT1JUXzRfNF80XzRcIl0gPSAzMjgxOV0gPSBcIlVOU0lHTkVEX1NIT1JUXzRfNF80XzRcIjtcbiAgR0xfVFlQRVMyW0dMX1RZUEVTMltcIlVOU0lHTkVEX1NIT1JUXzVfNV81XzFcIl0gPSAzMjgyMF0gPSBcIlVOU0lHTkVEX1NIT1JUXzVfNV81XzFcIjtcbiAgR0xfVFlQRVMyW0dMX1RZUEVTMltcIlVOU0lHTkVEX0lOVFwiXSA9IDUxMjVdID0gXCJVTlNJR05FRF9JTlRcIjtcbiAgR0xfVFlQRVMyW0dMX1RZUEVTMltcIlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZcIl0gPSAzNTg5OV0gPSBcIlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZcIjtcbiAgR0xfVFlQRVMyW0dMX1RZUEVTMltcIlVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVlwiXSA9IDMzNjQwXSA9IFwiVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWXCI7XG4gIEdMX1RZUEVTMltHTF9UWVBFUzJbXCJVTlNJR05FRF9JTlRfMjRfOFwiXSA9IDM0MDQyXSA9IFwiVU5TSUdORURfSU5UXzI0XzhcIjtcbiAgR0xfVFlQRVMyW0dMX1RZUEVTMltcIlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVlwiXSA9IDM1OTAyXSA9IFwiVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXCI7XG4gIEdMX1RZUEVTMltHTF9UWVBFUzJbXCJCWVRFXCJdID0gNTEyMF0gPSBcIkJZVEVcIjtcbiAgR0xfVFlQRVMyW0dMX1RZUEVTMltcIlNIT1JUXCJdID0gNTEyMl0gPSBcIlNIT1JUXCI7XG4gIEdMX1RZUEVTMltHTF9UWVBFUzJbXCJJTlRcIl0gPSA1MTI0XSA9IFwiSU5UXCI7XG4gIEdMX1RZUEVTMltHTF9UWVBFUzJbXCJGTE9BVFwiXSA9IDUxMjZdID0gXCJGTE9BVFwiO1xuICBHTF9UWVBFUzJbR0xfVFlQRVMyW1wiRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXCJdID0gMzYyNjldID0gXCJGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVZcIjtcbiAgR0xfVFlQRVMyW0dMX1RZUEVTMltcIkhBTEZfRkxPQVRcIl0gPSAzNjE5M10gPSBcIkhBTEZfRkxPQVRcIjtcbiAgcmV0dXJuIEdMX1RZUEVTMjtcbn0pKEdMX1RZUEVTIHx8IHt9KTtcblxuZXhwb3J0IHsgR0xfRk9STUFUUywgR0xfVEFSR0VUUywgR0xfVFlQRVMsIEdMX1dSQVBfTU9ERVMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiIsImltcG9ydCB7IEdMX1RZUEVTIH0gZnJvbSAnLi4vLi4vdGV4dHVyZS9jb25zdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGluZm9NYXAgPSB7XG4gIHVpbnQ4eDI6IEdMX1RZUEVTLlVOU0lHTkVEX0JZVEUsXG4gIHVpbnQ4eDQ6IEdMX1RZUEVTLlVOU0lHTkVEX0JZVEUsXG4gIHNpbnQ4eDI6IEdMX1RZUEVTLkJZVEUsXG4gIHNpbnQ4eDQ6IEdMX1RZUEVTLkJZVEUsXG4gIHVub3JtOHgyOiBHTF9UWVBFUy5VTlNJR05FRF9CWVRFLFxuICB1bm9ybTh4NDogR0xfVFlQRVMuVU5TSUdORURfQllURSxcbiAgc25vcm04eDI6IEdMX1RZUEVTLkJZVEUsXG4gIHNub3JtOHg0OiBHTF9UWVBFUy5CWVRFLFxuICB1aW50MTZ4MjogR0xfVFlQRVMuVU5TSUdORURfU0hPUlQsXG4gIHVpbnQxNng0OiBHTF9UWVBFUy5VTlNJR05FRF9TSE9SVCxcbiAgc2ludDE2eDI6IEdMX1RZUEVTLlNIT1JULFxuICBzaW50MTZ4NDogR0xfVFlQRVMuU0hPUlQsXG4gIHVub3JtMTZ4MjogR0xfVFlQRVMuVU5TSUdORURfU0hPUlQsXG4gIHVub3JtMTZ4NDogR0xfVFlQRVMuVU5TSUdORURfU0hPUlQsXG4gIHNub3JtMTZ4MjogR0xfVFlQRVMuU0hPUlQsXG4gIHNub3JtMTZ4NDogR0xfVFlQRVMuU0hPUlQsXG4gIGZsb2F0MTZ4MjogR0xfVFlQRVMuSEFMRl9GTE9BVCxcbiAgZmxvYXQxNng0OiBHTF9UWVBFUy5IQUxGX0ZMT0FULFxuICBmbG9hdDMyOiBHTF9UWVBFUy5GTE9BVCxcbiAgZmxvYXQzMngyOiBHTF9UWVBFUy5GTE9BVCxcbiAgZmxvYXQzMngzOiBHTF9UWVBFUy5GTE9BVCxcbiAgZmxvYXQzMng0OiBHTF9UWVBFUy5GTE9BVCxcbiAgdWludDMyOiBHTF9UWVBFUy5VTlNJR05FRF9JTlQsXG4gIHVpbnQzMngyOiBHTF9UWVBFUy5VTlNJR05FRF9JTlQsXG4gIHVpbnQzMngzOiBHTF9UWVBFUy5VTlNJR05FRF9JTlQsXG4gIHVpbnQzMng0OiBHTF9UWVBFUy5VTlNJR05FRF9JTlQsXG4gIHNpbnQzMjogR0xfVFlQRVMuSU5ULFxuICBzaW50MzJ4MjogR0xfVFlQRVMuSU5ULFxuICBzaW50MzJ4MzogR0xfVFlQRVMuSU5ULFxuICBzaW50MzJ4NDogR0xfVFlQRVMuSU5UXG59O1xuZnVuY3Rpb24gZ2V0R2xUeXBlRnJvbUZvcm1hdChmb3JtYXQpIHtcbiAgcmV0dXJuIGluZm9NYXBbZm9ybWF0XSA/PyBpbmZvTWFwLmZsb2F0MzI7XG59XG5cbmV4cG9ydCB7IGdldEdsVHlwZUZyb21Gb3JtYXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEdsVHlwZUZyb21Gb3JtYXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlSW5mb0Zyb21Gb3JtYXQgfSBmcm9tICcuLi8uLi9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvZ2V0QXR0cmlidXRlSW5mb0Zyb21Gb3JtYXQubWpzJztcbmltcG9ydCB7IGVuc3VyZUF0dHJpYnV0ZXMgfSBmcm9tICcuLi9zaGFkZXIvcHJvZ3JhbS9lbnN1cmVBdHRyaWJ1dGVzLm1qcyc7XG5pbXBvcnQgeyBnZXRHbFR5cGVGcm9tRm9ybWF0IH0gZnJvbSAnLi91dGlscy9nZXRHbFR5cGVGcm9tRm9ybWF0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdG9wb2xvZ3lUb0dsTWFwID0ge1xuICBcInBvaW50LWxpc3RcIjogMCxcbiAgXCJsaW5lLWxpc3RcIjogMSxcbiAgXCJsaW5lLXN0cmlwXCI6IDMsXG4gIFwidHJpYW5nbGUtbGlzdFwiOiA0LFxuICBcInRyaWFuZ2xlLXN0cmlwXCI6IDVcbn07XG5jbGFzcyBHbEdlb21ldHJ5U3lzdGVtIHtcbiAgLyoqIEBwYXJhbSByZW5kZXJlciAtIFRoZSByZW5kZXJlciB0aGlzIFN5c3RlbSB3b3JrcyBmb3IuICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZ2VvbWV0cnlWYW9IYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl9hY3RpdmVHZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlVmFvID0gbnVsbDtcbiAgICB0aGlzLmhhc1ZhbyA9IHRydWU7XG4gICAgdGhpcy5oYXNJbnN0YW5jZSA9IHRydWU7XG4gIH1cbiAgLyoqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLiAqL1xuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbCA9IHRoaXMuX3JlbmRlcmVyLmdsO1xuICAgIGlmICghdGhpcy5fcmVuZGVyZXIuY29udGV4dC5zdXBwb3J0cy52ZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1BpeGlKU10gVmVydGV4IEFycmF5IE9iamVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2VcIik7XG4gICAgfVxuICAgIGNvbnN0IG5hdGl2ZVZhb0V4dGVuc2lvbiA9IHRoaXMuX3JlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9ucy52ZXJ0ZXhBcnJheU9iamVjdDtcbiAgICBpZiAobmF0aXZlVmFvRXh0ZW5zaW9uKSB7XG4gICAgICBnbC5jcmVhdGVWZXJ0ZXhBcnJheSA9ICgpID0+IG5hdGl2ZVZhb0V4dGVuc2lvbi5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xuICAgICAgZ2wuYmluZFZlcnRleEFycmF5ID0gKHZhbykgPT4gbmF0aXZlVmFvRXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8pO1xuICAgICAgZ2wuZGVsZXRlVmVydGV4QXJyYXkgPSAodmFvKSA9PiBuYXRpdmVWYW9FeHRlbnNpb24uZGVsZXRlVmVydGV4QXJyYXlPRVModmFvKTtcbiAgICB9XG4gICAgY29uc3QgbmF0aXZlSW5zdGFuY2VkRXh0ZW5zaW9uID0gdGhpcy5fcmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRTtcbiAgICBpZiAobmF0aXZlSW5zdGFuY2VkRXh0ZW5zaW9uKSB7XG4gICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkID0gKGEsIGIsIGMsIGQpID0+IHtcbiAgICAgICAgbmF0aXZlSW5zdGFuY2VkRXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShhLCBiLCBjLCBkKTtcbiAgICAgIH07XG4gICAgICBnbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQgPSAoYSwgYiwgYywgZCwgZSkgPT4ge1xuICAgICAgICBuYXRpdmVJbnN0YW5jZWRFeHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoYSwgYiwgYywgZCwgZSk7XG4gICAgICB9O1xuICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvciA9IChhLCBiKSA9PiBuYXRpdmVJbnN0YW5jZWRFeHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGEsIGIpO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmVHZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlVmFvID0gbnVsbDtcbiAgICB0aGlzLl9nZW9tZXRyeVZhb0hhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgZ2VvbWV0cnkgc28gdGhhdCBpcyBjYW4gYmUgZHJhd24uIENyZWF0aW5nIGEgVmFvIGlmIHJlcXVpcmVkXG4gICAqIEBwYXJhbSBnZW9tZXRyeSAtIEluc3RhbmNlIG9mIGdlb21ldHJ5IHRvIGJpbmQuXG4gICAqIEBwYXJhbSBwcm9ncmFtIC0gSW5zdGFuY2Ugb2YgcHJvZ3JhbSB0byB1c2UgdmFvIGZvci5cbiAgICovXG4gIGJpbmQoZ2VvbWV0cnksIHByb2dyYW0pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICBjb25zdCB2YW8gPSB0aGlzLmdldFZhbyhnZW9tZXRyeSwgcHJvZ3JhbSk7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVZhbyAhPT0gdmFvKSB7XG4gICAgICB0aGlzLl9hY3RpdmVWYW8gPSB2YW87XG4gICAgICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCdWZmZXJzKCk7XG4gIH1cbiAgLyoqIFJlc2V0IGFuZCB1bmJpbmQgYW55IGFjdGl2ZSBWQU8gYW5kIGdlb21ldHJ5LiAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICB9XG4gIC8qKiBVcGRhdGUgYnVmZmVycyBvZiB0aGUgY3VycmVudGx5IGJvdW5kIGdlb21ldHJ5LiAqL1xuICB1cGRhdGVCdWZmZXJzKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fYWN0aXZlR2VvbWV0cnk7XG4gICAgY29uc3QgYnVmZmVyU3lzdGVtID0gdGhpcy5fcmVuZGVyZXIuYnVmZmVyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZ2VvbWV0cnkuYnVmZmVyc1tpXTtcbiAgICAgIGJ1ZmZlclN5c3RlbS51cGRhdGVCdWZmZXIoYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGNvbXBhdGliaWxpdHkgYmV0d2VlbiBhIGdlb21ldHJ5IGFuZCBhIHByb2dyYW1cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gR2VvbWV0cnkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBwcm9ncmFtIC0gUHJvZ3JhbSBpbnN0YW5jZS5cbiAgICovXG4gIGNoZWNrQ29tcGF0aWJpbGl0eShnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgY29uc3Qgc2hhZGVyQXR0cmlidXRlcyA9IHByb2dyYW0uX2F0dHJpYnV0ZURhdGE7XG4gICAgZm9yIChjb25zdCBqIGluIHNoYWRlckF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghZ2VvbWV0cnlBdHRyaWJ1dGVzW2pdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc2hhZGVyIGFuZCBnZW9tZXRyeSBpbmNvbXBhdGlibGUsIGdlb21ldHJ5IG1pc3NpbmcgdGhlIFwiJHtqfVwiIGF0dHJpYnV0ZWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGFrZXMgYSBnZW9tZXRyeSBhbmQgcHJvZ3JhbSBhbmQgZ2VuZXJhdGVzIGEgdW5pcXVlIHNpZ25hdHVyZSBmb3IgdGhlbS5cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gVG8gZ2V0IHNpZ25hdHVyZSBmcm9tLlxuICAgKiBAcGFyYW0gcHJvZ3JhbSAtIFRvIHRlc3QgZ2VvbWV0cnkgYWdhaW5zdC5cbiAgICogQHJldHVybnMgLSBVbmlxdWUgc2lnbmF0dXJlIG9mIHRoZSBnZW9tZXRyeSBhbmQgcHJvZ3JhbVxuICAgKi9cbiAgZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgY29uc3QgYXR0cmlicyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgY29uc3Qgc2hhZGVyQXR0cmlidXRlcyA9IHByb2dyYW0uX2F0dHJpYnV0ZURhdGE7XG4gICAgY29uc3Qgc3RyaW5ncyA9IFtcImdcIiwgZ2VvbWV0cnkudWlkXTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gYXR0cmlicykge1xuICAgICAgaWYgKHNoYWRlckF0dHJpYnV0ZXNbaV0pIHtcbiAgICAgICAgc3RyaW5ncy5wdXNoKGksIHNoYWRlckF0dHJpYnV0ZXNbaV0ubG9jYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyaW5ncy5qb2luKFwiLVwiKTtcbiAgfVxuICBnZXRWYW8oZ2VvbWV0cnksIHByb2dyYW0pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnlWYW9IYXNoW2dlb21ldHJ5LnVpZF0/Lltwcm9ncmFtLl9rZXldIHx8IHRoaXMuaW5pdEdlb21ldHJ5VmFvKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBvciBnZXRzIFZhbyB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZSBhcyB0aGUgZ2VvbWV0cnkgYW5kIHN0b3JlcyBpdCBvbiB0aGUgZ2VvbWV0cnkuXG4gICAqIElmIHZhbyBpcyBjcmVhdGVkLCBpdCBpcyBib3VuZCBhdXRvbWF0aWNhbGx5LiBXZSB1c2UgYSBzaGFkZXIgdG8gaW5mZXIgd2hhdCBhbmQgaG93IHRvIHNldCB1cCB0aGVcbiAgICogYXR0cmlidXRlIGxvY2F0aW9ucy5cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gSW5zdGFuY2Ugb2YgZ2VvbWV0cnkgdG8gdG8gZ2VuZXJhdGUgVmFvIGZvci5cbiAgICogQHBhcmFtIHByb2dyYW1cbiAgICogQHBhcmFtIF9pbmNSZWZDb3VudCAtIEluY3JlbWVudCByZWZDb3VudCBvZiBhbGwgZ2VvbWV0cnkgYnVmZmVycy5cbiAgICovXG4gIGluaXRHZW9tZXRyeVZhbyhnZW9tZXRyeSwgcHJvZ3JhbSwgX2luY1JlZkNvdW50ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2w7XG4gICAgY29uc3QgYnVmZmVyU3lzdGVtID0gdGhpcy5fcmVuZGVyZXIuYnVmZmVyO1xuICAgIHRoaXMuX3JlbmRlcmVyLnNoYWRlci5fZ2V0UHJvZ3JhbURhdGEocHJvZ3JhbSk7XG4gICAgdGhpcy5jaGVja0NvbXBhdGliaWxpdHkoZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICBpZiAoIXRoaXMuX2dlb21ldHJ5VmFvSGFzaFtnZW9tZXRyeS51aWRdKSB7XG4gICAgICB0aGlzLl9nZW9tZXRyeVZhb0hhc2hbZ2VvbWV0cnkudWlkXSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgZ2VvbWV0cnkub24oXCJkZXN0cm95XCIsIHRoaXMub25HZW9tZXRyeURlc3Ryb3ksIHRoaXMpO1xuICAgIH1cbiAgICBjb25zdCB2YW9PYmplY3RIYXNoID0gdGhpcy5fZ2VvbWV0cnlWYW9IYXNoW2dlb21ldHJ5LnVpZF07XG4gICAgbGV0IHZhbyA9IHZhb09iamVjdEhhc2hbc2lnbmF0dXJlXTtcbiAgICBpZiAodmFvKSB7XG4gICAgICB2YW9PYmplY3RIYXNoW3Byb2dyYW0uX2tleV0gPSB2YW87XG4gICAgICByZXR1cm4gdmFvO1xuICAgIH1cbiAgICBlbnN1cmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcm9ncmFtLl9hdHRyaWJ1dGVEYXRhKTtcbiAgICBjb25zdCBidWZmZXJzID0gZ2VvbWV0cnkuYnVmZmVycztcbiAgICB2YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICAgIGJ1ZmZlclN5c3RlbS5iaW5kKGJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZhdGVWYW8oZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIHZhb09iamVjdEhhc2hbcHJvZ3JhbS5fa2V5XSA9IHZhbztcbiAgICB2YW9PYmplY3RIYXNoW3NpZ25hdHVyZV0gPSB2YW87XG4gICAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICAgIHJldHVybiB2YW87XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2VzIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0gZ2VvbWV0cnkgLSBHZW9tZXRyeSB3aXRoIGJ1ZmZlcnMuIE9ubHkgVkFPIHdpbGwgYmUgZGlzcG9zZWRcbiAgICogQHBhcmFtIFtjb250ZXh0TG9zdD1mYWxzZV0gLSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBkZWxldGVWZXJ0ZXhBcnJheVxuICAgKi9cbiAgb25HZW9tZXRyeURlc3Ryb3koZ2VvbWV0cnksIGNvbnRleHRMb3N0KSB7XG4gICAgY29uc3QgdmFvT2JqZWN0SGFzaCA9IHRoaXMuX2dlb21ldHJ5VmFvSGFzaFtnZW9tZXRyeS51aWRdO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBpZiAodmFvT2JqZWN0SGFzaCkge1xuICAgICAgaWYgKGNvbnRleHRMb3N0KSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB2YW9PYmplY3RIYXNoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVZhbyAhPT0gdmFvT2JqZWN0SGFzaFtpXSkge1xuICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2wuZGVsZXRlVmVydGV4QXJyYXkodmFvT2JqZWN0SGFzaFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2dlb21ldHJ5VmFvSGFzaFtnZW9tZXRyeS51aWRdID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2UgYWxsIFdlYkdMIHJlc291cmNlcyBvZiBhbGwgbWFuYWdlZCBnZW9tZXRyaWVzLlxuICAgKiBAcGFyYW0gW2NvbnRleHRMb3N0PWZhbHNlXSAtIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGBnbC5kZWxldGVgIGNhbGxzXG4gICAqL1xuICBkZXN0cm95QWxsKGNvbnRleHRMb3N0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2dlb21ldHJ5VmFvSGFzaCkge1xuICAgICAgaWYgKGNvbnRleHRMb3N0KSB7XG4gICAgICAgIGZvciAoY29uc3QgaiBpbiB0aGlzLl9nZW9tZXRyeVZhb0hhc2hbaV0pIHtcbiAgICAgICAgICBjb25zdCB2YW9PYmplY3RIYXNoID0gdGhpcy5fZ2VvbWV0cnlWYW9IYXNoW2ldO1xuICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVWYW8gIT09IHZhb09iamVjdEhhc2gpIHtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdsLmRlbGV0ZVZlcnRleEFycmF5KHZhb09iamVjdEhhc2hbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9nZW9tZXRyeVZhb0hhc2hbaV0gPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGUgdmVydGV4IGFycmF5IG9iamVjdC5cbiAgICogQHBhcmFtIGdlb21ldHJ5IC0gR2VvbWV0cnkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBwcm9ncmFtIC0gU2hhZGVyIHByb2dyYW0gaW5zdGFuY2UuXG4gICAqL1xuICBhY3RpdmF0ZVZhbyhnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2w7XG4gICAgY29uc3QgYnVmZmVyU3lzdGVtID0gdGhpcy5fcmVuZGVyZXIuYnVmZmVyO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgYnVmZmVyU3lzdGVtLmJpbmQoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpO1xuICAgIH1cbiAgICBsZXQgbGFzdEJ1ZmZlciA9IG51bGw7XG4gICAgZm9yIChjb25zdCBqIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XG4gICAgICBjb25zdCBidWZmZXIgPSBhdHRyaWJ1dGUuYnVmZmVyO1xuICAgICAgY29uc3QgZ2xCdWZmZXIgPSBidWZmZXJTeXN0ZW0uZ2V0R2xCdWZmZXIoYnVmZmVyKTtcbiAgICAgIGNvbnN0IHByb2dyYW1BdHRyaWIgPSBwcm9ncmFtLl9hdHRyaWJ1dGVEYXRhW2pdO1xuICAgICAgaWYgKHByb2dyYW1BdHRyaWIpIHtcbiAgICAgICAgaWYgKGxhc3RCdWZmZXIgIT09IGdsQnVmZmVyKSB7XG4gICAgICAgICAgYnVmZmVyU3lzdGVtLmJpbmQoYnVmZmVyKTtcbiAgICAgICAgICBsYXN0QnVmZmVyID0gZ2xCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBhdHRyaWJ1dGUubG9jYXRpb247XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlSW5mbyA9IGdldEF0dHJpYnV0ZUluZm9Gcm9tRm9ybWF0KGF0dHJpYnV0ZS5mb3JtYXQpO1xuICAgICAgICBjb25zdCB0eXBlID0gZ2V0R2xUeXBlRnJvbUZvcm1hdChhdHRyaWJ1dGUuZm9ybWF0KTtcbiAgICAgICAgaWYgKHByb2dyYW1BdHRyaWIuZm9ybWF0Py5zdWJzdHJpbmcoMSwgNCkgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJJUG9pbnRlcihcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgYXR0cmlidXRlSW5mby5zaXplLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZS5zdHJpZGUsXG4gICAgICAgICAgICBhdHRyaWJ1dGUub2Zmc2V0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBhdHRyaWJ1dGVJbmZvLnNpemUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgYXR0cmlidXRlSW5mby5ub3JtYWxpc2VkLFxuICAgICAgICAgICAgYXR0cmlidXRlLnN0cmlkZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZS5vZmZzZXRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNJbnN0YW5jZSkge1xuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IGF0dHJpYnV0ZS5kaXZpc29yID8/IDE7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGxvY2F0aW9uLCBkaXZpc29yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvbWV0cnkgZXJyb3IsIEdQVSBJbnN0YW5jaW5nIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2VcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEcmF3cyB0aGUgY3VycmVudGx5IGJvdW5kIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0gdG9wb2xvZ3kgLSBUaGUgdHlwZSBwcmltaXRpdmUgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gc2l6ZSAtIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gYmUgcmVuZGVyZWQuIElmIG5vdCBzcGVjaWZpZWQsIGFsbCB2ZXJ0aWNlcyBhZnRlciB0aGVcbiAgICogIHN0YXJ0aW5nIHZlcnRleCB3aWxsIGJlIGRyYXduLlxuICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgc3RhcnRpbmcgdmVydGV4IGluIHRoZSBnZW9tZXRyeSB0byBzdGFydCBkcmF3aW5nIGZyb20uIElmIG5vdCBzcGVjaWZpZWQsXG4gICAqICBkcmF3aW5nIHdpbGwgc3RhcnQgZnJvbSB0aGUgZmlyc3QgdmVydGV4LlxuICAgKiBAcGFyYW0gaW5zdGFuY2VDb3VudCAtIFRoZSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzZXQgb2YgZWxlbWVudHMgdG8gZXhlY3V0ZS4gSWYgbm90IHNwZWNpZmllZCxcbiAgICogIGFsbCBpbnN0YW5jZXMgd2lsbCBiZSBkcmF3bi5cbiAgICovXG4gIGRyYXcodG9wb2xvZ3ksIHNpemUsIHN0YXJ0LCBpbnN0YW5jZUNvdW50KSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9hY3RpdmVHZW9tZXRyeTtcbiAgICBjb25zdCBnbFRvcG9sb2d5ID0gdG9wb2xvZ3lUb0dsTWFwW2dlb21ldHJ5LnRvcG9sb2d5IHx8IHRvcG9sb2d5XTtcbiAgICBpbnN0YW5jZUNvdW50IHx8IChpbnN0YW5jZUNvdW50ID0gZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCk7XG4gICAgaWYgKGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XG4gICAgICBjb25zdCBieXRlU2l6ZSA9IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICBjb25zdCBnbFR5cGUgPSBieXRlU2l6ZSA9PT0gMiA/IGdsLlVOU0lHTkVEX1NIT1JUIDogZ2wuVU5TSUdORURfSU5UO1xuICAgICAgaWYgKGluc3RhbmNlQ291bnQgPiAxKSB7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZChnbFRvcG9sb2d5LCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbFR5cGUsIChzdGFydCB8fCAwKSAqIGJ5dGVTaXplLCBpbnN0YW5jZUNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbFRvcG9sb2d5LCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbFR5cGUsIChzdGFydCB8fCAwKSAqIGJ5dGVTaXplKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlQ291bnQgPiAxKSB7XG4gICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKGdsVG9wb2xvZ3ksIHN0YXJ0IHx8IDAsIHNpemUgfHwgZ2VvbWV0cnkuZ2V0U2l6ZSgpLCBpbnN0YW5jZUNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuZHJhd0FycmF5cyhnbFRvcG9sb2d5LCBzdGFydCB8fCAwLCBzaXplIHx8IGdlb21ldHJ5LmdldFNpemUoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBVbmJpbmQvcmVzZXQgZXZlcnl0aGluZy4gKi9cbiAgdW5iaW5kKCkge1xuICAgIHRoaXMuZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICAgIHRoaXMuX2FjdGl2ZVZhbyA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZVZhbyA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR2xHZW9tZXRyeVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiZ2VvbWV0cnlcIlxufTtcblxuZXhwb3J0IHsgR2xHZW9tZXRyeVN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2xHZW9tZXRyeVN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4uL3NoYXJlZC9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSAnLi4vc2hhcmVkL3NoYWRlci9TaGFkZXIubWpzJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi4vc2hhcmVkL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlU291cmNlIH0gZnJvbSAnLi4vc2hhcmVkL3RleHR1cmUvc291cmNlcy9UZXh0dXJlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgR2xQcm9ncmFtIH0gZnJvbSAnLi9zaGFkZXIvR2xQcm9ncmFtLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgYmlnVHJpYW5nbGVHZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSh7XG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBhUG9zaXRpb246IFtcbiAgICAgIC0xLFxuICAgICAgLTEsXG4gICAgICAvLyBCb3R0b20gbGVmdCBjb3JuZXJcbiAgICAgIDMsXG4gICAgICAtMSxcbiAgICAgIC8vIEJvdHRvbSByaWdodCBjb3JuZXIsIGV4dGVuZGluZyBiZXlvbmQgcmlnaHQgZWRnZVxuICAgICAgLTEsXG4gICAgICAzXG4gICAgICAvLyBUb3AgbGVmdCBjb3JuZXIsIGV4dGVuZGluZyBiZXlvbmQgdG9wIGVkZ2VcbiAgICBdXG4gIH1cbn0pO1xuY29uc3QgX0dsQmFja0J1ZmZlclN5c3RlbSA9IGNsYXNzIF9HbEJhY2tCdWZmZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIC8qKiBpZiB0cnVlLCB0aGUgYmFjayBidWZmZXIgaXMgdXNlZCAqL1xuICAgIHRoaXMudXNlQmFja0J1ZmZlciA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZUJhY2tCdWZmZXJUaGlzUmVuZGVyID0gZmFsc2U7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBpbml0KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgdXNlQmFja0J1ZmZlciwgYW50aWFsaWFzIH0gPSB7IC4uLl9HbEJhY2tCdWZmZXJTeXN0ZW0uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLnVzZUJhY2tCdWZmZXIgPSB1c2VCYWNrQnVmZmVyO1xuICAgIHRoaXMuX2FudGlhbGlhcyA9IGFudGlhbGlhcztcbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmNvbnRleHQuc3VwcG9ydHMubXNhYSkge1xuICAgICAgd2FybihcImFudGlhbGlhc2luZywgaXMgbm90IHN1cHBvcnRlZCBvbiB3aGVuIHVzaW5nIHRoZSBiYWNrIGJ1ZmZlclwiKTtcbiAgICAgIHRoaXMuX2FudGlhbGlhcyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlLmZvcjJkKCk7XG4gICAgY29uc3QgYmlnVHJpYW5nbGVQcm9ncmFtID0gbmV3IEdsUHJvZ3JhbSh7XG4gICAgICB2ZXJ0ZXg6IGBcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgICAgICAgICAgICAgb3V0IHZlYzIgdlV2O1xuXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uLCAwLjAsIDEuMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdlV2ID0gKGFQb3NpdGlvbiArIDEuMCkgLyAyLjA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmxpcCBkZW0gVVZzXG4gICAgICAgICAgICAgICAgICAgIHZVdi55ID0gMS4wIC0gdlV2Lnk7XG4gICAgICAgICAgICAgICAgfWAsXG4gICAgICBmcmFnbWVudDogYFxuICAgICAgICAgICAgICAgIGluIHZlYzIgdlV2O1xuICAgICAgICAgICAgICAgIG91dCB2ZWM0IGZpbmFsQ29sb3I7XG5cbiAgICAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcblxuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxDb2xvciA9IHRleHR1cmUodVRleHR1cmUsIHZVdik7XG4gICAgICAgICAgICAgICAgfWAsXG4gICAgICBuYW1lOiBcImJpZy10cmlhbmdsZVwiXG4gICAgfSk7XG4gICAgdGhpcy5fYmlnVHJpYW5nbGVTaGFkZXIgPSBuZXcgU2hhZGVyKHtcbiAgICAgIGdsUHJvZ3JhbTogYmlnVHJpYW5nbGVQcm9ncmFtLFxuICAgICAgcmVzb3VyY2VzOiB7XG4gICAgICAgIHVUZXh0dXJlOiBUZXh0dXJlLldISVRFLnNvdXJjZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIFJlbmRlclRhcmdldFN5c3RlbSBpcyBzdGFydGVkLiBUaGlzIGlzIHdoZXJlXG4gICAqIHdlIHJlcGxhY2UgdGhlIHRhcmdldCB3aXRoIHRoZSBiYWNrIGJ1ZmZlciBpZiByZXF1aXJlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhpcyByZW5kZXIuXG4gICAqL1xuICByZW5kZXJTdGFydChvcHRpb25zKSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmdldFJlbmRlclRhcmdldChvcHRpb25zLnRhcmdldCk7XG4gICAgdGhpcy5fdXNlQmFja0J1ZmZlclRoaXNSZW5kZXIgPSB0aGlzLnVzZUJhY2tCdWZmZXIgJiYgISFyZW5kZXJUYXJnZXQuaXNSb290O1xuICAgIGlmICh0aGlzLl91c2VCYWNrQnVmZmVyVGhpc1JlbmRlcikge1xuICAgICAgY29uc3QgcmVuZGVyVGFyZ2V0MiA9IHRoaXMuX3JlbmRlcmVyLnJlbmRlclRhcmdldC5nZXRSZW5kZXJUYXJnZXQob3B0aW9ucy50YXJnZXQpO1xuICAgICAgdGhpcy5fdGFyZ2V0VGV4dHVyZSA9IHJlbmRlclRhcmdldDIuY29sb3JUZXh0dXJlO1xuICAgICAgb3B0aW9ucy50YXJnZXQgPSB0aGlzLl9nZXRCYWNrQnVmZmVyVGV4dHVyZShyZW5kZXJUYXJnZXQyLmNvbG9yVGV4dHVyZSk7XG4gICAgfVxuICB9XG4gIHJlbmRlckVuZCgpIHtcbiAgICB0aGlzLl9wcmVzZW50QmFja0J1ZmZlcigpO1xuICB9XG4gIF9wcmVzZW50QmFja0J1ZmZlcigpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHJlbmRlcmVyLnJlbmRlclRhcmdldC5maW5pc2hSZW5kZXJQYXNzKCk7XG4gICAgaWYgKCF0aGlzLl91c2VCYWNrQnVmZmVyVGhpc1JlbmRlcilcbiAgICAgIHJldHVybjtcbiAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQuYmluZCh0aGlzLl90YXJnZXRUZXh0dXJlLCBmYWxzZSk7XG4gICAgdGhpcy5fYmlnVHJpYW5nbGVTaGFkZXIucmVzb3VyY2VzLnVUZXh0dXJlID0gdGhpcy5fYmFja0J1ZmZlclRleHR1cmUuc291cmNlO1xuICAgIHJlbmRlcmVyLmVuY29kZXIuZHJhdyh7XG4gICAgICBnZW9tZXRyeTogYmlnVHJpYW5nbGVHZW9tZXRyeSxcbiAgICAgIHNoYWRlcjogdGhpcy5fYmlnVHJpYW5nbGVTaGFkZXIsXG4gICAgICBzdGF0ZTogdGhpcy5fc3RhdGVcbiAgICB9KTtcbiAgfVxuICBfZ2V0QmFja0J1ZmZlclRleHR1cmUodGFyZ2V0U291cmNlVGV4dHVyZSkge1xuICAgIHRoaXMuX2JhY2tCdWZmZXJUZXh0dXJlID0gdGhpcy5fYmFja0J1ZmZlclRleHR1cmUgfHwgbmV3IFRleHR1cmUoe1xuICAgICAgc291cmNlOiBuZXcgVGV4dHVyZVNvdXJjZSh7XG4gICAgICAgIHdpZHRoOiB0YXJnZXRTb3VyY2VUZXh0dXJlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRhcmdldFNvdXJjZVRleHR1cmUuaGVpZ2h0LFxuICAgICAgICByZXNvbHV0aW9uOiB0YXJnZXRTb3VyY2VUZXh0dXJlLl9yZXNvbHV0aW9uLFxuICAgICAgICBhbnRpYWxpYXM6IHRoaXMuX2FudGlhbGlhc1xuICAgICAgfSlcbiAgICB9KTtcbiAgICB0aGlzLl9iYWNrQnVmZmVyVGV4dHVyZS5zb3VyY2UucmVzaXplKFxuICAgICAgdGFyZ2V0U291cmNlVGV4dHVyZS53aWR0aCxcbiAgICAgIHRhcmdldFNvdXJjZVRleHR1cmUuaGVpZ2h0LFxuICAgICAgdGFyZ2V0U291cmNlVGV4dHVyZS5fcmVzb2x1dGlvblxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdWZmZXJUZXh0dXJlO1xuICB9XG4gIC8qKiBkZXN0cm95cyB0aGUgYmFjayBidWZmZXIgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fYmFja0J1ZmZlclRleHR1cmUpIHtcbiAgICAgIHRoaXMuX2JhY2tCdWZmZXJUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2JhY2tCdWZmZXJUZXh0dXJlID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG4vKiogQGlnbm9yZSAqL1xuX0dsQmFja0J1ZmZlclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiYmFja0J1ZmZlclwiLFxuICBwcmlvcml0eTogMVxufTtcbi8qKiBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBiYWNrIGJ1ZmZlciBzeXN0ZW0gKi9cbl9HbEJhY2tCdWZmZXJTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8qKiBpZiB0cnVlIHdpbGwgdXNlIHRoZSBiYWNrIGJ1ZmZlciB3aGVyZSByZXF1aXJlZCAqL1xuICB1c2VCYWNrQnVmZmVyOiBmYWxzZVxufTtcbmxldCBHbEJhY2tCdWZmZXJTeXN0ZW0gPSBfR2xCYWNrQnVmZmVyU3lzdGVtO1xuXG5leHBvcnQgeyBHbEJhY2tCdWZmZXJTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsQmFja0J1ZmZlclN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR2xDb2xvck1hc2tTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2NvbG9yTWFza0NhY2hlID0gMTU7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBzZXRNYXNrKGNvbG9yTWFzaykge1xuICAgIGlmICh0aGlzLl9jb2xvck1hc2tDYWNoZSA9PT0gY29sb3JNYXNrKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvbG9yTWFza0NhY2hlID0gY29sb3JNYXNrO1xuICAgIHRoaXMuX3JlbmRlcmVyLmdsLmNvbG9yTWFzayhcbiAgICAgICEhKGNvbG9yTWFzayAmIDgpLFxuICAgICAgISEoY29sb3JNYXNrICYgNCksXG4gICAgICAhIShjb2xvck1hc2sgJiAyKSxcbiAgICAgICEhKGNvbG9yTWFzayAmIDEpXG4gICAgKTtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdsQ29sb3JNYXNrU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJjb2xvck1hc2tcIlxufTtcblxuZXhwb3J0IHsgR2xDb2xvck1hc2tTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsQ29sb3JNYXNrU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHbEVuY29kZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuY29tbWFuZEZpbmlzaGVkID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBzZXRHZW9tZXRyeShnZW9tZXRyeSwgc2hhZGVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChnZW9tZXRyeSwgc2hhZGVyLmdsUHJvZ3JhbSk7XG4gIH1cbiAgZmluaXNoUmVuZGVyUGFzcygpIHtcbiAgfVxuICBkcmF3KG9wdGlvbnMpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IHsgZ2VvbWV0cnksIHNoYWRlciwgc3RhdGUsIHNraXBTeW5jLCB0b3BvbG9neTogdHlwZSwgc2l6ZSwgc3RhcnQsIGluc3RhbmNlQ291bnQgfSA9IG9wdGlvbnM7XG4gICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyLCBza2lwU3luYyk7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChnZW9tZXRyeSwgcmVuZGVyZXIuc2hhZGVyLl9hY3RpdmVQcm9ncmFtKTtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHJlbmRlcmVyLnN0YXRlLnNldChzdGF0ZSk7XG4gICAgfVxuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcodHlwZSwgc2l6ZSwgc3RhcnQsIGluc3RhbmNlQ291bnQgPz8gZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HbEVuY29kZXJTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbVxuICBdLFxuICBuYW1lOiBcImVuY29kZXJcIlxufTtcblxuZXhwb3J0IHsgR2xFbmNvZGVyU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbEVuY29kZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgR3B1U3RlbmNpbE1vZGVzVG9QaXhpIH0gZnJvbSAnLi4vZ3B1L3N0YXRlL0dwdVN0ZW5jaWxNb2Rlc1RvUGl4aS5tanMnO1xuaW1wb3J0IHsgU1RFTkNJTF9NT0RFUyB9IGZyb20gJy4uL3NoYXJlZC9zdGF0ZS9jb25zdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdsU3RlbmNpbFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fc3RlbmNpbENhY2hlID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBzdGVuY2lsUmVmZXJlbmNlOiAwLFxuICAgICAgc3RlbmNpbE1vZGU6IFNURU5DSUxfTU9ERVMuTk9ORVxuICAgIH07XG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0U3RlbmNpbFN0YXRlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0Lm9uUmVuZGVyVGFyZ2V0Q2hhbmdlLmFkZCh0aGlzKTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgdGhpcy5fZ2wgPSBnbDtcbiAgICB0aGlzLl9jb21wYXJpc29uRnVuY01hcHBpbmcgPSB7XG4gICAgICBhbHdheXM6IGdsLkFMV0FZUyxcbiAgICAgIG5ldmVyOiBnbC5ORVZFUixcbiAgICAgIGVxdWFsOiBnbC5FUVVBTCxcbiAgICAgIFwibm90LWVxdWFsXCI6IGdsLk5PVEVRVUFMLFxuICAgICAgbGVzczogZ2wuTEVTUyxcbiAgICAgIFwibGVzcy1lcXVhbFwiOiBnbC5MRVFVQUwsXG4gICAgICBncmVhdGVyOiBnbC5HUkVBVEVSLFxuICAgICAgXCJncmVhdGVyLWVxdWFsXCI6IGdsLkdFUVVBTFxuICAgIH07XG4gICAgdGhpcy5fc3RlbmNpbE9wc01hcHBpbmcgPSB7XG4gICAgICBrZWVwOiBnbC5LRUVQLFxuICAgICAgemVybzogZ2wuWkVSTyxcbiAgICAgIHJlcGxhY2U6IGdsLlJFUExBQ0UsXG4gICAgICBpbnZlcnQ6IGdsLklOVkVSVCxcbiAgICAgIFwiaW5jcmVtZW50LWNsYW1wXCI6IGdsLklOQ1IsXG4gICAgICBcImRlY3JlbWVudC1jbGFtcFwiOiBnbC5ERUNSLFxuICAgICAgXCJpbmNyZW1lbnQtd3JhcFwiOiBnbC5JTkNSX1dSQVAsXG4gICAgICBcImRlY3JlbWVudC13cmFwXCI6IGdsLkRFQ1JfV1JBUFxuICAgIH07XG4gICAgdGhpcy5fc3RlbmNpbENhY2hlLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGVuY2lsQ2FjaGUuc3RlbmNpbE1vZGUgPSBTVEVOQ0lMX01PREVTLk5PTkU7XG4gICAgdGhpcy5fc3RlbmNpbENhY2hlLnN0ZW5jaWxSZWZlcmVuY2UgPSAwO1xuICB9XG4gIG9uUmVuZGVyVGFyZ2V0Q2hhbmdlKHJlbmRlclRhcmdldCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQgPT09IHJlbmRlclRhcmdldClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgbGV0IHN0ZW5jaWxTdGF0ZSA9IHRoaXMuX3JlbmRlclRhcmdldFN0ZW5jaWxTdGF0ZVtyZW5kZXJUYXJnZXQudWlkXTtcbiAgICBpZiAoIXN0ZW5jaWxTdGF0ZSkge1xuICAgICAgc3RlbmNpbFN0YXRlID0gdGhpcy5fcmVuZGVyVGFyZ2V0U3RlbmNpbFN0YXRlW3JlbmRlclRhcmdldC51aWRdID0ge1xuICAgICAgICBzdGVuY2lsTW9kZTogU1RFTkNJTF9NT0RFUy5ESVNBQkxFRCxcbiAgICAgICAgc3RlbmNpbFJlZmVyZW5jZTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGVuY2lsTW9kZShzdGVuY2lsU3RhdGUuc3RlbmNpbE1vZGUsIHN0ZW5jaWxTdGF0ZS5zdGVuY2lsUmVmZXJlbmNlKTtcbiAgfVxuICBzZXRTdGVuY2lsTW9kZShzdGVuY2lsTW9kZSwgc3RlbmNpbFJlZmVyZW5jZSkge1xuICAgIGNvbnN0IHN0ZW5jaWxTdGF0ZSA9IHRoaXMuX3JlbmRlclRhcmdldFN0ZW5jaWxTdGF0ZVt0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQudWlkXTtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IG1vZGUgPSBHcHVTdGVuY2lsTW9kZXNUb1BpeGlbc3RlbmNpbE1vZGVdO1xuICAgIGNvbnN0IF9zdGVuY2lsQ2FjaGUgPSB0aGlzLl9zdGVuY2lsQ2FjaGU7XG4gICAgc3RlbmNpbFN0YXRlLnN0ZW5jaWxNb2RlID0gc3RlbmNpbE1vZGU7XG4gICAgc3RlbmNpbFN0YXRlLnN0ZW5jaWxSZWZlcmVuY2UgPSBzdGVuY2lsUmVmZXJlbmNlO1xuICAgIGlmIChzdGVuY2lsTW9kZSA9PT0gU1RFTkNJTF9NT0RFUy5ESVNBQkxFRCkge1xuICAgICAgaWYgKHRoaXMuX3N0ZW5jaWxDYWNoZS5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX3N0ZW5jaWxDYWNoZS5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zdGVuY2lsQ2FjaGUuZW5hYmxlZCkge1xuICAgICAgdGhpcy5fc3RlbmNpbENhY2hlLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgfVxuICAgIGlmIChzdGVuY2lsTW9kZSAhPT0gX3N0ZW5jaWxDYWNoZS5zdGVuY2lsTW9kZSB8fCBfc3RlbmNpbENhY2hlLnN0ZW5jaWxSZWZlcmVuY2UgIT09IHN0ZW5jaWxSZWZlcmVuY2UpIHtcbiAgICAgIF9zdGVuY2lsQ2FjaGUuc3RlbmNpbE1vZGUgPSBzdGVuY2lsTW9kZTtcbiAgICAgIF9zdGVuY2lsQ2FjaGUuc3RlbmNpbFJlZmVyZW5jZSA9IHN0ZW5jaWxSZWZlcmVuY2U7XG4gICAgICBnbC5zdGVuY2lsRnVuYyh0aGlzLl9jb21wYXJpc29uRnVuY01hcHBpbmdbbW9kZS5zdGVuY2lsQmFjay5jb21wYXJlXSwgc3RlbmNpbFJlZmVyZW5jZSwgMjU1KTtcbiAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCB0aGlzLl9zdGVuY2lsT3BzTWFwcGluZ1ttb2RlLnN0ZW5jaWxCYWNrLnBhc3NPcF0pO1xuICAgIH1cbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdsU3RlbmNpbFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwic3RlbmNpbFwiXG59O1xuXG5leHBvcnQgeyBHbFN0ZW5jaWxTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsU3RlbmNpbFN5c3RlbS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFdHU0xfVE9fU1RENDBfU0laRSA9IHtcbiAgZjMyOiA0LFxuICBcInZlYzI8ZjMyPlwiOiA4LFxuICBcInZlYzM8ZjMyPlwiOiAxMixcbiAgXCJ2ZWM0PGYzMj5cIjogMTYsXG4gIFwibWF0MngyPGYzMj5cIjogMTYgKiAyLFxuICBcIm1hdDN4MzxmMzI+XCI6IDE2ICogMyxcbiAgXCJtYXQ0eDQ8ZjMyPlwiOiAxNiAqIDRcbiAgLy8gVE9ETyAtIG5vdCBlc3NlbnRpYWwgZm9yIG5vdyBidXQgc3VwcG9ydCB0aGVzZSBpbiB0aGUgZnV0dXJlXG4gIC8vIGludDogICAgICA0LFxuICAvLyBpdmVjMjogICAgOCxcbiAgLy8gaXZlYzM6ICAgIDEyLFxuICAvLyBpdmVjNDogICAgMTYsXG4gIC8vIHVpbnQ6ICAgICA0LFxuICAvLyB1dmVjMjogICAgOCxcbiAgLy8gdXZlYzM6ICAgIDEyLFxuICAvLyB1dmVjNDogICAgMTYsXG4gIC8vIGJvb2w6ICAgICA0LFxuICAvLyBidmVjMjogICAgOCxcbiAgLy8gYnZlYzM6ICAgIDEyLFxuICAvLyBidmVjNDogICAgMTYsXG4gIC8vIG1hdDI6ICAgICAxNiAqIDIsXG4gIC8vIG1hdDM6ICAgICAxNiAqIDMsXG4gIC8vIG1hdDQ6ICAgICAxNiAqIDQsXG59O1xuZnVuY3Rpb24gY3JlYXRlVWJvRWxlbWVudHNTVEQ0MCh1bmlmb3JtRGF0YSkge1xuICBjb25zdCB1Ym9FbGVtZW50cyA9IHVuaWZvcm1EYXRhLm1hcCgoZGF0YSkgPT4gKHtcbiAgICBkYXRhLFxuICAgIG9mZnNldDogMCxcbiAgICBzaXplOiAwXG4gIH0pKTtcbiAgbGV0IHNpemUgPSAwO1xuICBsZXQgY2h1bmtTaXplID0gMDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdWJvRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB1Ym9FbGVtZW50ID0gdWJvRWxlbWVudHNbaV07XG4gICAgc2l6ZSA9IFdHU0xfVE9fU1RENDBfU0laRVt1Ym9FbGVtZW50LmRhdGEudHlwZV07XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdHlwZSAke3Vib0VsZW1lbnQuZGF0YS50eXBlfWApO1xuICAgIH1cbiAgICBpZiAodWJvRWxlbWVudC5kYXRhLnNpemUgPiAxKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgMTYpICogdWJvRWxlbWVudC5kYXRhLnNpemU7XG4gICAgfVxuICAgIHVib0VsZW1lbnQuc2l6ZSA9IHNpemU7XG4gICAgaWYgKGNodW5rU2l6ZSAlIHNpemUgIT09IDAgJiYgY2h1bmtTaXplIDwgMTYpIHtcbiAgICAgIGNvbnN0IGxpbmVVcFZhbHVlID0gY2h1bmtTaXplICUgc2l6ZSAlIDE2O1xuICAgICAgY2h1bmtTaXplICs9IGxpbmVVcFZhbHVlO1xuICAgICAgb2Zmc2V0ICs9IGxpbmVVcFZhbHVlO1xuICAgIH1cbiAgICBpZiAoY2h1bmtTaXplICsgc2l6ZSA+IDE2KSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLmNlaWwob2Zmc2V0IC8gMTYpICogMTY7XG4gICAgICB1Ym9FbGVtZW50Lm9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgY2h1bmtTaXplID0gc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdWJvRWxlbWVudC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBjaHVua1NpemUgKz0gc2l6ZTtcbiAgICAgIG9mZnNldCArPSBzaXplO1xuICAgIH1cbiAgfVxuICBvZmZzZXQgPSBNYXRoLmNlaWwob2Zmc2V0IC8gMTYpICogMTY7XG4gIHJldHVybiB7IHVib0VsZW1lbnRzLCBzaXplOiBvZmZzZXQgfTtcbn1cblxuZXhwb3J0IHsgV0dTTF9UT19TVEQ0MF9TSVpFLCBjcmVhdGVVYm9FbGVtZW50c1NURDQwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVVYm9FbGVtZW50c1NURDQwLm1qcy5tYXBcbiIsImltcG9ydCB7IFdHU0xfVE9fU1RENDBfU0laRSB9IGZyb20gJy4vY3JlYXRlVWJvRWxlbWVudHNTVEQ0MC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdlbmVyYXRlQXJyYXlTeW5jU1RENDAodWJvRWxlbWVudCwgb2Zmc2V0VG9BZGQpIHtcbiAgY29uc3Qgcm93U2l6ZSA9IE1hdGgubWF4KFdHU0xfVE9fU1RENDBfU0laRVt1Ym9FbGVtZW50LmRhdGEudHlwZV0gLyAxNiwgMSk7XG4gIGNvbnN0IGVsZW1lbnRTaXplID0gdWJvRWxlbWVudC5kYXRhLnZhbHVlLmxlbmd0aCAvIHVib0VsZW1lbnQuZGF0YS5zaXplO1xuICBjb25zdCByZW1haW5kZXIgPSAoNCAtIGVsZW1lbnRTaXplICUgNCkgJSA0O1xuICByZXR1cm4gYFxuICAgICAgICB2ID0gdXYuJHt1Ym9FbGVtZW50LmRhdGEubmFtZX07XG4gICAgICAgIG9mZnNldCArPSAke29mZnNldFRvQWRkfTtcblxuICAgICAgICBhcnJheU9mZnNldCA9IG9mZnNldDtcblxuICAgICAgICB0ID0gMDtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaSA8ICR7dWJvRWxlbWVudC5kYXRhLnNpemUgKiByb3dTaXplfTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgJHtlbGVtZW50U2l6ZX07IGorKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkYXRhW2FycmF5T2Zmc2V0KytdID0gdlt0KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtyZW1haW5kZXIgIT09IDAgPyBgYXJyYXlPZmZzZXQgKz0gJHtyZW1haW5kZXJ9O2AgOiBcIlwifVxuICAgICAgICB9XG4gICAgYDtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVBcnJheVN5bmNTVEQ0MCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVBcnJheVN5bmNTVEQ0MC5tanMubWFwXG4iLCJpbXBvcnQgeyBjcmVhdGVVYm9TeW5jRnVuY3Rpb24gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib1N5bmNGdW5jdGlvbi5tanMnO1xuaW1wb3J0IHsgdWJvU3luY0Z1bmN0aW9uc1NURDQwIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3NoYWRlci91dGlscy91Ym9TeW5jRnVuY3Rpb25zLm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUFycmF5U3luY1NURDQwIH0gZnJvbSAnLi9nZW5lcmF0ZUFycmF5U3luY1NURDQwLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY3JlYXRlVWJvU3luY0Z1bmN0aW9uU1RENDAodWJvRWxlbWVudHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVVib1N5bmNGdW5jdGlvbihcbiAgICB1Ym9FbGVtZW50cyxcbiAgICBcInVib1N0ZDQwXCIsXG4gICAgZ2VuZXJhdGVBcnJheVN5bmNTVEQ0MCxcbiAgICB1Ym9TeW5jRnVuY3Rpb25zU1RENDBcbiAgKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlVWJvU3luY0Z1bmN0aW9uU1RENDAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVVib1N5bmNTVEQ0MC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBVYm9TeXN0ZW0gfSBmcm9tICcuLi9zaGFyZWQvc2hhZGVyL1Vib1N5c3RlbS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlVWJvRWxlbWVudHNTVEQ0MCB9IGZyb20gJy4vc2hhZGVyL3V0aWxzL2NyZWF0ZVVib0VsZW1lbnRzU1RENDAubWpzJztcbmltcG9ydCB7IGNyZWF0ZVVib1N5bmNGdW5jdGlvblNURDQwIH0gZnJvbSAnLi9zaGFkZXIvdXRpbHMvY3JlYXRlVWJvU3luY1NURDQwLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR2xVYm9TeXN0ZW0gZXh0ZW5kcyBVYm9TeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBjcmVhdGVVYm9FbGVtZW50czogY3JlYXRlVWJvRWxlbWVudHNTVEQ0MCxcbiAgICAgIGdlbmVyYXRlVWJvU3luYzogY3JlYXRlVWJvU3luY0Z1bmN0aW9uU1RENDBcbiAgICB9KTtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdsVWJvU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW0V4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW1dLFxuICBuYW1lOiBcInVib1wiXG59O1xuXG5leHBvcnQgeyBHbFVib1N5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2xVYm9TeXN0ZW0ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHbFJlbmRlclRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMud2lkdGggPSAtMTtcbiAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgIHRoaXMubXNhYSA9IGZhbHNlO1xuICAgIHRoaXMubXNhYVJlbmRlckJ1ZmZlciA9IFtdO1xuICB9XG59XG5cbmV4cG9ydCB7IEdsUmVuZGVyVGFyZ2V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbFJlbmRlclRhcmdldC5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBDTEVBUiB9IGZyb20gJy4uL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBHbFJlbmRlclRhcmdldCB9IGZyb20gJy4uL0dsUmVuZGVyVGFyZ2V0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgR2xSZW5kZXJUYXJnZXRBZGFwdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fY2xlYXJDb2xvckNhY2hlID0gWzAsIDAsIDAsIDBdO1xuICAgIHRoaXMuX3ZpZXdQb3J0Q2FjaGUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gIH1cbiAgaW5pdChyZW5kZXJlciwgcmVuZGVyVGFyZ2V0U3lzdGVtKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXRTeXN0ZW0gPSByZW5kZXJUYXJnZXRTeXN0ZW07XG4gICAgcmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLmFkZCh0aGlzKTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIHRoaXMuX2NsZWFyQ29sb3JDYWNoZSA9IFswLCAwLCAwLCAwXTtcbiAgICB0aGlzLl92aWV3UG9ydENhY2hlID0gbmV3IFJlY3RhbmdsZSgpO1xuICB9XG4gIGNvcHlUb1RleHR1cmUoc291cmNlUmVuZGVyU3VyZmFjZVRleHR1cmUsIGRlc3RpbmF0aW9uVGV4dHVyZSwgb3JpZ2luU3JjLCBzaXplLCBvcmlnaW5EZXN0KSB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0U3lzdGVtID0gdGhpcy5fcmVuZGVyVGFyZ2V0U3lzdGVtO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgY29uc3QgZ2xSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXRTeXN0ZW0uZ2V0R3B1UmVuZGVyVGFyZ2V0KHNvdXJjZVJlbmRlclN1cmZhY2VUZXh0dXJlKTtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgIHRoaXMuZmluaXNoUmVuZGVyUGFzcyhzb3VyY2VSZW5kZXJTdXJmYWNlVGV4dHVyZSk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbFJlbmRlclRhcmdldC5yZXNvbHZlVGFyZ2V0RnJhbWVidWZmZXIpO1xuICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZChkZXN0aW5hdGlvblRleHR1cmUsIDApO1xuICAgIGdsLmNvcHlUZXhTdWJJbWFnZTJEKFxuICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgIDAsXG4gICAgICBvcmlnaW5EZXN0LngsXG4gICAgICBvcmlnaW5EZXN0LnksXG4gICAgICBvcmlnaW5TcmMueCxcbiAgICAgIG9yaWdpblNyYy55LFxuICAgICAgc2l6ZS53aWR0aCxcbiAgICAgIHNpemUuaGVpZ2h0XG4gICAgKTtcbiAgICByZXR1cm4gZGVzdGluYXRpb25UZXh0dXJlO1xuICB9XG4gIHN0YXJ0UmVuZGVyUGFzcyhyZW5kZXJUYXJnZXQsIGNsZWFyID0gdHJ1ZSwgY2xlYXJDb2xvciwgdmlld3BvcnQpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRTeXN0ZW0gPSB0aGlzLl9yZW5kZXJUYXJnZXRTeXN0ZW07XG4gICAgY29uc3Qgc291cmNlID0gcmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZTtcbiAgICBjb25zdCBncHVSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXRTeXN0ZW0uZ2V0R3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgbGV0IHZpZXdQb3J0WSA9IHZpZXdwb3J0Lnk7XG4gICAgaWYgKHJlbmRlclRhcmdldC5pc1Jvb3QpIHtcbiAgICAgIHZpZXdQb3J0WSA9IHNvdXJjZS5waXhlbEhlaWdodCAtIHZpZXdwb3J0LmhlaWdodDtcbiAgICB9XG4gICAgcmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZXMuZm9yRWFjaCgodGV4dHVyZSkgPT4ge1xuICAgICAgdGhpcy5fcmVuZGVyZXIudGV4dHVyZS51bmJpbmQodGV4dHVyZSk7XG4gICAgfSk7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9yZW5kZXJlci5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdwdVJlbmRlclRhcmdldC5mcmFtZWJ1ZmZlcik7XG4gICAgY29uc3Qgdmlld1BvcnRDYWNoZSA9IHRoaXMuX3ZpZXdQb3J0Q2FjaGU7XG4gICAgaWYgKHZpZXdQb3J0Q2FjaGUueCAhPT0gdmlld3BvcnQueCB8fCB2aWV3UG9ydENhY2hlLnkgIT09IHZpZXdQb3J0WSB8fCB2aWV3UG9ydENhY2hlLndpZHRoICE9PSB2aWV3cG9ydC53aWR0aCB8fCB2aWV3UG9ydENhY2hlLmhlaWdodCAhPT0gdmlld3BvcnQuaGVpZ2h0KSB7XG4gICAgICB2aWV3UG9ydENhY2hlLnggPSB2aWV3cG9ydC54O1xuICAgICAgdmlld1BvcnRDYWNoZS55ID0gdmlld1BvcnRZO1xuICAgICAgdmlld1BvcnRDYWNoZS53aWR0aCA9IHZpZXdwb3J0LndpZHRoO1xuICAgICAgdmlld1BvcnRDYWNoZS5oZWlnaHQgPSB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICBnbC52aWV3cG9ydChcbiAgICAgICAgdmlld3BvcnQueCxcbiAgICAgICAgdmlld1BvcnRZLFxuICAgICAgICB2aWV3cG9ydC53aWR0aCxcbiAgICAgICAgdmlld3BvcnQuaGVpZ2h0XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWdwdVJlbmRlclRhcmdldC5kZXB0aFN0ZW5jaWxSZW5kZXJCdWZmZXIgJiYgKHJlbmRlclRhcmdldC5zdGVuY2lsIHx8IHJlbmRlclRhcmdldC5kZXB0aCkpIHtcbiAgICAgIHRoaXMuX2luaXRTdGVuY2lsKGdwdVJlbmRlclRhcmdldCk7XG4gICAgfVxuICAgIHRoaXMuY2xlYXIocmVuZGVyVGFyZ2V0LCBjbGVhciwgY2xlYXJDb2xvcik7XG4gIH1cbiAgZmluaXNoUmVuZGVyUGFzcyhyZW5kZXJUYXJnZXQpIHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRTeXN0ZW0gPSB0aGlzLl9yZW5kZXJUYXJnZXRTeXN0ZW07XG4gICAgY29uc3QgZ2xSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXRTeXN0ZW0uZ2V0R3B1UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgaWYgKCFnbFJlbmRlclRhcmdldC5tc2FhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2w7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbFJlbmRlclRhcmdldC5yZXNvbHZlVGFyZ2V0RnJhbWVidWZmZXIpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5SRUFEX0ZSQU1FQlVGRkVSLCBnbFJlbmRlclRhcmdldC5mcmFtZWJ1ZmZlcik7XG4gICAgZ2wuYmxpdEZyYW1lYnVmZmVyKFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBnbFJlbmRlclRhcmdldC53aWR0aCxcbiAgICAgIGdsUmVuZGVyVGFyZ2V0LmhlaWdodCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgZ2xSZW5kZXJUYXJnZXQud2lkdGgsXG4gICAgICBnbFJlbmRlclRhcmdldC5oZWlnaHQsXG4gICAgICBnbC5DT0xPUl9CVUZGRVJfQklULFxuICAgICAgZ2wuTkVBUkVTVFxuICAgICk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbFJlbmRlclRhcmdldC5mcmFtZWJ1ZmZlcik7XG4gIH1cbiAgaW5pdEdwdVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgY29uc3QgZ2xSZW5kZXJUYXJnZXQgPSBuZXcgR2xSZW5kZXJUYXJnZXQoKTtcbiAgICBpZiAocmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZS5yZXNvdXJjZSA9PT0gcmVuZGVyZXIuZ2wuY2FudmFzKSB7XG4gICAgICBnbFJlbmRlclRhcmdldC5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgICByZXR1cm4gZ2xSZW5kZXJUYXJnZXQ7XG4gICAgfVxuICAgIHRoaXMuX2luaXRDb2xvcihyZW5kZXJUYXJnZXQsIGdsUmVuZGVyVGFyZ2V0KTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIHJldHVybiBnbFJlbmRlclRhcmdldDtcbiAgfVxuICBkZXN0cm95R3B1UmVuZGVyVGFyZ2V0KGdwdVJlbmRlclRhcmdldCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2w7XG4gICAgaWYgKGdwdVJlbmRlclRhcmdldC5mcmFtZWJ1ZmZlcikge1xuICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZ3B1UmVuZGVyVGFyZ2V0LmZyYW1lYnVmZmVyKTtcbiAgICAgIGdwdVJlbmRlclRhcmdldC5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChncHVSZW5kZXJUYXJnZXQucmVzb2x2ZVRhcmdldEZyYW1lYnVmZmVyKSB7XG4gICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihncHVSZW5kZXJUYXJnZXQucmVzb2x2ZVRhcmdldEZyYW1lYnVmZmVyKTtcbiAgICAgIGdwdVJlbmRlclRhcmdldC5yZXNvbHZlVGFyZ2V0RnJhbWVidWZmZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZ3B1UmVuZGVyVGFyZ2V0LmRlcHRoU3RlbmNpbFJlbmRlckJ1ZmZlcikge1xuICAgICAgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGdwdVJlbmRlclRhcmdldC5kZXB0aFN0ZW5jaWxSZW5kZXJCdWZmZXIpO1xuICAgICAgZ3B1UmVuZGVyVGFyZ2V0LmRlcHRoU3RlbmNpbFJlbmRlckJ1ZmZlciA9IG51bGw7XG4gICAgfVxuICAgIGdwdVJlbmRlclRhcmdldC5tc2FhUmVuZGVyQnVmZmVyLmZvckVhY2goKHJlbmRlckJ1ZmZlcikgPT4ge1xuICAgICAgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHJlbmRlckJ1ZmZlcik7XG4gICAgfSk7XG4gICAgZ3B1UmVuZGVyVGFyZ2V0Lm1zYWFSZW5kZXJCdWZmZXIgPSBudWxsO1xuICB9XG4gIGNsZWFyKF9yZW5kZXJUYXJnZXQsIGNsZWFyLCBjbGVhckNvbG9yKSB7XG4gICAgaWYgKCFjbGVhcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZW5kZXJUYXJnZXRTeXN0ZW0gPSB0aGlzLl9yZW5kZXJUYXJnZXRTeXN0ZW07XG4gICAgaWYgKHR5cGVvZiBjbGVhciA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGNsZWFyID0gY2xlYXIgPyBDTEVBUi5BTEwgOiBDTEVBUi5OT05FO1xuICAgIH1cbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdsO1xuICAgIGlmIChjbGVhciAmIENMRUFSLkNPTE9SKSB7XG4gICAgICBjbGVhckNvbG9yID8/IChjbGVhckNvbG9yID0gcmVuZGVyVGFyZ2V0U3lzdGVtLmRlZmF1bHRDbGVhckNvbG9yKTtcbiAgICAgIGNvbnN0IGNsZWFyQ29sb3JDYWNoZSA9IHRoaXMuX2NsZWFyQ29sb3JDYWNoZTtcbiAgICAgIGNvbnN0IGNsZWFyQ29sb3JBcnJheSA9IGNsZWFyQ29sb3I7XG4gICAgICBpZiAoY2xlYXJDb2xvckNhY2hlWzBdICE9PSBjbGVhckNvbG9yQXJyYXlbMF0gfHwgY2xlYXJDb2xvckNhY2hlWzFdICE9PSBjbGVhckNvbG9yQXJyYXlbMV0gfHwgY2xlYXJDb2xvckNhY2hlWzJdICE9PSBjbGVhckNvbG9yQXJyYXlbMl0gfHwgY2xlYXJDb2xvckNhY2hlWzNdICE9PSBjbGVhckNvbG9yQXJyYXlbM10pIHtcbiAgICAgICAgY2xlYXJDb2xvckNhY2hlWzBdID0gY2xlYXJDb2xvckFycmF5WzBdO1xuICAgICAgICBjbGVhckNvbG9yQ2FjaGVbMV0gPSBjbGVhckNvbG9yQXJyYXlbMV07XG4gICAgICAgIGNsZWFyQ29sb3JDYWNoZVsyXSA9IGNsZWFyQ29sb3JBcnJheVsyXTtcbiAgICAgICAgY2xlYXJDb2xvckNhY2hlWzNdID0gY2xlYXJDb2xvckFycmF5WzNdO1xuICAgICAgICBnbC5jbGVhckNvbG9yKGNsZWFyQ29sb3JBcnJheVswXSwgY2xlYXJDb2xvckFycmF5WzFdLCBjbGVhckNvbG9yQXJyYXlbMl0sIGNsZWFyQ29sb3JBcnJheVszXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGdsLmNsZWFyKGNsZWFyKTtcbiAgfVxuICByZXNpemVHcHVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KSB7XG4gICAgaWYgKHJlbmRlclRhcmdldC5pc1Jvb3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0U3lzdGVtID0gdGhpcy5fcmVuZGVyVGFyZ2V0U3lzdGVtO1xuICAgIGNvbnN0IGdsUmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0U3lzdGVtLmdldEdwdVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgIHRoaXMuX3Jlc2l6ZUNvbG9yKHJlbmRlclRhcmdldCwgZ2xSZW5kZXJUYXJnZXQpO1xuICAgIGlmIChyZW5kZXJUYXJnZXQuc3RlbmNpbCB8fCByZW5kZXJUYXJnZXQuZGVwdGgpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZVN0ZW5jaWwoZ2xSZW5kZXJUYXJnZXQpO1xuICAgIH1cbiAgfVxuICBfaW5pdENvbG9yKHJlbmRlclRhcmdldCwgZ2xSZW5kZXJUYXJnZXQpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgY29uc3QgcmVzb2x2ZVRhcmdldEZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbFJlbmRlclRhcmdldC5yZXNvbHZlVGFyZ2V0RnJhbWVidWZmZXIgPSByZXNvbHZlVGFyZ2V0RnJhbWVidWZmZXI7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCByZXNvbHZlVGFyZ2V0RnJhbWVidWZmZXIpO1xuICAgIGdsUmVuZGVyVGFyZ2V0LndpZHRoID0gcmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZS5zb3VyY2UucGl4ZWxXaWR0aDtcbiAgICBnbFJlbmRlclRhcmdldC5oZWlnaHQgPSByZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlLnNvdXJjZS5waXhlbEhlaWdodDtcbiAgICByZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlcy5mb3JFYWNoKChjb2xvclRleHR1cmUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGNvbG9yVGV4dHVyZS5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlLmFudGlhbGlhcykge1xuICAgICAgICBpZiAocmVuZGVyZXIuY29udGV4dC5zdXBwb3J0cy5tc2FhKSB7XG4gICAgICAgICAgZ2xSZW5kZXJUYXJnZXQubXNhYSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihcIltSZW5kZXJUZXh0dXJlXSBBbnRpYWxpYXNpbmcgb24gdGV4dHVyZXMgaXMgbm90IHN1cHBvcnRlZCBpbiBXZWJHTDFcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZFNvdXJjZShzb3VyY2UsIDApO1xuICAgICAgY29uc3QgZ2xTb3VyY2UgPSByZW5kZXJlci50ZXh0dXJlLmdldEdsU291cmNlKHNvdXJjZSk7XG4gICAgICBjb25zdCBnbFRleHR1cmUgPSBnbFNvdXJjZS50ZXh0dXJlO1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksXG4gICAgICAgIDM1NTMsXG4gICAgICAgIC8vIHRleHR1cmUudGFyZ2V0LFxuICAgICAgICBnbFRleHR1cmUsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgfSk7XG4gICAgaWYgKGdsUmVuZGVyVGFyZ2V0Lm1zYWEpIHtcbiAgICAgIGNvbnN0IHZpZXdGcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBnbFJlbmRlclRhcmdldC5mcmFtZWJ1ZmZlciA9IHZpZXdGcmFtZWJ1ZmZlcjtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdmlld0ZyYW1lYnVmZmVyKTtcbiAgICAgIHJlbmRlclRhcmdldC5jb2xvclRleHR1cmVzLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgICAgY29uc3QgbXNhYVJlbmRlckJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgICBnbFJlbmRlclRhcmdldC5tc2FhUmVuZGVyQnVmZmVyW2ldID0gbXNhYVJlbmRlckJ1ZmZlcjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbFJlbmRlclRhcmdldC5mcmFtZWJ1ZmZlciA9IHJlc29sdmVUYXJnZXRGcmFtZWJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy5fcmVzaXplQ29sb3IocmVuZGVyVGFyZ2V0LCBnbFJlbmRlclRhcmdldCk7XG4gIH1cbiAgX3Jlc2l6ZUNvbG9yKHJlbmRlclRhcmdldCwgZ2xSZW5kZXJUYXJnZXQpIHtcbiAgICBjb25zdCBzb3VyY2UgPSByZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlLnNvdXJjZTtcbiAgICBnbFJlbmRlclRhcmdldC53aWR0aCA9IHNvdXJjZS5waXhlbFdpZHRoO1xuICAgIGdsUmVuZGVyVGFyZ2V0LmhlaWdodCA9IHNvdXJjZS5waXhlbEhlaWdodDtcbiAgICByZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlcy5mb3JFYWNoKChjb2xvclRleHR1cmUsIGkpID0+IHtcbiAgICAgIGlmIChpID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb2xvclRleHR1cmUuc291cmNlLnJlc2l6ZShzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQsIHNvdXJjZS5fcmVzb2x1dGlvbik7XG4gICAgfSk7XG4gICAgaWYgKGdsUmVuZGVyVGFyZ2V0Lm1zYWEpIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgICAgY29uc3Qgdmlld0ZyYW1lYnVmZmVyID0gZ2xSZW5kZXJUYXJnZXQuZnJhbWVidWZmZXI7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHZpZXdGcmFtZWJ1ZmZlcik7XG4gICAgICByZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlcy5mb3JFYWNoKChjb2xvclRleHR1cmUsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgc291cmNlMiA9IGNvbG9yVGV4dHVyZS5zb3VyY2U7XG4gICAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZFNvdXJjZShzb3VyY2UyLCAwKTtcbiAgICAgICAgY29uc3QgZ2xTb3VyY2UgPSByZW5kZXJlci50ZXh0dXJlLmdldEdsU291cmNlKHNvdXJjZTIpO1xuICAgICAgICBjb25zdCBnbEludGVybmFsRm9ybWF0ID0gZ2xTb3VyY2UuaW50ZXJuYWxGb3JtYXQ7XG4gICAgICAgIGNvbnN0IG1zYWFSZW5kZXJCdWZmZXIgPSBnbFJlbmRlclRhcmdldC5tc2FhUmVuZGVyQnVmZmVyW2ldO1xuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKFxuICAgICAgICAgIGdsLlJFTkRFUkJVRkZFUixcbiAgICAgICAgICBtc2FhUmVuZGVyQnVmZmVyXG4gICAgICAgICk7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShcbiAgICAgICAgICBnbC5SRU5ERVJCVUZGRVIsXG4gICAgICAgICAgNCxcbiAgICAgICAgICBnbEludGVybmFsRm9ybWF0LFxuICAgICAgICAgIHNvdXJjZTIucGl4ZWxXaWR0aCxcbiAgICAgICAgICBzb3VyY2UyLnBpeGVsSGVpZ2h0XG4gICAgICAgICk7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKFxuICAgICAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSxcbiAgICAgICAgICBnbC5SRU5ERVJCVUZGRVIsXG4gICAgICAgICAgbXNhYVJlbmRlckJ1ZmZlclxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9pbml0U3RlbmNpbChnbFJlbmRlclRhcmdldCkge1xuICAgIGlmIChnbFJlbmRlclRhcmdldC5mcmFtZWJ1ZmZlciA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdsO1xuICAgIGNvbnN0IGRlcHRoU3RlbmNpbFJlbmRlckJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgIGdsUmVuZGVyVGFyZ2V0LmRlcHRoU3RlbmNpbFJlbmRlckJ1ZmZlciA9IGRlcHRoU3RlbmNpbFJlbmRlckJ1ZmZlcjtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKFxuICAgICAgZ2wuUkVOREVSQlVGRkVSLFxuICAgICAgZGVwdGhTdGVuY2lsUmVuZGVyQnVmZmVyXG4gICAgKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihcbiAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULFxuICAgICAgZ2wuUkVOREVSQlVGRkVSLFxuICAgICAgZGVwdGhTdGVuY2lsUmVuZGVyQnVmZmVyXG4gICAgKTtcbiAgICB0aGlzLl9yZXNpemVTdGVuY2lsKGdsUmVuZGVyVGFyZ2V0KTtcbiAgfVxuICBfcmVzaXplU3RlbmNpbChnbFJlbmRlclRhcmdldCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2w7XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihcbiAgICAgIGdsLlJFTkRFUkJVRkZFUixcbiAgICAgIGdsUmVuZGVyVGFyZ2V0LmRlcHRoU3RlbmNpbFJlbmRlckJ1ZmZlclxuICAgICk7XG4gICAgaWYgKGdsUmVuZGVyVGFyZ2V0Lm1zYWEpIHtcbiAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShcbiAgICAgICAgZ2wuUkVOREVSQlVGRkVSLFxuICAgICAgICA0LFxuICAgICAgICBnbC5ERVBUSDI0X1NURU5DSUw4LFxuICAgICAgICBnbFJlbmRlclRhcmdldC53aWR0aCxcbiAgICAgICAgZ2xSZW5kZXJUYXJnZXQuaGVpZ2h0XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKFxuICAgICAgICBnbC5SRU5ERVJCVUZGRVIsXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAyID8gZ2wuREVQVEgyNF9TVEVOQ0lMOCA6IGdsLkRFUFRIX1NURU5DSUwsXG4gICAgICAgIGdsUmVuZGVyVGFyZ2V0LndpZHRoLFxuICAgICAgICBnbFJlbmRlclRhcmdldC5oZWlnaHRcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEdsUmVuZGVyVGFyZ2V0QWRhcHRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2xSZW5kZXJUYXJnZXRBZGFwdG9yLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFJlbmRlclRhcmdldFN5c3RlbSB9IGZyb20gJy4uLy4uL3NoYXJlZC9yZW5kZXJUYXJnZXQvUmVuZGVyVGFyZ2V0U3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHbFJlbmRlclRhcmdldEFkYXB0b3IgfSBmcm9tICcuL0dsUmVuZGVyVGFyZ2V0QWRhcHRvci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdsUmVuZGVyVGFyZ2V0U3lzdGVtIGV4dGVuZHMgUmVuZGVyVGFyZ2V0U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgdGhpcy5hZGFwdG9yID0gbmV3IEdsUmVuZGVyVGFyZ2V0QWRhcHRvcigpO1xuICAgIHRoaXMuYWRhcHRvci5pbml0KHJlbmRlcmVyLCB0aGlzKTtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdsUmVuZGVyVGFyZ2V0U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW0V4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW1dLFxuICBuYW1lOiBcInJlbmRlclRhcmdldFwiXG59O1xuXG5leHBvcnQgeyBHbFJlbmRlclRhcmdldFN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2xSZW5kZXJUYXJnZXRTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgQnVmZmVyUmVzb3VyY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvYnVmZmVyL0J1ZmZlclJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4uLy4uL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvVGV4dHVyZVNvdXJjZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdlbmVyYXRlU2hhZGVyU3luY0NvZGUoc2hhZGVyLCBzaGFkZXJTeXN0ZW0pIHtcbiAgY29uc3QgZnVuY0ZyYWdtZW50cyA9IFtdO1xuICBjb25zdCBoZWFkZXJGcmFnbWVudHMgPSBbYFxuICAgICAgICB2YXIgZyA9IHMuZ3JvdXBzO1xuICAgICAgICB2YXIgc1MgPSByLnNoYWRlcjtcbiAgICAgICAgdmFyIHAgPSBzLmdsUHJvZ3JhbTtcbiAgICAgICAgdmFyIHVnUyA9IHIudW5pZm9ybUdyb3VwO1xuICAgICAgICB2YXIgcmVzb3VyY2VzO1xuICAgIGBdO1xuICBsZXQgYWRkZWRUZXh0cmVTeXN0ZW0gPSBmYWxzZTtcbiAgbGV0IGJsb2NrSW5kZXggPSAwO1xuICBsZXQgdGV4dHVyZUNvdW50ID0gMDtcbiAgY29uc3QgcHJvZ3JhbURhdGEgPSBzaGFkZXJTeXN0ZW0uX2dldFByb2dyYW1EYXRhKHNoYWRlci5nbFByb2dyYW0pO1xuICBmb3IgKGNvbnN0IGkgaW4gc2hhZGVyLmdyb3Vwcykge1xuICAgIGNvbnN0IGdyb3VwID0gc2hhZGVyLmdyb3Vwc1tpXTtcbiAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgcmVzb3VyY2VzID0gZ1ske2l9XS5yZXNvdXJjZXM7XG4gICAgICAgIGApO1xuICAgIGZvciAoY29uc3QgaiBpbiBncm91cC5yZXNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gZ3JvdXAucmVzb3VyY2VzW2pdO1xuICAgICAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgVW5pZm9ybUdyb3VwKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZS51Ym8pIHtcbiAgICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgICAgICAgICAgc1MuYmluZFVuaWZvcm1CbG9jayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXNbJHtqfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc1MuX3VuaWZvcm1CaW5kTWFwWyR7aX1bJHtqfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtibG9ja0luZGV4Kyt9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgICAgICAgICAgdWdTLnVwZGF0ZVVuaWZvcm1Hcm91cChyZXNvdXJjZXNbJHtqfV0sIHAsIHNEKTtcbiAgICAgICAgICAgICAgICAgICAgYCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBCdWZmZXJSZXNvdXJjZSkge1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgICAgICBzUy5iaW5kVW5pZm9ybUJsb2NrKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzWyR7an1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgc1MuX3VuaWZvcm1CaW5kTWFwWyR7aX1bJHtqfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAke2Jsb2NrSW5kZXgrK31cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBUZXh0dXJlU291cmNlKSB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1OYW1lID0gc2hhZGVyLl91bmlmb3JtQmluZE1hcFtpXVtqXTtcbiAgICAgICAgY29uc3QgdW5pZm9ybURhdGEgPSBwcm9ncmFtRGF0YS51bmlmb3JtRGF0YVt1bmlmb3JtTmFtZV07XG4gICAgICAgIGlmICh1bmlmb3JtRGF0YSkge1xuICAgICAgICAgIGlmICghYWRkZWRUZXh0cmVTeXN0ZW0pIHtcbiAgICAgICAgICAgIGFkZGVkVGV4dHJlU3lzdGVtID0gdHJ1ZTtcbiAgICAgICAgICAgIGhlYWRlckZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0UyA9IHIudGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaGFkZXJTeXN0ZW0uX2dsLnVuaWZvcm0xaSh1bmlmb3JtRGF0YS5sb2NhdGlvbiwgdGV4dHVyZUNvdW50KTtcbiAgICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgICAgICAgICAgdFMuYmluZChyZXNvdXJjZXNbJHtqfV0sICR7dGV4dHVyZUNvdW50fSk7XG4gICAgICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgIHRleHR1cmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGZ1bmN0aW9uU291cmNlID0gWy4uLmhlYWRlckZyYWdtZW50cywgLi4uZnVuY0ZyYWdtZW50c10uam9pbihcIlxcblwiKTtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInJcIiwgXCJzXCIsIFwic0RcIiwgZnVuY3Rpb25Tb3VyY2UpO1xufVxuXG5leHBvcnQgeyBnZW5lcmF0ZVNoYWRlclN5bmNDb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmF0ZVNoYWRlclN5bmNDb2RlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgSUdMVW5pZm9ybURhdGEge1xufVxuY2xhc3MgR2xQcm9ncmFtRGF0YSB7XG4gIC8qKlxuICAgKiBNYWtlcyBhIG5ldyBQaXhpIHByb2dyYW0uXG4gICAqIEBwYXJhbSBwcm9ncmFtIC0gd2ViZ2wgcHJvZ3JhbVxuICAgKiBAcGFyYW0gdW5pZm9ybURhdGEgLSB1bmlmb3Jtc1xuICAgKi9cbiAgY29uc3RydWN0b3IocHJvZ3JhbSwgdW5pZm9ybURhdGEpIHtcbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgIHRoaXMudW5pZm9ybURhdGEgPSB1bmlmb3JtRGF0YTtcbiAgICB0aGlzLnVuaWZvcm1Hcm91cHMgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm1EaXJ0eUdyb3VwcyA9IHt9O1xuICAgIHRoaXMudW5pZm9ybUJsb2NrQmluZGluZ3MgPSB7fTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhpcyBwcm9ncmFtLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5pZm9ybURhdGEgPSBudWxsO1xuICAgIHRoaXMudW5pZm9ybUdyb3VwcyA9IG51bGw7XG4gICAgdGhpcy51bmlmb3JtRGlydHlHcm91cHMgPSBudWxsO1xuICAgIHRoaXMudW5pZm9ybUJsb2NrQmluZGluZ3MgPSBudWxsO1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2xQcm9ncmFtRGF0YSwgSUdMVW5pZm9ybURhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsUHJvZ3JhbURhdGEubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjb21waWxlU2hhZGVyKGdsLCB0eXBlLCBzcmMpIHtcbiAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gIHJldHVybiBzaGFkZXI7XG59XG5cbmV4cG9ydCB7IGNvbXBpbGVTaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBpbGVTaGFkZXIubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBib29sZWFuQXJyYXkoc2l6ZSkge1xuICBjb25zdCBhcnJheSA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gZGVmYXVsdFZhbHVlKHR5cGUsIHNpemUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlIFwidmVjMlwiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMiAqIHNpemUpO1xuICAgIGNhc2UgXCJ2ZWMzXCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgzICogc2l6ZSk7XG4gICAgY2FzZSBcInZlYzRcIjpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDQgKiBzaXplKTtcbiAgICBjYXNlIFwiaW50XCI6XG4gICAgY2FzZSBcInVpbnRcIjpcbiAgICBjYXNlIFwic2FtcGxlcjJEXCI6XG4gICAgY2FzZSBcInNhbXBsZXIyREFycmF5XCI6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlIFwiaXZlYzJcIjpcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSgyICogc2l6ZSk7XG4gICAgY2FzZSBcIml2ZWMzXCI6XG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMyAqIHNpemUpO1xuICAgIGNhc2UgXCJpdmVjNFwiOlxuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDQgKiBzaXplKTtcbiAgICBjYXNlIFwidXZlYzJcIjpcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoMiAqIHNpemUpO1xuICAgIGNhc2UgXCJ1dmVjM1wiOlxuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheSgzICogc2l6ZSk7XG4gICAgY2FzZSBcInV2ZWM0XCI6XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KDQgKiBzaXplKTtcbiAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgXCJidmVjMlwiOlxuICAgICAgcmV0dXJuIGJvb2xlYW5BcnJheSgyICogc2l6ZSk7XG4gICAgY2FzZSBcImJ2ZWMzXCI6XG4gICAgICByZXR1cm4gYm9vbGVhbkFycmF5KDMgKiBzaXplKTtcbiAgICBjYXNlIFwiYnZlYzRcIjpcbiAgICAgIHJldHVybiBib29sZWFuQXJyYXkoNCAqIHNpemUpO1xuICAgIGNhc2UgXCJtYXQyXCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJtYXQzXCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJtYXQ0XCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF0pO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBkZWZhdWx0VmFsdWUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRWYWx1ZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmxldCBHTF9UQUJMRSA9IG51bGw7XG5jb25zdCBHTF9UT19HTFNMX1RZUEVTID0ge1xuICBGTE9BVDogXCJmbG9hdFwiLFxuICBGTE9BVF9WRUMyOiBcInZlYzJcIixcbiAgRkxPQVRfVkVDMzogXCJ2ZWMzXCIsXG4gIEZMT0FUX1ZFQzQ6IFwidmVjNFwiLFxuICBJTlQ6IFwiaW50XCIsXG4gIElOVF9WRUMyOiBcIml2ZWMyXCIsXG4gIElOVF9WRUMzOiBcIml2ZWMzXCIsXG4gIElOVF9WRUM0OiBcIml2ZWM0XCIsXG4gIFVOU0lHTkVEX0lOVDogXCJ1aW50XCIsXG4gIFVOU0lHTkVEX0lOVF9WRUMyOiBcInV2ZWMyXCIsXG4gIFVOU0lHTkVEX0lOVF9WRUMzOiBcInV2ZWMzXCIsXG4gIFVOU0lHTkVEX0lOVF9WRUM0OiBcInV2ZWM0XCIsXG4gIEJPT0w6IFwiYm9vbFwiLFxuICBCT09MX1ZFQzI6IFwiYnZlYzJcIixcbiAgQk9PTF9WRUMzOiBcImJ2ZWMzXCIsXG4gIEJPT0xfVkVDNDogXCJidmVjNFwiLFxuICBGTE9BVF9NQVQyOiBcIm1hdDJcIixcbiAgRkxPQVRfTUFUMzogXCJtYXQzXCIsXG4gIEZMT0FUX01BVDQ6IFwibWF0NFwiLFxuICBTQU1QTEVSXzJEOiBcInNhbXBsZXIyRFwiLFxuICBJTlRfU0FNUExFUl8yRDogXCJzYW1wbGVyMkRcIixcbiAgVU5TSUdORURfSU5UX1NBTVBMRVJfMkQ6IFwic2FtcGxlcjJEXCIsXG4gIFNBTVBMRVJfQ1VCRTogXCJzYW1wbGVyQ3ViZVwiLFxuICBJTlRfU0FNUExFUl9DVUJFOiBcInNhbXBsZXJDdWJlXCIsXG4gIFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkU6IFwic2FtcGxlckN1YmVcIixcbiAgU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiLFxuICBJTlRfU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiLFxuICBVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiXG59O1xuY29uc3QgR0xTTF9UT19WRVJURVhfVFlQRVMgPSB7XG4gIGZsb2F0OiBcImZsb2F0MzJcIixcbiAgdmVjMjogXCJmbG9hdDMyeDJcIixcbiAgdmVjMzogXCJmbG9hdDMyeDNcIixcbiAgdmVjNDogXCJmbG9hdDMyeDRcIixcbiAgaW50OiBcInNpbnQzMlwiLFxuICBpdmVjMjogXCJzaW50MzJ4MlwiLFxuICBpdmVjMzogXCJzaW50MzJ4M1wiLFxuICBpdmVjNDogXCJzaW50MzJ4NFwiLFxuICB1aW50OiBcInVpbnQzMlwiLFxuICB1dmVjMjogXCJ1aW50MzJ4MlwiLFxuICB1dmVjMzogXCJ1aW50MzJ4M1wiLFxuICB1dmVjNDogXCJ1aW50MzJ4NFwiLFxuICBib29sOiBcInVpbnQzMlwiLFxuICBidmVjMjogXCJ1aW50MzJ4MlwiLFxuICBidmVjMzogXCJ1aW50MzJ4M1wiLFxuICBidmVjNDogXCJ1aW50MzJ4NFwiXG59O1xuZnVuY3Rpb24gbWFwVHlwZShnbCwgdHlwZSkge1xuICBpZiAoIUdMX1RBQkxFKSB7XG4gICAgY29uc3QgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoR0xfVE9fR0xTTF9UWVBFUyk7XG4gICAgR0xfVEFCTEUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgdG4gPSB0eXBlTmFtZXNbaV07XG4gICAgICBHTF9UQUJMRVtnbFt0bl1dID0gR0xfVE9fR0xTTF9UWVBFU1t0bl07XG4gICAgfVxuICB9XG4gIHJldHVybiBHTF9UQUJMRVt0eXBlXTtcbn1cbmZ1bmN0aW9uIG1hcEdsVG9WZXJ0ZXhGb3JtYXQoZ2wsIHR5cGUpIHtcbiAgY29uc3QgdHlwZVZhbHVlID0gbWFwVHlwZShnbCwgdHlwZSk7XG4gIHJldHVybiBHTFNMX1RPX1ZFUlRFWF9UWVBFU1t0eXBlVmFsdWVdIHx8IFwiZmxvYXQzMlwiO1xufVxuXG5leHBvcnQgeyBtYXBHbFRvVmVydGV4Rm9ybWF0LCBtYXBUeXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBUeXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IGdldEF0dHJpYnV0ZUluZm9Gcm9tRm9ybWF0IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2dlb21ldHJ5L3V0aWxzL2dldEF0dHJpYnV0ZUluZm9Gcm9tRm9ybWF0Lm1qcyc7XG5pbXBvcnQgeyBtYXBHbFRvVmVydGV4Rm9ybWF0IH0gZnJvbSAnLi9tYXBUeXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZXh0cmFjdEF0dHJpYnV0ZXNGcm9tR2xQcm9ncmFtKHByb2dyYW0sIGdsLCBzb3J0QXR0cmlidXRlcyA9IGZhbHNlKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgdG90YWxBdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxBdHRyaWJ1dGVzOyBpKyspIHtcbiAgICBjb25zdCBhdHRyaWJEYXRhID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIGkpO1xuICAgIGlmIChhdHRyaWJEYXRhLm5hbWUuc3RhcnRzV2l0aChcImdsX1wiKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IG1hcEdsVG9WZXJ0ZXhGb3JtYXQoZ2wsIGF0dHJpYkRhdGEudHlwZSk7XG4gICAgYXR0cmlidXRlc1thdHRyaWJEYXRhLm5hbWVdID0ge1xuICAgICAgbG9jYXRpb246IDAsXG4gICAgICAvLyBzZXQgZnVydGhlciBkb3duLi5cbiAgICAgIGZvcm1hdCxcbiAgICAgIHN0cmlkZTogZ2V0QXR0cmlidXRlSW5mb0Zyb21Gb3JtYXQoZm9ybWF0KS5zdHJpZGUsXG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBpbnN0YW5jZTogZmFsc2UsXG4gICAgICBzdGFydDogMFxuICAgIH07XG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpO1xuICBpZiAoc29ydEF0dHJpYnV0ZXMpIHtcbiAgICBrZXlzLnNvcnQoKGEsIGIpID0+IGEgPiBiID8gMSA6IC0xKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF0dHJpYnV0ZXNba2V5c1tpXV0ubG9jYXRpb24gPSBpO1xuICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGksIGtleXNbaV0pO1xuICAgIH1cbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF0dHJpYnV0ZXNba2V5c1tpXV0ubG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5cbmV4cG9ydCB7IGV4dHJhY3RBdHRyaWJ1dGVzRnJvbUdsUHJvZ3JhbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdEF0dHJpYnV0ZXNGcm9tR2xQcm9ncmFtLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0VWJvRGF0YShwcm9ncmFtLCBnbCkge1xuICBpZiAoIWdsLkFDVElWRV9VTklGT1JNX0JMT0NLUylcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IHVuaWZvcm1CbG9ja3MgPSB7fTtcbiAgY29uc3QgdG90YWxVbmlmb3Jtc0Jsb2NrcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1fQkxPQ0tTKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFVuaWZvcm1zQmxvY2tzOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybUJsb2NrTmFtZShwcm9ncmFtLCBpKTtcbiAgICBjb25zdCB1bmlmb3JtQmxvY2tJbmRleCA9IGdsLmdldFVuaWZvcm1CbG9ja0luZGV4KHByb2dyYW0sIG5hbWUpO1xuICAgIGNvbnN0IHNpemUgPSBnbC5nZXRBY3RpdmVVbmlmb3JtQmxvY2tQYXJhbWV0ZXIocHJvZ3JhbSwgaSwgZ2wuVU5JRk9STV9CTE9DS19EQVRBX1NJWkUpO1xuICAgIHVuaWZvcm1CbG9ja3NbbmFtZV0gPSB7XG4gICAgICBuYW1lLFxuICAgICAgaW5kZXg6IHVuaWZvcm1CbG9ja0luZGV4LFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1CbG9ja3M7XG59XG5cbmV4cG9ydCB7IGdldFVib0RhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFVib0RhdGEubWpzLm1hcFxuIiwiaW1wb3J0IHsgZGVmYXVsdFZhbHVlIH0gZnJvbSAnLi9kZWZhdWx0VmFsdWUubWpzJztcbmltcG9ydCB7IG1hcFR5cGUgfSBmcm9tICcuL21hcFR5cGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRVbmlmb3JtRGF0YShwcm9ncmFtLCBnbCkge1xuICBjb25zdCB1bmlmb3JtcyA9IHt9O1xuICBjb25zdCB0b3RhbFVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsVW5pZm9ybXM7IGkrKykge1xuICAgIGNvbnN0IHVuaWZvcm1EYXRhID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKTtcbiAgICBjb25zdCBuYW1lID0gdW5pZm9ybURhdGEubmFtZS5yZXBsYWNlKC9cXFsuKj9cXF0kLywgXCJcIik7XG4gICAgY29uc3QgaXNBcnJheSA9ICEhdW5pZm9ybURhdGEubmFtZS5tYXRjaCgvXFxbLio/XFxdJC8pO1xuICAgIGNvbnN0IHR5cGUgPSBtYXBUeXBlKGdsLCB1bmlmb3JtRGF0YS50eXBlKTtcbiAgICB1bmlmb3Jtc1tuYW1lXSA9IHtcbiAgICAgIG5hbWUsXG4gICAgICBpbmRleDogaSxcbiAgICAgIHR5cGUsXG4gICAgICBzaXplOiB1bmlmb3JtRGF0YS5zaXplLFxuICAgICAgaXNBcnJheSxcbiAgICAgIHZhbHVlOiBkZWZhdWx0VmFsdWUodHlwZSwgdW5pZm9ybURhdGEuc2l6ZSlcbiAgICB9O1xuICB9XG4gIHJldHVybiB1bmlmb3Jtcztcbn1cblxuZXhwb3J0IHsgZ2V0VW5pZm9ybURhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFVuaWZvcm1EYXRhLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbG9nUHJldHR5U2hhZGVyRXJyb3IoZ2wsIHNoYWRlcikge1xuICBjb25zdCBzaGFkZXJTcmMgPSBnbC5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKS5zcGxpdChcIlxcblwiKS5tYXAoKGxpbmUsIGluZGV4KSA9PiBgJHtpbmRleH06ICR7bGluZX1gKTtcbiAgY29uc3Qgc2hhZGVyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICBjb25zdCBzcGxpdFNoYWRlciA9IHNoYWRlckxvZy5zcGxpdChcIlxcblwiKTtcbiAgY29uc3QgZGVkdXBlID0ge307XG4gIGNvbnN0IGxpbmVOdW1iZXJzID0gc3BsaXRTaGFkZXIubWFwKChsaW5lKSA9PiBwYXJzZUZsb2F0KGxpbmUucmVwbGFjZSgvXkVSUk9SXFw6IDBcXDooW1xcZF0rKVxcOi4qJC8sIFwiJDFcIikpKS5maWx0ZXIoKG4pID0+IHtcbiAgICBpZiAobiAmJiAhZGVkdXBlW25dKSB7XG4gICAgICBkZWR1cGVbbl0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIGNvbnN0IGxvZ0FyZ3MgPSBbXCJcIl07XG4gIGxpbmVOdW1iZXJzLmZvckVhY2goKG51bWJlcikgPT4ge1xuICAgIHNoYWRlclNyY1tudW1iZXIgLSAxXSA9IGAlYyR7c2hhZGVyU3JjW251bWJlciAtIDFdfSVjYDtcbiAgICBsb2dBcmdzLnB1c2goXCJiYWNrZ3JvdW5kOiAjRkYwMDAwOyBjb2xvcjojRkZGRkZGOyBmb250LXNpemU6IDEwcHhcIiwgXCJmb250LXNpemU6IDEwcHhcIik7XG4gIH0pO1xuICBjb25zdCBmcmFnbWVudFNvdXJjZVRvTG9nID0gc2hhZGVyU3JjLmpvaW4oXCJcXG5cIik7XG4gIGxvZ0FyZ3NbMF0gPSBmcmFnbWVudFNvdXJjZVRvTG9nO1xuICBjb25zb2xlLmVycm9yKHNoYWRlckxvZyk7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJjbGljayB0byB2aWV3IGZ1bGwgc2hhZGVyIGNvZGVcIik7XG4gIGNvbnNvbGUud2FybiguLi5sb2dBcmdzKTtcbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuZnVuY3Rpb24gbG9nUHJvZ3JhbUVycm9yKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKSB7XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgbG9nUHJldHR5U2hhZGVyRXJyb3IoZ2wsIHZlcnRleFNoYWRlcik7XG4gICAgfVxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIGxvZ1ByZXR0eVNoYWRlckVycm9yKGdsLCBmcmFnbWVudFNoYWRlcik7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoXCJQaXhpSlMgRXJyb3I6IENvdWxkIG5vdCBpbml0aWFsaXplIHNoYWRlci5cIik7XG4gICAgaWYgKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pICE9PSBcIlwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQaXhpSlMgV2FybmluZzogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKVwiLCBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IGxvZ1Byb2dyYW1FcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nUHJvZ3JhbUVycm9yLm1qcy5tYXBcbiIsImltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IEdsUHJvZ3JhbURhdGEgfSBmcm9tICcuLi9HbFByb2dyYW1EYXRhLm1qcyc7XG5pbXBvcnQgeyBjb21waWxlU2hhZGVyIH0gZnJvbSAnLi9jb21waWxlU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBkZWZhdWx0VmFsdWUgfSBmcm9tICcuL2RlZmF1bHRWYWx1ZS5tanMnO1xuaW1wb3J0IHsgZXh0cmFjdEF0dHJpYnV0ZXNGcm9tR2xQcm9ncmFtIH0gZnJvbSAnLi9leHRyYWN0QXR0cmlidXRlc0Zyb21HbFByb2dyYW0ubWpzJztcbmltcG9ydCB7IGdldFVib0RhdGEgfSBmcm9tICcuL2dldFVib0RhdGEubWpzJztcbmltcG9ydCB7IGdldFVuaWZvcm1EYXRhIH0gZnJvbSAnLi9nZXRVbmlmb3JtRGF0YS5tanMnO1xuaW1wb3J0IHsgbG9nUHJvZ3JhbUVycm9yIH0gZnJvbSAnLi9sb2dQcm9ncmFtRXJyb3IubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZW5lcmF0ZVByb2dyYW0oZ2wsIHByb2dyYW0pIHtcbiAgY29uc3QgZ2xWZXJ0U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgcHJvZ3JhbS52ZXJ0ZXgpO1xuICBjb25zdCBnbEZyYWdTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIHByb2dyYW0uZnJhZ21lbnQpO1xuICBjb25zdCB3ZWJHTFByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGdsLmF0dGFjaFNoYWRlcih3ZWJHTFByb2dyYW0sIGdsVmVydFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcih3ZWJHTFByb2dyYW0sIGdsRnJhZ1NoYWRlcik7XG4gIGNvbnN0IHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgPSBwcm9ncmFtLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3M7XG4gIGlmICh0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKSB7XG4gICAgaWYgKHR5cGVvZiBnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHdhcm4oYFRyYW5zZm9ybUZlZWRiYWNrIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IFRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgYXJlIGdpdmVuLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKFxuICAgICAgICB3ZWJHTFByb2dyYW0sXG4gICAgICAgIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MubmFtZXMsXG4gICAgICAgIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MuYnVmZmVyTW9kZSA9PT0gXCJzZXBhcmF0ZVwiID8gZ2wuU0VQQVJBVEVfQVRUUklCUyA6IGdsLklOVEVSTEVBVkVEX0FUVFJJQlNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGdsLmxpbmtQcm9ncmFtKHdlYkdMUHJvZ3JhbSk7XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih3ZWJHTFByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgIGxvZ1Byb2dyYW1FcnJvcihnbCwgd2ViR0xQcm9ncmFtLCBnbFZlcnRTaGFkZXIsIGdsRnJhZ1NoYWRlcik7XG4gIH1cbiAgcHJvZ3JhbS5fYXR0cmlidXRlRGF0YSA9IGV4dHJhY3RBdHRyaWJ1dGVzRnJvbUdsUHJvZ3JhbShcbiAgICB3ZWJHTFByb2dyYW0sXG4gICAgZ2wsXG4gICAgIS9eWyBcXHRdKiNbIFxcdF0qdmVyc2lvblsgXFx0XSszMDBbIFxcdF0rZXNbIFxcdF0qJC9tLnRlc3QocHJvZ3JhbS52ZXJ0ZXgpXG4gICk7XG4gIHByb2dyYW0uX3VuaWZvcm1EYXRhID0gZ2V0VW5pZm9ybURhdGEod2ViR0xQcm9ncmFtLCBnbCk7XG4gIHByb2dyYW0uX3VuaWZvcm1CbG9ja0RhdGEgPSBnZXRVYm9EYXRhKHdlYkdMUHJvZ3JhbSwgZ2wpO1xuICBnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0U2hhZGVyKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKGdsRnJhZ1NoYWRlcik7XG4gIGNvbnN0IHVuaWZvcm1EYXRhID0ge307XG4gIGZvciAoY29uc3QgaSBpbiBwcm9ncmFtLl91bmlmb3JtRGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBwcm9ncmFtLl91bmlmb3JtRGF0YVtpXTtcbiAgICB1bmlmb3JtRGF0YVtpXSA9IHtcbiAgICAgIGxvY2F0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCBpKSxcbiAgICAgIHZhbHVlOiBkZWZhdWx0VmFsdWUoZGF0YS50eXBlLCBkYXRhLnNpemUpXG4gICAgfTtcbiAgfVxuICBjb25zdCBnbFByb2dyYW0gPSBuZXcgR2xQcm9ncmFtRGF0YSh3ZWJHTFByb2dyYW0sIHVuaWZvcm1EYXRhKTtcbiAgcmV0dXJuIGdsUHJvZ3JhbTtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVQcm9ncmFtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZVByb2dyYW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVTaGFkZXJTeW5jQ29kZSB9IGZyb20gJy4vR2VuZXJhdGVTaGFkZXJTeW5jQ29kZS5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVQcm9ncmFtIH0gZnJvbSAnLi9wcm9ncmFtL2dlbmVyYXRlUHJvZ3JhbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGRlZmF1bHRTeW5jRGF0YSA9IHtcbiAgdGV4dHVyZUNvdW50OiAwLFxuICBibG9ja0luZGV4OiAwXG59O1xuY2xhc3MgR2xTaGFkZXJTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYWN0aXZlUHJvZ3JhbSA9IG51bGw7XG4gICAgdGhpcy5fcHJvZ3JhbURhdGFIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fbmV4dEluZGV4ID0gMDtcbiAgICB0aGlzLl9ib3VuZFVuaWZvcm1zSWRzVG9JbmRleEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ib3VuZEluZGV4VG9Vbmlmb3Jtc0hhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9zaGFkZXJTeW5jRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgdGhpcy5fZ2wgPSBnbDtcbiAgICB0aGlzLl9tYXhCaW5kaW5ncyA9IGdsLk1BWF9VTklGT1JNX0JVRkZFUl9CSU5ESU5HUyA/IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVU5JRk9STV9CVUZGRVJfQklORElOR1MpIDogMDtcbiAgICB0aGlzLl9wcm9ncmFtRGF0YUhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ib3VuZFVuaWZvcm1zSWRzVG9JbmRleEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ib3VuZEluZGV4VG9Vbmlmb3Jtc0hhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9zaGFkZXJTeW5jRnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fYWN0aXZlUHJvZ3JhbSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgc2hhZGVyIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0gc2hhZGVyIC0gdGhlIG5ldyBzaGFkZXJcbiAgICogQHBhcmFtIHNraXBTeW5jIC0gZmFsc2UgaWYgdGhlIHNoYWRlciBzaG91bGQgYXV0b21hdGljYWxseSBzeW5jIGl0cyB1bmlmb3Jtcy5cbiAgICogQHJldHVybnMgdGhlIGdsUHJvZ3JhbSB0aGF0IGJlbG9uZ3MgdG8gdGhlIHNoYWRlci5cbiAgICovXG4gIGJpbmQoc2hhZGVyLCBza2lwU3luYykge1xuICAgIHRoaXMuX3NldFByb2dyYW0oc2hhZGVyLmdsUHJvZ3JhbSk7XG4gICAgaWYgKHNraXBTeW5jKVxuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHRTeW5jRGF0YS50ZXh0dXJlQ291bnQgPSAwO1xuICAgIGRlZmF1bHRTeW5jRGF0YS5ibG9ja0luZGV4ID0gMDtcbiAgICBsZXQgc3luY0Z1bmN0aW9uID0gdGhpcy5fc2hhZGVyU3luY0Z1bmN0aW9uc1tzaGFkZXIuZ2xQcm9ncmFtLl9rZXldO1xuICAgIGlmICghc3luY0Z1bmN0aW9uKSB7XG4gICAgICBzeW5jRnVuY3Rpb24gPSB0aGlzLl9zaGFkZXJTeW5jRnVuY3Rpb25zW3NoYWRlci5nbFByb2dyYW0uX2tleV0gPSB0aGlzLl9nZW5lcmF0ZVNoYWRlclN5bmMoc2hhZGVyLCB0aGlzKTtcbiAgICB9XG4gICAgc3luY0Z1bmN0aW9uKHRoaXMuX3JlbmRlcmVyLCBzaGFkZXIsIGRlZmF1bHRTeW5jRGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVuaWZvcm0gZ3JvdXAuXG4gICAqIEBwYXJhbSB1bmlmb3JtR3JvdXAgLSB0aGUgdW5pZm9ybSBncm91cCB0byB1cGRhdGVcbiAgICovXG4gIHVwZGF0ZVVuaWZvcm1Hcm91cCh1bmlmb3JtR3JvdXApIHtcbiAgICB0aGlzLl9yZW5kZXJlci51bmlmb3JtR3JvdXAudXBkYXRlVW5pZm9ybUdyb3VwKHVuaWZvcm1Hcm91cCwgdGhpcy5fYWN0aXZlUHJvZ3JhbSwgZGVmYXVsdFN5bmNEYXRhKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgYSB1bmlmb3JtIGJsb2NrIHRvIHRoZSBzaGFkZXIuXG4gICAqIEBwYXJhbSB1bmlmb3JtR3JvdXAgLSB0aGUgdW5pZm9ybSBncm91cCB0byBiaW5kXG4gICAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0gYmxvY2tcbiAgICogQHBhcmFtIGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSB1bmlmb3JtIGJsb2NrXG4gICAqL1xuICBiaW5kVW5pZm9ybUJsb2NrKHVuaWZvcm1Hcm91cCwgbmFtZSwgaW5kZXggPSAwKSB7XG4gICAgY29uc3QgYnVmZmVyU3lzdGVtID0gdGhpcy5fcmVuZGVyZXIuYnVmZmVyO1xuICAgIGNvbnN0IHByb2dyYW1EYXRhID0gdGhpcy5fZ2V0UHJvZ3JhbURhdGEodGhpcy5fYWN0aXZlUHJvZ3JhbSk7XG4gICAgY29uc3QgaXNCdWZmZXJSZXNvdXJjZSA9IHVuaWZvcm1Hcm91cC5fYnVmZmVyUmVzb3VyY2U7XG4gICAgaWYgKGlzQnVmZmVyUmVzb3VyY2UpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnViby51cGRhdGVVbmlmb3JtR3JvdXAodW5pZm9ybUdyb3VwKTtcbiAgICB9XG4gICAgYnVmZmVyU3lzdGVtLnVwZGF0ZUJ1ZmZlcih1bmlmb3JtR3JvdXAuYnVmZmVyKTtcbiAgICBsZXQgYm91bmRJbmRleCA9IHRoaXMuX2JvdW5kVW5pZm9ybXNJZHNUb0luZGV4SGFzaFt1bmlmb3JtR3JvdXAudWlkXTtcbiAgICBpZiAoYm91bmRJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLl9uZXh0SW5kZXgrKyAlIHRoaXMuX21heEJpbmRpbmdzO1xuICAgICAgY29uc3QgY3VycmVudEJvdW5kVW5pZm9ybUdyb3VwID0gdGhpcy5fYm91bmRJbmRleFRvVW5pZm9ybXNIYXNoW25leHRJbmRleF07XG4gICAgICBpZiAoY3VycmVudEJvdW5kVW5pZm9ybUdyb3VwKSB7XG4gICAgICAgIHRoaXMuX2JvdW5kVW5pZm9ybXNJZHNUb0luZGV4SGFzaFtjdXJyZW50Qm91bmRVbmlmb3JtR3JvdXAudWlkXSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGJvdW5kSW5kZXggPSB0aGlzLl9ib3VuZFVuaWZvcm1zSWRzVG9JbmRleEhhc2hbdW5pZm9ybUdyb3VwLnVpZF0gPSBuZXh0SW5kZXg7XG4gICAgICB0aGlzLl9ib3VuZEluZGV4VG9Vbmlmb3Jtc0hhc2hbbmV4dEluZGV4XSA9IHVuaWZvcm1Hcm91cDtcbiAgICAgIGlmIChpc0J1ZmZlclJlc291cmNlKSB7XG4gICAgICAgIGJ1ZmZlclN5c3RlbS5iaW5kQnVmZmVyUmFuZ2UodW5pZm9ybUdyb3VwLmJ1ZmZlciwgbmV4dEluZGV4LCB1bmlmb3JtR3JvdXAub2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlclN5c3RlbS5iaW5kQnVmZmVyQmFzZSh1bmlmb3JtR3JvdXAuYnVmZmVyLCBuZXh0SW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IHVuaWZvcm1CbG9ja0luZGV4ID0gdGhpcy5fYWN0aXZlUHJvZ3JhbS5fdW5pZm9ybUJsb2NrRGF0YVtuYW1lXS5pbmRleDtcbiAgICBpZiAocHJvZ3JhbURhdGEudW5pZm9ybUJsb2NrQmluZGluZ3NbaW5kZXhdID09PSBib3VuZEluZGV4KVxuICAgICAgcmV0dXJuO1xuICAgIHByb2dyYW1EYXRhLnVuaWZvcm1CbG9ja0JpbmRpbmdzW2luZGV4XSA9IGJvdW5kSW5kZXg7XG4gICAgZ2wudW5pZm9ybUJsb2NrQmluZGluZyhwcm9ncmFtRGF0YS5wcm9ncmFtLCB1bmlmb3JtQmxvY2tJbmRleCwgYm91bmRJbmRleCk7XG4gIH1cbiAgX3NldFByb2dyYW0ocHJvZ3JhbSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmVQcm9ncmFtID09PSBwcm9ncmFtKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2FjdGl2ZVByb2dyYW0gPSBwcm9ncmFtO1xuICAgIGNvbnN0IHByb2dyYW1EYXRhID0gdGhpcy5fZ2V0UHJvZ3JhbURhdGEocHJvZ3JhbSk7XG4gICAgdGhpcy5fZ2wudXNlUHJvZ3JhbShwcm9ncmFtRGF0YS5wcm9ncmFtKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHByb2dyYW0gLSB0aGUgcHJvZ3JhbSB0byBnZXQgdGhlIGRhdGEgZm9yXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFByb2dyYW1EYXRhKHByb2dyYW0pIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbURhdGFIYXNoW3Byb2dyYW0uX2tleV0gfHwgdGhpcy5fY3JlYXRlUHJvZ3JhbURhdGEocHJvZ3JhbSk7XG4gIH1cbiAgX2NyZWF0ZVByb2dyYW1EYXRhKHByb2dyYW0pIHtcbiAgICBjb25zdCBrZXkgPSBwcm9ncmFtLl9rZXk7XG4gICAgdGhpcy5fcHJvZ3JhbURhdGFIYXNoW2tleV0gPSBnZW5lcmF0ZVByb2dyYW0odGhpcy5fZ2wsIHByb2dyYW0pO1xuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRGF0YUhhc2hba2V5XTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuX3Byb2dyYW1EYXRhSGFzaCkpIHtcbiAgICAgIGNvbnN0IHByb2dyYW1EYXRhID0gdGhpcy5fcHJvZ3JhbURhdGFIYXNoW2tleV07XG4gICAgICBwcm9ncmFtRGF0YS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9wcm9ncmFtRGF0YUhhc2hba2V5XSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3Byb2dyYW1EYXRhSGFzaCA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRVbmlmb3Jtc0lkc1RvSW5kZXhIYXNoID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGV4ZWN1dGVkIHRoYXQgd2lsbCBzeW5jIHRoZSBzaGFkZXIgYXMgZWZmaWNpZW50bHkgYXMgcG9zc2libGUuXG4gICAqIE92ZXJyaWRkZW4gYnkgdGhlIHVuc2FmZSBldmFsIHBhY2thZ2UgaWYgeW91IGRvbid0IHdhbnQgZXZhbCB1c2VkIGluIHlvdXIgcHJvamVjdC5cbiAgICogQHBhcmFtIHNoYWRlciAtIHRoZSBzaGFkZXIgdG8gZ2VuZXJhdGUgdGhlIHN5bmMgZnVuY3Rpb24gZm9yXG4gICAqIEBwYXJhbSBzaGFkZXJTeXN0ZW0gLSB0aGUgc2hhZGVyIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybnMgLSB0aGUgZ2VuZXJhdGVkIHN5bmMgZnVuY3Rpb25cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX2dlbmVyYXRlU2hhZGVyU3luYyhzaGFkZXIsIHNoYWRlclN5c3RlbSkge1xuICAgIHJldHVybiBnZW5lcmF0ZVNoYWRlclN5bmNDb2RlKHNoYWRlciwgc2hhZGVyU3lzdGVtKTtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdsU2hhZGVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJzaGFkZXJcIlxufTtcblxuZXhwb3J0IHsgR2xTaGFkZXJTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsU2hhZGVyU3lzdGVtLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgVU5JRk9STV9UT19TSU5HTEVfU0VUVEVSUyA9IHtcbiAgZjMyOiBgaWYgKGN2ICE9PSB2KSB7XG4gICAgICAgICAgICBjdS52YWx1ZSA9IHY7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHYpO1xuICAgICAgICB9YCxcbiAgXCJ2ZWMyPGYzMj5cIjogYGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSkge1xuICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB2WzBdLCB2WzFdKTtcbiAgICAgICAgfWAsXG4gIFwidmVjMzxmMzI+XCI6IGBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0pIHtcbiAgICAgICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZihsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSk7XG4gICAgICAgIH1gLFxuICBcInZlYzQ8ZjMyPlwiOiBgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKSB7XG4gICAgICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgICAgICBjdlsyXSA9IHZbMl07XG4gICAgICAgICAgICBjdlszXSA9IHZbM107XG4gICAgICAgICAgICBnbC51bmlmb3JtNGYobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgICAgICB9YCxcbiAgaTMyOiBgaWYgKGN2ICE9PSB2KSB7XG4gICAgICAgICAgICBjdS52YWx1ZSA9IHY7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpO1xuICAgICAgICB9YCxcbiAgXCJ2ZWMyPGkzMj5cIjogYGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSkge1xuICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJpKGxvY2F0aW9uLCB2WzBdLCB2WzFdKTtcbiAgICAgICAgfWAsXG4gIFwidmVjMzxpMzI+XCI6IGBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0pIHtcbiAgICAgICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zaShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSk7XG4gICAgICAgIH1gLFxuICBcInZlYzQ8aTMyPlwiOiBgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKSB7XG4gICAgICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgICAgICBjdlsyXSA9IHZbMl07XG4gICAgICAgICAgICBjdlszXSA9IHZbM107XG4gICAgICAgICAgICBnbC51bmlmb3JtNGkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgICAgICB9YCxcbiAgdTMyOiBgaWYgKGN2ICE9PSB2KSB7XG4gICAgICAgICAgICBjdS52YWx1ZSA9IHY7XG4gICAgICAgICAgICBnbC51bmlmb3JtMXVpKGxvY2F0aW9uLCB2KTtcbiAgICAgICAgfWAsXG4gIFwidmVjMjx1MzI+XCI6IGBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0pIHtcbiAgICAgICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0ydWkobG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgICAgICB9YCxcbiAgXCJ2ZWMzPHUzMj5cIjogYGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSkge1xuICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICAgICAgY3ZbMl0gPSB2WzJdO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTN1aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSk7XG4gICAgICAgIH1gLFxuICBcInZlYzQ8dTMyPlwiOiBgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKSB7XG4gICAgICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgICAgICBjdlsyXSA9IHZbMl07XG4gICAgICAgICAgICBjdlszXSA9IHZbM107XG4gICAgICAgICAgICBnbC51bmlmb3JtNHVpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKTtcbiAgICAgICAgfWAsXG4gIGJvb2w6IGBpZiAoY3YgIT09IHYpIHtcbiAgICAgICAgICAgIGN1LnZhbHVlID0gdjtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgICAgIH1gLFxuICBcInZlYzI8Ym9vbD5cIjogYGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSkge1xuICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJpKGxvY2F0aW9uLCB2WzBdLCB2WzFdKTtcbiAgICAgICAgfWAsXG4gIFwidmVjMzxib29sPlwiOiBgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdKSB7XG4gICAgICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgICAgICBjdlsyXSA9IHZbMl07XG4gICAgICAgICAgICBnbC51bmlmb3JtM2kobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgICAgICB9YCxcbiAgXCJ2ZWM0PGJvb2w+XCI6IGBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pIHtcbiAgICAgICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgICAgIGN2WzNdID0gdlszXTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm00aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSk7XG4gICAgICAgIH1gLFxuICBcIm1hdDJ4MjxmMzI+XCI6IGBnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7YCxcbiAgXCJtYXQzeDM8ZjMyPlwiOiBgZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHYpO2AsXG4gIFwibWF0NHg0PGYzMj5cIjogYGdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2KTtgXG59O1xuY29uc3QgVU5JRk9STV9UT19BUlJBWV9TRVRURVJTID0ge1xuICBmMzI6IGBnbC51bmlmb3JtMWZ2KGxvY2F0aW9uLCB2KTtgLFxuICBcInZlYzI8ZjMyPlwiOiBgZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdik7YCxcbiAgXCJ2ZWMzPGYzMj5cIjogYGdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHYpO2AsXG4gIFwidmVjNDxmMzI+XCI6IGBnbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB2KTtgLFxuICBcIm1hdDJ4MjxmMzI+XCI6IGBnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdik7YCxcbiAgXCJtYXQzeDM8ZjMyPlwiOiBgZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHYpO2AsXG4gIFwibWF0NHg0PGYzMj5cIjogYGdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2KTtgLFxuICBpMzI6IGBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KTtgLFxuICBcInZlYzI8aTMyPlwiOiBgZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdik7YCxcbiAgXCJ2ZWMzPGkzMj5cIjogYGdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpO2AsXG4gIFwidmVjNDxpMzI+XCI6IGBnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2KTtgLFxuICB1MzI6IGBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KTtgLFxuICBcInZlYzI8dTMyPlwiOiBgZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdik7YCxcbiAgXCJ2ZWMzPHUzMj5cIjogYGdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpO2AsXG4gIFwidmVjNDx1MzI+XCI6IGBnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2KTtgLFxuICBib29sOiBgZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdik7YCxcbiAgXCJ2ZWMyPGJvb2w+XCI6IGBnbC51bmlmb3JtMml2KGxvY2F0aW9uLCB2KTtgLFxuICBcInZlYzM8Ym9vbD5cIjogYGdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpO2AsXG4gIFwidmVjNDxib29sPlwiOiBgZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdik7YFxufTtcblxuZXhwb3J0IHsgVU5JRk9STV9UT19BUlJBWV9TRVRURVJTLCBVTklGT1JNX1RPX1NJTkdMRV9TRVRURVJTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZVVuaWZvcm1zU3luY1R5cGVzLm1qcy5tYXBcbiIsImltcG9ydCB7IEJ1ZmZlclJlc291cmNlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2J1ZmZlci9CdWZmZXJSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IHVuaWZvcm1QYXJzZXJzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3NoYWRlci91dGlscy91bmlmb3JtUGFyc2Vycy5tanMnO1xuaW1wb3J0IHsgVU5JRk9STV9UT19TSU5HTEVfU0VUVEVSUywgVU5JRk9STV9UT19BUlJBWV9TRVRURVJTIH0gZnJvbSAnLi9nZW5lcmF0ZVVuaWZvcm1zU3luY1R5cGVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2VuZXJhdGVVbmlmb3Jtc1N5bmMoZ3JvdXAsIHVuaWZvcm1EYXRhKSB7XG4gIGNvbnN0IGZ1bmNGcmFnbWVudHMgPSBbYFxuICAgICAgICB2YXIgdiA9IG51bGw7XG4gICAgICAgIHZhciBjdiA9IG51bGw7XG4gICAgICAgIHZhciBjdSA9IG51bGw7XG4gICAgICAgIHZhciB0ID0gMDtcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICBgXTtcbiAgZm9yIChjb25zdCBpIGluIGdyb3VwLnVuaWZvcm1zKSB7XG4gICAgaWYgKCF1bmlmb3JtRGF0YVtpXSkge1xuICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW2ldIGluc3RhbmNlb2YgVW5pZm9ybUdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cC51bmlmb3Jtc1tpXS51Ym8pIHtcbiAgICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuc2hhZGVyLmJpbmRVbmlmb3JtQmxvY2sodXYuJHtpfSwgXCIke2l9XCIpO1xuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuc2hhZGVyLnVwZGF0ZVVuaWZvcm1Hcm91cCh1di4ke2l9KTtcbiAgICAgICAgICAgICAgICAgICAgYCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAudW5pZm9ybXNbaV0gaW5zdGFuY2VvZiBCdWZmZXJSZXNvdXJjZSkge1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuc2hhZGVyLmJpbmRCdWZmZXJSZXNvdXJjZSh1di4ke2l9LCBcIiR7aX1cIik7XG4gICAgICAgICAgICAgICAgICAgIGApO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHVuaWZvcm0gPSBncm91cC51bmlmb3JtU3RydWN0dXJlc1tpXTtcbiAgICBsZXQgcGFyc2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bmlmb3JtUGFyc2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgcGFyc2VyID0gdW5pZm9ybVBhcnNlcnNbal07XG4gICAgICBpZiAodW5pZm9ybS50eXBlID09PSBwYXJzZXIudHlwZSAmJiBwYXJzZXIudGVzdCh1bmlmb3JtKSkge1xuICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYG5hbWUgPSBcIiR7aX1cIjtgLCB1bmlmb3JtUGFyc2Vyc1tqXS51bmlmb3JtKTtcbiAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZVR5cGUgPSB1bmlmb3JtLnNpemUgPT09IDEgPyBVTklGT1JNX1RPX1NJTkdMRV9TRVRURVJTIDogVU5JRk9STV9UT19BUlJBWV9TRVRURVJTO1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVR5cGVbdW5pZm9ybS50eXBlXS5yZXBsYWNlKFwibG9jYXRpb25cIiwgYHVkW1wiJHtpfVwiXS5sb2NhdGlvbmApO1xuICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgIGN1ID0gdWRbXCIke2l9XCJdO1xuICAgICAgICAgICAgY3YgPSBjdS52YWx1ZTtcbiAgICAgICAgICAgIHYgPSB1dltcIiR7aX1cIl07XG4gICAgICAgICAgICAke3RlbXBsYXRlfTtgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInVkXCIsIFwidXZcIiwgXCJyZW5kZXJlclwiLCBcInN5bmNEYXRhXCIsIGZ1bmNGcmFnbWVudHMuam9pbihcIlxcblwiKSk7XG59XG5cbmV4cG9ydCB7IGdlbmVyYXRlVW5pZm9ybXNTeW5jIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZVVuaWZvcm1zU3luYy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVVuaWZvcm1zU3luYyB9IGZyb20gJy4vdXRpbHMvZ2VuZXJhdGVVbmlmb3Jtc1N5bmMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHbFVuaWZvcm1Hcm91cFN5c3RlbSB7XG4gIC8qKiBAcGFyYW0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBTeXN0ZW0gd29ya3MgZm9yLiAqL1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIC8qKiBDYWNoZSB0byBob2xkcyB0aGUgZ2VuZXJhdGVkIGZ1bmN0aW9ucy4gU3RvcmVkIGFnYWluc3QgVW5pZm9ybU9iamVjdHMgdW5pcXVlIHNpZ25hdHVyZS4gKi9cbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX3VuaWZvcm1Hcm91cFN5bmNIYXNoID0ge307XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmdsID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gIH1cbiAgLyoqXG4gICAqIFVwbG9hZHMgdGhlIHVuaWZvcm1zIHZhbHVlcyB0byB0aGUgY3VycmVudGx5IGJvdW5kIHNoYWRlci5cbiAgICogQHBhcmFtIGdyb3VwIC0gdGhlIHVuaWZvcm1zIHZhbHVlcyB0aGF0IGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2hhZGVyXG4gICAqIEBwYXJhbSBwcm9ncmFtXG4gICAqIEBwYXJhbSBzeW5jRGF0YVxuICAgKiBAcGFyYW0gc3luY0RhdGEudGV4dHVyZUNvdW50XG4gICAqL1xuICB1cGRhdGVVbmlmb3JtR3JvdXAoZ3JvdXAsIHByb2dyYW0sIHN5bmNEYXRhKSB7XG4gICAgY29uc3QgcHJvZ3JhbURhdGEgPSB0aGlzLl9yZW5kZXJlci5zaGFkZXIuX2dldFByb2dyYW1EYXRhKHByb2dyYW0pO1xuICAgIGlmICghZ3JvdXAuaXNTdGF0aWMgfHwgZ3JvdXAuX2RpcnR5SWQgIT09IHByb2dyYW1EYXRhLnVuaWZvcm1EaXJ0eUdyb3Vwc1tncm91cC51aWRdKSB7XG4gICAgICBwcm9ncmFtRGF0YS51bmlmb3JtRGlydHlHcm91cHNbZ3JvdXAudWlkXSA9IGdyb3VwLl9kaXJ0eUlkO1xuICAgICAgY29uc3Qgc3luY0Z1bmMgPSB0aGlzLl9nZXRVbmlmb3JtU3luY0Z1bmN0aW9uKGdyb3VwLCBwcm9ncmFtKTtcbiAgICAgIHN5bmNGdW5jKHByb2dyYW1EYXRhLnVuaWZvcm1EYXRhLCBncm91cC51bmlmb3JtcywgdGhpcy5fcmVuZGVyZXIsIHN5bmNEYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIGJ5IHRoZSBwaXhpLmpzL3Vuc2FmZS1ldmFsIHBhY2thZ2UgdG8gdXNlIHN0YXRpYyBzeW5jVW5pZm9ybXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIGdyb3VwXG4gICAqIEBwYXJhbSBwcm9ncmFtXG4gICAqL1xuICBfZ2V0VW5pZm9ybVN5bmNGdW5jdGlvbihncm91cCwgcHJvZ3JhbSkge1xuICAgIHJldHVybiB0aGlzLl91bmlmb3JtR3JvdXBTeW5jSGFzaFtncm91cC5fc2lnbmF0dXJlXT8uW3Byb2dyYW0uX2tleV0gfHwgdGhpcy5fY3JlYXRlVW5pZm9ybVN5bmNGdW5jdGlvbihncm91cCwgcHJvZ3JhbSk7XG4gIH1cbiAgX2NyZWF0ZVVuaWZvcm1TeW5jRnVuY3Rpb24oZ3JvdXAsIHByb2dyYW0pIHtcbiAgICBjb25zdCB1bmlmb3JtR3JvdXBTeW5jSGFzaCA9IHRoaXMuX3VuaWZvcm1Hcm91cFN5bmNIYXNoW2dyb3VwLl9zaWduYXR1cmVdIHx8ICh0aGlzLl91bmlmb3JtR3JvdXBTeW5jSGFzaFtncm91cC5fc2lnbmF0dXJlXSA9IHt9KTtcbiAgICBjb25zdCBpZCA9IHRoaXMuX2dldFNpZ25hdHVyZShncm91cCwgcHJvZ3JhbS5fdW5pZm9ybURhdGEsIFwidVwiKTtcbiAgICBpZiAoIXRoaXMuX2NhY2hlW2lkXSkge1xuICAgICAgdGhpcy5fY2FjaGVbaWRdID0gdGhpcy5fZ2VuZXJhdGVVbmlmb3Jtc1N5bmMoZ3JvdXAsIHByb2dyYW0uX3VuaWZvcm1EYXRhKTtcbiAgICB9XG4gICAgdW5pZm9ybUdyb3VwU3luY0hhc2hbcHJvZ3JhbS5fa2V5XSA9IHRoaXMuX2NhY2hlW2lkXTtcbiAgICByZXR1cm4gdW5pZm9ybUdyb3VwU3luY0hhc2hbcHJvZ3JhbS5fa2V5XTtcbiAgfVxuICBfZ2VuZXJhdGVVbmlmb3Jtc1N5bmMoZ3JvdXAsIHVuaWZvcm1EYXRhKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlVW5pZm9ybXNTeW5jKGdyb3VwLCB1bmlmb3JtRGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIFRha2VzIGEgdW5pZm9ybSBncm91cCBhbmQgZGF0YSBhbmQgZ2VuZXJhdGVzIGEgdW5pcXVlIHNpZ25hdHVyZSBmb3IgdGhlbS5cbiAgICogQHBhcmFtIGdyb3VwIC0gVGhlIHVuaWZvcm0gZ3JvdXAgdG8gZ2V0IHNpZ25hdHVyZSBvZlxuICAgKiBAcGFyYW0gZ3JvdXAudW5pZm9ybXNcbiAgICogQHBhcmFtIHVuaWZvcm1EYXRhIC0gVW5pZm9ybSBpbmZvcm1hdGlvbiBnZW5lcmF0ZWQgYnkgdGhlIHNoYWRlclxuICAgKiBAcGFyYW0gcHJlRml4XG4gICAqIEByZXR1cm5zIFVuaXF1ZSBzaWduYXR1cmUgb2YgdGhlIHVuaWZvcm0gZ3JvdXBcbiAgICovXG4gIF9nZXRTaWduYXR1cmUoZ3JvdXAsIHVuaWZvcm1EYXRhLCBwcmVGaXgpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IGdyb3VwLnVuaWZvcm1zO1xuICAgIGNvbnN0IHN0cmluZ3MgPSBbYCR7cHJlRml4fS1gXTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdW5pZm9ybXMpIHtcbiAgICAgIHN0cmluZ3MucHVzaChpKTtcbiAgICAgIGlmICh1bmlmb3JtRGF0YVtpXSkge1xuICAgICAgICBzdHJpbmdzLnB1c2godW5pZm9ybURhdGFbaV0udHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdzLmpvaW4oXCItXCIpO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGlzIFN5c3RlbSBhbmQgcmVtb3ZlcyBhbGwgaXRzIHRleHR1cmVzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5HbFVuaWZvcm1Hcm91cFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwidW5pZm9ybUdyb3VwXCJcbn07XG5cbmV4cG9ydCB7IEdsVW5pZm9ybUdyb3VwU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbFVuaWZvcm1Hcm91cFN5c3RlbS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aShnbCkge1xuICBjb25zdCBibGVuZE1hcCA9IHt9O1xuICBibGVuZE1hcC5ub3JtYWwgPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYmxlbmRNYXAuYWRkID0gW2dsLk9ORSwgZ2wuT05FXTtcbiAgYmxlbmRNYXAubXVsdGlwbHkgPSBbZ2wuRFNUX0NPTE9SLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBibGVuZE1hcC5zY3JlZW4gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBibGVuZE1hcC5ub25lID0gWzAsIDBdO1xuICBibGVuZE1hcFtcIm5vcm1hbC1ucG1cIl0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBibGVuZE1hcFtcImFkZC1ucG1cIl0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FXTtcbiAgYmxlbmRNYXBbXCJzY3JlZW4tbnBtXCJdID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYmxlbmRNYXAuZXJhc2UgPSBbZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIHJldHVybiBibGVuZE1hcDtcbn1cblxuZXhwb3J0IHsgbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvc3RhdGUvU3RhdGUubWpzJztcbmltcG9ydCB7IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aSB9IGZyb20gJy4vbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgQkxFTkQgPSAwO1xuY29uc3QgT0ZGU0VUID0gMTtcbmNvbnN0IENVTExJTkcgPSAyO1xuY29uc3QgREVQVEhfVEVTVCA9IDM7XG5jb25zdCBXSU5ESU5HID0gNDtcbmNvbnN0IERFUFRIX01BU0sgPSA1O1xuY29uc3QgX0dsU3RhdGVTeXN0ZW0gPSBjbGFzcyBfR2xTdGF0ZVN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIHRoaXMuc3RhdGVJZCA9IDA7XG4gICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IFwibm9uZVwiO1xuICAgIHRoaXMuX2JsZW5kRXEgPSBmYWxzZTtcbiAgICB0aGlzLm1hcCA9IFtdO1xuICAgIHRoaXMubWFwW0JMRU5EXSA9IHRoaXMuc2V0QmxlbmQ7XG4gICAgdGhpcy5tYXBbT0ZGU0VUXSA9IHRoaXMuc2V0T2Zmc2V0O1xuICAgIHRoaXMubWFwW0NVTExJTkddID0gdGhpcy5zZXRDdWxsRmFjZTtcbiAgICB0aGlzLm1hcFtERVBUSF9URVNUXSA9IHRoaXMuc2V0RGVwdGhUZXN0O1xuICAgIHRoaXMubWFwW1dJTkRJTkddID0gdGhpcy5zZXRGcm9udEZhY2U7XG4gICAgdGhpcy5tYXBbREVQVEhfTUFTS10gPSB0aGlzLnNldERlcHRoTWFzaztcbiAgICB0aGlzLmNoZWNrcyA9IFtdO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuYmxlbmRNb2Rlc01hcCA9IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aShnbCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHN0YXRlXG4gICAqIEBwYXJhbSB7Kn0gc3RhdGUgLSBUaGUgc3RhdGUgdG8gc2V0LlxuICAgKi9cbiAgc2V0KHN0YXRlKSB7XG4gICAgc3RhdGUgPSBzdGF0ZSB8fCB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgICBpZiAodGhpcy5zdGF0ZUlkICE9PSBzdGF0ZS5kYXRhKSB7XG4gICAgICBsZXQgZGlmZiA9IHRoaXMuc3RhdGVJZCBeIHN0YXRlLmRhdGE7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZSAoZGlmZikge1xuICAgICAgICBpZiAoZGlmZiAmIDEpIHtcbiAgICAgICAgICB0aGlzLm1hcFtpXS5jYWxsKHRoaXMsICEhKHN0YXRlLmRhdGEgJiAxIDw8IGkpKTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmID0gZGlmZiA+PiAxO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlSWQgPSBzdGF0ZS5kYXRhO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hlY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmNoZWNrc1tpXSh0aGlzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGF0ZSwgd2hlbiBwcmV2aW91cyBzdGF0ZSBpcyB1bmtub3duLlxuICAgKiBAcGFyYW0geyp9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIHNldFxuICAgKi9cbiAgZm9yY2VTdGF0ZShzdGF0ZSkge1xuICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5kZWZhdWx0U3RhdGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5tYXBbaV0uY2FsbCh0aGlzLCAhIShzdGF0ZS5kYXRhICYgMSA8PCBpKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGVja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuY2hlY2tzW2ldKHRoaXMsIHN0YXRlKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZUlkID0gc3RhdGUuZGF0YTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIGJsZW5kaW5nLlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiBXZWJHbCBibGVuZGluZy5cbiAgICovXG4gIHNldEJsZW5kKHZhbHVlKSB7XG4gICAgdGhpcy5fdXBkYXRlQ2hlY2soX0dsU3RhdGVTeXN0ZW0uX2NoZWNrQmxlbmRNb2RlLCB2YWx1ZSk7XG4gICAgdGhpcy5nbFt2YWx1ZSA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIl0odGhpcy5nbC5CTEVORCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBwb2x5Z29uIG9mZnNldCBmaWxsLlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBwb2x5Z29uIG9mZnNldCB0ZXN0aW5nLlxuICAgKi9cbiAgc2V0T2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5fdXBkYXRlQ2hlY2soX0dsU3RhdGVTeXN0ZW0uX2NoZWNrUG9seWdvbk9mZnNldCwgdmFsdWUpO1xuICAgIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBkZXB0aCB0ZXN0LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBkZXB0aCB0ZXN0aW5nLlxuICAgKi9cbiAgc2V0RGVwdGhUZXN0KHZhbHVlKSB7XG4gICAgdGhpcy5nbFt2YWx1ZSA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIl0odGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIGRlcHRoIG1hc2suXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGRlcHRoIG1hc2suXG4gICAqL1xuICBzZXREZXB0aE1hc2sodmFsdWUpIHtcbiAgICB0aGlzLmdsLmRlcHRoTWFzayh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBjdWxsIGZhY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBjdWxsIGZhY2UuXG4gICAqL1xuICBzZXRDdWxsRmFjZSh2YWx1ZSkge1xuICAgIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZ2wgZnJvbnQgZmFjZS5cbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIHRydWUgaXMgY2xvY2t3aXNlIGFuZCBmYWxzZSBpcyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgKi9cbiAgc2V0RnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgdGhpcy5nbC5mcm9udEZhY2UodGhpcy5nbFt2YWx1ZSA/IFwiQ1dcIiA6IFwiQ0NXXCJdKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYmxlbmQgbW9kZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIGJsZW5kIG1vZGUgdG8gc2V0IHRvLlxuICAgKi9cbiAgc2V0QmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmJsZW5kTW9kZXNNYXBbdmFsdWVdKSB7XG4gICAgICB2YWx1ZSA9IFwibm9ybWFsXCI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5ibGVuZE1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy5ibGVuZE1vZGVzTWFwW3ZhbHVlXTtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKG1vZGUubGVuZ3RoID09PSAyKSB7XG4gICAgICBnbC5ibGVuZEZ1bmMobW9kZVswXSwgbW9kZVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKG1vZGVbMF0sIG1vZGVbMV0sIG1vZGVbMl0sIG1vZGVbM10pO1xuICAgIH1cbiAgICBpZiAobW9kZS5sZW5ndGggPT09IDYpIHtcbiAgICAgIHRoaXMuX2JsZW5kRXEgPSB0cnVlO1xuICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKG1vZGVbNF0sIG1vZGVbNV0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fYmxlbmRFcSkge1xuICAgICAgdGhpcy5fYmxlbmRFcSA9IGZhbHNlO1xuICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb2x5Z29uIG9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdGhlIHBvbHlnb24gb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIHRoZSBwb2x5Z29uIG9mZnNldCBzY2FsZVxuICAgKi9cbiAgc2V0UG9seWdvbk9mZnNldCh2YWx1ZSwgc2NhbGUpIHtcbiAgICB0aGlzLmdsLnBvbHlnb25PZmZzZXQodmFsdWUsIHNjYWxlKTtcbiAgfVxuICAvLyB1c2VkXG4gIC8qKiBSZXNldHMgYWxsIHRoZSBsb2dpYyBhbmQgZGlzYWJsZXMgdGhlIFZBT3MuICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZ2wucGl4ZWxTdG9yZWkodGhpcy5nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgdGhpcy5mb3JjZVN0YXRlKHRoaXMuZGVmYXVsdFN0YXRlKTtcbiAgICB0aGlzLl9ibGVuZEVxID0gdHJ1ZTtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IFwiXCI7XG4gICAgdGhpcy5zZXRCbGVuZE1vZGUoXCJub3JtYWxcIik7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgd2hpY2ggdXBkYXRlcyBzaG91bGQgYmUgY2hlY2tlZCBiYXNlZCBvbiB3aGljaCBzZXR0aW5ncyBoYXZlIGJlZW4gYWN0aXZhdGVkLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgYmxlbmQgaXMgZW5hYmxlZCB0aGVuIHdlIHNob3VsZCBjaGVjayB0aGUgYmxlbmQgbW9kZXMgZWFjaCB0aW1lIHRoZSBzdGF0ZSBpcyBjaGFuZ2VkXG4gICAqIG9yIGlmIHBvbHlnb24gZmlsbCBpcyBhY3RpdmF0ZWQgdGhlbiB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBwb2x5Z29uIG9mZnNldCBjaGFuZ2VzLlxuICAgKiBUaGUgaWRlYSBpcyB0aGF0IHdlIG9ubHkgY2hlY2sgd2hhdCB3ZSBoYXZlIHRvby5cbiAgICogQHBhcmFtIGZ1bmMgLSB0aGUgY2hlY2tpbmcgZnVuY3Rpb24gdG8gYWRkIG9yIHJlbW92ZVxuICAgKiBAcGFyYW0gdmFsdWUgLSBzaG91bGQgdGhlIGNoZWNrIGZ1bmN0aW9uIGJlIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAqL1xuICBfdXBkYXRlQ2hlY2soZnVuYywgdmFsdWUpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hlY2tzLmluZGV4T2YoZnVuYyk7XG4gICAgaWYgKHZhbHVlICYmIGluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5jaGVja3MucHVzaChmdW5jKTtcbiAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuY2hlY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBIHByaXZhdGUgbGl0dGxlIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCB3ZSBjYWxsIHRvIGNoZWNrIHRoZSBibGVuZCBtb2RlLlxuICAgKiBAcGFyYW0gc3lzdGVtIC0gdGhlIFN5c3RlbSB0byBwZXJmb3JtIHRoZSBzdGF0ZSBjaGVjayBvblxuICAgKiBAcGFyYW0gc3RhdGUgLSB0aGUgc3RhdGUgdGhhdCB0aGUgYmxlbmRNb2RlIHdpbGwgcHVsbGVkIGZyb21cbiAgICovXG4gIHN0YXRpYyBfY2hlY2tCbGVuZE1vZGUoc3lzdGVtLCBzdGF0ZSkge1xuICAgIHN5c3RlbS5zZXRCbGVuZE1vZGUoc3RhdGUuYmxlbmRNb2RlKTtcbiAgfVxuICAvKipcbiAgICogQSBwcml2YXRlIGxpdHRsZSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgd2UgY2FsbCB0byBjaGVjayB0aGUgcG9seWdvbiBvZmZzZXQuXG4gICAqIEBwYXJhbSBzeXN0ZW0gLSB0aGUgU3lzdGVtIHRvIHBlcmZvcm0gdGhlIHN0YXRlIGNoZWNrIG9uXG4gICAqIEBwYXJhbSBzdGF0ZSAtIHRoZSBzdGF0ZSB0aGF0IHRoZSBibGVuZE1vZGUgd2lsbCBwdWxsZWQgZnJvbVxuICAgKi9cbiAgc3RhdGljIF9jaGVja1BvbHlnb25PZmZzZXQoc3lzdGVtLCBzdGF0ZSkge1xuICAgIHN5c3RlbS5zZXRQb2x5Z29uT2Zmc2V0KDEsIHN0YXRlLnBvbHlnb25PZmZzZXQpO1xuICB9XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIHRoaXMuY2hlY2tzLmxlbmd0aCA9IDA7XG4gIH1cbn07XG4vKiogQGlnbm9yZSAqL1xuX0dsU3RhdGVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbVxuICBdLFxuICBuYW1lOiBcInN0YXRlXCJcbn07XG5sZXQgR2xTdGF0ZVN5c3RlbSA9IF9HbFN0YXRlU3lzdGVtO1xuXG5leHBvcnQgeyBHbFN0YXRlU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbFN0YXRlU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEdMX1RBUkdFVFMsIEdMX1RZUEVTLCBHTF9GT1JNQVRTIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdsVGV4dHVyZSB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUpIHtcbiAgICB0aGlzLnRhcmdldCA9IEdMX1RBUkdFVFMuVEVYVFVSRV8yRDtcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIHRoaXMud2lkdGggPSAtMTtcbiAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgIHRoaXMudHlwZSA9IEdMX1RZUEVTLlVOU0lHTkVEX0JZVEU7XG4gICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IEdMX0ZPUk1BVFMuUkdCQTtcbiAgICB0aGlzLmZvcm1hdCA9IEdMX0ZPUk1BVFMuUkdCQTtcbiAgICB0aGlzLnNhbXBsZXJUeXBlID0gMDtcbiAgfVxufVxuXG5leHBvcnQgeyBHbFRleHR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsVGV4dHVyZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGdsVXBsb2FkQnVmZmVySW1hZ2VSZXNvdXJjZSA9IHtcbiAgaWQ6IFwiYnVmZmVyXCIsXG4gIHVwbG9hZChzb3VyY2UsIGdsVGV4dHVyZSwgZ2wpIHtcbiAgICBpZiAoZ2xUZXh0dXJlLndpZHRoID09PSBzb3VyY2Uud2lkdGggfHwgZ2xUZXh0dXJlLmhlaWdodCA9PT0gc291cmNlLmhlaWdodCkge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgc291cmNlLndpZHRoLFxuICAgICAgICBzb3VyY2UuaGVpZ2h0LFxuICAgICAgICBnbFRleHR1cmUuZm9ybWF0LFxuICAgICAgICBnbFRleHR1cmUudHlwZSxcbiAgICAgICAgc291cmNlLnJlc291cmNlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICBnbFRleHR1cmUudGFyZ2V0LFxuICAgICAgICAwLFxuICAgICAgICBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIHNvdXJjZS53aWR0aCxcbiAgICAgICAgc291cmNlLmhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgZ2xUZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgZ2xUZXh0dXJlLnR5cGUsXG4gICAgICAgIHNvdXJjZS5yZXNvdXJjZVxuICAgICAgKTtcbiAgICB9XG4gICAgZ2xUZXh0dXJlLndpZHRoID0gc291cmNlLndpZHRoO1xuICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuICB9XG59O1xuXG5leHBvcnQgeyBnbFVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsVXBsb2FkQnVmZmVySW1hZ2VSZXNvdXJjZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNvbXByZXNzZWRGb3JtYXRNYXAgPSB7XG4gIFwiYmMxLXJnYmEtdW5vcm1cIjogdHJ1ZSxcbiAgXCJiYzEtcmdiYS11bm9ybS1zcmdiXCI6IHRydWUsXG4gIFwiYmMyLXJnYmEtdW5vcm1cIjogdHJ1ZSxcbiAgXCJiYzItcmdiYS11bm9ybS1zcmdiXCI6IHRydWUsXG4gIFwiYmMzLXJnYmEtdW5vcm1cIjogdHJ1ZSxcbiAgXCJiYzMtcmdiYS11bm9ybS1zcmdiXCI6IHRydWUsXG4gIFwiYmM0LXItdW5vcm1cIjogdHJ1ZSxcbiAgXCJiYzQtci1zbm9ybVwiOiB0cnVlLFxuICBcImJjNS1yZy11bm9ybVwiOiB0cnVlLFxuICBcImJjNS1yZy1zbm9ybVwiOiB0cnVlLFxuICBcImJjNmgtcmdiLXVmbG9hdFwiOiB0cnVlLFxuICBcImJjNmgtcmdiLWZsb2F0XCI6IHRydWUsXG4gIFwiYmM3LXJnYmEtdW5vcm1cIjogdHJ1ZSxcbiAgXCJiYzctcmdiYS11bm9ybS1zcmdiXCI6IHRydWUsXG4gIC8vIEVUQzIgY29tcHJlc3NlZCBmb3JtYXRzIHVzYWJsZSBpZiBcInRleHR1cmUtY29tcHJlc3Npb24tZXRjMlwiIGlzIGJvdGhcbiAgLy8gc3VwcG9ydGVkIGJ5IHRoZSBkZXZpY2UvdXNlciBhZ2VudCBhbmQgZW5hYmxlZCBpbiByZXF1ZXN0RGV2aWNlLlxuICBcImV0YzItcmdiOHVub3JtXCI6IHRydWUsXG4gIFwiZXRjMi1yZ2I4dW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImV0YzItcmdiOGExdW5vcm1cIjogdHJ1ZSxcbiAgXCJldGMyLXJnYjhhMXVub3JtLXNyZ2JcIjogdHJ1ZSxcbiAgXCJldGMyLXJnYmE4dW5vcm1cIjogdHJ1ZSxcbiAgXCJldGMyLXJnYmE4dW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImVhYy1yMTF1bm9ybVwiOiB0cnVlLFxuICBcImVhYy1yMTFzbm9ybVwiOiB0cnVlLFxuICBcImVhYy1yZzExdW5vcm1cIjogdHJ1ZSxcbiAgXCJlYWMtcmcxMXNub3JtXCI6IHRydWUsXG4gIC8vIEFTVEMgY29tcHJlc3NlZCBmb3JtYXRzIHVzYWJsZSBpZiBcInRleHR1cmUtY29tcHJlc3Npb24tYXN0Y1wiIGlzIGJvdGhcbiAgLy8gc3VwcG9ydGVkIGJ5IHRoZSBkZXZpY2UvdXNlciBhZ2VudCBhbmQgZW5hYmxlZCBpbiByZXF1ZXN0RGV2aWNlLlxuICBcImFzdGMtNHg0LXVub3JtXCI6IHRydWUsXG4gIFwiYXN0Yy00eDQtdW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImFzdGMtNXg0LXVub3JtXCI6IHRydWUsXG4gIFwiYXN0Yy01eDQtdW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImFzdGMtNXg1LXVub3JtXCI6IHRydWUsXG4gIFwiYXN0Yy01eDUtdW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImFzdGMtNng1LXVub3JtXCI6IHRydWUsXG4gIFwiYXN0Yy02eDUtdW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImFzdGMtNng2LXVub3JtXCI6IHRydWUsXG4gIFwiYXN0Yy02eDYtdW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImFzdGMtOHg1LXVub3JtXCI6IHRydWUsXG4gIFwiYXN0Yy04eDUtdW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImFzdGMtOHg2LXVub3JtXCI6IHRydWUsXG4gIFwiYXN0Yy04eDYtdW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImFzdGMtOHg4LXVub3JtXCI6IHRydWUsXG4gIFwiYXN0Yy04eDgtdW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImFzdGMtMTB4NS11bm9ybVwiOiB0cnVlLFxuICBcImFzdGMtMTB4NS11bm9ybS1zcmdiXCI6IHRydWUsXG4gIFwiYXN0Yy0xMHg2LXVub3JtXCI6IHRydWUsXG4gIFwiYXN0Yy0xMHg2LXVub3JtLXNyZ2JcIjogdHJ1ZSxcbiAgXCJhc3RjLTEweDgtdW5vcm1cIjogdHJ1ZSxcbiAgXCJhc3RjLTEweDgtdW5vcm0tc3JnYlwiOiB0cnVlLFxuICBcImFzdGMtMTB4MTAtdW5vcm1cIjogdHJ1ZSxcbiAgXCJhc3RjLTEweDEwLXVub3JtLXNyZ2JcIjogdHJ1ZSxcbiAgXCJhc3RjLTEyeDEwLXVub3JtXCI6IHRydWUsXG4gIFwiYXN0Yy0xMngxMC11bm9ybS1zcmdiXCI6IHRydWUsXG4gIFwiYXN0Yy0xMngxMi11bm9ybVwiOiB0cnVlLFxuICBcImFzdGMtMTJ4MTItdW5vcm0tc3JnYlwiOiB0cnVlXG59O1xuY29uc3QgZ2xVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlID0ge1xuICBpZDogXCJjb21wcmVzc2VkXCIsXG4gIHVwbG9hZChzb3VyY2UsIGdsVGV4dHVyZSwgZ2wpIHtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfQUxJR05NRU5ULCA0KTtcbiAgICBsZXQgbWlwV2lkdGggPSBzb3VyY2UucGl4ZWxXaWR0aDtcbiAgICBsZXQgbWlwSGVpZ2h0ID0gc291cmNlLnBpeGVsSGVpZ2h0O1xuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAhIWNvbXByZXNzZWRGb3JtYXRNYXBbc291cmNlLmZvcm1hdF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UucmVzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxldmVsQnVmZmVyID0gc291cmNlLnJlc291cmNlW2ldO1xuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgZ2wuY29tcHJlc3NlZFRleEltYWdlMkQoXG4gICAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgICBtaXBXaWR0aCxcbiAgICAgICAgICBtaXBIZWlnaHQsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBsZXZlbEJ1ZmZlclxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAgIGksXG4gICAgICAgICAgZ2xUZXh0dXJlLmludGVybmFsRm9ybWF0LFxuICAgICAgICAgIG1pcFdpZHRoLFxuICAgICAgICAgIG1pcEhlaWdodCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGdsVGV4dHVyZS5mb3JtYXQsXG4gICAgICAgICAgZ2xUZXh0dXJlLnR5cGUsXG4gICAgICAgICAgbGV2ZWxCdWZmZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1pcFdpZHRoID0gTWF0aC5tYXgobWlwV2lkdGggPj4gMSwgMSk7XG4gICAgICBtaXBIZWlnaHQgPSBNYXRoLm1heChtaXBIZWlnaHQgPj4gMSwgMSk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgeyBnbFVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsVXBsb2FkQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGdsVXBsb2FkSW1hZ2VSZXNvdXJjZSA9IHtcbiAgaWQ6IFwiaW1hZ2VcIixcbiAgdXBsb2FkKHNvdXJjZSwgZ2xUZXh0dXJlLCBnbCwgd2ViR0xWZXJzaW9uKSB7XG4gICAgY29uc3QgcHJlbXVsdGlwbGllZEFscGhhID0gc291cmNlLmFscGhhTW9kZSA9PT0gXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIjtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHByZW11bHRpcGxpZWRBbHBoYSk7XG4gICAgY29uc3QgZ2xXaWR0aCA9IGdsVGV4dHVyZS53aWR0aDtcbiAgICBjb25zdCBnbEhlaWdodCA9IGdsVGV4dHVyZS5oZWlnaHQ7XG4gICAgY29uc3QgdGV4dHVyZVdpZHRoID0gc291cmNlLnBpeGVsV2lkdGg7XG4gICAgY29uc3QgdGV4dHVyZUhlaWdodCA9IHNvdXJjZS5waXhlbEhlaWdodDtcbiAgICBjb25zdCByZXNvdXJjZVdpZHRoID0gc291cmNlLnJlc291cmNlV2lkdGg7XG4gICAgY29uc3QgcmVzb3VyY2VIZWlnaHQgPSBzb3VyY2UucmVzb3VyY2VIZWlnaHQ7XG4gICAgaWYgKHJlc291cmNlV2lkdGggPCB0ZXh0dXJlV2lkdGggfHwgcmVzb3VyY2VIZWlnaHQgPCB0ZXh0dXJlSGVpZ2h0KSB7XG4gICAgICBpZiAoZ2xXaWR0aCAhPT0gdGV4dHVyZVdpZHRoIHx8IGdsSGVpZ2h0ICE9PSB0ZXh0dXJlSGVpZ2h0KSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgZ2xUZXh0dXJlLnRhcmdldCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgICB0ZXh0dXJlV2lkdGgsXG4gICAgICAgICAgdGV4dHVyZUhlaWdodCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGdsVGV4dHVyZS5mb3JtYXQsXG4gICAgICAgICAgZ2xUZXh0dXJlLnR5cGUsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMikge1xuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgcmVzb3VyY2VXaWR0aCxcbiAgICAgICAgICByZXNvdXJjZUhlaWdodCxcbiAgICAgICAgICBnbFRleHR1cmUuZm9ybWF0LFxuICAgICAgICAgIGdsVGV4dHVyZS50eXBlLFxuICAgICAgICAgIHNvdXJjZS5yZXNvdXJjZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChcbiAgICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGdsVGV4dHVyZS5mb3JtYXQsXG4gICAgICAgICAgZ2xUZXh0dXJlLnR5cGUsXG4gICAgICAgICAgc291cmNlLnJlc291cmNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChnbFdpZHRoID09PSB0ZXh0dXJlV2lkdGggfHwgZ2xIZWlnaHQgPT09IHRleHR1cmVIZWlnaHQpIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGdsVGV4dHVyZS5mb3JtYXQsXG4gICAgICAgIGdsVGV4dHVyZS50eXBlLFxuICAgICAgICBzb3VyY2UucmVzb3VyY2VcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh3ZWJHTFZlcnNpb24gPT09IDIpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIGdsVGV4dHVyZS50YXJnZXQsXG4gICAgICAgIDAsXG4gICAgICAgIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgdGV4dHVyZVdpZHRoLFxuICAgICAgICB0ZXh0dXJlSGVpZ2h0LFxuICAgICAgICAwLFxuICAgICAgICBnbFRleHR1cmUuZm9ybWF0LFxuICAgICAgICBnbFRleHR1cmUudHlwZSxcbiAgICAgICAgc291cmNlLnJlc291cmNlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICBnbFRleHR1cmUudGFyZ2V0LFxuICAgICAgICAwLFxuICAgICAgICBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgIGdsVGV4dHVyZS5mb3JtYXQsXG4gICAgICAgIGdsVGV4dHVyZS50eXBlLFxuICAgICAgICBzb3VyY2UucmVzb3VyY2VcbiAgICAgICk7XG4gICAgfVxuICAgIGdsVGV4dHVyZS53aWR0aCA9IHRleHR1cmVXaWR0aDtcbiAgICBnbFRleHR1cmUuaGVpZ2h0ID0gdGV4dHVyZUhlaWdodDtcbiAgfVxufTtcblxuZXhwb3J0IHsgZ2xVcGxvYWRJbWFnZVJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbFVwbG9hZEltYWdlUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgZ2xVcGxvYWRJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9nbFVwbG9hZEltYWdlUmVzb3VyY2UubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBnbFVwbG9hZFZpZGVvUmVzb3VyY2UgPSB7XG4gIGlkOiBcInZpZGVvXCIsXG4gIHVwbG9hZChzb3VyY2UsIGdsVGV4dHVyZSwgZ2wsIHdlYkdMVmVyc2lvbikge1xuICAgIGlmICghc291cmNlLmlzVmFsaWQpIHtcbiAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIGdsVGV4dHVyZS50YXJnZXQsXG4gICAgICAgIDAsXG4gICAgICAgIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgZ2xUZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgZ2xUZXh0dXJlLnR5cGUsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGdsVXBsb2FkSW1hZ2VSZXNvdXJjZS51cGxvYWQoc291cmNlLCBnbFRleHR1cmUsIGdsLCB3ZWJHTFZlcnNpb24pO1xuICB9XG59O1xuXG5leHBvcnQgeyBnbFVwbG9hZFZpZGVvUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsVXBsb2FkVmlkZW9SZXNvdXJjZS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHNjYWxlTW9kZVRvR2xGaWx0ZXIgPSB7XG4gIGxpbmVhcjogOTcyOSxcbiAgbmVhcmVzdDogOTcyOFxufTtcbmNvbnN0IG1pcG1hcFNjYWxlTW9kZVRvR2xGaWx0ZXIgPSB7XG4gIGxpbmVhcjoge1xuICAgIGxpbmVhcjogOTk4NyxcbiAgICBuZWFyZXN0OiA5OTg1XG4gIH0sXG4gIG5lYXJlc3Q6IHtcbiAgICBsaW5lYXI6IDk5ODYsXG4gICAgbmVhcmVzdDogOTk4NFxuICB9XG59O1xuY29uc3Qgd3JhcE1vZGVUb0dsQWRkcmVzcyA9IHtcbiAgXCJjbGFtcC10by1lZGdlXCI6IDMzMDcxLFxuICByZXBlYXQ6IDEwNDk3LFxuICBcIm1pcnJvci1yZXBlYXRcIjogMzM2NDhcbn07XG5jb25zdCBjb21wYXJlTW9kZVRvR2xDb21wYXJlID0ge1xuICBuZXZlcjogNTEyLFxuICBsZXNzOiA1MTMsXG4gIGVxdWFsOiA1MTQsXG4gIFwibGVzcy1lcXVhbFwiOiA1MTUsXG4gIGdyZWF0ZXI6IDUxNixcbiAgXCJub3QtZXF1YWxcIjogNTE3LFxuICBcImdyZWF0ZXItZXF1YWxcIjogNTE4LFxuICBhbHdheXM6IDUxOVxufTtcblxuZXhwb3J0IHsgY29tcGFyZU1vZGVUb0dsQ29tcGFyZSwgbWlwbWFwU2NhbGVNb2RlVG9HbEZpbHRlciwgc2NhbGVNb2RlVG9HbEZpbHRlciwgd3JhcE1vZGVUb0dsQWRkcmVzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGl4aVRvR2xNYXBzLm1qcy5tYXBcbiIsImltcG9ydCB7IHdyYXBNb2RlVG9HbEFkZHJlc3MsIHNjYWxlTW9kZVRvR2xGaWx0ZXIsIG1pcG1hcFNjYWxlTW9kZVRvR2xGaWx0ZXIsIGNvbXBhcmVNb2RlVG9HbENvbXBhcmUgfSBmcm9tICcuL3BpeGlUb0dsTWFwcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFwcGx5U3R5bGVQYXJhbXMoc3R5bGUsIGdsLCBtaXBtYXBzLCBhbmlzb3Ryb3BpY0V4dCwgZ2xGdW5jdGlvbk5hbWUsIGZpcnN0UGFyYW0sIGZvcmNlQ2xhbXAsIGZpcnN0Q3JlYXRpb24pIHtcbiAgY29uc3QgY2FzdFBhcmFtID0gZmlyc3RQYXJhbTtcbiAgaWYgKCFmaXJzdENyZWF0aW9uIHx8IHN0eWxlLmFkZHJlc3NNb2RlVSAhPT0gXCJyZXBlYXRcIiB8fCBzdHlsZS5hZGRyZXNzTW9kZVYgIT09IFwicmVwZWF0XCIgfHwgc3R5bGUuYWRkcmVzc01vZGVXICE9PSBcInJlcGVhdFwiKSB7XG4gICAgY29uc3Qgd3JhcE1vZGVTID0gd3JhcE1vZGVUb0dsQWRkcmVzc1tmb3JjZUNsYW1wID8gXCJjbGFtcC10by1lZGdlXCIgOiBzdHlsZS5hZGRyZXNzTW9kZVVdO1xuICAgIGNvbnN0IHdyYXBNb2RlVCA9IHdyYXBNb2RlVG9HbEFkZHJlc3NbZm9yY2VDbGFtcCA/IFwiY2xhbXAtdG8tZWRnZVwiIDogc3R5bGUuYWRkcmVzc01vZGVWXTtcbiAgICBjb25zdCB3cmFwTW9kZVIgPSB3cmFwTW9kZVRvR2xBZGRyZXNzW2ZvcmNlQ2xhbXAgPyBcImNsYW1wLXRvLWVkZ2VcIiA6IHN0eWxlLmFkZHJlc3NNb2RlV107XG4gICAgZ2xbZ2xGdW5jdGlvbk5hbWVdKGNhc3RQYXJhbSwgZ2wuVEVYVFVSRV9XUkFQX1MsIHdyYXBNb2RlUyk7XG4gICAgZ2xbZ2xGdW5jdGlvbk5hbWVdKGNhc3RQYXJhbSwgZ2wuVEVYVFVSRV9XUkFQX1QsIHdyYXBNb2RlVCk7XG4gICAgaWYgKGdsLlRFWFRVUkVfV1JBUF9SKVxuICAgICAgZ2xbZ2xGdW5jdGlvbk5hbWVdKGNhc3RQYXJhbSwgZ2wuVEVYVFVSRV9XUkFQX1IsIHdyYXBNb2RlUik7XG4gIH1cbiAgaWYgKCFmaXJzdENyZWF0aW9uIHx8IHN0eWxlLm1hZ0ZpbHRlciAhPT0gXCJsaW5lYXJcIikge1xuICAgIGdsW2dsRnVuY3Rpb25OYW1lXShjYXN0UGFyYW0sIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgc2NhbGVNb2RlVG9HbEZpbHRlcltzdHlsZS5tYWdGaWx0ZXJdKTtcbiAgfVxuICBpZiAobWlwbWFwcykge1xuICAgIGlmICghZmlyc3RDcmVhdGlvbiB8fCBzdHlsZS5taXBtYXBGaWx0ZXIgIT09IFwibGluZWFyXCIpIHtcbiAgICAgIGNvbnN0IGdsRmlsdGVyTW9kZSA9IG1pcG1hcFNjYWxlTW9kZVRvR2xGaWx0ZXJbc3R5bGUubWluRmlsdGVyXVtzdHlsZS5taXBtYXBGaWx0ZXJdO1xuICAgICAgZ2xbZ2xGdW5jdGlvbk5hbWVdKGNhc3RQYXJhbSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbEZpbHRlck1vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBnbFtnbEZ1bmN0aW9uTmFtZV0oY2FzdFBhcmFtLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHNjYWxlTW9kZVRvR2xGaWx0ZXJbc3R5bGUubWluRmlsdGVyXSk7XG4gIH1cbiAgaWYgKGFuaXNvdHJvcGljRXh0ICYmIHN0eWxlLm1heEFuaXNvdHJvcHkgPiAxKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBNYXRoLm1pbihzdHlsZS5tYXhBbmlzb3Ryb3B5LCBnbC5nZXRQYXJhbWV0ZXIoYW5pc290cm9waWNFeHQuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKSk7XG4gICAgZ2xbZ2xGdW5jdGlvbk5hbWVdKGNhc3RQYXJhbSwgYW5pc290cm9waWNFeHQuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIGxldmVsKTtcbiAgfVxuICBpZiAoc3R5bGUuY29tcGFyZSkge1xuICAgIGdsW2dsRnVuY3Rpb25OYW1lXShjYXN0UGFyYW0sIGdsLlRFWFRVUkVfQ09NUEFSRV9GVU5DLCBjb21wYXJlTW9kZVRvR2xDb21wYXJlW3N0eWxlLmNvbXBhcmVdKTtcbiAgfVxufVxuXG5leHBvcnQgeyBhcHBseVN0eWxlUGFyYW1zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBseVN0eWxlUGFyYW1zLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbWFwRm9ybWF0VG9HbEZvcm1hdChnbCkge1xuICByZXR1cm4ge1xuICAgIC8vIDgtYml0IGZvcm1hdHNcbiAgICByOHVub3JtOiBnbC5SRUQsXG4gICAgcjhzbm9ybTogZ2wuUkVELFxuICAgIHI4dWludDogZ2wuUkVELFxuICAgIHI4c2ludDogZ2wuUkVELFxuICAgIC8vIDE2LWJpdCBmb3JtYXRzXG4gICAgcjE2dWludDogZ2wuUkVELFxuICAgIHIxNnNpbnQ6IGdsLlJFRCxcbiAgICByMTZmbG9hdDogZ2wuUkVELFxuICAgIHJnOHVub3JtOiBnbC5SRyxcbiAgICByZzhzbm9ybTogZ2wuUkcsXG4gICAgcmc4dWludDogZ2wuUkcsXG4gICAgcmc4c2ludDogZ2wuUkcsXG4gICAgLy8gMzItYml0IGZvcm1hdHNcbiAgICByMzJ1aW50OiBnbC5SRUQsXG4gICAgcjMyc2ludDogZ2wuUkVELFxuICAgIHIzMmZsb2F0OiBnbC5SRUQsXG4gICAgcmcxNnVpbnQ6IGdsLlJHLFxuICAgIHJnMTZzaW50OiBnbC5SRyxcbiAgICByZzE2ZmxvYXQ6IGdsLlJHLFxuICAgIHJnYmE4dW5vcm06IGdsLlJHQkEsXG4gICAgXCJyZ2JhOHVub3JtLXNyZ2JcIjogZ2wuUkdCQSxcbiAgICAvLyBQYWNrZWQgMzItYml0IGZvcm1hdHNcbiAgICByZ2JhOHNub3JtOiBnbC5SR0JBLFxuICAgIHJnYmE4dWludDogZ2wuUkdCQSxcbiAgICByZ2JhOHNpbnQ6IGdsLlJHQkEsXG4gICAgYmdyYTh1bm9ybTogZ2wuUkdCQSxcbiAgICBcImJncmE4dW5vcm0tc3JnYlwiOiBnbC5SR0JBLFxuICAgIHJnYjllNXVmbG9hdDogZ2wuUkdCLFxuICAgIHJnYjEwYTJ1bm9ybTogZ2wuUkdCQSxcbiAgICByZzExYjEwdWZsb2F0OiBnbC5SR0IsXG4gICAgLy8gNjQtYml0IGZvcm1hdHNcbiAgICByZzMydWludDogZ2wuUkcsXG4gICAgcmczMnNpbnQ6IGdsLlJHLFxuICAgIHJnMzJmbG9hdDogZ2wuUkcsXG4gICAgcmdiYTE2dWludDogZ2wuUkdCQSxcbiAgICByZ2JhMTZzaW50OiBnbC5SR0JBLFxuICAgIHJnYmExNmZsb2F0OiBnbC5SR0JBLFxuICAgIC8vIDEyOC1iaXQgZm9ybWF0c1xuICAgIHJnYmEzMnVpbnQ6IGdsLlJHQkEsXG4gICAgcmdiYTMyc2ludDogZ2wuUkdCQSxcbiAgICByZ2JhMzJmbG9hdDogZ2wuUkdCQSxcbiAgICAvLyBEZXB0aC9zdGVuY2lsIGZvcm1hdHNcbiAgICBzdGVuY2lsODogZ2wuU1RFTkNJTF9JTkRFWDgsXG4gICAgZGVwdGgxNnVub3JtOiBnbC5ERVBUSF9DT01QT05FTlQsXG4gICAgZGVwdGgyNHBsdXM6IGdsLkRFUFRIX0NPTVBPTkVOVCxcbiAgICBcImRlcHRoMjRwbHVzLXN0ZW5jaWw4XCI6IGdsLkRFUFRIX1NURU5DSUwsXG4gICAgZGVwdGgzMmZsb2F0OiBnbC5ERVBUSF9DT01QT05FTlQsXG4gICAgXCJkZXB0aDMyZmxvYXQtc3RlbmNpbDhcIjogZ2wuREVQVEhfU1RFTkNJTFxuICB9O1xufVxuXG5leHBvcnQgeyBtYXBGb3JtYXRUb0dsRm9ybWF0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBGb3JtYXRUb0dsRm9ybWF0Lm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbWFwRm9ybWF0VG9HbEludGVybmFsRm9ybWF0KGdsLCBleHRlbnNpb25zKSB7XG4gIGxldCBzcmdiID0ge307XG4gIGxldCBiZ3JhOHVub3JtID0gZ2wuUkdCQTtcbiAgaWYgKCEoZ2wgaW5zdGFuY2VvZiBET01BZGFwdGVyLmdldCgpLmdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCgpKSkge1xuICAgIHNyZ2IgPSB7XG4gICAgICBcInJnYmE4dW5vcm0tc3JnYlwiOiBnbC5TUkdCOF9BTFBIQTgsXG4gICAgICBcImJncmE4dW5vcm0tc3JnYlwiOiBnbC5TUkdCOF9BTFBIQThcbiAgICB9O1xuICAgIGJncmE4dW5vcm0gPSBnbC5SR0JBODtcbiAgfSBlbHNlIGlmIChleHRlbnNpb25zLnNyZ2IpIHtcbiAgICBzcmdiID0ge1xuICAgICAgXCJyZ2JhOHVub3JtLXNyZ2JcIjogZXh0ZW5zaW9ucy5zcmdiLlNSR0I4X0FMUEhBOF9FWFQsXG4gICAgICBcImJncmE4dW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLnNyZ2IuU1JHQjhfQUxQSEE4X0VYVFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAvLyA4LWJpdCBmb3JtYXRzXG4gICAgcjh1bm9ybTogZ2wuUjgsXG4gICAgcjhzbm9ybTogZ2wuUjhfU05PUk0sXG4gICAgcjh1aW50OiBnbC5SOFVJLFxuICAgIHI4c2ludDogZ2wuUjhJLFxuICAgIC8vIDE2LWJpdCBmb3JtYXRzXG4gICAgcjE2dWludDogZ2wuUjE2VUksXG4gICAgcjE2c2ludDogZ2wuUjE2SSxcbiAgICByMTZmbG9hdDogZ2wuUjE2RixcbiAgICByZzh1bm9ybTogZ2wuUkc4LFxuICAgIHJnOHNub3JtOiBnbC5SRzhfU05PUk0sXG4gICAgcmc4dWludDogZ2wuUkc4VUksXG4gICAgcmc4c2ludDogZ2wuUkc4SSxcbiAgICAvLyAzMi1iaXQgZm9ybWF0c1xuICAgIHIzMnVpbnQ6IGdsLlIzMlVJLFxuICAgIHIzMnNpbnQ6IGdsLlIzMkksXG4gICAgcjMyZmxvYXQ6IGdsLlIzMkYsXG4gICAgcmcxNnVpbnQ6IGdsLlJHMTZVSSxcbiAgICByZzE2c2ludDogZ2wuUkcxNkksXG4gICAgcmcxNmZsb2F0OiBnbC5SRzE2RixcbiAgICByZ2JhOHVub3JtOiBnbC5SR0JBLFxuICAgIC4uLnNyZ2IsXG4gICAgLy8gUGFja2VkIDMyLWJpdCBmb3JtYXRzXG4gICAgcmdiYThzbm9ybTogZ2wuUkdCQThfU05PUk0sXG4gICAgcmdiYTh1aW50OiBnbC5SR0JBOFVJLFxuICAgIHJnYmE4c2ludDogZ2wuUkdCQThJLFxuICAgIGJncmE4dW5vcm0sXG4gICAgcmdiOWU1dWZsb2F0OiBnbC5SR0I5X0U1LFxuICAgIHJnYjEwYTJ1bm9ybTogZ2wuUkdCMTBfQTIsXG4gICAgcmcxMWIxMHVmbG9hdDogZ2wuUjExRl9HMTFGX0IxMEYsXG4gICAgLy8gNjQtYml0IGZvcm1hdHNcbiAgICByZzMydWludDogZ2wuUkczMlVJLFxuICAgIHJnMzJzaW50OiBnbC5SRzMySSxcbiAgICByZzMyZmxvYXQ6IGdsLlJHMzJGLFxuICAgIHJnYmExNnVpbnQ6IGdsLlJHQkExNlVJLFxuICAgIHJnYmExNnNpbnQ6IGdsLlJHQkExNkksXG4gICAgcmdiYTE2ZmxvYXQ6IGdsLlJHQkExNkYsXG4gICAgLy8gMTI4LWJpdCBmb3JtYXRzXG4gICAgcmdiYTMydWludDogZ2wuUkdCQTMyVUksXG4gICAgcmdiYTMyc2ludDogZ2wuUkdCQTMySSxcbiAgICByZ2JhMzJmbG9hdDogZ2wuUkdCQTMyRixcbiAgICAvLyBEZXB0aC9zdGVuY2lsIGZvcm1hdHNcbiAgICBzdGVuY2lsODogZ2wuU1RFTkNJTF9JTkRFWDgsXG4gICAgZGVwdGgxNnVub3JtOiBnbC5ERVBUSF9DT01QT05FTlQxNixcbiAgICBkZXB0aDI0cGx1czogZ2wuREVQVEhfQ09NUE9ORU5UMjQsXG4gICAgXCJkZXB0aDI0cGx1cy1zdGVuY2lsOFwiOiBnbC5ERVBUSDI0X1NURU5DSUw4LFxuICAgIGRlcHRoMzJmbG9hdDogZ2wuREVQVEhfQ09NUE9ORU5UMzJGLFxuICAgIFwiZGVwdGgzMmZsb2F0LXN0ZW5jaWw4XCI6IGdsLkRFUFRIMzJGX1NURU5DSUw4LFxuICAgIC8vIENvbXByZXNzZWQgZm9ybWF0c1xuICAgIC4uLmV4dGVuc2lvbnMuczN0YyA/IHtcbiAgICAgIFwiYmMxLXJnYmEtdW5vcm1cIjogZXh0ZW5zaW9ucy5zM3RjLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICAgICAgXCJiYzItcmdiYS11bm9ybVwiOiBleHRlbnNpb25zLnMzdGMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQsXG4gICAgICBcImJjMy1yZ2JhLXVub3JtXCI6IGV4dGVuc2lvbnMuczN0Yy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFxuICAgIH0gOiB7fSxcbiAgICAuLi5leHRlbnNpb25zLnMzdGNfc1JHQiA/IHtcbiAgICAgIFwiYmMxLXJnYmEtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLnMzdGNfc1JHQi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVCxcbiAgICAgIFwiYmMyLXJnYmEtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLnMzdGNfc1JHQi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQzX0VYVCxcbiAgICAgIFwiYmMzLXJnYmEtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLnMzdGNfc1JHQi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVFxuICAgIH0gOiB7fSxcbiAgICAuLi5leHRlbnNpb25zLnJndGMgPyB7XG4gICAgICBcImJjNC1yLXVub3JtXCI6IGV4dGVuc2lvbnMucmd0Yy5DT01QUkVTU0VEX1JFRF9SR1RDMV9FWFQsXG4gICAgICBcImJjNC1yLXNub3JtXCI6IGV4dGVuc2lvbnMucmd0Yy5DT01QUkVTU0VEX1NJR05FRF9SRURfUkdUQzFfRVhULFxuICAgICAgXCJiYzUtcmctdW5vcm1cIjogZXh0ZW5zaW9ucy5yZ3RjLkNPTVBSRVNTRURfUkVEX0dSRUVOX1JHVEMyX0VYVCxcbiAgICAgIFwiYmM1LXJnLXNub3JtXCI6IGV4dGVuc2lvbnMucmd0Yy5DT01QUkVTU0VEX1NJR05FRF9SRURfR1JFRU5fUkdUQzJfRVhUXG4gICAgfSA6IHt9LFxuICAgIC4uLmV4dGVuc2lvbnMuYnB0YyA/IHtcbiAgICAgIFwiYmM2aC1yZ2ItZmxvYXRcIjogZXh0ZW5zaW9ucy5icHRjLkNPTVBSRVNTRURfUkdCX0JQVENfU0lHTkVEX0ZMT0FUX0VYVCxcbiAgICAgIFwiYmM2aC1yZ2ItdWZsb2F0XCI6IGV4dGVuc2lvbnMuYnB0Yy5DT01QUkVTU0VEX1JHQl9CUFRDX1VOU0lHTkVEX0ZMT0FUX0VYVCxcbiAgICAgIFwiYmM3LXJnYmEtdW5vcm1cIjogZXh0ZW5zaW9ucy5icHRjLkNPTVBSRVNTRURfUkdCQV9CUFRDX1VOT1JNX0VYVCxcbiAgICAgIFwiYmM3LXJnYmEtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmJwdGMuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX0JQVENfVU5PUk1fRVhUXG4gICAgfSA6IHt9LFxuICAgIC4uLmV4dGVuc2lvbnMuZXRjID8ge1xuICAgICAgXCJldGMyLXJnYjh1bm9ybVwiOiBleHRlbnNpb25zLmV0Yy5DT01QUkVTU0VEX1JHQjhfRVRDMixcbiAgICAgIFwiZXRjMi1yZ2I4dW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmV0Yy5DT01QUkVTU0VEX1NSR0I4X0VUQzIsXG4gICAgICBcImV0YzItcmdiOGExdW5vcm1cIjogZXh0ZW5zaW9ucy5ldGMuQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMixcbiAgICAgIFwiZXRjMi1yZ2I4YTF1bm9ybS1zcmdiXCI6IGV4dGVuc2lvbnMuZXRjLkNPTVBSRVNTRURfU1JHQjhfUFVOQ0hUSFJPVUdIX0FMUEhBMV9FVEMyLFxuICAgICAgXCJldGMyLXJnYmE4dW5vcm1cIjogZXh0ZW5zaW9ucy5ldGMuQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQyxcbiAgICAgIFwiZXRjMi1yZ2JhOHVub3JtLXNyZ2JcIjogZXh0ZW5zaW9ucy5ldGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUMsXG4gICAgICBcImVhYy1yMTF1bm9ybVwiOiBleHRlbnNpb25zLmV0Yy5DT01QUkVTU0VEX1IxMV9FQUMsXG4gICAgICAvLyAnZWFjLXIxMXNub3JtJ1xuICAgICAgXCJlYWMtcmcxMXVub3JtXCI6IGV4dGVuc2lvbnMuZXRjLkNPTVBSRVNTRURfU0lHTkVEX1JHMTFfRUFDXG4gICAgICAvLyAnZWFjLXJnMTFzbm9ybSdcbiAgICB9IDoge30sXG4gICAgLi4uZXh0ZW5zaW9ucy5hc3RjID8ge1xuICAgICAgXCJhc3RjLTR4NC11bm9ybVwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9SR0JBX0FTVENfNHg0X0tIUixcbiAgICAgIFwiYXN0Yy00eDQtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ180eDRfS0hSLFxuICAgICAgXCJhc3RjLTV4NC11bm9ybVwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9SR0JBX0FTVENfNXg0X0tIUixcbiAgICAgIFwiYXN0Yy01eDQtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDRfS0hSLFxuICAgICAgXCJhc3RjLTV4NS11bm9ybVwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9SR0JBX0FTVENfNXg1X0tIUixcbiAgICAgIFwiYXN0Yy01eDUtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDVfS0hSLFxuICAgICAgXCJhc3RjLTZ4NS11bm9ybVwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9SR0JBX0FTVENfNng1X0tIUixcbiAgICAgIFwiYXN0Yy02eDUtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDVfS0hSLFxuICAgICAgXCJhc3RjLTZ4Ni11bm9ybVwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9SR0JBX0FTVENfNng2X0tIUixcbiAgICAgIFwiYXN0Yy02eDYtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDZfS0hSLFxuICAgICAgXCJhc3RjLTh4NS11bm9ybVwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg1X0tIUixcbiAgICAgIFwiYXN0Yy04eDUtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDVfS0hSLFxuICAgICAgXCJhc3RjLTh4Ni11bm9ybVwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg2X0tIUixcbiAgICAgIFwiYXN0Yy04eDYtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDZfS0hSLFxuICAgICAgXCJhc3RjLTh4OC11bm9ybVwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9SR0JBX0FTVENfOHg4X0tIUixcbiAgICAgIFwiYXN0Yy04eDgtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDhfS0hSLFxuICAgICAgXCJhc3RjLTEweDUtdW5vcm1cIjogZXh0ZW5zaW9ucy5hc3RjLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDVfS0hSLFxuICAgICAgXCJhc3RjLTEweDUtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHg1X0tIUixcbiAgICAgIFwiYXN0Yy0xMHg2LXVub3JtXCI6IGV4dGVuc2lvbnMuYXN0Yy5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHg2X0tIUixcbiAgICAgIFwiYXN0Yy0xMHg2LXVub3JtLXNyZ2JcIjogZXh0ZW5zaW9ucy5hc3RjLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4Nl9LSFIsXG4gICAgICBcImFzdGMtMTB4OC11bm9ybVwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4OF9LSFIsXG4gICAgICBcImFzdGMtMTB4OC11bm9ybS1zcmdiXCI6IGV4dGVuc2lvbnMuYXN0Yy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDhfS0hSLFxuICAgICAgXCJhc3RjLTEweDEwLXVub3JtXCI6IGV4dGVuc2lvbnMuYXN0Yy5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHgxMF9LSFIsXG4gICAgICBcImFzdGMtMTB4MTAtdW5vcm0tc3JnYlwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHgxMF9LSFIsXG4gICAgICBcImFzdGMtMTJ4MTAtdW5vcm1cIjogZXh0ZW5zaW9ucy5hc3RjLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEyeDEwX0tIUixcbiAgICAgIFwiYXN0Yy0xMngxMC11bm9ybS1zcmdiXCI6IGV4dGVuc2lvbnMuYXN0Yy5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEwX0tIUixcbiAgICAgIFwiYXN0Yy0xMngxMi11bm9ybVwiOiBleHRlbnNpb25zLmFzdGMuQ09NUFJFU1NFRF9SR0JBX0FTVENfMTJ4MTJfS0hSLFxuICAgICAgXCJhc3RjLTEyeDEyLXVub3JtLXNyZ2JcIjogZXh0ZW5zaW9ucy5hc3RjLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTJfS0hSXG4gICAgfSA6IHt9XG4gIH07XG59XG5cbmV4cG9ydCB7IG1hcEZvcm1hdFRvR2xJbnRlcm5hbEZvcm1hdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwRm9ybWF0VG9HbEludGVybmFsRm9ybWF0Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbWFwRm9ybWF0VG9HbFR5cGUoZ2wpIHtcbiAgcmV0dXJuIHtcbiAgICAvLyA4LWJpdCBmb3JtYXRzXG4gICAgcjh1bm9ybTogZ2wuVU5TSUdORURfQllURSxcbiAgICByOHNub3JtOiBnbC5CWVRFLFxuICAgIHI4dWludDogZ2wuVU5TSUdORURfQllURSxcbiAgICByOHNpbnQ6IGdsLkJZVEUsXG4gICAgLy8gMTYtYml0IGZvcm1hdHNcbiAgICByMTZ1aW50OiBnbC5VTlNJR05FRF9TSE9SVCxcbiAgICByMTZzaW50OiBnbC5TSE9SVCxcbiAgICByMTZmbG9hdDogZ2wuSEFMRl9GTE9BVCxcbiAgICByZzh1bm9ybTogZ2wuVU5TSUdORURfQllURSxcbiAgICByZzhzbm9ybTogZ2wuQllURSxcbiAgICByZzh1aW50OiBnbC5VTlNJR05FRF9CWVRFLFxuICAgIHJnOHNpbnQ6IGdsLkJZVEUsXG4gICAgLy8gMzItYml0IGZvcm1hdHNcbiAgICByMzJ1aW50OiBnbC5VTlNJR05FRF9JTlQsXG4gICAgcjMyc2ludDogZ2wuSU5ULFxuICAgIHIzMmZsb2F0OiBnbC5GTE9BVCxcbiAgICByZzE2dWludDogZ2wuVU5TSUdORURfU0hPUlQsXG4gICAgcmcxNnNpbnQ6IGdsLlNIT1JULFxuICAgIHJnMTZmbG9hdDogZ2wuSEFMRl9GTE9BVCxcbiAgICByZ2JhOHVub3JtOiBnbC5VTlNJR05FRF9CWVRFLFxuICAgIFwicmdiYTh1bm9ybS1zcmdiXCI6IGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgLy8gUGFja2VkIDMyLWJpdCBmb3JtYXRzXG4gICAgcmdiYThzbm9ybTogZ2wuQllURSxcbiAgICByZ2JhOHVpbnQ6IGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgcmdiYThzaW50OiBnbC5CWVRFLFxuICAgIGJncmE4dW5vcm06IGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgXCJiZ3JhOHVub3JtLXNyZ2JcIjogZ2wuVU5TSUdORURfQllURSxcbiAgICByZ2I5ZTV1ZmxvYXQ6IGdsLlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVixcbiAgICByZ2IxMGEydW5vcm06IGdsLlVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVixcbiAgICByZzExYjEwdWZsb2F0OiBnbC5VTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWLFxuICAgIC8vIDY0LWJpdCBmb3JtYXRzXG4gICAgcmczMnVpbnQ6IGdsLlVOU0lHTkVEX0lOVCxcbiAgICByZzMyc2ludDogZ2wuSU5ULFxuICAgIHJnMzJmbG9hdDogZ2wuRkxPQVQsXG4gICAgcmdiYTE2dWludDogZ2wuVU5TSUdORURfU0hPUlQsXG4gICAgcmdiYTE2c2ludDogZ2wuU0hPUlQsXG4gICAgcmdiYTE2ZmxvYXQ6IGdsLkhBTEZfRkxPQVQsXG4gICAgLy8gMTI4LWJpdCBmb3JtYXRzXG4gICAgcmdiYTMydWludDogZ2wuVU5TSUdORURfSU5ULFxuICAgIHJnYmEzMnNpbnQ6IGdsLklOVCxcbiAgICByZ2JhMzJmbG9hdDogZ2wuRkxPQVQsXG4gICAgLy8gRGVwdGgvc3RlbmNpbCBmb3JtYXRzXG4gICAgc3RlbmNpbDg6IGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgZGVwdGgxNnVub3JtOiBnbC5VTlNJR05FRF9TSE9SVCxcbiAgICBkZXB0aDI0cGx1czogZ2wuVU5TSUdORURfSU5ULFxuICAgIFwiZGVwdGgyNHBsdXMtc3RlbmNpbDhcIjogZ2wuVU5TSUdORURfSU5UXzI0XzgsXG4gICAgZGVwdGgzMmZsb2F0OiBnbC5GTE9BVCxcbiAgICBcImRlcHRoMzJmbG9hdC1zdGVuY2lsOFwiOiBnbC5GTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVZcbiAgfTtcbn1cblxuZXhwb3J0IHsgbWFwRm9ybWF0VG9HbFR5cGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcEZvcm1hdFRvR2xUeXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgR2xUZXh0dXJlIH0gZnJvbSAnLi9HbFRleHR1cmUubWpzJztcbmltcG9ydCB7IGdsVXBsb2FkQnVmZmVySW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vdXBsb2FkZXJzL2dsVXBsb2FkQnVmZmVySW1hZ2VSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgZ2xVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlIH0gZnJvbSAnLi91cGxvYWRlcnMvZ2xVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBnbFVwbG9hZEltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3VwbG9hZGVycy9nbFVwbG9hZEltYWdlUmVzb3VyY2UubWpzJztcbmltcG9ydCB7IGdsVXBsb2FkVmlkZW9SZXNvdXJjZSB9IGZyb20gJy4vdXBsb2FkZXJzL2dsVXBsb2FkVmlkZW9SZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgYXBwbHlTdHlsZVBhcmFtcyB9IGZyb20gJy4vdXRpbHMvYXBwbHlTdHlsZVBhcmFtcy5tanMnO1xuaW1wb3J0IHsgbWFwRm9ybWF0VG9HbEZvcm1hdCB9IGZyb20gJy4vdXRpbHMvbWFwRm9ybWF0VG9HbEZvcm1hdC5tanMnO1xuaW1wb3J0IHsgbWFwRm9ybWF0VG9HbEludGVybmFsRm9ybWF0IH0gZnJvbSAnLi91dGlscy9tYXBGb3JtYXRUb0dsSW50ZXJuYWxGb3JtYXQubWpzJztcbmltcG9ydCB7IG1hcEZvcm1hdFRvR2xUeXBlIH0gZnJvbSAnLi91dGlscy9tYXBGb3JtYXRUb0dsVHlwZS5tanMnO1xuaW1wb3J0ICcuL3V0aWxzL3VucHJlbXVsdGlwbHlBbHBoYS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IEJZVEVTX1BFUl9QSVhFTCA9IDQ7XG5jbGFzcyBHbFRleHR1cmVTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMubWFuYWdlZFRleHR1cmVzID0gW107XG4gICAgdGhpcy5fZ2xUZXh0dXJlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2dsU2FtcGxlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ib3VuZFRleHR1cmVzID0gW107XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZUxvY2F0aW9uID0gLTE7XG4gICAgdGhpcy5fYm91bmRTYW1wbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3VwbG9hZHMgPSB7XG4gICAgICBpbWFnZTogZ2xVcGxvYWRJbWFnZVJlc291cmNlLFxuICAgICAgYnVmZmVyOiBnbFVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UsXG4gICAgICB2aWRlbzogZ2xVcGxvYWRWaWRlb1Jlc291cmNlLFxuICAgICAgY29tcHJlc3NlZDogZ2xVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlXG4gICAgfTtcbiAgICAvLyBUT0RPIC0gc2VwYXJhdGUgc2FtcGxlcnMgd2lsbCBiZSBhIGNvb2wgdGhpbmcgdG8gYWRkLCBidXQgbm90IHJpZ2h0IG5vdyFcbiAgICB0aGlzLl91c2VTZXBhcmF0ZVNhbXBsZXJzID0gZmFsc2U7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgdGhpcy5fZ2wgPSBnbDtcbiAgICBpZiAoIXRoaXMuX21hcEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQpIHtcbiAgICAgIHRoaXMuX21hcEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQgPSBtYXBGb3JtYXRUb0dsSW50ZXJuYWxGb3JtYXQoZ2wsIHRoaXMuX3JlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9ucyk7XG4gICAgICB0aGlzLl9tYXBGb3JtYXRUb1R5cGUgPSBtYXBGb3JtYXRUb0dsVHlwZShnbCk7XG4gICAgICB0aGlzLl9tYXBGb3JtYXRUb0Zvcm1hdCA9IG1hcEZvcm1hdFRvR2xGb3JtYXQoZ2wpO1xuICAgIH1cbiAgICB0aGlzLl9nbFRleHR1cmVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZ2xTYW1wbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2JvdW5kU2FtcGxlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHRoaXMuYmluZChUZXh0dXJlLkVNUFRZLCBpKTtcbiAgICB9XG4gIH1cbiAgaW5pdFNvdXJjZShzb3VyY2UpIHtcbiAgICB0aGlzLmJpbmQoc291cmNlKTtcbiAgfVxuICBiaW5kKHRleHR1cmUsIGxvY2F0aW9uID0gMCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRleHR1cmUuc291cmNlO1xuICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICB0aGlzLmJpbmRTb3VyY2Uoc291cmNlLCBsb2NhdGlvbik7XG4gICAgICBpZiAodGhpcy5fdXNlU2VwYXJhdGVTYW1wbGVycykge1xuICAgICAgICB0aGlzLl9iaW5kU2FtcGxlcihzb3VyY2Uuc3R5bGUsIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaW5kU291cmNlKG51bGwsIGxvY2F0aW9uKTtcbiAgICAgIGlmICh0aGlzLl91c2VTZXBhcmF0ZVNhbXBsZXJzKSB7XG4gICAgICAgIHRoaXMuX2JpbmRTYW1wbGVyKG51bGwsIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmluZFNvdXJjZShzb3VyY2UsIGxvY2F0aW9uID0gMCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgc291cmNlLl90b3VjaGVkID0gdGhpcy5fcmVuZGVyZXIudGV4dHVyZUdDLmNvdW50O1xuICAgIGlmICh0aGlzLl9ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSAhPT0gc291cmNlKSB7XG4gICAgICB0aGlzLl9ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuX2FjdGl2YXRlTG9jYXRpb24obG9jYXRpb24pO1xuICAgICAgc291cmNlID0gc291cmNlIHx8IFRleHR1cmUuRU1QVFkuc291cmNlO1xuICAgICAgY29uc3QgZ2xUZXh0dXJlID0gdGhpcy5nZXRHbFNvdXJjZShzb3VyY2UpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2xUZXh0dXJlLnRhcmdldCwgZ2xUZXh0dXJlLnRleHR1cmUpO1xuICAgIH1cbiAgfVxuICBfYmluZFNhbXBsZXIoc3R5bGUsIGxvY2F0aW9uID0gMCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgaWYgKCFzdHlsZSkge1xuICAgICAgdGhpcy5fYm91bmRTYW1wbGVyc1tsb2NhdGlvbl0gPSBudWxsO1xuICAgICAgZ2wuYmluZFNhbXBsZXIobG9jYXRpb24sIG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzYW1wbGVyID0gdGhpcy5fZ2V0R2xTYW1wbGVyKHN0eWxlKTtcbiAgICBpZiAodGhpcy5fYm91bmRTYW1wbGVyc1tsb2NhdGlvbl0gIT09IHNhbXBsZXIpIHtcbiAgICAgIHRoaXMuX2JvdW5kU2FtcGxlcnNbbG9jYXRpb25dID0gc2FtcGxlcjtcbiAgICAgIGdsLmJpbmRTYW1wbGVyKGxvY2F0aW9uLCBzYW1wbGVyKTtcbiAgICB9XG4gIH1cbiAgdW5iaW5kKHRleHR1cmUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcbiAgICBjb25zdCBib3VuZFRleHR1cmVzID0gdGhpcy5fYm91bmRUZXh0dXJlcztcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGJvdW5kVGV4dHVyZXNbaV0gPT09IHNvdXJjZSkge1xuICAgICAgICB0aGlzLl9hY3RpdmF0ZUxvY2F0aW9uKGkpO1xuICAgICAgICBjb25zdCBnbFRleHR1cmUgPSB0aGlzLmdldEdsU291cmNlKHNvdXJjZSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsVGV4dHVyZS50YXJnZXQsIG51bGwpO1xuICAgICAgICBib3VuZFRleHR1cmVzW2ldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2FjdGl2YXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlVGV4dHVyZUxvY2F0aW9uICE9PSBsb2NhdGlvbikge1xuICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZUxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICB0aGlzLl9nbC5hY3RpdmVUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuICAgIH1cbiAgfVxuICBfaW5pdFNvdXJjZShzb3VyY2UpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IGdsVGV4dHVyZSA9IG5ldyBHbFRleHR1cmUoZ2wuY3JlYXRlVGV4dHVyZSgpKTtcbiAgICBnbFRleHR1cmUudHlwZSA9IHRoaXMuX21hcEZvcm1hdFRvVHlwZVtzb3VyY2UuZm9ybWF0XTtcbiAgICBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQgPSB0aGlzLl9tYXBGb3JtYXRUb0ludGVybmFsRm9ybWF0W3NvdXJjZS5mb3JtYXRdO1xuICAgIGdsVGV4dHVyZS5mb3JtYXQgPSB0aGlzLl9tYXBGb3JtYXRUb0Zvcm1hdFtzb3VyY2UuZm9ybWF0XTtcbiAgICBpZiAoc291cmNlLmF1dG9HZW5lcmF0ZU1pcG1hcHMgJiYgKHRoaXMuX3JlbmRlcmVyLmNvbnRleHQuc3VwcG9ydHMubm9uUG93T2YybWlwbWFwcyB8fCBzb3VyY2UuaXNQb3dlck9mVHdvKSkge1xuICAgICAgY29uc3QgYmlnZ2VzdERpbWVuc2lvbiA9IE1hdGgubWF4KHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XG4gICAgICBzb3VyY2UubWlwTGV2ZWxDb3VudCA9IE1hdGguZmxvb3IoTWF0aC5sb2cyKGJpZ2dlc3REaW1lbnNpb24pKSArIDE7XG4gICAgfVxuICAgIHRoaXMuX2dsVGV4dHVyZXNbc291cmNlLnVpZF0gPSBnbFRleHR1cmU7XG4gICAgaWYgKCF0aGlzLm1hbmFnZWRUZXh0dXJlcy5pbmNsdWRlcyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2Uub24oXCJ1cGRhdGVcIiwgdGhpcy5vblNvdXJjZVVwZGF0ZSwgdGhpcyk7XG4gICAgICBzb3VyY2Uub24oXCJyZXNpemVcIiwgdGhpcy5vblNvdXJjZVVwZGF0ZSwgdGhpcyk7XG4gICAgICBzb3VyY2Uub24oXCJzdHlsZUNoYW5nZVwiLCB0aGlzLm9uU3R5bGVDaGFuZ2UsIHRoaXMpO1xuICAgICAgc291cmNlLm9uKFwiZGVzdHJveVwiLCB0aGlzLm9uU291cmNlRGVzdHJveSwgdGhpcyk7XG4gICAgICBzb3VyY2Uub24oXCJ1bmxvYWRcIiwgdGhpcy5vblNvdXJjZVVubG9hZCwgdGhpcyk7XG4gICAgICBzb3VyY2Uub24oXCJ1cGRhdGVNaXBtYXBzXCIsIHRoaXMub25VcGRhdGVNaXBtYXBzLCB0aGlzKTtcbiAgICAgIHRoaXMubWFuYWdlZFRleHR1cmVzLnB1c2goc291cmNlKTtcbiAgICB9XG4gICAgdGhpcy5vblNvdXJjZVVwZGF0ZShzb3VyY2UpO1xuICAgIHRoaXMudXBkYXRlU3R5bGUoc291cmNlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGdsVGV4dHVyZTtcbiAgfVxuICBvblN0eWxlQ2hhbmdlKHNvdXJjZSkge1xuICAgIHRoaXMudXBkYXRlU3R5bGUoc291cmNlLCBmYWxzZSk7XG4gIH1cbiAgdXBkYXRlU3R5bGUoc291cmNlLCBmaXJzdENyZWF0aW9uKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBjb25zdCBnbFRleHR1cmUgPSB0aGlzLmdldEdsU291cmNlKHNvdXJjZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlLnRleHR1cmUpO1xuICAgIHRoaXMuX2JvdW5kVGV4dHVyZXNbdGhpcy5fYWN0aXZlVGV4dHVyZUxvY2F0aW9uXSA9IHNvdXJjZTtcbiAgICBhcHBseVN0eWxlUGFyYW1zKFxuICAgICAgc291cmNlLnN0eWxlLFxuICAgICAgZ2wsXG4gICAgICBzb3VyY2UubWlwTGV2ZWxDb3VudCA+IDEsXG4gICAgICB0aGlzLl9yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuYW5pc290cm9waWNGaWx0ZXJpbmcsXG4gICAgICBcInRleFBhcmFtZXRlcmlcIixcbiAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAvLyB3aWxsIGZvcmNlIGEgY2xhbXAgdG8gZWRnZSBpZiB0aGUgdGV4dHVyZSBpcyBub3QgYSBwb3dlciBvZiB0d29cbiAgICAgICF0aGlzLl9yZW5kZXJlci5jb250ZXh0LnN1cHBvcnRzLm5vblBvd09mMndyYXBwaW5nICYmICFzb3VyY2UuaXNQb3dlck9mVHdvLFxuICAgICAgZmlyc3RDcmVhdGlvblxuICAgICk7XG4gIH1cbiAgb25Tb3VyY2VVbmxvYWQoc291cmNlKSB7XG4gICAgY29uc3QgZ2xUZXh0dXJlID0gdGhpcy5fZ2xUZXh0dXJlc1tzb3VyY2UudWlkXTtcbiAgICBpZiAoIWdsVGV4dHVyZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnVuYmluZChzb3VyY2UpO1xuICAgIHRoaXMuX2dsVGV4dHVyZXNbc291cmNlLnVpZF0gPSBudWxsO1xuICAgIHRoaXMuX2dsLmRlbGV0ZVRleHR1cmUoZ2xUZXh0dXJlLnRleHR1cmUpO1xuICB9XG4gIG9uU291cmNlVXBkYXRlKHNvdXJjZSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgY29uc3QgZ2xUZXh0dXJlID0gdGhpcy5nZXRHbFNvdXJjZShzb3VyY2UpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZS50ZXh0dXJlKTtcbiAgICB0aGlzLl9ib3VuZFRleHR1cmVzW3RoaXMuX2FjdGl2ZVRleHR1cmVMb2NhdGlvbl0gPSBzb3VyY2U7XG4gICAgaWYgKHRoaXMuX3VwbG9hZHNbc291cmNlLnVwbG9hZE1ldGhvZElkXSkge1xuICAgICAgdGhpcy5fdXBsb2Fkc1tzb3VyY2UudXBsb2FkTWV0aG9kSWRdLnVwbG9hZChzb3VyY2UsIGdsVGV4dHVyZSwgZ2wsIHRoaXMuX3JlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzb3VyY2UucGl4ZWxXaWR0aCwgc291cmNlLnBpeGVsSGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5hdXRvR2VuZXJhdGVNaXBtYXBzICYmIHNvdXJjZS5taXBMZXZlbENvdW50ID4gMSkge1xuICAgICAgdGhpcy5vblVwZGF0ZU1pcG1hcHMoc291cmNlLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIG9uVXBkYXRlTWlwbWFwcyhzb3VyY2UsIGJpbmQgPSB0cnVlKSB7XG4gICAgaWYgKGJpbmQpXG4gICAgICB0aGlzLmJpbmRTb3VyY2Uoc291cmNlLCAwKTtcbiAgICBjb25zdCBnbFRleHR1cmUgPSB0aGlzLmdldEdsU291cmNlKHNvdXJjZSk7XG4gICAgdGhpcy5fZ2wuZ2VuZXJhdGVNaXBtYXAoZ2xUZXh0dXJlLnRhcmdldCk7XG4gIH1cbiAgb25Tb3VyY2VEZXN0cm95KHNvdXJjZSkge1xuICAgIHNvdXJjZS5vZmYoXCJkZXN0cm95XCIsIHRoaXMub25Tb3VyY2VEZXN0cm95LCB0aGlzKTtcbiAgICBzb3VyY2Uub2ZmKFwidXBkYXRlXCIsIHRoaXMub25Tb3VyY2VVcGRhdGUsIHRoaXMpO1xuICAgIHNvdXJjZS5vZmYoXCJyZXNpemVcIiwgdGhpcy5vblNvdXJjZVVwZGF0ZSwgdGhpcyk7XG4gICAgc291cmNlLm9mZihcInVubG9hZFwiLCB0aGlzLm9uU291cmNlVW5sb2FkLCB0aGlzKTtcbiAgICBzb3VyY2Uub2ZmKFwic3R5bGVDaGFuZ2VcIiwgdGhpcy5vblN0eWxlQ2hhbmdlLCB0aGlzKTtcbiAgICBzb3VyY2Uub2ZmKFwidXBkYXRlTWlwbWFwc1wiLCB0aGlzLm9uVXBkYXRlTWlwbWFwcywgdGhpcyk7XG4gICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMuc3BsaWNlKHRoaXMubWFuYWdlZFRleHR1cmVzLmluZGV4T2Yoc291cmNlKSwgMSk7XG4gICAgdGhpcy5vblNvdXJjZVVubG9hZChzb3VyY2UpO1xuICB9XG4gIF9pbml0U2FtcGxlcihzdHlsZSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgY29uc3QgZ2xTYW1wbGVyID0gdGhpcy5fZ2wuY3JlYXRlU2FtcGxlcigpO1xuICAgIHRoaXMuX2dsU2FtcGxlcnNbc3R5bGUuX3Jlc291cmNlSWRdID0gZ2xTYW1wbGVyO1xuICAgIGFwcGx5U3R5bGVQYXJhbXMoXG4gICAgICBzdHlsZSxcbiAgICAgIGdsLFxuICAgICAgdGhpcy5fYm91bmRUZXh0dXJlc1t0aGlzLl9hY3RpdmVUZXh0dXJlTG9jYXRpb25dLm1pcExldmVsQ291bnQgPiAxLFxuICAgICAgdGhpcy5fcmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLmFuaXNvdHJvcGljRmlsdGVyaW5nLFxuICAgICAgXCJzYW1wbGVyUGFyYW1ldGVyaVwiLFxuICAgICAgZ2xTYW1wbGVyLFxuICAgICAgZmFsc2UsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fZ2xTYW1wbGVyc1tzdHlsZS5fcmVzb3VyY2VJZF07XG4gIH1cbiAgX2dldEdsU2FtcGxlcihzYW1wbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dsU2FtcGxlcnNbc2FtcGxlci5fcmVzb3VyY2VJZF0gfHwgdGhpcy5faW5pdFNhbXBsZXIoc2FtcGxlcik7XG4gIH1cbiAgZ2V0R2xTb3VyY2Uoc291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dsVGV4dHVyZXNbc291cmNlLnVpZF0gfHwgdGhpcy5faW5pdFNvdXJjZShzb3VyY2UpO1xuICB9XG4gIGdlbmVyYXRlQ2FudmFzKHRleHR1cmUpIHtcbiAgICBjb25zdCB7IHBpeGVscywgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5nZXRQaXhlbHModGV4dHVyZSk7XG4gICAgY29uc3QgY2FudmFzID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKGN0eCkge1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGltYWdlRGF0YS5kYXRhLnNldChwaXhlbHMpO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG4gIGdldFBpeGVscyh0ZXh0dXJlKSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRleHR1cmUuc291cmNlLnJlc29sdXRpb247XG4gICAgY29uc3QgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoTWF0aC5yb3VuZChmcmFtZS53aWR0aCAqIHJlc29sdXRpb24pLCAxKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChNYXRoLnJvdW5kKGZyYW1lLmhlaWdodCAqIHJlc29sdXRpb24pLCAxKTtcbiAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhBcnJheShCWVRFU19QRVJfUElYRUwgKiB3aWR0aCAqIGhlaWdodCk7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQuZ2V0UmVuZGVyVGFyZ2V0KHRleHR1cmUpO1xuICAgIGNvbnN0IGdsUmVudGVyVGFyZ2V0ID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmdldEdwdVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbFJlbnRlclRhcmdldC5yZXNvbHZlVGFyZ2V0RnJhbWVidWZmZXIpO1xuICAgIGdsLnJlYWRQaXhlbHMoXG4gICAgICBNYXRoLnJvdW5kKGZyYW1lLnggKiByZXNvbHV0aW9uKSxcbiAgICAgIE1hdGgucm91bmQoZnJhbWUueSAqIHJlc29sdXRpb24pLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBnbC5SR0JBLFxuICAgICAgZ2wuVU5TSUdORURfQllURSxcbiAgICAgIHBpeGVsc1xuICAgICk7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICB1bnByZW11bHRpcGx5QWxwaGEocGl4ZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcGl4ZWxzOiBuZXcgVWludDhDbGFtcGVkQXJyYXkocGl4ZWxzLmJ1ZmZlciksIHdpZHRoLCBoZWlnaHQgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubWFuYWdlZFRleHR1cmVzLnNsaWNlKCkuZm9yRWFjaCgoc291cmNlKSA9PiB0aGlzLm9uU291cmNlRGVzdHJveShzb3VyY2UpKTtcbiAgICB0aGlzLm1hbmFnZWRUZXh0dXJlcyA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuR2xUZXh0dXJlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJ0ZXh0dXJlXCJcbn07XG5cbmV4cG9ydCB7IEdsVGV4dHVyZVN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2xUZXh0dXJlU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEdsR3JhcGhpY3NBZGFwdG9yIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvZ3JhcGhpY3MvZ2wvR2xHcmFwaGljc0FkYXB0b3IubWpzJztcbmltcG9ydCB7IEdsTWVzaEFkYXB0b3IgfSBmcm9tICcuLi8uLi8uLi9zY2VuZS9tZXNoL2dsL0dsTWVzaEFkYXB0b3IubWpzJztcbmltcG9ydCB7IEdsQmF0Y2hBZGFwdG9yIH0gZnJvbSAnLi4vLi4vYmF0Y2hlci9nbC9HbEJhdGNoQWRhcHRvci5tanMnO1xuaW1wb3J0IHsgQWJzdHJhY3RSZW5kZXJlciB9IGZyb20gJy4uL3NoYXJlZC9zeXN0ZW0vQWJzdHJhY3RSZW5kZXJlci5tanMnO1xuaW1wb3J0IHsgU2hhcmVkU3lzdGVtcywgU2hhcmVkUmVuZGVyUGlwZXMgfSBmcm9tICcuLi9zaGFyZWQvc3lzdGVtL1NoYXJlZFN5c3RlbXMubWpzJztcbmltcG9ydCB7IFJlbmRlcmVyVHlwZSB9IGZyb20gJy4uL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBHbEJ1ZmZlclN5c3RlbSB9IGZyb20gJy4vYnVmZmVyL0dsQnVmZmVyU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHbENvbnRleHRTeXN0ZW0gfSBmcm9tICcuL2NvbnRleHQvR2xDb250ZXh0U3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHbEdlb21ldHJ5U3lzdGVtIH0gZnJvbSAnLi9nZW9tZXRyeS9HbEdlb21ldHJ5U3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHbEJhY2tCdWZmZXJTeXN0ZW0gfSBmcm9tICcuL0dsQmFja0J1ZmZlclN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR2xDb2xvck1hc2tTeXN0ZW0gfSBmcm9tICcuL0dsQ29sb3JNYXNrU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHbEVuY29kZXJTeXN0ZW0gfSBmcm9tICcuL0dsRW5jb2RlclN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR2xTdGVuY2lsU3lzdGVtIH0gZnJvbSAnLi9HbFN0ZW5jaWxTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEdsVWJvU3lzdGVtIH0gZnJvbSAnLi9HbFVib1N5c3RlbS5tanMnO1xuaW1wb3J0IHsgR2xSZW5kZXJUYXJnZXRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlclRhcmdldC9HbFJlbmRlclRhcmdldFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR2xTaGFkZXJTeXN0ZW0gfSBmcm9tICcuL3NoYWRlci9HbFNoYWRlclN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR2xVbmlmb3JtR3JvdXBTeXN0ZW0gfSBmcm9tICcuL3NoYWRlci9HbFVuaWZvcm1Hcm91cFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR2xTdGF0ZVN5c3RlbSB9IGZyb20gJy4vc3RhdGUvR2xTdGF0ZVN5c3RlbS5tanMnO1xuaW1wb3J0IHsgR2xUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi90ZXh0dXJlL0dsVGV4dHVyZVN5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IERlZmF1bHRXZWJHTFN5c3RlbXMgPSBbXG4gIC4uLlNoYXJlZFN5c3RlbXMsXG4gIEdsVWJvU3lzdGVtLFxuICBHbEJhY2tCdWZmZXJTeXN0ZW0sXG4gIEdsQ29udGV4dFN5c3RlbSxcbiAgR2xCdWZmZXJTeXN0ZW0sXG4gIEdsVGV4dHVyZVN5c3RlbSxcbiAgR2xSZW5kZXJUYXJnZXRTeXN0ZW0sXG4gIEdsR2VvbWV0cnlTeXN0ZW0sXG4gIEdsVW5pZm9ybUdyb3VwU3lzdGVtLFxuICBHbFNoYWRlclN5c3RlbSxcbiAgR2xFbmNvZGVyU3lzdGVtLFxuICBHbFN0YXRlU3lzdGVtLFxuICBHbFN0ZW5jaWxTeXN0ZW0sXG4gIEdsQ29sb3JNYXNrU3lzdGVtXG5dO1xuY29uc3QgRGVmYXVsdFdlYkdMUGlwZXMgPSBbLi4uU2hhcmVkUmVuZGVyUGlwZXNdO1xuY29uc3QgRGVmYXVsdFdlYkdMQWRhcHRlcnMgPSBbR2xCYXRjaEFkYXB0b3IsIEdsTWVzaEFkYXB0b3IsIEdsR3JhcGhpY3NBZGFwdG9yXTtcbmNvbnN0IHN5c3RlbXMgPSBbXTtcbmNvbnN0IHJlbmRlclBpcGVzID0gW107XG5jb25zdCByZW5kZXJQaXBlQWRhcHRvcnMgPSBbXTtcbmV4dGVuc2lvbnMuaGFuZGxlQnlOYW1lZExpc3QoRXh0ZW5zaW9uVHlwZS5XZWJHTFN5c3RlbSwgc3lzdGVtcyk7XG5leHRlbnNpb25zLmhhbmRsZUJ5TmFtZWRMaXN0KEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcywgcmVuZGVyUGlwZXMpO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeU5hbWVkTGlzdChFeHRlbnNpb25UeXBlLldlYkdMUGlwZXNBZGFwdG9yLCByZW5kZXJQaXBlQWRhcHRvcnMpO1xuZXh0ZW5zaW9ucy5hZGQoLi4uRGVmYXVsdFdlYkdMU3lzdGVtcywgLi4uRGVmYXVsdFdlYkdMUGlwZXMsIC4uLkRlZmF1bHRXZWJHTEFkYXB0ZXJzKTtcbmNsYXNzIFdlYkdMUmVuZGVyZXIgZXh0ZW5kcyBBYnN0cmFjdFJlbmRlcmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3Qgc3lzdGVtQ29uZmlnID0ge1xuICAgICAgbmFtZTogXCJ3ZWJnbFwiLFxuICAgICAgdHlwZTogUmVuZGVyZXJUeXBlLldFQkdMLFxuICAgICAgc3lzdGVtcyxcbiAgICAgIHJlbmRlclBpcGVzLFxuICAgICAgcmVuZGVyUGlwZUFkYXB0b3JzXG4gICAgfTtcbiAgICBzdXBlcihzeXN0ZW1Db25maWcpO1xuICB9XG59XG5cbmV4cG9ydCB7IFdlYkdMUmVuZGVyZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYkdMUmVuZGVyZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2172\n')},2189:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   O: () => (/* binding */ getBatchSamplersUniformGroup)\n/* harmony export */ });\n/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4537);\n\n\n"use strict";\nconst batchSamplersUniformGroupHash = {};\nfunction getBatchSamplersUniformGroup(maxTextures) {\n  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n  if (batchSamplersUniformGroup)\n    return batchSamplersUniformGroup;\n  const sampleValues = new Int32Array(maxTextures);\n  for (let i = 0; i < maxTextures; i++) {\n    sampleValues[i] = i;\n  }\n  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__/* .UniformGroup */ .o({\n    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n  }, { isStatic: true });\n  return batchSamplersUniformGroup;\n}\n\n\n//# sourceMappingURL=getBatchSamplersUniformGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE4OS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLCtFQUErRSxrRkFBWTtBQUMzRixpQkFBaUI7QUFDakIsR0FBRyxJQUFJLGdCQUFnQjtBQUN2QjtBQUNBOztBQUV3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvZ2V0QmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cC5tanM/OGQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXBIYXNoID0ge307XG5mdW5jdGlvbiBnZXRCYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwKG1heFRleHR1cmVzKSB7XG4gIGxldCBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwID0gYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cEhhc2hbbWF4VGV4dHVyZXNdO1xuICBpZiAoYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cClcbiAgICByZXR1cm4gYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cDtcbiAgY29uc3Qgc2FtcGxlVmFsdWVzID0gbmV3IEludDMyQXJyYXkobWF4VGV4dHVyZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICBzYW1wbGVWYWx1ZXNbaV0gPSBpO1xuICB9XG4gIGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgPSBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwSGFzaFttYXhUZXh0dXJlc10gPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICB1VGV4dHVyZXM6IHsgdmFsdWU6IHNhbXBsZVZhbHVlcywgdHlwZTogYGkzMmAsIHNpemU6IG1heFRleHR1cmVzIH1cbiAgfSwgeyBpc1N0YXRpYzogdHJ1ZSB9KTtcbiAgcmV0dXJuIGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXA7XG59XG5cbmV4cG9ydCB7IGdldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2189\n')}}]);