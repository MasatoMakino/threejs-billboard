"use strict";(self.webpackChunk_masatomakino_threejs_billboard=self.webpackChunk_masatomakino_threejs_billboard||[]).push([[148],{8148:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(8507);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(4263);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(5101);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/events/FederatedEvent.mjs\n\n\n"use strict";\nclass FederatedEvent {\n  /**\n   * @param manager - The event boundary which manages this event. Propagation can only occur\n   *  within the boundary\'s jurisdiction.\n   */\n  constructor(manager) {\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    this.bubbles = true;\n    /** @deprecated since 7.0.0 */\n    this.cancelBubble = true;\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    this.cancelable = false;\n    /**\n     * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    this.composed = false;\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    this.defaultPrevented = false;\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    this.eventPhase = FederatedEvent.prototype.NONE;\n    /** Flags whether propagation was stopped. */\n    this.propagationStopped = false;\n    /** Flags whether propagation was immediately stopped. */\n    this.propagationImmediatelyStopped = false;\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    this.layer = new Point/* Point */.b();\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    this.page = new Point/* Point */.b();\n    this.NONE = 0;\n    this.CAPTURING_PHASE = 1;\n    this.AT_TARGET = 2;\n    this.BUBBLING_PHASE = 3;\n    this.manager = manager;\n  }\n  /** @readonly */\n  get layerX() {\n    return this.layer.x;\n  }\n  /** @readonly */\n  get layerY() {\n    return this.layer.y;\n  }\n  /** @readonly */\n  get pageX() {\n    return this.page.x;\n  }\n  /** @readonly */\n  get pageY() {\n    return this.page.y;\n  }\n  /**\n   * Fallback for the deprecated @code{InteractionEvent.data}.\n   * @deprecated since 7.0.0\n   */\n  get data() {\n    return this;\n  }\n  /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */\n  composedPath() {\n    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {\n      this.path = this.target ? this.manager.propagationPath(this.target) : [];\n    }\n    return this.path;\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.\n   * @deprecated\n   * @param _type\n   * @param _bubbles\n   * @param _cancelable\n   */\n  initEvent(_type, _bubbles, _cancelable) {\n    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.\n   * @deprecated\n   * @param _typeArg\n   * @param _bubblesArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   */\n  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {\n    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  /** Prevent default behavior of PixiJS and the user agent. */\n  preventDefault() {\n    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {\n      this.nativeEvent.preventDefault();\n    }\n    this.defaultPrevented = true;\n  }\n  /**\n   * Stop this event from propagating to any addition listeners, including on the\n   * {@link FederatedEventTarget.currentTarget currentTarget} and also the following\n   * event targets on the propagation path.\n   */\n  stopImmediatePropagation() {\n    this.propagationImmediatelyStopped = true;\n  }\n  /**\n   * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners\n   * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.\n   */\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\n\n//# sourceMappingURL=FederatedEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/ismobilejs/esm/isMobile.js\nvar appleIphone = /iPhone/i;\nvar appleIpod = /iPod/i;\nvar appleTablet = /iPad/i;\nvar appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nvar androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\nvar androidTablet = /Android/i;\nvar amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\nvar amazonTablet = /Silk/i;\nvar windowsPhone = /Windows Phone/i;\nvar windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\nvar otherBlackBerry = /BlackBerry/i;\nvar otherBlackBerry10 = /BB10/i;\nvar otherOpera = /Opera Mini/i;\nvar otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nvar otherFirefox = /Mobile(?:.+)Firefox\\b/i;\nvar isAppleTabletOnIos13 = function (navigator) {\n    return (typeof navigator !== \'undefined\' &&\n        navigator.platform === \'MacIntel\' &&\n        typeof navigator.maxTouchPoints === \'number\' &&\n        navigator.maxTouchPoints > 1 &&\n        typeof MSStream === \'undefined\');\n};\nfunction createMatch(userAgent) {\n    return function (regex) { return regex.test(userAgent); };\n}\nfunction isMobile(param) {\n    var nav = {\n        userAgent: \'\',\n        platform: \'\',\n        maxTouchPoints: 0\n    };\n    if (!param && typeof navigator !== \'undefined\') {\n        nav = {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            maxTouchPoints: navigator.maxTouchPoints || 0\n        };\n    }\n    else if (typeof param === \'string\') {\n        nav.userAgent = param;\n    }\n    else if (param && param.userAgent) {\n        nav = {\n            userAgent: param.userAgent,\n            platform: param.platform,\n            maxTouchPoints: param.maxTouchPoints || 0\n        };\n    }\n    var userAgent = nav.userAgent;\n    var tmp = userAgent.split(\'[FBAN\');\n    if (typeof tmp[1] !== \'undefined\') {\n        userAgent = tmp[0];\n    }\n    tmp = userAgent.split(\'Twitter\');\n    if (typeof tmp[1] !== \'undefined\') {\n        userAgent = tmp[0];\n    }\n    var match = createMatch(userAgent);\n    var result = {\n        apple: {\n            phone: match(appleIphone) && !match(windowsPhone),\n            ipod: match(appleIpod),\n            tablet: !match(appleIphone) &&\n                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone),\n            universal: match(appleUniversal),\n            device: (match(appleIphone) ||\n                match(appleIpod) ||\n                match(appleTablet) ||\n                match(appleUniversal) ||\n                isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone)\n        },\n        amazon: {\n            phone: match(amazonPhone),\n            tablet: !match(amazonPhone) && match(amazonTablet),\n            device: match(amazonPhone) || match(amazonTablet)\n        },\n        android: {\n            phone: (!match(windowsPhone) && match(amazonPhone)) ||\n                (!match(windowsPhone) && match(androidPhone)),\n            tablet: !match(windowsPhone) &&\n                !match(amazonPhone) &&\n                !match(androidPhone) &&\n                (match(amazonTablet) || match(androidTablet)),\n            device: (!match(windowsPhone) &&\n                (match(amazonPhone) ||\n                    match(amazonTablet) ||\n                    match(androidPhone) ||\n                    match(androidTablet))) ||\n                match(/\\bokhttp\\b/i)\n        },\n        windows: {\n            phone: match(windowsPhone),\n            tablet: match(windowsTablet),\n            device: match(windowsPhone) || match(windowsTablet)\n        },\n        other: {\n            blackberry: match(otherBlackBerry),\n            blackberry10: match(otherBlackBerry10),\n            opera: match(otherOpera),\n            firefox: match(otherFirefox),\n            chrome: match(otherChrome),\n            device: match(otherBlackBerry) ||\n                match(otherBlackBerry10) ||\n                match(otherOpera) ||\n                match(otherFirefox) ||\n                match(otherChrome)\n        },\n        any: false,\n        phone: false,\n        tablet: false\n    };\n    result.any =\n        result.apple.device ||\n            result.android.device ||\n            result.windows.device ||\n            result.other.device;\n    result.phone =\n        result.apple.phone || result.android.phone || result.windows.phone;\n    result.tablet =\n        result.apple.tablet || result.android.tablet || result.windows.tablet;\n    return result;\n}\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isMobile.mjs\n\n\n"use strict";\nconst isMobileCall = isMobile["default"] ?? isMobile;\nconst isMobile_isMobile = isMobileCall(globalThis.navigator);\n\n\n//# sourceMappingURL=isMobile.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/removeItems.mjs\nvar removeItems = __webpack_require__(9903);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs\n\n\n\n\n\n"use strict";\nconst KEY_CODE_TAB = 9;\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1e3;\nconst DIV_HOOK_POS_Y = -1e3;\nconst DIV_HOOK_ZINDEX = 2;\nclass AccessibilitySystem {\n  // 2fps\n  // eslint-disable-next-line jsdoc/require-param\n  /**\n   * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n   */\n  constructor(renderer, _mobileInfo = isMobile_isMobile) {\n    this._mobileInfo = _mobileInfo;\n    /** Setting this to true will visually show the divs. */\n    this.debug = false;\n    /** Internal variable, see isActive getter. */\n    this._isActive = false;\n    /** Internal variable, see isMobileAccessibility getter. */\n    this._isMobileAccessibility = false;\n    /** A simple pool for storing divs. */\n    this._pool = [];\n    /** This is a tick used to check if an object is no longer being rendered. */\n    this._renderId = 0;\n    /** The array of currently active accessible items. */\n    this._children = [];\n    /** Count to throttle div updates on android devices. */\n    this._androidUpdateCount = 0;\n    /**  The frequency to update the div elements. */\n    this._androidUpdateFrequency = 500;\n    this._hookDiv = null;\n    if (_mobileInfo.tablet || _mobileInfo.phone) {\n      this._createTouchHook();\n    }\n    const div = document.createElement("div");\n    div.style.width = `${DIV_TOUCH_SIZE}px`;\n    div.style.height = `${DIV_TOUCH_SIZE}px`;\n    div.style.position = "absolute";\n    div.style.top = `${DIV_TOUCH_POS_X}px`;\n    div.style.left = `${DIV_TOUCH_POS_Y}px`;\n    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n    this._div = div;\n    this._renderer = renderer;\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onMouseMove = this._onMouseMove.bind(this);\n    globalThis.addEventListener("keydown", this._onKeyDown, false);\n  }\n  /**\n   * Value of `true` if accessibility is currently active and accessibility layers are showing.\n   * @member {boolean}\n   * @readonly\n   */\n  get isActive() {\n    return this._isActive;\n  }\n  /**\n   * Value of `true` if accessibility is enabled for touch devices.\n   * @member {boolean}\n   * @readonly\n   */\n  get isMobileAccessibility() {\n    return this._isMobileAccessibility;\n  }\n  get hookDiv() {\n    return this._hookDiv;\n  }\n  /**\n   * Creates the touch hooks.\n   * @private\n   */\n  _createTouchHook() {\n    const hookDiv = document.createElement("button");\n    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.position = "absolute";\n    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n    hookDiv.style.backgroundColor = "#FF0000";\n    hookDiv.title = "select to enable accessibility for this content";\n    hookDiv.addEventListener("focus", () => {\n      this._isMobileAccessibility = true;\n      this._activate();\n      this._destroyTouchHook();\n    });\n    document.body.appendChild(hookDiv);\n    this._hookDiv = hookDiv;\n  }\n  /**\n   * Destroys the touch hooks.\n   * @private\n   */\n  _destroyTouchHook() {\n    if (!this._hookDiv) {\n      return;\n    }\n    document.body.removeChild(this._hookDiv);\n    this._hookDiv = null;\n  }\n  /**\n   * Activating will cause the Accessibility layer to be shown.\n   * This is called when a user presses the tab key.\n   * @private\n   */\n  _activate() {\n    if (this._isActive) {\n      return;\n    }\n    this._isActive = true;\n    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);\n    globalThis.removeEventListener("keydown", this._onKeyDown, false);\n    this._renderer.runners.postrender.add(this);\n    this._renderer.view.canvas.parentNode?.appendChild(this._div);\n  }\n  /**\n   * Deactivating will cause the Accessibility layer to be hidden.\n   * This is called when a user moves the mouse.\n   * @private\n   */\n  _deactivate() {\n    if (!this._isActive || this._isMobileAccessibility) {\n      return;\n    }\n    this._isActive = false;\n    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);\n    globalThis.addEventListener("keydown", this._onKeyDown, false);\n    this._renderer.runners.postrender.remove(this);\n    this._div.parentNode?.removeChild(this._div);\n  }\n  /**\n   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n   * @private\n   * @param {Container} container - The Container to check.\n   */\n  _updateAccessibleObjects(container) {\n    if (!container.visible || !container.accessibleChildren) {\n      return;\n    }\n    if (container.accessible && container.isInteractive()) {\n      if (!container._accessibleActive) {\n        this._addChild(container);\n      }\n      container._renderId = this._renderId;\n    }\n    const children = container.children;\n    if (children) {\n      for (let i = 0; i < children.length; i++) {\n        this._updateAccessibleObjects(children[i]);\n      }\n    }\n  }\n  /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */\n  init(options) {\n    this.debug = options?.debug ?? this.debug;\n    this._renderer.runners.postrender.remove(this);\n  }\n  /**\n   * Runner postrender was called, ensure that all divs are mapped correctly to their Containers.\n   * Only fires while active.\n   * @ignore\n   */\n  postrender() {\n    const now = performance.now();\n    if (this._mobileInfo.android.device && now < this._androidUpdateCount) {\n      return;\n    }\n    this._androidUpdateCount = now + this._androidUpdateFrequency;\n    if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {\n      return;\n    }\n    if (this._renderer.lastObjectRendered) {\n      this._updateAccessibleObjects(this._renderer.lastObjectRendered);\n    }\n    const { x, y, width, height } = this._renderer.view.canvas.getBoundingClientRect();\n    const { width: viewWidth, height: viewHeight, resolution } = this._renderer;\n    const sx = width / viewWidth * resolution;\n    const sy = height / viewHeight * resolution;\n    let div = this._div;\n    div.style.left = `${x}px`;\n    div.style.top = `${y}px`;\n    div.style.width = `${viewWidth}px`;\n    div.style.height = `${viewHeight}px`;\n    for (let i = 0; i < this._children.length; i++) {\n      const child = this._children[i];\n      if (child._renderId !== this._renderId) {\n        child._accessibleActive = false;\n        (0,removeItems/* removeItems */.d)(this._children, i, 1);\n        this._div.removeChild(child._accessibleDiv);\n        this._pool.push(child._accessibleDiv);\n        child._accessibleDiv = null;\n        i--;\n      } else {\n        div = child._accessibleDiv;\n        let hitArea = child.hitArea;\n        const wt = child.worldTransform;\n        if (child.hitArea) {\n          div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;\n          div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;\n          div.style.width = `${hitArea.width * wt.a * sx}px`;\n          div.style.height = `${hitArea.height * wt.d * sy}px`;\n        } else {\n          hitArea = child.getBounds().rectangle;\n          this._capHitArea(hitArea);\n          div.style.left = `${hitArea.x * sx}px`;\n          div.style.top = `${hitArea.y * sy}px`;\n          div.style.width = `${hitArea.width * sx}px`;\n          div.style.height = `${hitArea.height * sy}px`;\n          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {\n            div.title = child.accessibleTitle || "";\n          }\n          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {\n            div.setAttribute("aria-label", child.accessibleHint || "");\n          }\n        }\n        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {\n          div.title = child.accessibleTitle || "";\n          div.tabIndex = child.tabIndex;\n          if (this.debug) {\n            this._updateDebugHTML(div);\n          }\n        }\n      }\n    }\n    this._renderId++;\n  }\n  /**\n   * private function that will visually add the information to the\n   * accessibility div\n   * @param {HTMLElement} div -\n   */\n  _updateDebugHTML(div) {\n    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n  }\n  /**\n   * Adjust the hit area based on the bounds of a display object\n   * @param {Rectangle} hitArea - Bounds of the child\n   */\n  _capHitArea(hitArea) {\n    if (hitArea.x < 0) {\n      hitArea.width += hitArea.x;\n      hitArea.x = 0;\n    }\n    if (hitArea.y < 0) {\n      hitArea.height += hitArea.y;\n      hitArea.y = 0;\n    }\n    const { width: viewWidth, height: viewHeight } = this._renderer;\n    if (hitArea.x + hitArea.width > viewWidth) {\n      hitArea.width = viewWidth - hitArea.x;\n    }\n    if (hitArea.y + hitArea.height > viewHeight) {\n      hitArea.height = viewHeight - hitArea.y;\n    }\n  }\n  /**\n   * Adds a Container to the accessibility manager\n   * @private\n   * @param {Container} container - The child to make accessible.\n   */\n  _addChild(container) {\n    let div = this._pool.pop();\n    if (!div) {\n      div = document.createElement("button");\n      div.style.width = `${DIV_TOUCH_SIZE}px`;\n      div.style.height = `${DIV_TOUCH_SIZE}px`;\n      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";\n      div.style.position = "absolute";\n      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n      div.style.borderStyle = "none";\n      if (navigator.userAgent.toLowerCase().includes("chrome")) {\n        div.setAttribute("aria-live", "off");\n      } else {\n        div.setAttribute("aria-live", "polite");\n      }\n      if (navigator.userAgent.match(/rv:.*Gecko\\//)) {\n        div.setAttribute("aria-relevant", "additions");\n      } else {\n        div.setAttribute("aria-relevant", "text");\n      }\n      div.addEventListener("click", this._onClick.bind(this));\n      div.addEventListener("focus", this._onFocus.bind(this));\n      div.addEventListener("focusout", this._onFocusOut.bind(this));\n    }\n    div.style.pointerEvents = container.accessiblePointerEvents;\n    div.type = container.accessibleType;\n    if (container.accessibleTitle && container.accessibleTitle !== null) {\n      div.title = container.accessibleTitle;\n    } else if (!container.accessibleHint || container.accessibleHint === null) {\n      div.title = `container ${container.tabIndex}`;\n    }\n    if (container.accessibleHint && container.accessibleHint !== null) {\n      div.setAttribute("aria-label", container.accessibleHint);\n    }\n    if (this.debug) {\n      this._updateDebugHTML(div);\n    }\n    container._accessibleActive = true;\n    container._accessibleDiv = div;\n    div.container = container;\n    this._children.push(container);\n    this._div.appendChild(container._accessibleDiv);\n    container._accessibleDiv.tabIndex = container.tabIndex;\n  }\n  /**\n   * Dispatch events with the EventSystem.\n   * @param e\n   * @param type\n   * @private\n   */\n  _dispatchEvent(e, type) {\n    const { container: target } = e.target;\n    const boundary = this._renderer.events.rootBoundary;\n    const event = Object.assign(new FederatedEvent(boundary), { target });\n    boundary.rootTarget = this._renderer.lastObjectRendered;\n    type.forEach((type2) => boundary.dispatchEvent(event, type2));\n  }\n  /**\n   * Maps the div button press to pixi\'s EventSystem (click)\n   * @private\n   * @param {MouseEvent} e - The click event.\n   */\n  _onClick(e) {\n    this._dispatchEvent(e, ["click", "pointertap", "tap"]);\n  }\n  /**\n   * Maps the div focus events to pixi\'s EventSystem (mouseover)\n   * @private\n   * @param {FocusEvent} e - The focus event.\n   */\n  _onFocus(e) {\n    if (!e.target.getAttribute("aria-live")) {\n      e.target.setAttribute("aria-live", "assertive");\n    }\n    this._dispatchEvent(e, ["mouseover"]);\n  }\n  /**\n   * Maps the div focus events to pixi\'s EventSystem (mouseout)\n   * @private\n   * @param {FocusEvent} e - The focusout event.\n   */\n  _onFocusOut(e) {\n    if (!e.target.getAttribute("aria-live")) {\n      e.target.setAttribute("aria-live", "polite");\n    }\n    this._dispatchEvent(e, ["mouseout"]);\n  }\n  /**\n   * Is called when a key is pressed\n   * @private\n   * @param {KeyboardEvent} e - The keydown event.\n   */\n  _onKeyDown(e) {\n    if (e.keyCode !== KEY_CODE_TAB) {\n      return;\n    }\n    this._activate();\n  }\n  /**\n   * Is called when the mouse moves across the renderer element\n   * @private\n   * @param {MouseEvent} e - The mouse event.\n   */\n  _onMouseMove(e) {\n    if (e.movementX === 0 && e.movementY === 0) {\n      return;\n    }\n    this._deactivate();\n  }\n  /** Destroys the accessibility manager */\n  destroy() {\n    this._destroyTouchHook();\n    this._div = null;\n    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);\n    globalThis.removeEventListener("keydown", this._onKeyDown);\n    this._pool = null;\n    this._children = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nAccessibilitySystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  name: "accessibility"\n};\n\n\n//# sourceMappingURL=AccessibilitySystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs\n\nconst accessibilityTarget = {\n  /**\n   * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n   * shadow div with attributes set\n   * @member {boolean}\n   * @memberof scene.Container#\n   */\n  accessible: false,\n  /**\n   * Sets the title attribute of the shadow div\n   * If accessibleTitle AND accessibleHint has not been this will default to \'container [tabIndex]\'\n   * @member {string}\n   * @memberof scene.Container#\n   */\n  accessibleTitle: null,\n  /**\n   * Sets the aria-label attribute of the shadow div\n   * @member {string}\n   * @memberof scene.Container#\n   */\n  accessibleHint: null,\n  /**\n   * @member {number}\n   * @memberof scene.Container#\n   * @todo Needs docs.\n   */\n  tabIndex: 0,\n  /**\n   * @member {boolean}\n   * @memberof scene.Container#\n   * @private\n   */\n  _accessibleActive: false,\n  /**\n   * @memberof scene.Container#\n   * @private\n   */\n  _accessibleDiv: null,\n  /**\n   * Specify the type of div the accessible layer is. Screen readers treat the element differently\n   * depending on this type. Defaults to button.\n   * @member {string}\n   * @memberof scene.Container#\n   * @default \'button\'\n   */\n  accessibleType: "button",\n  /**\n   * Specify the pointer-events the accessible div will use\n   * Defaults to auto.\n   * @type {PointerEvents}\n   * @memberof scene.Container#\n   * @default \'auto\'\n   */\n  accessiblePointerEvents: "auto",\n  /**\n   * Setting to false will prevent any children inside this container to\n   * be accessible. Defaults to true.\n   * @member {boolean}\n   * @memberof scene.Container#\n   * @default true\n   */\n  accessibleChildren: true,\n  /**\n   * @member {number}\n   * @memberof scene.Container#\n   * @private\n   */\n  _renderId: -1\n};\n\n\n//# sourceMappingURL=accessibilityTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/accessibility/init.mjs\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.XO.add(AccessibilitySystem);\nContainer/* Container */.mc.mixin(accessibilityTarget);\n//# sourceMappingURL=init.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/app/init.mjs + 2 modules\nvar init = __webpack_require__(4732);\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(8875);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(268);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(4458);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(7309);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/events/EventTicker.mjs\n\n\n\n"use strict";\nclass EventsTickerClass {\n  constructor() {\n    /** The frequency that fake events will be fired. */\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  /**\n   * Initializes the event ticker.\n   * @param events - The event system.\n   */\n  init(events) {\n    this.removeTickerListener();\n    this.events = events;\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  /** Whether to pause the update checks or not. */\n  get pauseUpdate() {\n    return this._pauseUpdate;\n  }\n  set pauseUpdate(paused) {\n    this._pauseUpdate = paused;\n  }\n  /** Adds the ticker listener. */\n  addTickerListener() {\n    if (this._tickerAdded || !this.domElement) {\n      return;\n    }\n    Ticker/* Ticker */.R.system.add(this._tickerUpdate, this, ticker_const/* UPDATE_PRIORITY */.d.INTERACTION);\n    this._tickerAdded = true;\n  }\n  /** Removes the ticker listener. */\n  removeTickerListener() {\n    if (!this._tickerAdded) {\n      return;\n    }\n    Ticker/* Ticker */.R.system.remove(this._tickerUpdate, this);\n    this._tickerAdded = false;\n  }\n  /** Sets flag to not fire extra events when the user has already moved there mouse */\n  pointerMoved() {\n    this._didMove = true;\n  }\n  /** Updates the state of interactive objects. */\n  _update() {\n    if (!this.domElement || this._pauseUpdate) {\n      return;\n    }\n    if (this._didMove) {\n      this._didMove = false;\n      return;\n    }\n    const rootPointerEvent = this.events["_rootPointerEvent"];\n    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {\n      return;\n    }\n    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY,\n      pointerType: rootPointerEvent.pointerType,\n      pointerId: rootPointerEvent.pointerId\n    }));\n  }\n  /**\n   * Updates the state of interactive objects if at least {@link interactionFrequency}\n   * milliseconds have passed since the last invocation.\n   *\n   * Invoked by a throttled ticker update from {@link Ticker.system}.\n   * @param ticker - The throttled ticker.\n   */\n  _tickerUpdate(ticker) {\n    this._deltaTime += ticker.deltaTime;\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n    this._deltaTime = 0;\n    this._update();\n  }\n}\nconst EventsTicker = new EventsTickerClass();\n\n\n//# sourceMappingURL=EventTicker.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs\n\n\n\n"use strict";\nclass FederatedMouseEvent extends FederatedEvent {\n  constructor() {\n    super(...arguments);\n    /** The coordinates of the mouse event relative to the canvas. */\n    this.client = new Point/* Point */.b();\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    this.movement = new Point/* Point */.b();\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    this.offset = new Point/* Point */.b();\n    /** The pointer coordinates in world space. */\n    this.global = new Point/* Point */.b();\n    /**\n     * The pointer coordinates in the renderer\'s {@link Renderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    this.screen = new Point/* Point */.b();\n  }\n  /** @readonly */\n  get clientX() {\n    return this.client.x;\n  }\n  /** @readonly */\n  get clientY() {\n    return this.client.y;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n   * @readonly\n   */\n  get x() {\n    return this.clientX;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n   * @readonly\n   */\n  get y() {\n    return this.clientY;\n  }\n  /** @readonly */\n  get movementX() {\n    return this.movement.x;\n  }\n  /** @readonly */\n  get movementY() {\n    return this.movement.y;\n  }\n  /** @readonly */\n  get offsetX() {\n    return this.offset.x;\n  }\n  /** @readonly */\n  get offsetY() {\n    return this.offset.y;\n  }\n  /** @readonly */\n  get globalX() {\n    return this.global.x;\n  }\n  /** @readonly */\n  get globalY() {\n    return this.global.y;\n  }\n  /**\n   * The pointer coordinates in the renderer\'s screen. Alias for {@code screen.x}.\n   * @readonly\n   */\n  get screenX() {\n    return this.screen.x;\n  }\n  /**\n   * The pointer coordinates in the renderer\'s screen. Alias for {@code screen.y}.\n   * @readonly\n   */\n  get screenY() {\n    return this.screen.y;\n  }\n  /**\n   * This will return the local coordinates of the specified container for this InteractionData\n   * @param {Container} container - The Container that you would like the local\n   *  coords off\n   * @param {PointData} point - A Point object in which to store the value, optional (otherwise\n   *  will create a new point)\n   * @param {PointData} globalPos - A Point object containing your custom global coords, optional\n   *  (otherwise will use the current global coords)\n   * @returns - A point containing the coordinates of the InteractionData position relative\n   *  to the Container\n   */\n  getLocalPosition(container, point, globalPos) {\n    return container.worldTransform.applyInverse(globalPos || this.global, point);\n  }\n  /**\n   * Whether the modifier key was pressed when this event natively occurred.\n   * @param key - The modifier key.\n   */\n  getModifierState(key) {\n    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n  }\n  /**\n   * Not supported.\n   * @param _typeArg\n   * @param _canBubbleArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   * @param _screenXArg\n   * @param _screenYArg\n   * @param _clientXArg\n   * @param _clientYArg\n   * @param _ctrlKeyArg\n   * @param _altKeyArg\n   * @param _shiftKeyArg\n   * @param _metaKeyArg\n   * @param _buttonArg\n   * @param _relatedTargetArg\n   * @deprecated since 7.0.0\n   */\n  // eslint-disable-next-line max-params\n  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n    throw new Error("Method not implemented.");\n  }\n}\n\n\n//# sourceMappingURL=FederatedMouseEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs\n\n\n"use strict";\nclass FederatedPointerEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    /**\n     * The width of the pointer\'s contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    this.width = 0;\n    /**\n     * The height of the pointer\'s contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    this.height = 0;\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    this.isPrimary = false;\n  }\n  // Only included for completeness for now\n  getCoalescedEvents() {\n    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {\n      return [this];\n    }\n    return [];\n  }\n  // Only included for completeness for now\n  getPredictedEvents() {\n    throw new Error("getPredictedEvents is not supported!");\n  }\n}\n\n\n//# sourceMappingURL=FederatedPointerEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs\n\n\n"use strict";\nclass FederatedWheelEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    /** Units specified in pixels. */\n    this.DOM_DELTA_PIXEL = 0;\n    /** Units specified in lines. */\n    this.DOM_DELTA_LINE = 1;\n    /** Units specified in pages. */\n    this.DOM_DELTA_PAGE = 2;\n  }\n}\n/** Units specified in pixels. */\nFederatedWheelEvent.DOM_DELTA_PIXEL = 0;\n/** Units specified in lines. */\nFederatedWheelEvent.DOM_DELTA_LINE = 1;\n/** Units specified in pages. */\nFederatedWheelEvent.DOM_DELTA_PAGE = 2;\n\n\n//# sourceMappingURL=FederatedWheelEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/events/EventBoundary.mjs\n\n\n\n\n\n\n\n\n"use strict";\nconst PROPAGATION_LIMIT = 2048;\nconst tempHitLocation = new Point/* Point */.b();\nconst tempLocalMapping = new Point/* Point */.b();\nclass EventBoundary {\n  /**\n   * @param rootTarget - The holder of the event boundary.\n   */\n  constructor(rootTarget) {\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    this.dispatch = new eventemitter3/* default */.A();\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API\'s approach.\n     */\n    this.moveOnAll = false;\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    this.enableGlobalMoveEvents = true;\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    this.mappingState = {\n      trackingData: {}\n    };\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    this.eventPool = /* @__PURE__ */ new Map();\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    this._allInteractiveElements = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    this._hitElements = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    this._isPointerMoveEvent = false;\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping("pointerdown", this.mapPointerDown);\n    this.addEventMapping("pointermove", this.mapPointerMove);\n    this.addEventMapping("pointerout", this.mapPointerOut);\n    this.addEventMapping("pointerleave", this.mapPointerOut);\n    this.addEventMapping("pointerover", this.mapPointerOver);\n    this.addEventMapping("pointerup", this.mapPointerUp);\n    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);\n    this.addEventMapping("wheel", this.mapWheel);\n  }\n  /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */\n  addEventMapping(type, fn) {\n    if (!this.mappingTable[type]) {\n      this.mappingTable[type] = [];\n    }\n    this.mappingTable[type].push({\n      fn,\n      priority: 0\n    });\n    this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Dispatches the given event\n   * @param e - The event to dispatch.\n   * @param type - The type of event to dispatch. Defaults to `e.type`.\n   */\n  dispatchEvent(e, type) {\n    e.propagationStopped = false;\n    e.propagationImmediatelyStopped = false;\n    this.propagate(e, type);\n    this.dispatch.emit(type || e.type, e);\n  }\n  /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e - The event to map.\n   */\n  mapEvent(e) {\n    if (!this.rootTarget) {\n      return;\n    }\n    const mappers = this.mappingTable[e.type];\n    if (mappers) {\n      for (let i = 0, j = mappers.length; i < j; i++) {\n        mappers[i].fn(e);\n      }\n    } else {\n      (0,warn/* warn */.R)(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n    }\n  }\n  /**\n   * Finds the Container that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x - The x coordinate of the event.\n   * @param y - The y coordinate of the event.\n   */\n  hitTest(x, y) {\n    EventsTicker.pauseUpdate = true;\n    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";\n    const invertedPath = this[fn](\n      this.rootTarget,\n      this.rootTarget.eventMode,\n      tempHitLocation.set(x, y),\n      this.hitTestFn,\n      this.hitPruneFn\n    );\n    return invertedPath && invertedPath[0];\n  }\n  /**\n   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n   * target {@code e.target}.\n   * @param e - The event to propagate.\n   * @param type - The type of event to propagate. Defaults to `e.type`.\n   */\n  propagate(e, type) {\n    if (!e.target) {\n      return;\n    }\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n    e.eventPhase = e.AT_TARGET;\n    e.currentTarget = e.target;\n    this.notifyTarget(e, type);\n    if (e.propagationStopped || e.propagationImmediatelyStopped)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    for (let i = composedPath.length - 2; i >= 0; i--) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n  }\n  /**\n   * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--) {\n      events.forEach((event) => {\n        e.currentTarget = targets[i];\n        this.notifyTarget(e, event);\n      });\n    }\n  }\n  /**\n   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n   * {@code target}. The last element in the path is {@code target}.\n   * @param target - The target to find the propagation path to.\n   */\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++) {\n      if (!target.parent) {\n        throw new Error("Cannot find propagation path to disconnected target");\n      }\n      propagationPath.push(target.parent);\n      target = target.parent;\n    }\n    propagationPath.reverse();\n    return propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {\n    let shouldReturn = false;\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestMoveRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn,\n          ignore || pruneFn(currentTarget, location)\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive) {\n            if (isInteractive)\n              this._allInteractiveElements.push(currentTarget);\n            nestedHit.push(currentTarget);\n          }\n          if (this._hitElements.length === 0)\n            this._hitElements = nestedHit;\n          shouldReturn = true;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveTarget && isInteractiveTarget)\n      this._allInteractiveElements.push(currentTarget);\n    if (ignore || this._hitElements.length > 0)\n      return null;\n    if (shouldReturn)\n      return this._hitElements;\n    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  /**\n   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The Container that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the container.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {\n      return null;\n    }\n    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      const relativeLocation = location;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          relativeLocation,\n          testFn,\n          pruneFn\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive)\n            nestedHit.push(currentTarget);\n          return nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveMode && testFn(currentTarget, location)) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  _isInteractive(int) {\n    return int === "static" || int === "dynamic";\n  }\n  _interactivePrune(container) {\n    if (!container || !container.visible || !container.renderable || !container.includeInBuild || !container.measurable) {\n      return true;\n    }\n    if (container.eventMode === "none") {\n      return true;\n    }\n    if (container.eventMode === "passive" && !container.interactiveChildren) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container or any of its children cannot pass the hit test at all.\n   *\n   * {@link EventBoundary}\'s implementation uses the {@link Container.hitArea hitArea}\n   * and {@link Container._maskEffect} for pruning.\n   * @param container - The container to prune.\n   * @param location - The location to test for overlap.\n   */\n  hitPruneFn(container, location) {\n    if (container.hitArea) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n        return true;\n      }\n    }\n    if (container.effects && container.effects.length) {\n      for (let i = 0; i < container.effects.length; i++) {\n        const effect = container.effects[i];\n        if (effect.containsPoint) {\n          const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n          if (!effectContainsPoint) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container passes hit testing for the given location.\n   * @param container - The container to test.\n   * @param location - The location to test for overlap.\n   * @returns - Whether `container` passes hit testing for `location`.\n   */\n  hitTestFn(container, location) {\n    if (container.hitArea) {\n      return true;\n    }\n    if (container?.containsPoint) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      return container.containsPoint(tempLocalMapping);\n    }\n    return false;\n  }\n  /**\n   * Notify all the listeners to the event\'s `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type - The type of event to notify. Defaults to `e.type`.\n   */\n  notifyTarget(e, type) {\n    if (!e.currentTarget.isInteractive()) {\n      return;\n    }\n    type = type ?? e.type;\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this._notifyListeners(e, key);\n    if (e.eventPhase === e.AT_TARGET) {\n      this._notifyListeners(e, type);\n    }\n  }\n  /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from - The upstream `pointerdown` event.\n   */\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, "pointerdown");\n    if (e.pointerType === "touch") {\n      this.dispatchEvent(e, "touchstart");\n    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    this._isPointerMoveEvent = true;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = false;\n    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";\n    const trackingData = this.trackingData(from.pointerId);\n    const outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";\n      const outEvent = this.createPointerEvent(from, outType, outTarget);\n      this.dispatchEvent(outEvent, "pointerout");\n      if (isMouse)\n        this.dispatchEvent(outEvent, "mouseout");\n      if (!e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse)\n            this.notifyTarget(leaveEvent, "mouseleave");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";\n      const overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, "pointerover");\n      if (isMouse)\n        this.dispatchEvent(overEvent, "mouseover");\n      let overTargetAncestor = outTarget?.parent;\n      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n        if (overTargetAncestor === e.target)\n          break;\n        overTargetAncestor = overTargetAncestor.parent;\n      }\n      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n      if (didPointerEnter) {\n        const enterEvent = this.clonePointerEvent(e, "pointerenter");\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n          enterEvent.currentTarget = enterEvent.target;\n          this.notifyTarget(enterEvent);\n          if (isMouse)\n            this.notifyTarget(enterEvent, "mouseenter");\n          enterEvent.target = enterEvent.target.parent;\n        }\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [];\n    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");\n    allowGlobalPointerEvents && allMethods.push("globalpointermove");\n    if (e.pointerType === "touch") {\n      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");\n      allowGlobalPointerEvents && allMethods.push("globaltouchmove");\n    }\n    if (isMouse) {\n      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");\n      allowGlobalPointerEvents && allMethods.push("globalmousemove");\n      this.cursor = e.target?.cursor;\n    }\n    if (allMethods.length > 0) {\n      this.all(e, allMethods);\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const e = this.createPointerEvent(from);\n    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";\n    this.dispatchEvent(e, "pointerover");\n    if (isMouse)\n      this.dispatchEvent(e, "mouseover");\n    if (e.pointerType === "mouse")\n      this.cursor = e.target?.cursor;\n    const enterEvent = this.clonePointerEvent(e, "pointerenter");\n    enterEvent.eventPhase = enterEvent.AT_TARGET;\n    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n      enterEvent.currentTarget = enterEvent.target;\n      this.notifyTarget(enterEvent);\n      if (isMouse)\n        this.notifyTarget(enterEvent, "mouseenter");\n      enterEvent.target = enterEvent.target.parent;\n    }\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n    this.freeEvent(enterEvent);\n  }\n  /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";\n      const outTarget = this.findMountedTarget(trackingData.overTargets);\n      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);\n      this.dispatchEvent(outEvent);\n      if (isMouse)\n        this.dispatchEvent(outEvent, "mouseout");\n      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);\n      leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n        leaveEvent.currentTarget = leaveEvent.target;\n        this.notifyTarget(leaveEvent);\n        if (isMouse)\n          this.notifyTarget(leaveEvent, "mouseleave");\n        leaveEvent.target = leaveEvent.target.parent;\n      }\n      trackingData.overTargets = null;\n      this.freeEvent(outEvent);\n      this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event\'s target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const now = performance.now();\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, "pointerup");\n    if (e.pointerType === "touch") {\n      this.dispatchEvent(e, "touchend");\n    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      while (currentTarget && !e.composedPath().includes(currentTarget)) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, "pointerupoutside");\n        if (e.pointerType === "touch") {\n          this.notifyTarget(e, "touchendoutside");\n        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n      clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, "click");\n      clickEvent.target = clickTarget;\n      clickEvent.path = null;\n      if (!trackingData.clicksByButton[from.button]) {\n        trackingData.clicksByButton[from.button] = {\n          clickCount: 0,\n          target: clickEvent.target,\n          timeStamp: now\n        };\n      }\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n        ++clickHistory.clickCount;\n      } else {\n        clickHistory.clickCount = 1;\n      }\n      clickHistory.target = clickEvent.target;\n      clickHistory.timeStamp = now;\n      clickEvent.detail = clickHistory.clickCount;\n      if (clickEvent.pointerType === "mouse") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");\n      } else if (clickEvent.pointerType === "touch") {\n        this.dispatchEvent(clickEvent, "tap");\n      }\n      this.dispatchEvent(clickEvent, "pointertap");\n      this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link EventBoundary}\'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    const e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      while (currentTarget) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, "pointerupoutside");\n        if (e.pointerType === "touch") {\n          this.notifyTarget(e, "touchendoutside");\n        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n          this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent)) {\n      (0,warn/* warn */.R)("EventBoundary cannot map a non-wheel event as a wheel event");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent);\n    this.freeEvent(wheelEvent);\n  }\n  /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */\n  findMountedTarget(propagationPath) {\n    if (!propagationPath) {\n      return null;\n    }\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length; i++) {\n      if (propagationPath[i].parent === currentTarget) {\n        currentTarget = propagationPath[i];\n      } else {\n        break;\n      }\n    }\n    return currentTarget;\n  }\n  /**\n   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The {@code originalEvent} for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];\n    if (typeof type === "string") {\n      event.type = type;\n    }\n    return event;\n  }\n  /**\n   * Creates a wheel event whose {@code originalEvent} is {@code from}.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent);\n    this.copyWheelData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = this.hitTest(event.global.x, event.global.y);\n    return event;\n  }\n  /**\n   * Clones the event {@code from}, with an optional {@code type} override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from.originalEvent;\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.target = from.target;\n    event.path = from.composedPath().slice();\n    event.type = type ?? event.type;\n    return event;\n  }\n  /**\n   * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode;\n    to.deltaX = from.deltaX;\n    to.deltaY = from.deltaY;\n    to.deltaZ = from.deltaZ;\n  }\n  /**\n   * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyPointerData(from, to) {\n    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))\n      return;\n    to.pointerId = from.pointerId;\n    to.width = from.width;\n    to.height = from.height;\n    to.isPrimary = from.isPrimary;\n    to.pointerType = from.pointerType;\n    to.pressure = from.pressure;\n    to.tangentialPressure = from.tangentialPressure;\n    to.tiltX = from.tiltX;\n    to.tiltY = from.tiltY;\n    to.twist = from.twist;\n  }\n  /**\n   * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyMouseData(from, to) {\n    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))\n      return;\n    to.altKey = from.altKey;\n    to.button = from.button;\n    to.buttons = from.buttons;\n    to.client.copyFrom(from.client);\n    to.ctrlKey = from.ctrlKey;\n    to.metaKey = from.metaKey;\n    to.movement.copyFrom(from.movement);\n    to.screen.copyFrom(from.screen);\n    to.shiftKey = from.shiftKey;\n    to.global.copyFrom(from.global);\n  }\n  /**\n   * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted;\n    to.srcElement = from.srcElement;\n    to.timeStamp = performance.now();\n    to.type = from.type;\n    to.detail = from.detail;\n    to.view = from.view;\n    to.which = from.which;\n    to.layer.copyFrom(from.layer);\n    to.page.copyFrom(from.page);\n  }\n  /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */\n  trackingData(id) {\n    if (!this.mappingState.trackingData[id]) {\n      this.mappingState.trackingData[id] = {\n        pressTargetsByButton: {},\n        clicksByButton: {},\n        overTarget: null\n      };\n    }\n    return this.mappingState.trackingData[id];\n  }\n  /**\n   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event\'s constructor.\n   */\n  allocateEvent(constructor) {\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    event.eventPhase = event.NONE;\n    event.currentTarget = null;\n    event.path = null;\n    event.target = null;\n    return event;\n  }\n  /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error("It is illegal to free an event not managed by this EventBoundary!");\n    const constructor = event.constructor;\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    this.eventPool.get(constructor).push(event);\n  }\n  /**\n   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */\n  _notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (!listeners)\n      return;\n    if ("fn" in listeners) {\n      if (listeners.once)\n        e.currentTarget.removeListener(type, listeners.fn, void 0, true);\n      listeners.fn.call(listeners.context, e);\n    } else {\n      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n        if (listeners[i].once)\n          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);\n        listeners[i].fn.call(listeners[i].context, e);\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=EventBoundary.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/events/EventSystem.mjs\n\n\n\n\n\n\n"use strict";\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER = {\n  touchstart: "pointerdown",\n  touchend: "pointerup",\n  touchendoutside: "pointerupoutside",\n  touchmove: "pointermove",\n  touchcancel: "pointercancel"\n};\nconst _EventSystem = class _EventSystem {\n  /**\n   * @param {Renderer} renderer\n   */\n  constructor(renderer) {\n    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */\n    this.supportsTouchEvents = "ontouchstart" in globalThis;\n    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */\n    this.supportsPointerEvents = !!globalThis.PointerEvent;\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer\'s {@link Renderer#view view}.\n     */\n    this.domElement = null;\n    /** The resolution used to convert between the DOM client space into world space. */\n    this.resolution = 1;\n    this.renderer = renderer;\n    this.rootBoundary = new EventBoundary(null);\n    EventsTicker.init(this);\n    this.autoPreventDefault = true;\n    this._eventsAdded = false;\n    this._rootPointerEvent = new FederatedPointerEvent(null);\n    this._rootWheelEvent = new FederatedWheelEvent(null);\n    this.cursorStyles = {\n      default: "inherit",\n      pointer: "pointer"\n    };\n    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {\n      set: (target, key, value) => {\n        if (key === "globalMove") {\n          this.rootBoundary.enableGlobalMoveEvents = value;\n        }\n        target[key] = value;\n        return true;\n      }\n    });\n    this._onPointerDown = this._onPointerDown.bind(this);\n    this._onPointerMove = this._onPointerMove.bind(this);\n    this._onPointerUp = this._onPointerUp.bind(this);\n    this._onPointerOverOut = this._onPointerOverOut.bind(this);\n    this.onWheel = this.onWheel.bind(this);\n  }\n  /**\n   * The default interaction mode for all display objects.\n   * @see Container.eventMode\n   * @type {EventMode}\n   * @readonly\n   * @since 7.2.0\n   */\n  static get defaultEventMode() {\n    return this._defaultEventMode;\n  }\n  /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */\n  init(options) {\n    const { canvas, resolution } = this.renderer;\n    this.setTargetElement(canvas);\n    this.resolution = resolution;\n    _EventSystem._defaultEventMode = options.eventMode ?? "passive";\n    Object.assign(this.features, options.eventFeatures ?? {});\n    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n  }\n  /**\n   * Handle changing resolution.\n   * @ignore\n   */\n  resolutionChange(resolution) {\n    this.resolution = resolution;\n  }\n  /** Destroys all event listeners and detaches the renderer. */\n  destroy() {\n    this.setTargetElement(null);\n    this.renderer = null;\n    this._currentCursor = null;\n  }\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   * @param mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursor(mode) {\n    mode = mode || "default";\n    let applyStyles = true;\n    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {\n      applyStyles = false;\n    }\n    if (this._currentCursor === mode) {\n      return;\n    }\n    this._currentCursor = mode;\n    const style = this.cursorStyles[mode];\n    if (style) {\n      switch (typeof style) {\n        case "string":\n          if (applyStyles) {\n            this.domElement.style.cursor = style;\n          }\n          break;\n        case "function":\n          style(mode);\n          break;\n        case "object":\n          if (applyStyles) {\n            Object.assign(this.domElement.style, style);\n          }\n          break;\n      }\n    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      this.domElement.style.cursor = mode;\n    }\n  }\n  /**\n   * The global pointer event.\n   * Useful for getting the pointer position without listening to events.\n   * @since 7.2.0\n   */\n  get pointer() {\n    return this._rootPointerEvent;\n  }\n  /**\n   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerDown(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const events = this._normalizeToPointerData(nativeEvent);\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);\n      if (cancelable) {\n        nativeEvent.preventDefault();\n      }\n    }\n    for (let i = 0, j = events.length; i < j; i++) {\n      const nativeEvent2 = events[i];\n      const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);\n      this.rootBoundary.mapEvent(federatedEvent);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch events.\n   */\n  _onPointerMove(nativeEvent) {\n    if (!this.features.move)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    EventsTicker.pointerMoved();\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerUp(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    let target = nativeEvent.target;\n    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {\n      target = nativeEvent.composedPath()[0];\n    }\n    const outside = target !== this.domElement ? "outside" : "";\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      event.type += outside;\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerOverOut(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n   * @param nativeEvent - The native wheel event.\n   */\n  onWheel(nativeEvent) {\n    if (!this.features.wheel)\n      return;\n    const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    this.rootBoundary.mapEvent(wheelEvent);\n  }\n  /**\n   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n   *\n   * To deregister the current DOM element without setting a new one, pass {@code null}.\n   * @param element - The new DOM element.\n   */\n  setTargetElement(element) {\n    this._removeEvents();\n    this.domElement = element;\n    EventsTicker.domElement = element;\n    this._addEvents();\n  }\n  /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n  _addEvents() {\n    if (this._eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.addTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = "none";\n        style.msTouchAction = "none";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = "none";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.addEventListener("pointermove", this._onPointerMove, true);\n      this.domElement.addEventListener("pointerdown", this._onPointerDown, true);\n      this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);\n      this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);\n      globalThis.addEventListener("pointerup", this._onPointerUp, true);\n    } else {\n      globalThis.document.addEventListener("mousemove", this._onPointerMove, true);\n      this.domElement.addEventListener("mousedown", this._onPointerDown, true);\n      this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);\n      this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);\n      globalThis.addEventListener("mouseup", this._onPointerUp, true);\n      if (this.supportsTouchEvents) {\n        this.domElement.addEventListener("touchstart", this._onPointerDown, true);\n        this.domElement.addEventListener("touchend", this._onPointerUp, true);\n        this.domElement.addEventListener("touchmove", this._onPointerMove, true);\n      }\n    }\n    this.domElement.addEventListener("wheel", this.onWheel, {\n      passive: true,\n      capture: true\n    });\n    this._eventsAdded = true;\n  }\n  /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n  _removeEvents() {\n    if (!this._eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.removeTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = "";\n        style.msTouchAction = "";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = "";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);\n      this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);\n      this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);\n      this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);\n      globalThis.removeEventListener("pointerup", this._onPointerUp, true);\n    } else {\n      globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);\n      this.domElement.removeEventListener("mousedown", this._onPointerDown, true);\n      this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);\n      this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);\n      globalThis.removeEventListener("mouseup", this._onPointerUp, true);\n      if (this.supportsTouchEvents) {\n        this.domElement.removeEventListener("touchstart", this._onPointerDown, true);\n        this.domElement.removeEventListener("touchend", this._onPointerUp, true);\n        this.domElement.removeEventListener("touchmove", this._onPointerMove, true);\n      }\n    }\n    this.domElement.removeEventListener("wheel", this.onWheel, true);\n    this.domElement = null;\n    this._eventsAdded = false;\n  }\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   * @param  {PointData} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {\n      x: 0,\n      y: 0,\n      width: this.domElement.width,\n      height: this.domElement.height,\n      left: 0,\n      top: 0\n    };\n    const resolutionMultiplier = 1 / this.resolution;\n    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n  }\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   * @param event - The original event data from a touch or mouse event\n   * @returns An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  _normalizeToPointerData(event) {\n    const normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n        if (typeof touch.button === "undefined")\n          touch.button = 0;\n        if (typeof touch.buttons === "undefined")\n          touch.buttons = 1;\n        if (typeof touch.isPrimary === "undefined") {\n          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";\n        }\n        if (typeof touch.width === "undefined")\n          touch.width = touch.radiusX || 1;\n        if (typeof touch.height === "undefined")\n          touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === "undefined")\n          touch.tiltX = 0;\n        if (typeof touch.tiltY === "undefined")\n          touch.tiltY = 0;\n        if (typeof touch.pointerType === "undefined")\n          touch.pointerType = "touch";\n        if (typeof touch.pointerId === "undefined")\n          touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === "undefined")\n          touch.pressure = touch.force || 0.5;\n        if (typeof touch.twist === "undefined")\n          touch.twist = 0;\n        if (typeof touch.tangentialPressure === "undefined")\n          touch.tangentialPressure = 0;\n        if (typeof touch.layerX === "undefined")\n          touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === "undefined")\n          touch.layerY = touch.offsetY = touch.clientY;\n        touch.isNormalized = true;\n        touch.type = event.type;\n        normalizedEvents.push(touch);\n      }\n    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      const tempEvent = event;\n      if (typeof tempEvent.isPrimary === "undefined")\n        tempEvent.isPrimary = true;\n      if (typeof tempEvent.width === "undefined")\n        tempEvent.width = 1;\n      if (typeof tempEvent.height === "undefined")\n        tempEvent.height = 1;\n      if (typeof tempEvent.tiltX === "undefined")\n        tempEvent.tiltX = 0;\n      if (typeof tempEvent.tiltY === "undefined")\n        tempEvent.tiltY = 0;\n      if (typeof tempEvent.pointerType === "undefined")\n        tempEvent.pointerType = "mouse";\n      if (typeof tempEvent.pointerId === "undefined")\n        tempEvent.pointerId = MOUSE_POINTER_ID;\n      if (typeof tempEvent.pressure === "undefined")\n        tempEvent.pressure = 0.5;\n      if (typeof tempEvent.twist === "undefined")\n        tempEvent.twist = 0;\n      if (typeof tempEvent.tangentialPressure === "undefined")\n        tempEvent.tangentialPressure = 0;\n      tempEvent.isNormalized = true;\n      normalizedEvents.push(tempEvent);\n    } else {\n      normalizedEvents.push(event);\n    }\n    return normalizedEvents;\n  }\n  /**\n   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n   *\n   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n   * multiple native wheel events.\n   * @param nativeEvent - The native wheel event that occurred on the canvas.\n   * @returns A federated wheel event.\n   */\n  normalizeWheelEvent(nativeEvent) {\n    const event = this._rootWheelEvent;\n    this._transferMouseData(event, nativeEvent);\n    event.deltaX = nativeEvent.deltaX;\n    event.deltaY = nativeEvent.deltaY;\n    event.deltaZ = nativeEvent.deltaZ;\n    event.deltaMode = nativeEvent.deltaMode;\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.nativeEvent = nativeEvent;\n    event.type = nativeEvent.type;\n    return event;\n  }\n  /**\n   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n   * @param event\n   * @param nativeEvent\n   */\n  _bootstrapEvent(event, nativeEvent) {\n    event.originalEvent = null;\n    event.nativeEvent = nativeEvent;\n    event.pointerId = nativeEvent.pointerId;\n    event.width = nativeEvent.width;\n    event.height = nativeEvent.height;\n    event.isPrimary = nativeEvent.isPrimary;\n    event.pointerType = nativeEvent.pointerType;\n    event.pressure = nativeEvent.pressure;\n    event.tangentialPressure = nativeEvent.tangentialPressure;\n    event.tiltX = nativeEvent.tiltX;\n    event.tiltY = nativeEvent.tiltY;\n    event.twist = nativeEvent.twist;\n    this._transferMouseData(event, nativeEvent);\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.isTrusted = nativeEvent.isTrusted;\n    if (event.type === "pointerleave") {\n      event.type = "pointerout";\n    }\n    if (event.type.startsWith("mouse")) {\n      event.type = event.type.replace("mouse", "pointer");\n    }\n    if (event.type.startsWith("touch")) {\n      event.type = TOUCH_TO_POINTER[event.type] || event.type;\n    }\n    return event;\n  }\n  /**\n   * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n   * @param event\n   * @param nativeEvent\n   */\n  _transferMouseData(event, nativeEvent) {\n    event.isTrusted = nativeEvent.isTrusted;\n    event.srcElement = nativeEvent.srcElement;\n    event.timeStamp = performance.now();\n    event.type = nativeEvent.type;\n    event.altKey = nativeEvent.altKey;\n    event.button = nativeEvent.button;\n    event.buttons = nativeEvent.buttons;\n    event.client.x = nativeEvent.clientX;\n    event.client.y = nativeEvent.clientY;\n    event.ctrlKey = nativeEvent.ctrlKey;\n    event.metaKey = nativeEvent.metaKey;\n    event.movement.x = nativeEvent.movementX;\n    event.movement.y = nativeEvent.movementY;\n    event.page.x = nativeEvent.pageX;\n    event.page.y = nativeEvent.pageY;\n    event.relatedTarget = null;\n    event.shiftKey = nativeEvent.shiftKey;\n  }\n};\n/** @ignore */\n_EventSystem.extension = {\n  name: "events",\n  type: [\n    Extensions/* ExtensionType */.Ag.WebGLSystem,\n    Extensions/* ExtensionType */.Ag.CanvasSystem,\n    Extensions/* ExtensionType */.Ag.WebGPUSystem\n  ],\n  priority: -1\n};\n/**\n * The event features that are enabled by the EventSystem\n * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n * @since 7.2.0\n */\n_EventSystem.defaultEventFeatures = {\n  /** Enables pointer events associated with pointer movement. */\n  move: true,\n  /** Enables global pointer move events. */\n  globalMove: true,\n  /** Enables pointer events associated with clicking. */\n  click: true,\n  /** Enables wheel events. */\n  wheel: true\n};\nlet EventSystem = _EventSystem;\n\n\n//# sourceMappingURL=EventSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/events/FederatedEventTarget.mjs\n\n\n\n"use strict";\nconst FederatedContainer = {\n  /**\n   * Property-based event handler for the `click` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onclick = (event) => {\n   *  //some function here that happens on click\n   * }\n   */\n  onclick: null,\n  /**\n   * Property-based event handler for the `mousedown` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onmousedown = (event) => {\n   *  //some function here that happens on mousedown\n   * }\n   */\n  onmousedown: null,\n  /**\n   * Property-based event handler for the `mouseenter` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onmouseenter = (event) => {\n   *  //some function here that happens on mouseenter\n   * }\n   */\n  onmouseenter: null,\n  /**\n   * Property-based event handler for the `mouseleave` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onmouseleave = (event) => {\n   *  //some function here that happens on mouseleave\n   * }\n   */\n  onmouseleave: null,\n  /**\n   * Property-based event handler for the `mousemove` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onmousemove = (event) => {\n   *  //some function here that happens on mousemove\n   * }\n   */\n  onmousemove: null,\n  /**\n   * Property-based event handler for the `globalmousemove` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onglobalmousemove = (event) => {\n   *  //some function here that happens on globalmousemove\n   * }\n   */\n  onglobalmousemove: null,\n  /**\n   * Property-based event handler for the `mouseout` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onmouseout = (event) => {\n   *  //some function here that happens on mouseout\n   * }\n   */\n  onmouseout: null,\n  /**\n   * Property-based event handler for the `mouseover` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onmouseover = (event) => {\n   *  //some function here that happens on mouseover\n   * }\n   */\n  onmouseover: null,\n  /**\n   * Property-based event handler for the `mouseup` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onmouseup = (event) => {\n   *  //some function here that happens on mouseup\n   * }\n   */\n  onmouseup: null,\n  /**\n   * Property-based event handler for the `mouseupoutside` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onmouseupoutside = (event) => {\n   *  //some function here that happens on mouseupoutside\n   * }\n   */\n  onmouseupoutside: null,\n  /**\n   * Property-based event handler for the `pointercancel` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onpointercancel = (event) => {\n   *  //some function here that happens on pointercancel\n   * }\n   */\n  onpointercancel: null,\n  /**\n   * Property-based event handler for the `pointerdown` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onpointerdown = (event) => {\n   *  //some function here that happens on pointerdown\n   * }\n   */\n  onpointerdown: null,\n  /**\n   * Property-based event handler for the `pointerenter` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onpointerenter = (event) => {\n   *  //some function here that happens on pointerenter\n   * }\n   */\n  onpointerenter: null,\n  /**\n   * Property-based event handler for the `pointerleave` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onpointerleave = (event) => {\n   *  //some function here that happens on pointerleave\n   * }\n   */\n  onpointerleave: null,\n  /**\n   * Property-based event handler for the `pointermove` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onpointermove = (event) => {\n   *  //some function here that happens on pointermove\n   * }\n   */\n  onpointermove: null,\n  /**\n   * Property-based event handler for the `globalpointermove` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onglobalpointermove = (event) => {\n   *  //some function here that happens on globalpointermove\n   * }\n   */\n  onglobalpointermove: null,\n  /**\n   * Property-based event handler for the `pointerout` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onpointerout = (event) => {\n   *  //some function here that happens on pointerout\n   * }\n   */\n  onpointerout: null,\n  /**\n   * Property-based event handler for the `pointerover` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onpointerover = (event) => {\n   *  //some function here that happens on pointerover\n   * }\n   */\n  onpointerover: null,\n  /**\n   * Property-based event handler for the `pointertap` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onpointertap = (event) => {\n   *  //some function here that happens on pointertap\n   * }\n   */\n  onpointertap: null,\n  /**\n   * Property-based event handler for the `pointerup` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onpointerup = (event) => {\n   *  //some function here that happens on pointerup\n   * }\n   */\n  onpointerup: null,\n  /**\n   * Property-based event handler for the `pointerupoutside` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onpointerupoutside = (event) => {\n   *  //some function here that happens on pointerupoutside\n   * }\n   */\n  onpointerupoutside: null,\n  /**\n   * Property-based event handler for the `rightclick` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onrightclick = (event) => {\n   *  //some function here that happens on rightclick\n   * }\n   */\n  onrightclick: null,\n  /**\n   * Property-based event handler for the `rightdown` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onrightdown = (event) => {\n   *  //some function here that happens on rightdown\n   * }\n   */\n  onrightdown: null,\n  /**\n   * Property-based event handler for the `rightup` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onrightup = (event) => {\n   *  //some function here that happens on rightup\n   * }\n   */\n  onrightup: null,\n  /**\n   * Property-based event handler for the `rightupoutside` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onrightupoutside = (event) => {\n   *  //some function here that happens on rightupoutside\n   * }\n   */\n  onrightupoutside: null,\n  /**\n   * Property-based event handler for the `tap` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.ontap = (event) => {\n   *  //some function here that happens on tap\n   * }\n   */\n  ontap: null,\n  /**\n   * Property-based event handler for the `touchcancel` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.ontouchcancel = (event) => {\n   *  //some function here that happens on touchcancel\n   * }\n   */\n  ontouchcancel: null,\n  /**\n   * Property-based event handler for the `touchend` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.ontouchend = (event) => {\n   *  //some function here that happens on touchend\n   * }\n   */\n  ontouchend: null,\n  /**\n   * Property-based event handler for the `touchendoutside` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.ontouchendoutside = (event) => {\n   *  //some function here that happens on touchendoutside\n   * }\n   */\n  ontouchendoutside: null,\n  /**\n   * Property-based event handler for the `touchmove` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.ontouchmove = (event) => {\n   *  //some function here that happens on touchmove\n   * }\n   */\n  ontouchmove: null,\n  /**\n   * Property-based event handler for the `globaltouchmove` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onglobaltouchmove = (event) => {\n   *  //some function here that happens on globaltouchmove\n   * }\n   */\n  onglobaltouchmove: null,\n  /**\n   * Property-based event handler for the `touchstart` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.ontouchstart = (event) => {\n   *  //some function here that happens on touchstart\n   * }\n   */\n  ontouchstart: null,\n  /**\n   * Property-based event handler for the `wheel` event.\n   * @memberof scene.Container#\n   * @default null\n   * @example\n   * this.onwheel = (event) => {\n   *  //some function here that happens on wheel\n   * }\n   */\n  onwheel: null,\n  /**\n   * Enable interaction events for the Container. Touch, pointer and mouse\n   * @memberof scene.Container#\n   */\n  get interactive() {\n    return this.eventMode === "dynamic" || this.eventMode === "static";\n  },\n  set interactive(value) {\n    this.eventMode = value ? "static" : "passive";\n  },\n  /**\n   * @ignore\n   */\n  _internalEventMode: void 0,\n  /**\n   * Enable interaction events for the Container. Touch, pointer and mouse.\n   * There are 5 types of interaction settings:\n   * - `\'none\'`: Ignores all interaction events, even on its children.\n   * - `\'passive\'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.\n   * Interactive children will still emit events.\n   * - `\'auto\'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n   * - `\'static\'`: Emit events and is hit tested. Same as `interaction = true` in v7\n   * - `\'dynamic\'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to\n   * allow for interaction when the mouse isn\'t moving\n   * @example\n   * import { Sprite } from \'pixi.js\';\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.eventMode = \'static\';\n   * sprite.on(\'tap\', (event) => {\n   *     // Handle event\n   * });\n   * @memberof scene.Container#\n   * @since 7.2.0\n   */\n  get eventMode() {\n    return this._internalEventMode ?? EventSystem.defaultEventMode;\n  },\n  set eventMode(value) {\n    this._internalEventMode = value;\n  },\n  /**\n   * Determines if the container is interactive or not\n   * @returns {boolean} Whether the container is interactive or not\n   * @memberof scene.Container#\n   * @since 7.2.0\n   * @example\n   * import { Sprite } from \'pixi.js\';\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.eventMode = \'static\';\n   * sprite.isInteractive(); // true\n   *\n   * sprite.eventMode = \'dynamic\';\n   * sprite.isInteractive(); // true\n   *\n   * sprite.eventMode = \'none\';\n   * sprite.isInteractive(); // false\n   *\n   * sprite.eventMode = \'passive\';\n   * sprite.isInteractive(); // false\n   *\n   * sprite.eventMode = \'auto\';\n   * sprite.isInteractive(); // false\n   */\n  isInteractive() {\n    return this.eventMode === "static" || this.eventMode === "dynamic";\n  },\n  /**\n   * Determines if the children to the container can be clicked/touched\n   * Setting this to false allows PixiJS to bypass a recursive `hitTest` function\n   * @memberof scene.Container#\n   */\n  interactiveChildren: true,\n  /**\n   * Interaction shape. Children will be hit first, then this shape will be checked.\n   * Setting this will cause this shape to be checked in hit tests rather than the container\'s bounds.\n   * @example\n   * import { Rectangle, Sprite } from \'pixi.js\';\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n   * @member {IHitArea}\n   * @memberof scene.Container#\n   */\n  hitArea: null,\n  /**\n   * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n   * seeks to be compatible with the DOM\'s `addEventListener` with support for options.\n   * @memberof scene.Container\n   * @param type - The type of event to listen to.\n   * @param listener - The listener callback or object.\n   * @param options - Listener options, used for capture phase.\n   * @example\n   * // Tell the user whether they did a single, double, triple, or nth click.\n   * button.addEventListener(\'click\', {\n   *     handleEvent(e): {\n   *         let prefix;\n   *\n   *         switch (e.detail) {\n   *             case 1: prefix = \'single\'; break;\n   *             case 2: prefix = \'double\'; break;\n   *             case 3: prefix = \'triple\'; break;\n   *             default: prefix = e.detail + \'th\'; break;\n   *         }\n   *\n   *         console.log(\'That was a \' + prefix + \'click\');\n   *     }\n   * });\n   *\n   * // But skip the first click!\n   * button.parent.addEventListener(\'click\', function blockClickOnce(e) {\n   *     e.stopImmediatePropagation();\n   *     button.parent.removeEventListener(\'click\', blockClickOnce, true);\n   * }, {\n   *     capture: true,\n   * });\n   */\n  addEventListener(type, listener, options) {\n    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;\n    const signal = typeof options === "object" ? options.signal : void 0;\n    const once = typeof options === "object" ? options.once === true : false;\n    const context = typeof listener === "function" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;\n    const emitter = this;\n    if (signal) {\n      signal.addEventListener("abort", () => {\n        emitter.off(type, listenerFn, context);\n      });\n    }\n    if (once) {\n      emitter.once(type, listenerFn, context);\n    } else {\n      emitter.on(type, listenerFn, context);\n    }\n  },\n  /**\n   * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n   * seeks to be compatible with the DOM\'s `removeEventListener` with support for options.\n   * @memberof scene.Container\n   * @param type - The type of event the listener is bound to.\n   * @param listener - The listener callback or object.\n   * @param options - The original listener options. This is required to deregister a capture phase listener.\n   */\n  removeEventListener(type, listener, options) {\n    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;\n    const context = typeof listener === "function" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    listener = typeof listener === "function" ? listener : listener.handleEvent;\n    this.off(type, listener, context);\n  },\n  /**\n   * Dispatch the event on this {@link Container} using the event\'s {@link EventBoundary}.\n   *\n   * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n   * @memberof scene.Container\n   * @param e - The event to dispatch.\n   * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.\n   * @example\n   * // Reuse a click event!\n   * button.dispatchEvent(clickEvent);\n   */\n  dispatchEvent(e) {\n    if (!(e instanceof FederatedEvent)) {\n      throw new Error("Container cannot propagate events outside of the Federated Events API");\n    }\n    e.defaultPrevented = false;\n    e.path = null;\n    e.target = this;\n    e.manager.dispatchEvent(e);\n    return !e.defaultPrevented;\n  }\n};\n\n\n//# sourceMappingURL=FederatedEventTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/events/init.mjs\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.XO.add(EventSystem);\nContainer/* Container */.mc.mixin(FederatedContainer);\n//# sourceMappingURL=init.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/spritesheet/init.mjs + 2 modules\nvar spritesheet_init = __webpack_require__(9010);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/init.mjs + 5 modules\nvar rendering_init = __webpack_require__(8480);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/init.mjs + 1 modules\nvar graphics_init = __webpack_require__(8928);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/init.mjs + 1 modules\nvar mesh_init = __webpack_require__(5285);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/init.mjs + 3 modules\nvar text_init = __webpack_require__(6958);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs + 5 modules\nvar text_bitmap_init = __webpack_require__(4243);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text-html/init.mjs + 14 modules\nvar text_html_init = __webpack_require__(7559);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs + 7 modules\nvar sprite_tiling_init = __webpack_require__(8723);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs + 3 modules\nvar sprite_nine_slice_init = __webpack_require__(7252);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/filters/init.mjs + 4 modules\nvar filters_init = __webpack_require__(9935);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment-browser/browserAll.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\n//# sourceMappingURL=browserAll.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLE1BQU0sb0JBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLE1BQU0sb0JBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLE1BQU0sb0JBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQ0FBaUMsaUJBQWlCLG1CQUFtQixvQkFBb0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQW1EO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCO0FBQzlCOzs7QUNoZ0IwRDtBQUNHO0FBQ2I7QUFDZ0I7O0FBRWhFO0FBQ0EsNkJBQVUsS0FBSyxXQUFXO0FBQzFCLDJCQUFTLE9BQU8sa0JBQWtCO0FBQ2xDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1JtQztBQUNWO0FBQ0c7QUFDSztBQUNGO0FBQ0s7QUFDSjtBQUNBO0FBQ087QUFDRjtBQUNJO0FBQ0k7QUFDaEI7O0FBRTdCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V2ZW50cy9GZWRlcmF0ZWRFdmVudC5tanM/ZWUyMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lzbW9iaWxlanMvc3JjL2lzTW9iaWxlLnRzP2FhOTgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9icm93c2VyL2lzTW9iaWxlLm1qcz8xNDA1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYWNjZXNzaWJpbGl0eS9BY2Nlc3NpYmlsaXR5U3lzdGVtLm1qcz9lNzhkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYWNjZXNzaWJpbGl0eS9hY2Nlc3NpYmlsaXR5VGFyZ2V0Lm1qcz85NDc4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYWNjZXNzaWJpbGl0eS9pbml0Lm1qcz84OGFjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXZlbnRzL0V2ZW50VGlja2VyLm1qcz8wZmI4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXZlbnRzL0ZlZGVyYXRlZE1vdXNlRXZlbnQubWpzPzg5NTQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9ldmVudHMvRmVkZXJhdGVkUG9pbnRlckV2ZW50Lm1qcz83NWRmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZXZlbnRzL0ZlZGVyYXRlZFdoZWVsRXZlbnQubWpzPzBmYWEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby90aHJlZWpzLWJpbGxib2FyZC8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9ldmVudHMvRXZlbnRCb3VuZGFyeS5tanM/OGZkOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V2ZW50cy9FdmVudFN5c3RlbS5tanM/NWY0MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V2ZW50cy9GZWRlcmF0ZWRFdmVudFRhcmdldC5tanM/ODgxNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3RocmVlanMtYmlsbGJvYXJkLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V2ZW50cy9pbml0Lm1qcz82YzhkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vdGhyZWVqcy1iaWxsYm9hcmQvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZW52aXJvbm1lbnQtYnJvd3Nlci9icm93c2VyQWxsLm1qcz9kNTJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBGZWRlcmF0ZWRFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbWFuYWdlciAtIFRoZSBldmVudCBib3VuZGFyeSB3aGljaCBtYW5hZ2VzIHRoaXMgZXZlbnQuIFByb3BhZ2F0aW9uIGNhbiBvbmx5IG9jY3VyXG4gICAqICB3aXRoaW4gdGhlIGJvdW5kYXJ5J3MganVyaXNkaWN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIC8qKiBGbGFncyB3aGV0aGVyIHRoaXMgZXZlbnQgYnViYmxlcy4gVGhpcyB3aWxsIHRha2UgZWZmZWN0IG9ubHkgaWYgaXQgaXMgc2V0IGJlZm9yZSBwcm9wYWdhdGlvbi4gKi9cbiAgICB0aGlzLmJ1YmJsZXMgPSB0cnVlO1xuICAgIC8qKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMCAqL1xuICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBGbGFncyB3aGV0aGVyIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGVkIHVzaW5nIHtAbGluayBGZWRlcmF0ZWRFdmVudC5wcmV2ZW50RGVmYXVsdH0uIFRoaXMgaXMgYWx3YXlzXG4gICAgICogZmFsc2UgKGZvciBub3cpLlxuICAgICAqL1xuICAgIHRoaXMuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEZsYWcgYWRkZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBET00ge0Bjb2RlIEV2ZW50fS4gSXQgaXMgbm90IHVzZWQgaW4gdGhlIEZlZGVyYXRlZCBFdmVudHNcbiAgICAgKiBBUEkuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1jb21wb3NlZFxuICAgICAqL1xuICAgIHRoaXMuY29tcG9zZWQgPSBmYWxzZTtcbiAgICAvKiogRmxhZ3Mgd2hldGhlciB0aGUgZGVmYXVsdCByZXNwb25zZSBvZiB0aGUgdXNlciBhZ2VudCB3YXMgcHJldmVudCB0aHJvdWdoIHRoaXMgZXZlbnQuICovXG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIHByb3BhZ2F0aW9uIHBoYXNlLlxuICAgICAqIEBkZWZhdWx0IHtAbGluayBGZWRlcmF0ZWRFdmVudC5OT05FfVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRQaGFzZSA9IEZlZGVyYXRlZEV2ZW50LnByb3RvdHlwZS5OT05FO1xuICAgIC8qKiBGbGFncyB3aGV0aGVyIHByb3BhZ2F0aW9uIHdhcyBzdG9wcGVkLiAqL1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gICAgLyoqIEZsYWdzIHdoZXRoZXIgcHJvcGFnYXRpb24gd2FzIGltbWVkaWF0ZWx5IHN0b3BwZWQuICovXG4gICAgdGhpcy5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZCA9IGZhbHNlO1xuICAgIC8qKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSBuZWFyZXN0IERPTSBsYXllci4gVGhpcyBpcyBhIG5vbi1zdGFuZGFyZCBwcm9wZXJ0eS4gKi9cbiAgICB0aGlzLmxheWVyID0gbmV3IFBvaW50KCk7XG4gICAgLyoqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIERPTSBkb2N1bWVudC4gVGhpcyBpcyBhIG5vbi1zdGFuZGFyZCBwcm9wZXJ0eS4gKi9cbiAgICB0aGlzLnBhZ2UgPSBuZXcgUG9pbnQoKTtcbiAgICB0aGlzLk5PTkUgPSAwO1xuICAgIHRoaXMuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbiAgICB0aGlzLkFUX1RBUkdFVCA9IDI7XG4gICAgdGhpcy5CVUJCTElOR19QSEFTRSA9IDM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBsYXllclgoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXIueDtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBsYXllclkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXIueTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBwYWdlWCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLng7XG4gIH1cbiAgLyoqIEByZWFkb25seSAqL1xuICBnZXQgcGFnZVkoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS55O1xuICB9XG4gIC8qKlxuICAgKiBGYWxsYmFjayBmb3IgdGhlIGRlcHJlY2F0ZWQgQGNvZGV7SW50ZXJhY3Rpb25FdmVudC5kYXRhfS5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNy4wLjBcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBUaGUgcHJvcGFnYXRpb24gcGF0aCBmb3IgdGhpcyBldmVudC4gQWxpYXMgZm9yIHtAbGluayBFdmVudEJvdW5kYXJ5LnByb3BhZ2F0aW9uUGF0aH0uICovXG4gIGNvbXBvc2VkUGF0aCgpIHtcbiAgICBpZiAodGhpcy5tYW5hZ2VyICYmICghdGhpcy5wYXRoIHx8IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0gIT09IHRoaXMudGFyZ2V0KSkge1xuICAgICAgdGhpcy5wYXRoID0gdGhpcy50YXJnZXQgPyB0aGlzLm1hbmFnZXIucHJvcGFnYXRpb25QYXRoKHRoaXMudGFyZ2V0KSA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXRoO1xuICB9XG4gIC8qKlxuICAgKiBVbmltcGxlbWVudGVkIG1ldGhvZCBpbmNsdWRlZCBmb3IgaW1wbGVtZW50aW5nIHRoZSBET00gaW50ZXJmYWNlIHtAY29kZSBFdmVudH0uIEl0IHdpbGwgdGhyb3cgYW4ge0Bjb2RlIEVycm9yfS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIF90eXBlXG4gICAqIEBwYXJhbSBfYnViYmxlc1xuICAgKiBAcGFyYW0gX2NhbmNlbGFibGVcbiAgICovXG4gIGluaXRFdmVudChfdHlwZSwgX2J1YmJsZXMsIF9jYW5jZWxhYmxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5pdEV2ZW50KCkgaXMgYSBsZWdhY3kgRE9NIEFQSS4gSXQgaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBGZWRlcmF0ZWQgRXZlbnRzIEFQSS5cIik7XG4gIH1cbiAgLyoqXG4gICAqIFVuaW1wbGVtZW50ZWQgbWV0aG9kIGluY2x1ZGVkIGZvciBpbXBsZW1lbnRpbmcgdGhlIERPTSBpbnRlcmZhY2Uge0Bjb2RlIFVJRXZlbnR9LiBJdCB3aWxsIHRocm93IGFuIHtAY29kZSBFcnJvcn0uXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSBfdHlwZUFyZ1xuICAgKiBAcGFyYW0gX2J1YmJsZXNBcmdcbiAgICogQHBhcmFtIF9jYW5jZWxhYmxlQXJnXG4gICAqIEBwYXJhbSBfdmlld0FyZ1xuICAgKiBAcGFyYW0gX2RldGFpbEFyZ1xuICAgKi9cbiAgaW5pdFVJRXZlbnQoX3R5cGVBcmcsIF9idWJibGVzQXJnLCBfY2FuY2VsYWJsZUFyZywgX3ZpZXdBcmcsIF9kZXRhaWxBcmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbml0VUlFdmVudCgpIGlzIGEgbGVnYWN5IERPTSBBUEkuIEl0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgRmVkZXJhdGVkIEV2ZW50cyBBUEkuXCIpO1xuICB9XG4gIC8qKiBQcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3Igb2YgUGl4aUpTIGFuZCB0aGUgdXNlciBhZ2VudC4gKi9cbiAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgaWYgKHRoaXMubmF0aXZlRXZlbnQgaW5zdGFuY2VvZiBFdmVudCAmJiB0aGlzLm5hdGl2ZUV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgIHRoaXMubmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU3RvcCB0aGlzIGV2ZW50IGZyb20gcHJvcGFnYXRpbmcgdG8gYW55IGFkZGl0aW9uIGxpc3RlbmVycywgaW5jbHVkaW5nIG9uIHRoZVxuICAgKiB7QGxpbmsgRmVkZXJhdGVkRXZlbnRUYXJnZXQuY3VycmVudFRhcmdldCBjdXJyZW50VGFyZ2V0fSBhbmQgYWxzbyB0aGUgZm9sbG93aW5nXG4gICAqIGV2ZW50IHRhcmdldHMgb24gdGhlIHByb3BhZ2F0aW9uIHBhdGguXG4gICAqL1xuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgdGhpcyBldmVudCBmcm9tIHByb3BhZ2F0aW5nIHRvIHRoZSBuZXh0IHtAbGluayBGZWRlcmF0ZWRFdmVudFRhcmdldH0uIFRoZSByZXN0IG9mIHRoZSBsaXN0ZW5lcnNcbiAgICogb24gdGhlIHtAbGluayBGZWRlcmF0ZWRFdmVudFRhcmdldC5jdXJyZW50VGFyZ2V0IGN1cnJlbnRUYXJnZXR9IHdpbGwgc3RpbGwgYmUgbm90aWZpZWQuXG4gICAqL1xuICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCB7IEZlZGVyYXRlZEV2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRFdmVudC5tanMubWFwXG4iLCJjb25zdCBhcHBsZUlwaG9uZSA9IC9pUGhvbmUvaTtcbmNvbnN0IGFwcGxlSXBvZCA9IC9pUG9kL2k7XG5jb25zdCBhcHBsZVRhYmxldCA9IC9pUGFkL2k7XG5jb25zdCBhcHBsZVVuaXZlcnNhbCA9IC9cXGJpT1MtdW5pdmVyc2FsKD86LispTWFjXFxiL2k7XG5jb25zdCBhbmRyb2lkUGhvbmUgPSAvXFxiQW5kcm9pZCg/Oi4rKU1vYmlsZVxcYi9pOyAvLyBNYXRjaCAnQW5kcm9pZCcgQU5EICdNb2JpbGUnXG5jb25zdCBhbmRyb2lkVGFibGV0ID0gL0FuZHJvaWQvaTtcbmNvbnN0IGFtYXpvblBob25lID0gLyg/OlNENDkzMFVSfFxcYlNpbGsoPzouKylNb2JpbGVcXGIpL2k7IC8vIE1hdGNoICdTaWxrJyBBTkQgJ01vYmlsZSdcbmNvbnN0IGFtYXpvblRhYmxldCA9IC9TaWxrL2k7XG5jb25zdCB3aW5kb3dzUGhvbmUgPSAvV2luZG93cyBQaG9uZS9pO1xuY29uc3Qgd2luZG93c1RhYmxldCA9IC9cXGJXaW5kb3dzKD86LispQVJNXFxiL2k7IC8vIE1hdGNoICdXaW5kb3dzJyBBTkQgJ0FSTSdcbmNvbnN0IG90aGVyQmxhY2tCZXJyeSA9IC9CbGFja0JlcnJ5L2k7XG5jb25zdCBvdGhlckJsYWNrQmVycnkxMCA9IC9CQjEwL2k7XG5jb25zdCBvdGhlck9wZXJhID0gL09wZXJhIE1pbmkvaTtcbmNvbnN0IG90aGVyQ2hyb21lID0gL1xcYihDcmlPU3xDaHJvbWUpKD86LispTW9iaWxlL2k7XG5jb25zdCBvdGhlckZpcmVmb3ggPSAvTW9iaWxlKD86LispRmlyZWZveFxcYi9pOyAvLyBNYXRjaCAnTW9iaWxlJyBBTkQgJ0ZpcmVmb3gnXG5cbmV4cG9ydCB0eXBlIFVzZXJBZ2VudCA9IHN0cmluZztcbmV4cG9ydCB0eXBlIE5hdmlnYXRvciA9IHtcbiAgdXNlckFnZW50OiBzdHJpbmc7XG4gIHBsYXRmb3JtOiBzdHJpbmc7XG4gIG1heFRvdWNoUG9pbnRzPzogbnVtYmVyO1xufTtcblxuY29uc3QgaXNBcHBsZVRhYmxldE9uSW9zMTMgPSAobmF2aWdhdG9yPzogTmF2aWdhdG9yKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiZcbiAgICB0eXBlb2YgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID09PSAnbnVtYmVyJyAmJlxuICAgIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEgJiZcbiAgICB0eXBlb2YgTVNTdHJlYW0gPT09ICd1bmRlZmluZWQnXG4gICk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaCh1c2VyQWdlbnQ6IFVzZXJBZ2VudCk6IChyZWdleDogUmVnRXhwKSA9PiBib29sZWFuIHtcbiAgcmV0dXJuIChyZWdleDogUmVnRXhwKTogYm9vbGVhbiA9PiByZWdleC50ZXN0KHVzZXJBZ2VudCk7XG59XG5cbmV4cG9ydCB0eXBlIGlzTW9iaWxlUmVzdWx0ID0ge1xuICBhcHBsZToge1xuICAgIHBob25lOiBib29sZWFuO1xuICAgIGlwb2Q6IGJvb2xlYW47XG4gICAgdGFibGV0OiBib29sZWFuO1xuICAgIHVuaXZlcnNhbDogYm9vbGVhbjtcbiAgICBkZXZpY2U6IGJvb2xlYW47XG4gIH07XG4gIGFtYXpvbjoge1xuICAgIHBob25lOiBib29sZWFuO1xuICAgIHRhYmxldDogYm9vbGVhbjtcbiAgICBkZXZpY2U6IGJvb2xlYW47XG4gIH07XG4gIGFuZHJvaWQ6IHtcbiAgICBwaG9uZTogYm9vbGVhbjtcbiAgICB0YWJsZXQ6IGJvb2xlYW47XG4gICAgZGV2aWNlOiBib29sZWFuO1xuICB9O1xuICB3aW5kb3dzOiB7XG4gICAgcGhvbmU6IGJvb2xlYW47XG4gICAgdGFibGV0OiBib29sZWFuO1xuICAgIGRldmljZTogYm9vbGVhbjtcbiAgfTtcbiAgb3RoZXI6IHtcbiAgICBibGFja2JlcnJ5OiBib29sZWFuO1xuICAgIGJsYWNrYmVycnkxMDogYm9vbGVhbjtcbiAgICBvcGVyYTogYm9vbGVhbjtcbiAgICBmaXJlZm94OiBib29sZWFuO1xuICAgIGNocm9tZTogYm9vbGVhbjtcbiAgICBkZXZpY2U6IGJvb2xlYW47XG4gIH07XG4gIHBob25lOiBib29sZWFuO1xuICB0YWJsZXQ6IGJvb2xlYW47XG4gIGFueTogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIElzTW9iaWxlUGFyYW1ldGVyID0gVXNlckFnZW50IHwgTmF2aWdhdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc01vYmlsZShwYXJhbT86IElzTW9iaWxlUGFyYW1ldGVyKTogaXNNb2JpbGVSZXN1bHQge1xuICBsZXQgbmF2OiBOYXZpZ2F0b3IgPSB7XG4gICAgdXNlckFnZW50OiAnJyxcbiAgICBwbGF0Zm9ybTogJycsXG4gICAgbWF4VG91Y2hQb2ludHM6IDAsXG4gIH07XG5cbiAgaWYgKCFwYXJhbSAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgIG5hdiA9IHtcbiAgICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIHBsYXRmb3JtOiBuYXZpZ2F0b3IucGxhdGZvcm0sXG4gICAgICBtYXhUb3VjaFBvaW50czogbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IDAsXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgbmF2LnVzZXJBZ2VudCA9IHBhcmFtO1xuICB9IGVsc2UgaWYgKHBhcmFtICYmIHBhcmFtLnVzZXJBZ2VudCkge1xuICAgIG5hdiA9IHtcbiAgICAgIHVzZXJBZ2VudDogcGFyYW0udXNlckFnZW50LFxuICAgICAgcGxhdGZvcm06IHBhcmFtLnBsYXRmb3JtLFxuICAgICAgbWF4VG91Y2hQb2ludHM6IHBhcmFtLm1heFRvdWNoUG9pbnRzIHx8IDAsXG4gICAgfTtcbiAgfVxuXG4gIGxldCB1c2VyQWdlbnQgPSBuYXYudXNlckFnZW50O1xuXG4gIC8vIEZhY2Vib29rIG1vYmlsZSBhcHAncyBpbnRlZ3JhdGVkIGJyb3dzZXIgYWRkcyBhIGJ1bmNoIG9mIHN0cmluZ3MgdGhhdFxuICAvLyBtYXRjaCBldmVyeXRoaW5nLiBTdHJpcCBpdCBvdXQgaWYgaXQgZXhpc3RzLlxuICBsZXQgdG1wID0gdXNlckFnZW50LnNwbGl0KCdbRkJBTicpO1xuICBpZiAodHlwZW9mIHRtcFsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB1c2VyQWdlbnQgPSB0bXBbMF07XG4gIH1cblxuICAvLyBUd2l0dGVyIG1vYmlsZSBhcHAncyBpbnRlZ3JhdGVkIGJyb3dzZXIgb24gaVBhZCBhZGRzIGEgXCJUd2l0dGVyIGZvclxuICAvLyBpUGhvbmVcIiBzdHJpbmcuIFNhbWUgcHJvYmFibHkgaGFwcGVucyBvbiBvdGhlciB0YWJsZXQgcGxhdGZvcm1zLlxuICAvLyBUaGlzIHdpbGwgY29uZnVzZSBkZXRlY3Rpb24gc28gc3RyaXAgaXQgb3V0IGlmIGl0IGV4aXN0cy5cbiAgdG1wID0gdXNlckFnZW50LnNwbGl0KCdUd2l0dGVyJyk7XG4gIGlmICh0eXBlb2YgdG1wWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHVzZXJBZ2VudCA9IHRtcFswXTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoID0gY3JlYXRlTWF0Y2godXNlckFnZW50KTtcblxuICBjb25zdCByZXN1bHQ6IGlzTW9iaWxlUmVzdWx0ID0ge1xuICAgIGFwcGxlOiB7XG4gICAgICBwaG9uZTogbWF0Y2goYXBwbGVJcGhvbmUpICYmICFtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgICAgaXBvZDogbWF0Y2goYXBwbGVJcG9kKSxcbiAgICAgIHRhYmxldDpcbiAgICAgICAgIW1hdGNoKGFwcGxlSXBob25lKSAmJlxuICAgICAgICAobWF0Y2goYXBwbGVUYWJsZXQpIHx8IGlzQXBwbGVUYWJsZXRPbklvczEzKG5hdikpICYmXG4gICAgICAgICFtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgICAgdW5pdmVyc2FsOiBtYXRjaChhcHBsZVVuaXZlcnNhbCksXG4gICAgICBkZXZpY2U6XG4gICAgICAgIChtYXRjaChhcHBsZUlwaG9uZSkgfHxcbiAgICAgICAgICBtYXRjaChhcHBsZUlwb2QpIHx8XG4gICAgICAgICAgbWF0Y2goYXBwbGVUYWJsZXQpIHx8XG4gICAgICAgICAgbWF0Y2goYXBwbGVVbml2ZXJzYWwpIHx8XG4gICAgICAgICAgaXNBcHBsZVRhYmxldE9uSW9zMTMobmF2KSkgJiZcbiAgICAgICAgIW1hdGNoKHdpbmRvd3NQaG9uZSksXG4gICAgfSxcbiAgICBhbWF6b246IHtcbiAgICAgIHBob25lOiBtYXRjaChhbWF6b25QaG9uZSksXG4gICAgICB0YWJsZXQ6ICFtYXRjaChhbWF6b25QaG9uZSkgJiYgbWF0Y2goYW1hem9uVGFibGV0KSxcbiAgICAgIGRldmljZTogbWF0Y2goYW1hem9uUGhvbmUpIHx8IG1hdGNoKGFtYXpvblRhYmxldCksXG4gICAgfSxcbiAgICBhbmRyb2lkOiB7XG4gICAgICBwaG9uZTpcbiAgICAgICAgKCFtYXRjaCh3aW5kb3dzUGhvbmUpICYmIG1hdGNoKGFtYXpvblBob25lKSkgfHxcbiAgICAgICAgKCFtYXRjaCh3aW5kb3dzUGhvbmUpICYmIG1hdGNoKGFuZHJvaWRQaG9uZSkpLFxuICAgICAgdGFibGV0OlxuICAgICAgICAhbWF0Y2god2luZG93c1Bob25lKSAmJlxuICAgICAgICAhbWF0Y2goYW1hem9uUGhvbmUpICYmXG4gICAgICAgICFtYXRjaChhbmRyb2lkUGhvbmUpICYmXG4gICAgICAgIChtYXRjaChhbWF6b25UYWJsZXQpIHx8IG1hdGNoKGFuZHJvaWRUYWJsZXQpKSxcbiAgICAgIGRldmljZTpcbiAgICAgICAgKCFtYXRjaCh3aW5kb3dzUGhvbmUpICYmXG4gICAgICAgICAgKG1hdGNoKGFtYXpvblBob25lKSB8fFxuICAgICAgICAgICAgbWF0Y2goYW1hem9uVGFibGV0KSB8fFxuICAgICAgICAgICAgbWF0Y2goYW5kcm9pZFBob25lKSB8fFxuICAgICAgICAgICAgbWF0Y2goYW5kcm9pZFRhYmxldCkpKSB8fFxuICAgICAgICBtYXRjaCgvXFxib2todHRwXFxiL2kpLFxuICAgIH0sXG4gICAgd2luZG93czoge1xuICAgICAgcGhvbmU6IG1hdGNoKHdpbmRvd3NQaG9uZSksXG4gICAgICB0YWJsZXQ6IG1hdGNoKHdpbmRvd3NUYWJsZXQpLFxuICAgICAgZGV2aWNlOiBtYXRjaCh3aW5kb3dzUGhvbmUpIHx8IG1hdGNoKHdpbmRvd3NUYWJsZXQpLFxuICAgIH0sXG4gICAgb3RoZXI6IHtcbiAgICAgIGJsYWNrYmVycnk6IG1hdGNoKG90aGVyQmxhY2tCZXJyeSksXG4gICAgICBibGFja2JlcnJ5MTA6IG1hdGNoKG90aGVyQmxhY2tCZXJyeTEwKSxcbiAgICAgIG9wZXJhOiBtYXRjaChvdGhlck9wZXJhKSxcbiAgICAgIGZpcmVmb3g6IG1hdGNoKG90aGVyRmlyZWZveCksXG4gICAgICBjaHJvbWU6IG1hdGNoKG90aGVyQ2hyb21lKSxcbiAgICAgIGRldmljZTpcbiAgICAgICAgbWF0Y2gob3RoZXJCbGFja0JlcnJ5KSB8fFxuICAgICAgICBtYXRjaChvdGhlckJsYWNrQmVycnkxMCkgfHxcbiAgICAgICAgbWF0Y2gob3RoZXJPcGVyYSkgfHxcbiAgICAgICAgbWF0Y2gob3RoZXJGaXJlZm94KSB8fFxuICAgICAgICBtYXRjaChvdGhlckNocm9tZSksXG4gICAgfSxcbiAgICBhbnk6IGZhbHNlLFxuICAgIHBob25lOiBmYWxzZSxcbiAgICB0YWJsZXQ6IGZhbHNlLFxuICB9O1xuXG4gIHJlc3VsdC5hbnkgPVxuICAgIHJlc3VsdC5hcHBsZS5kZXZpY2UgfHxcbiAgICByZXN1bHQuYW5kcm9pZC5kZXZpY2UgfHxcbiAgICByZXN1bHQud2luZG93cy5kZXZpY2UgfHxcbiAgICByZXN1bHQub3RoZXIuZGV2aWNlO1xuICAvLyBleGNsdWRlcyAnb3RoZXInIGRldmljZXMgYW5kIGlwb2RzLCB0YXJnZXRpbmcgdG91Y2hzY3JlZW4gcGhvbmVzXG4gIHJlc3VsdC5waG9uZSA9XG4gICAgcmVzdWx0LmFwcGxlLnBob25lIHx8IHJlc3VsdC5hbmRyb2lkLnBob25lIHx8IHJlc3VsdC53aW5kb3dzLnBob25lO1xuICByZXN1bHQudGFibGV0ID1cbiAgICByZXN1bHQuYXBwbGUudGFibGV0IHx8IHJlc3VsdC5hbmRyb2lkLnRhYmxldCB8fCByZXN1bHQud2luZG93cy50YWJsZXQ7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCBpc01vYmlsZUpzIGZyb20gJ2lzbW9iaWxlanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGlzTW9iaWxlQ2FsbCA9IGlzTW9iaWxlSnMuZGVmYXVsdCA/PyBpc01vYmlsZUpzO1xuY29uc3QgaXNNb2JpbGUgPSBpc01vYmlsZUNhbGwoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IpO1xuXG5leHBvcnQgeyBpc01vYmlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNNb2JpbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmVkZXJhdGVkRXZlbnQgfSBmcm9tICcuLi9ldmVudHMvRmVkZXJhdGVkRXZlbnQubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IGlzTW9iaWxlIH0gZnJvbSAnLi4vdXRpbHMvYnJvd3Nlci9pc01vYmlsZS5tanMnO1xuaW1wb3J0IHsgcmVtb3ZlSXRlbXMgfSBmcm9tICcuLi91dGlscy9kYXRhL3JlbW92ZUl0ZW1zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgS0VZX0NPREVfVEFCID0gOTtcbmNvbnN0IERJVl9UT1VDSF9TSVpFID0gMTAwO1xuY29uc3QgRElWX1RPVUNIX1BPU19YID0gMDtcbmNvbnN0IERJVl9UT1VDSF9QT1NfWSA9IDA7XG5jb25zdCBESVZfVE9VQ0hfWklOREVYID0gMjtcbmNvbnN0IERJVl9IT09LX1NJWkUgPSAxO1xuY29uc3QgRElWX0hPT0tfUE9TX1ggPSAtMWUzO1xuY29uc3QgRElWX0hPT0tfUE9TX1kgPSAtMWUzO1xuY29uc3QgRElWX0hPT0tfWklOREVYID0gMjtcbmNsYXNzIEFjY2Vzc2liaWxpdHlTeXN0ZW0ge1xuICAvLyAyZnBzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLXBhcmFtXG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ8V2ViR1BVUmVuZGVyZXJ9IHJlbmRlcmVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBfbW9iaWxlSW5mbyA9IGlzTW9iaWxlKSB7XG4gICAgdGhpcy5fbW9iaWxlSW5mbyA9IF9tb2JpbGVJbmZvO1xuICAgIC8qKiBTZXR0aW5nIHRoaXMgdG8gdHJ1ZSB3aWxsIHZpc3VhbGx5IHNob3cgdGhlIGRpdnMuICovXG4gICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAgIC8qKiBJbnRlcm5hbCB2YXJpYWJsZSwgc2VlIGlzQWN0aXZlIGdldHRlci4gKi9cbiAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIC8qKiBJbnRlcm5hbCB2YXJpYWJsZSwgc2VlIGlzTW9iaWxlQWNjZXNzaWJpbGl0eSBnZXR0ZXIuICovXG4gICAgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gZmFsc2U7XG4gICAgLyoqIEEgc2ltcGxlIHBvb2wgZm9yIHN0b3JpbmcgZGl2cy4gKi9cbiAgICB0aGlzLl9wb29sID0gW107XG4gICAgLyoqIFRoaXMgaXMgYSB0aWNrIHVzZWQgdG8gY2hlY2sgaWYgYW4gb2JqZWN0IGlzIG5vIGxvbmdlciBiZWluZyByZW5kZXJlZC4gKi9cbiAgICB0aGlzLl9yZW5kZXJJZCA9IDA7XG4gICAgLyoqIFRoZSBhcnJheSBvZiBjdXJyZW50bHkgYWN0aXZlIGFjY2Vzc2libGUgaXRlbXMuICovXG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAvKiogQ291bnQgdG8gdGhyb3R0bGUgZGl2IHVwZGF0ZXMgb24gYW5kcm9pZCBkZXZpY2VzLiAqL1xuICAgIHRoaXMuX2FuZHJvaWRVcGRhdGVDb3VudCA9IDA7XG4gICAgLyoqICBUaGUgZnJlcXVlbmN5IHRvIHVwZGF0ZSB0aGUgZGl2IGVsZW1lbnRzLiAqL1xuICAgIHRoaXMuX2FuZHJvaWRVcGRhdGVGcmVxdWVuY3kgPSA1MDA7XG4gICAgdGhpcy5faG9va0RpdiA9IG51bGw7XG4gICAgaWYgKF9tb2JpbGVJbmZvLnRhYmxldCB8fCBfbW9iaWxlSW5mby5waG9uZSkge1xuICAgICAgdGhpcy5fY3JlYXRlVG91Y2hIb29rKCk7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gYCR7RElWX1RPVUNIX1NJWkV9cHhgO1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHtESVZfVE9VQ0hfU0laRX1weGA7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi5zdHlsZS50b3AgPSBgJHtESVZfVE9VQ0hfUE9TX1h9cHhgO1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0gYCR7RElWX1RPVUNIX1BPU19ZfXB4YDtcbiAgICBkaXYuc3R5bGUuekluZGV4ID0gRElWX1RPVUNIX1pJTkRFWC50b1N0cmluZygpO1xuICAgIHRoaXMuX2RpdiA9IGRpdjtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuX29uS2V5RG93biA9IHRoaXMuX29uS2V5RG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICB9XG4gIC8qKlxuICAgKiBWYWx1ZSBvZiBgdHJ1ZWAgaWYgYWNjZXNzaWJpbGl0eSBpcyBjdXJyZW50bHkgYWN0aXZlIGFuZCBhY2Nlc3NpYmlsaXR5IGxheWVycyBhcmUgc2hvd2luZy5cbiAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQWN0aXZlO1xuICB9XG4gIC8qKlxuICAgKiBWYWx1ZSBvZiBgdHJ1ZWAgaWYgYWNjZXNzaWJpbGl0eSBpcyBlbmFibGVkIGZvciB0b3VjaCBkZXZpY2VzLlxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBpc01vYmlsZUFjY2Vzc2liaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzTW9iaWxlQWNjZXNzaWJpbGl0eTtcbiAgfVxuICBnZXQgaG9va0RpdigpIHtcbiAgICByZXR1cm4gdGhpcy5faG9va0RpdjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgdG91Y2ggaG9va3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlVG91Y2hIb29rKCkge1xuICAgIGNvbnN0IGhvb2tEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGhvb2tEaXYuc3R5bGUud2lkdGggPSBgJHtESVZfSE9PS19TSVpFfXB4YDtcbiAgICBob29rRGl2LnN0eWxlLmhlaWdodCA9IGAke0RJVl9IT09LX1NJWkV9cHhgO1xuICAgIGhvb2tEaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgaG9va0Rpdi5zdHlsZS50b3AgPSBgJHtESVZfSE9PS19QT1NfWH1weGA7XG4gICAgaG9va0Rpdi5zdHlsZS5sZWZ0ID0gYCR7RElWX0hPT0tfUE9TX1l9cHhgO1xuICAgIGhvb2tEaXYuc3R5bGUuekluZGV4ID0gRElWX0hPT0tfWklOREVYLnRvU3RyaW5nKCk7XG4gICAgaG9va0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNGRjAwMDBcIjtcbiAgICBob29rRGl2LnRpdGxlID0gXCJzZWxlY3QgdG8gZW5hYmxlIGFjY2Vzc2liaWxpdHkgZm9yIHRoaXMgY29udGVudFwiO1xuICAgIGhvb2tEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2lzTW9iaWxlQWNjZXNzaWJpbGl0eSA9IHRydWU7XG4gICAgICB0aGlzLl9hY3RpdmF0ZSgpO1xuICAgICAgdGhpcy5fZGVzdHJveVRvdWNoSG9vaygpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaG9va0Rpdik7XG4gICAgdGhpcy5faG9va0RpdiA9IGhvb2tEaXY7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSB0b3VjaCBob29rcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXN0cm95VG91Y2hIb29rKCkge1xuICAgIGlmICghdGhpcy5faG9va0Rpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuX2hvb2tEaXYpO1xuICAgIHRoaXMuX2hvb2tEaXYgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBBY3RpdmF0aW5nIHdpbGwgY2F1c2UgdGhlIEFjY2Vzc2liaWxpdHkgbGF5ZXIgdG8gYmUgc2hvd24uXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIHByZXNzZXMgdGhlIHRhYiBrZXkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWN0aXZhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzQWN0aXZlID0gdHJ1ZTtcbiAgICBnbG9iYWxUaGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUsIHRydWUpO1xuICAgIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XG4gICAgdGhpcy5fcmVuZGVyZXIucnVubmVycy5wb3N0cmVuZGVyLmFkZCh0aGlzKTtcbiAgICB0aGlzLl9yZW5kZXJlci52aWV3LmNhbnZhcy5wYXJlbnROb2RlPy5hcHBlbmRDaGlsZCh0aGlzLl9kaXYpO1xuICB9XG4gIC8qKlxuICAgKiBEZWFjdGl2YXRpbmcgd2lsbCBjYXVzZSB0aGUgQWNjZXNzaWJpbGl0eSBsYXllciB0byBiZSBoaWRkZW4uXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIG1vdmVzIHRoZSBtb3VzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWFjdGl2YXRlKCkge1xuICAgIGlmICghdGhpcy5faXNBY3RpdmUgfHwgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJ1bm5lcnMucG9zdHJlbmRlci5yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5fZGl2LnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMuX2Rpdik7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgcmVjdXJzaXZlIGZ1bmN0aW9uIHdpbGwgcnVuIHRocm91Z2ggdGhlIHNjZW5lIGdyYXBoIGFuZCBhZGQgYW55IG5ldyBhY2Nlc3NpYmxlIG9iamVjdHMgdG8gdGhlIERPTSBsYXllci5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBDb250YWluZXIgdG8gY2hlY2suXG4gICAqL1xuICBfdXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoY29udGFpbmVyKSB7XG4gICAgaWYgKCFjb250YWluZXIudmlzaWJsZSB8fCAhY29udGFpbmVyLmFjY2Vzc2libGVDaGlsZHJlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLmFjY2Vzc2libGUgJiYgY29udGFpbmVyLmlzSW50ZXJhY3RpdmUoKSkge1xuICAgICAgaWYgKCFjb250YWluZXIuX2FjY2Vzc2libGVBY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fYWRkQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lci5fcmVuZGVySWQgPSB0aGlzLl9yZW5kZXJJZDtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFjY2Vzc2libGVPYmplY3RzKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJ1bm5lciBpbml0IGNhbGxlZCwgdmlldyBpcyBhdmFpbGFibGUgYXQgdGhpcyBwb2ludC5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnM/LmRlYnVnID8/IHRoaXMuZGVidWc7XG4gICAgdGhpcy5fcmVuZGVyZXIucnVubmVycy5wb3N0cmVuZGVyLnJlbW92ZSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUnVubmVyIHBvc3RyZW5kZXIgd2FzIGNhbGxlZCwgZW5zdXJlIHRoYXQgYWxsIGRpdnMgYXJlIG1hcHBlZCBjb3JyZWN0bHkgdG8gdGhlaXIgQ29udGFpbmVycy5cbiAgICogT25seSBmaXJlcyB3aGlsZSBhY3RpdmUuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHBvc3RyZW5kZXIoKSB7XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKHRoaXMuX21vYmlsZUluZm8uYW5kcm9pZC5kZXZpY2UgJiYgbm93IDwgdGhpcy5fYW5kcm9pZFVwZGF0ZUNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FuZHJvaWRVcGRhdGVDb3VudCA9IG5vdyArIHRoaXMuX2FuZHJvaWRVcGRhdGVGcmVxdWVuY3k7XG4gICAgaWYgKCF0aGlzLl9yZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbiB8fCAhdGhpcy5fcmVuZGVyZXIudmlldy5jYW52YXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlQWNjZXNzaWJsZU9iamVjdHModGhpcy5fcmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkKTtcbiAgICB9XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLl9yZW5kZXJlci52aWV3LmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7IHdpZHRoOiB2aWV3V2lkdGgsIGhlaWdodDogdmlld0hlaWdodCwgcmVzb2x1dGlvbiB9ID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgY29uc3Qgc3ggPSB3aWR0aCAvIHZpZXdXaWR0aCAqIHJlc29sdXRpb247XG4gICAgY29uc3Qgc3kgPSBoZWlnaHQgLyB2aWV3SGVpZ2h0ICogcmVzb2x1dGlvbjtcbiAgICBsZXQgZGl2ID0gdGhpcy5fZGl2O1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0gYCR7eH1weGA7XG4gICAgZGl2LnN0eWxlLnRvcCA9IGAke3l9cHhgO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IGAke3ZpZXdXaWR0aH1weGA7XG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IGAke3ZpZXdIZWlnaHR9cHhgO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQuX3JlbmRlcklkICE9PSB0aGlzLl9yZW5kZXJJZCkge1xuICAgICAgICBjaGlsZC5fYWNjZXNzaWJsZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICByZW1vdmVJdGVtcyh0aGlzLl9jaGlsZHJlbiwgaSwgMSk7XG4gICAgICAgIHRoaXMuX2Rpdi5yZW1vdmVDaGlsZChjaGlsZC5fYWNjZXNzaWJsZURpdik7XG4gICAgICAgIHRoaXMuX3Bvb2wucHVzaChjaGlsZC5fYWNjZXNzaWJsZURpdik7XG4gICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlRGl2ID0gbnVsbDtcbiAgICAgICAgaS0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2ID0gY2hpbGQuX2FjY2Vzc2libGVEaXY7XG4gICAgICAgIGxldCBoaXRBcmVhID0gY2hpbGQuaGl0QXJlYTtcbiAgICAgICAgY29uc3Qgd3QgPSBjaGlsZC53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgaWYgKGNoaWxkLmhpdEFyZWEpIHtcbiAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9IGAkeyh3dC50eCArIGhpdEFyZWEueCAqIHd0LmEpICogc3h9cHhgO1xuICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSBgJHsod3QudHkgKyBoaXRBcmVhLnkgKiB3dC5kKSAqIHN5fXB4YDtcbiAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBgJHtoaXRBcmVhLndpZHRoICogd3QuYSAqIHN4fXB4YDtcbiAgICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7aGl0QXJlYS5oZWlnaHQgKiB3dC5kICogc3l9cHhgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpdEFyZWEgPSBjaGlsZC5nZXRCb3VuZHMoKS5yZWN0YW5nbGU7XG4gICAgICAgICAgdGhpcy5fY2FwSGl0QXJlYShoaXRBcmVhKTtcbiAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9IGAke2hpdEFyZWEueCAqIHN4fXB4YDtcbiAgICAgICAgICBkaXYuc3R5bGUudG9wID0gYCR7aGl0QXJlYS55ICogc3l9cHhgO1xuICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGAke2hpdEFyZWEud2lkdGggKiBzeH1weGA7XG4gICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGAke2hpdEFyZWEuaGVpZ2h0ICogc3l9cHhgO1xuICAgICAgICAgIGlmIChkaXYudGl0bGUgIT09IGNoaWxkLmFjY2Vzc2libGVUaXRsZSAmJiBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpdi50aXRsZSA9IGNoaWxkLmFjY2Vzc2libGVUaXRsZSB8fCBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGl2LmdldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIikgIT09IGNoaWxkLmFjY2Vzc2libGVIaW50ICYmIGNoaWxkLmFjY2Vzc2libGVIaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBjaGlsZC5hY2Nlc3NpYmxlSGludCB8fCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkLmFjY2Vzc2libGVUaXRsZSAhPT0gZGl2LnRpdGxlIHx8IGNoaWxkLnRhYkluZGV4ICE9PSBkaXYudGFiSW5kZXgpIHtcbiAgICAgICAgICBkaXYudGl0bGUgPSBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUgfHwgXCJcIjtcbiAgICAgICAgICBkaXYudGFiSW5kZXggPSBjaGlsZC50YWJJbmRleDtcbiAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGVidWdIVE1MKGRpdik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcklkKys7XG4gIH1cbiAgLyoqXG4gICAqIHByaXZhdGUgZnVuY3Rpb24gdGhhdCB3aWxsIHZpc3VhbGx5IGFkZCB0aGUgaW5mb3JtYXRpb24gdG8gdGhlXG4gICAqIGFjY2Vzc2liaWxpdHkgZGl2XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpdiAtXG4gICAqL1xuICBfdXBkYXRlRGVidWdIVE1MKGRpdikge1xuICAgIGRpdi5pbm5lckhUTUwgPSBgdHlwZTogJHtkaXYudHlwZX08L2JyPiB0aXRsZSA6ICR7ZGl2LnRpdGxlfTwvYnI+IHRhYkluZGV4OiAke2Rpdi50YWJJbmRleH1gO1xuICB9XG4gIC8qKlxuICAgKiBBZGp1c3QgdGhlIGhpdCBhcmVhIGJhc2VkIG9uIHRoZSBib3VuZHMgb2YgYSBkaXNwbGF5IG9iamVjdFxuICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gaGl0QXJlYSAtIEJvdW5kcyBvZiB0aGUgY2hpbGRcbiAgICovXG4gIF9jYXBIaXRBcmVhKGhpdEFyZWEpIHtcbiAgICBpZiAoaGl0QXJlYS54IDwgMCkge1xuICAgICAgaGl0QXJlYS53aWR0aCArPSBoaXRBcmVhLng7XG4gICAgICBoaXRBcmVhLnggPSAwO1xuICAgIH1cbiAgICBpZiAoaGl0QXJlYS55IDwgMCkge1xuICAgICAgaGl0QXJlYS5oZWlnaHQgKz0gaGl0QXJlYS55O1xuICAgICAgaGl0QXJlYS55ID0gMDtcbiAgICB9XG4gICAgY29uc3QgeyB3aWR0aDogdmlld1dpZHRoLCBoZWlnaHQ6IHZpZXdIZWlnaHQgfSA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGlmIChoaXRBcmVhLnggKyBoaXRBcmVhLndpZHRoID4gdmlld1dpZHRoKSB7XG4gICAgICBoaXRBcmVhLndpZHRoID0gdmlld1dpZHRoIC0gaGl0QXJlYS54O1xuICAgIH1cbiAgICBpZiAoaGl0QXJlYS55ICsgaGl0QXJlYS5oZWlnaHQgPiB2aWV3SGVpZ2h0KSB7XG4gICAgICBoaXRBcmVhLmhlaWdodCA9IHZpZXdIZWlnaHQgLSBoaXRBcmVhLnk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgQ29udGFpbmVyIHRvIHRoZSBhY2Nlc3NpYmlsaXR5IG1hbmFnZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjaGlsZCB0byBtYWtlIGFjY2Vzc2libGUuXG4gICAqL1xuICBfYWRkQ2hpbGQoY29udGFpbmVyKSB7XG4gICAgbGV0IGRpdiA9IHRoaXMuX3Bvb2wucG9wKCk7XG4gICAgaWYgKCFkaXYpIHtcbiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBkaXYuc3R5bGUud2lkdGggPSBgJHtESVZfVE9VQ0hfU0laRX1weGA7XG4gICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7RElWX1RPVUNIX1NJWkV9cHhgO1xuICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZGVidWcgPyBcInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiIDogXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgZGl2LnN0eWxlLnpJbmRleCA9IERJVl9UT1VDSF9aSU5ERVgudG9TdHJpbmcoKTtcbiAgICAgIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9IFwibm9uZVwiO1xuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImNocm9tZVwiKSkge1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwib2ZmXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9ydjouKkdlY2tvXFwvLykpIHtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtcmVsZXZhbnRcIiwgXCJhZGRpdGlvbnNcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1yZWxldmFudFwiLCBcInRleHRcIik7XG4gICAgICB9XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuX29uRm9jdXNPdXQuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGRpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gY29udGFpbmVyLmFjY2Vzc2libGVQb2ludGVyRXZlbnRzO1xuICAgIGRpdi50eXBlID0gY29udGFpbmVyLmFjY2Vzc2libGVUeXBlO1xuICAgIGlmIChjb250YWluZXIuYWNjZXNzaWJsZVRpdGxlICYmIGNvbnRhaW5lci5hY2Nlc3NpYmxlVGl0bGUgIT09IG51bGwpIHtcbiAgICAgIGRpdi50aXRsZSA9IGNvbnRhaW5lci5hY2Nlc3NpYmxlVGl0bGU7XG4gICAgfSBlbHNlIGlmICghY29udGFpbmVyLmFjY2Vzc2libGVIaW50IHx8IGNvbnRhaW5lci5hY2Nlc3NpYmxlSGludCA9PT0gbnVsbCkge1xuICAgICAgZGl2LnRpdGxlID0gYGNvbnRhaW5lciAke2NvbnRhaW5lci50YWJJbmRleH1gO1xuICAgIH1cbiAgICBpZiAoY29udGFpbmVyLmFjY2Vzc2libGVIaW50ICYmIGNvbnRhaW5lci5hY2Nlc3NpYmxlSGludCAhPT0gbnVsbCkge1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgY29udGFpbmVyLmFjY2Vzc2libGVIaW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURlYnVnSFRNTChkaXYpO1xuICAgIH1cbiAgICBjb250YWluZXIuX2FjY2Vzc2libGVBY3RpdmUgPSB0cnVlO1xuICAgIGNvbnRhaW5lci5fYWNjZXNzaWJsZURpdiA9IGRpdjtcbiAgICBkaXYuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY29udGFpbmVyKTtcbiAgICB0aGlzLl9kaXYuYXBwZW5kQ2hpbGQoY29udGFpbmVyLl9hY2Nlc3NpYmxlRGl2KTtcbiAgICBjb250YWluZXIuX2FjY2Vzc2libGVEaXYudGFiSW5kZXggPSBjb250YWluZXIudGFiSW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIERpc3BhdGNoIGV2ZW50cyB3aXRoIHRoZSBFdmVudFN5c3RlbS5cbiAgICogQHBhcmFtIGVcbiAgICogQHBhcmFtIHR5cGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXNwYXRjaEV2ZW50KGUsIHR5cGUpIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lcjogdGFyZ2V0IH0gPSBlLnRhcmdldDtcbiAgICBjb25zdCBib3VuZGFyeSA9IHRoaXMuX3JlbmRlcmVyLmV2ZW50cy5yb290Qm91bmRhcnk7XG4gICAgY29uc3QgZXZlbnQgPSBPYmplY3QuYXNzaWduKG5ldyBGZWRlcmF0ZWRFdmVudChib3VuZGFyeSksIHsgdGFyZ2V0IH0pO1xuICAgIGJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLl9yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgdHlwZS5mb3JFYWNoKCh0eXBlMikgPT4gYm91bmRhcnkuZGlzcGF0Y2hFdmVudChldmVudCwgdHlwZTIpKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgZGl2IGJ1dHRvbiBwcmVzcyB0byBwaXhpJ3MgRXZlbnRTeXN0ZW0gKGNsaWNrKVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBUaGUgY2xpY2sgZXZlbnQuXG4gICAqL1xuICBfb25DbGljayhlKSB7XG4gICAgdGhpcy5fZGlzcGF0Y2hFdmVudChlLCBbXCJjbGlja1wiLCBcInBvaW50ZXJ0YXBcIiwgXCJ0YXBcIl0pO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSBkaXYgZm9jdXMgZXZlbnRzIHRvIHBpeGkncyBFdmVudFN5c3RlbSAobW91c2VvdmVyKVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGUgLSBUaGUgZm9jdXMgZXZlbnQuXG4gICAqL1xuICBfb25Gb2N1cyhlKSB7XG4gICAgaWYgKCFlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIikpIHtcbiAgICAgIGUudGFyZ2V0LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcImFzc2VydGl2ZVwiKTtcbiAgICB9XG4gICAgdGhpcy5fZGlzcGF0Y2hFdmVudChlLCBbXCJtb3VzZW92ZXJcIl0pO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSBkaXYgZm9jdXMgZXZlbnRzIHRvIHBpeGkncyBFdmVudFN5c3RlbSAobW91c2VvdXQpXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Rm9jdXNFdmVudH0gZSAtIFRoZSBmb2N1c291dCBldmVudC5cbiAgICovXG4gIF9vbkZvY3VzT3V0KGUpIHtcbiAgICBpZiAoIWUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiKSkge1xuICAgICAgZS50YXJnZXQuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIpO1xuICAgIH1cbiAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGUsIFtcIm1vdXNlb3V0XCJdKTtcbiAgfVxuICAvKipcbiAgICogSXMgY2FsbGVkIHdoZW4gYSBrZXkgaXMgcHJlc3NlZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUgLSBUaGUga2V5ZG93biBldmVudC5cbiAgICovXG4gIF9vbktleURvd24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgIT09IEtFWV9DT0RFX1RBQikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgYWNyb3NzIHRoZSByZW5kZXJlciBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIFRoZSBtb3VzZSBldmVudC5cbiAgICovXG4gIF9vbk1vdXNlTW92ZShlKSB7XG4gICAgaWYgKGUubW92ZW1lbnRYID09PSAwICYmIGUubW92ZW1lbnRZID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RlYWN0aXZhdGUoKTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIGFjY2Vzc2liaWxpdHkgbWFuYWdlciAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2Rlc3Ryb3lUb3VjaEhvb2soKTtcbiAgICB0aGlzLl9kaXYgPSBudWxsO1xuICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24pO1xuICAgIHRoaXMuX3Bvb2wgPSBudWxsO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5BY2Nlc3NpYmlsaXR5U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJhY2Nlc3NpYmlsaXR5XCJcbn07XG5cbmV4cG9ydCB7IEFjY2Vzc2liaWxpdHlTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjY2Vzc2liaWxpdHlTeXN0ZW0ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBhY2Nlc3NpYmlsaXR5VGFyZ2V0ID0ge1xuICAvKipcbiAgICogRmxhZyBmb3IgaWYgdGhlIG9iamVjdCBpcyBhY2Nlc3NpYmxlLiBJZiB0cnVlIEFjY2Vzc2liaWxpdHlNYW5hZ2VyIHdpbGwgb3ZlcmxheSBhXG4gICAqIHNoYWRvdyBkaXYgd2l0aCBhdHRyaWJ1dGVzIHNldFxuICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgYWNjZXNzaWJsZTogZmFsc2UsXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aXRsZSBhdHRyaWJ1dGUgb2YgdGhlIHNoYWRvdyBkaXZcbiAgICogSWYgYWNjZXNzaWJsZVRpdGxlIEFORCBhY2Nlc3NpYmxlSGludCBoYXMgbm90IGJlZW4gdGhpcyB3aWxsIGRlZmF1bHQgdG8gJ2NvbnRhaW5lciBbdGFiSW5kZXhdJ1xuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBhY2Nlc3NpYmxlVGl0bGU6IG51bGwsXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhcmlhLWxhYmVsIGF0dHJpYnV0ZSBvZiB0aGUgc2hhZG93IGRpdlxuICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBhY2Nlc3NpYmxlSGludDogbnVsbCxcbiAgLyoqXG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQHRvZG8gTmVlZHMgZG9jcy5cbiAgICovXG4gIHRhYkluZGV4OiAwLFxuICAvKipcbiAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hY2Nlc3NpYmxlQWN0aXZlOiBmYWxzZSxcbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWNjZXNzaWJsZURpdjogbnVsbCxcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHR5cGUgb2YgZGl2IHRoZSBhY2Nlc3NpYmxlIGxheWVyIGlzLiBTY3JlZW4gcmVhZGVycyB0cmVhdCB0aGUgZWxlbWVudCBkaWZmZXJlbnRseVxuICAgKiBkZXBlbmRpbmcgb24gdGhpcyB0eXBlLiBEZWZhdWx0cyB0byBidXR0b24uXG4gICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgJ2J1dHRvbidcbiAgICovXG4gIGFjY2Vzc2libGVUeXBlOiBcImJ1dHRvblwiLFxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgcG9pbnRlci1ldmVudHMgdGhlIGFjY2Vzc2libGUgZGl2IHdpbGwgdXNlXG4gICAqIERlZmF1bHRzIHRvIGF1dG8uXG4gICAqIEB0eXBlIHtQb2ludGVyRXZlbnRzfVxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCAnYXV0bydcbiAgICovXG4gIGFjY2Vzc2libGVQb2ludGVyRXZlbnRzOiBcImF1dG9cIixcbiAgLyoqXG4gICAqIFNldHRpbmcgdG8gZmFsc2Ugd2lsbCBwcmV2ZW50IGFueSBjaGlsZHJlbiBpbnNpZGUgdGhpcyBjb250YWluZXIgdG9cbiAgICogYmUgYWNjZXNzaWJsZS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgYWNjZXNzaWJsZUNoaWxkcmVuOiB0cnVlLFxuICAvKipcbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlcklkOiAtMVxufTtcblxuZXhwb3J0IHsgYWNjZXNzaWJpbGl0eVRhcmdldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzaWJpbGl0eVRhcmdldC5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuLi9zY2VuZS9jb250YWluZXIvQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5U3lzdGVtIH0gZnJvbSAnLi9BY2Nlc3NpYmlsaXR5U3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBhY2Nlc3NpYmlsaXR5VGFyZ2V0IH0gZnJvbSAnLi9hY2Nlc3NpYmlsaXR5VGFyZ2V0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoQWNjZXNzaWJpbGl0eVN5c3RlbSk7XG5Db250YWluZXIubWl4aW4oYWNjZXNzaWJpbGl0eVRhcmdldCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiIsImltcG9ydCB7IFVQREFURV9QUklPUklUWSB9IGZyb20gJy4uL3RpY2tlci9jb25zdC5tanMnO1xuaW1wb3J0IHsgVGlja2VyIH0gZnJvbSAnLi4vdGlja2VyL1RpY2tlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEV2ZW50c1RpY2tlckNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIFRoZSBmcmVxdWVuY3kgdGhhdCBmYWtlIGV2ZW50cyB3aWxsIGJlIGZpcmVkLiAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kgPSAxMDtcbiAgICB0aGlzLl9kZWx0YVRpbWUgPSAwO1xuICAgIHRoaXMuX2RpZE1vdmUgPSBmYWxzZTtcbiAgICB0aGlzLl90aWNrZXJBZGRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhdXNlVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGV2ZW50IHRpY2tlci5cbiAgICogQHBhcmFtIGV2ZW50cyAtIFRoZSBldmVudCBzeXN0ZW0uXG4gICAqL1xuICBpbml0KGV2ZW50cykge1xuICAgIHRoaXMucmVtb3ZlVGlja2VyTGlzdGVuZXIoKTtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5ID0gMTA7XG4gICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcbiAgICB0aGlzLl9kaWRNb3ZlID0gZmFsc2U7XG4gICAgdGhpcy5fdGlja2VyQWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXVzZVVwZGF0ZSA9IHRydWU7XG4gIH1cbiAgLyoqIFdoZXRoZXIgdG8gcGF1c2UgdGhlIHVwZGF0ZSBjaGVja3Mgb3Igbm90LiAqL1xuICBnZXQgcGF1c2VVcGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlVXBkYXRlO1xuICB9XG4gIHNldCBwYXVzZVVwZGF0ZShwYXVzZWQpIHtcbiAgICB0aGlzLl9wYXVzZVVwZGF0ZSA9IHBhdXNlZDtcbiAgfVxuICAvKiogQWRkcyB0aGUgdGlja2VyIGxpc3RlbmVyLiAqL1xuICBhZGRUaWNrZXJMaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy5fdGlja2VyQWRkZWQgfHwgIXRoaXMuZG9tRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBUaWNrZXIuc3lzdGVtLmFkZCh0aGlzLl90aWNrZXJVcGRhdGUsIHRoaXMsIFVQREFURV9QUklPUklUWS5JTlRFUkFDVElPTik7XG4gICAgdGhpcy5fdGlja2VyQWRkZWQgPSB0cnVlO1xuICB9XG4gIC8qKiBSZW1vdmVzIHRoZSB0aWNrZXIgbGlzdGVuZXIuICovXG4gIHJlbW92ZVRpY2tlckxpc3RlbmVyKCkge1xuICAgIGlmICghdGhpcy5fdGlja2VyQWRkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgVGlja2VyLnN5c3RlbS5yZW1vdmUodGhpcy5fdGlja2VyVXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLl90aWNrZXJBZGRlZCA9IGZhbHNlO1xuICB9XG4gIC8qKiBTZXRzIGZsYWcgdG8gbm90IGZpcmUgZXh0cmEgZXZlbnRzIHdoZW4gdGhlIHVzZXIgaGFzIGFscmVhZHkgbW92ZWQgdGhlcmUgbW91c2UgKi9cbiAgcG9pbnRlck1vdmVkKCkge1xuICAgIHRoaXMuX2RpZE1vdmUgPSB0cnVlO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiBpbnRlcmFjdGl2ZSBvYmplY3RzLiAqL1xuICBfdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5kb21FbGVtZW50IHx8IHRoaXMuX3BhdXNlVXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWRNb3ZlKSB7XG4gICAgICB0aGlzLl9kaWRNb3ZlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb3RQb2ludGVyRXZlbnQgPSB0aGlzLmV2ZW50c1tcIl9yb290UG9pbnRlckV2ZW50XCJdO1xuICAgIGlmICh0aGlzLmV2ZW50cy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIHJvb3RQb2ludGVyRXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBnbG9iYWxUaGlzLmRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IFBvaW50ZXJFdmVudChcInBvaW50ZXJtb3ZlXCIsIHtcbiAgICAgIGNsaWVudFg6IHJvb3RQb2ludGVyRXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IHJvb3RQb2ludGVyRXZlbnQuY2xpZW50WSxcbiAgICAgIHBvaW50ZXJUeXBlOiByb290UG9pbnRlckV2ZW50LnBvaW50ZXJUeXBlLFxuICAgICAgcG9pbnRlcklkOiByb290UG9pbnRlckV2ZW50LnBvaW50ZXJJZFxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgaW50ZXJhY3RpdmUgb2JqZWN0cyBpZiBhdCBsZWFzdCB7QGxpbmsgaW50ZXJhY3Rpb25GcmVxdWVuY3l9XG4gICAqIG1pbGxpc2Vjb25kcyBoYXZlIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBpbnZvY2F0aW9uLlxuICAgKlxuICAgKiBJbnZva2VkIGJ5IGEgdGhyb3R0bGVkIHRpY2tlciB1cGRhdGUgZnJvbSB7QGxpbmsgVGlja2VyLnN5c3RlbX0uXG4gICAqIEBwYXJhbSB0aWNrZXIgLSBUaGUgdGhyb3R0bGVkIHRpY2tlci5cbiAgICovXG4gIF90aWNrZXJVcGRhdGUodGlja2VyKSB7XG4gICAgdGhpcy5fZGVsdGFUaW1lICs9IHRpY2tlci5kZWx0YVRpbWU7XG4gICAgaWYgKHRoaXMuX2RlbHRhVGltZSA8IHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxufVxuY29uc3QgRXZlbnRzVGlja2VyID0gbmV3IEV2ZW50c1RpY2tlckNsYXNzKCk7XG5cbmV4cG9ydCB7IEV2ZW50c1RpY2tlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRUaWNrZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9tYXRocy9wb2ludC9Qb2ludC5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZEV2ZW50Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRmVkZXJhdGVkTW91c2VFdmVudCBleHRlbmRzIEZlZGVyYXRlZEV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKiogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZSBldmVudCByZWxhdGl2ZSB0byB0aGUgY2FudmFzLiAqL1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IFBvaW50KCk7XG4gICAgLyoqIFRoZSBtb3ZlbWVudCBpbiB0aGlzIHBvaW50ZXIgcmVsYXRpdmUgdG8gdGhlIGxhc3QgYG1vdXNlbW92ZWAgZXZlbnQuICovXG4gICAgdGhpcy5tb3ZlbWVudCA9IG5ldyBQb2ludCgpO1xuICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIHcuci50LiB0YXJnZXQgQ29udGFpbmVyIGluIHdvcmxkIHNwYWNlLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYXQgdGhlIG1vbWVudC4gKi9cbiAgICB0aGlzLm9mZnNldCA9IG5ldyBQb2ludCgpO1xuICAgIC8qKiBUaGUgcG9pbnRlciBjb29yZGluYXRlcyBpbiB3b3JsZCBzcGFjZS4gKi9cbiAgICB0aGlzLmdsb2JhbCA9IG5ldyBQb2ludCgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXJlcidzIHtAbGluayBSZW5kZXJlci5zY3JlZW4gc2NyZWVufS4gVGhpcyBoYXMgc2xpZ2h0bHlcbiAgICAgKiBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gbmF0aXZlIFBvaW50ZXJFdmVudCBzY3JlZW5YL3NjcmVlblkuXG4gICAgICovXG4gICAgdGhpcy5zY3JlZW4gPSBuZXcgUG9pbnQoKTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBjbGllbnRYKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGNsaWVudFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Lnk7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWFzIGZvciB7QGxpbmsgRmVkZXJhdGVkTW91c2VFdmVudC5jbGllbnRYIHRoaXMuY2xpZW50WH0uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50WDtcbiAgfVxuICAvKipcbiAgICogQWxpYXMgZm9yIHtAbGluayBGZWRlcmF0ZWRNb3VzZUV2ZW50LmNsaWVudFkgdGhpcy5jbGllbnRZfS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRZO1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG1vdmVtZW50WCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG1vdmVtZW50WSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC55O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IG9mZnNldFgoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0Lng7XG4gIH1cbiAgLyoqIEByZWFkb25seSAqL1xuICBnZXQgb2Zmc2V0WSgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQueTtcbiAgfVxuICAvKiogQHJlYWRvbmx5ICovXG4gIGdldCBnbG9iYWxYKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbC54O1xuICB9XG4gIC8qKiBAcmVhZG9ubHkgKi9cbiAgZ2V0IGdsb2JhbFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsLnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXJlcidzIHNjcmVlbi4gQWxpYXMgZm9yIHtAY29kZSBzY3JlZW4ueH0uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjcmVlblgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLng7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb2ludGVyIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXJlcidzIHNjcmVlbi4gQWxpYXMgZm9yIHtAY29kZSBzY3JlZW4ueX0uXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjcmVlblkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBzcGVjaWZpZWQgY29udGFpbmVyIGZvciB0aGlzIEludGVyYWN0aW9uRGF0YVxuICAgKiBAcGFyYW0ge0NvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIENvbnRhaW5lciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSBsb2NhbFxuICAgKiAgY29vcmRzIG9mZlxuICAgKiBAcGFyYW0ge1BvaW50RGF0YX0gcG9pbnQgLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsIChvdGhlcndpc2VcbiAgICogIHdpbGwgY3JlYXRlIGEgbmV3IHBvaW50KVxuICAgKiBAcGFyYW0ge1BvaW50RGF0YX0gZ2xvYmFsUG9zIC0gQSBQb2ludCBvYmplY3QgY29udGFpbmluZyB5b3VyIGN1c3RvbSBnbG9iYWwgY29vcmRzLCBvcHRpb25hbFxuICAgKiAgKG90aGVyd2lzZSB3aWxsIHVzZSB0aGUgY3VycmVudCBnbG9iYWwgY29vcmRzKVxuICAgKiBAcmV0dXJucyAtIEEgcG9pbnQgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIEludGVyYWN0aW9uRGF0YSBwb3NpdGlvbiByZWxhdGl2ZVxuICAgKiAgdG8gdGhlIENvbnRhaW5lclxuICAgKi9cbiAgZ2V0TG9jYWxQb3NpdGlvbihjb250YWluZXIsIHBvaW50LCBnbG9iYWxQb3MpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShnbG9iYWxQb3MgfHwgdGhpcy5nbG9iYWwsIHBvaW50KTtcbiAgfVxuICAvKipcbiAgICogV2hldGhlciB0aGUgbW9kaWZpZXIga2V5IHdhcyBwcmVzc2VkIHdoZW4gdGhpcyBldmVudCBuYXRpdmVseSBvY2N1cnJlZC5cbiAgICogQHBhcmFtIGtleSAtIFRoZSBtb2RpZmllciBrZXkuXG4gICAqL1xuICBnZXRNb2RpZmllclN0YXRlKGtleSkge1xuICAgIHJldHVybiBcImdldE1vZGlmaWVyU3RhdGVcIiBpbiB0aGlzLm5hdGl2ZUV2ZW50ICYmIHRoaXMubmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBOb3Qgc3VwcG9ydGVkLlxuICAgKiBAcGFyYW0gX3R5cGVBcmdcbiAgICogQHBhcmFtIF9jYW5CdWJibGVBcmdcbiAgICogQHBhcmFtIF9jYW5jZWxhYmxlQXJnXG4gICAqIEBwYXJhbSBfdmlld0FyZ1xuICAgKiBAcGFyYW0gX2RldGFpbEFyZ1xuICAgKiBAcGFyYW0gX3NjcmVlblhBcmdcbiAgICogQHBhcmFtIF9zY3JlZW5ZQXJnXG4gICAqIEBwYXJhbSBfY2xpZW50WEFyZ1xuICAgKiBAcGFyYW0gX2NsaWVudFlBcmdcbiAgICogQHBhcmFtIF9jdHJsS2V5QXJnXG4gICAqIEBwYXJhbSBfYWx0S2V5QXJnXG4gICAqIEBwYXJhbSBfc2hpZnRLZXlBcmdcbiAgICogQHBhcmFtIF9tZXRhS2V5QXJnXG4gICAqIEBwYXJhbSBfYnV0dG9uQXJnXG4gICAqIEBwYXJhbSBfcmVsYXRlZFRhcmdldEFyZ1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA3LjAuMFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgaW5pdE1vdXNlRXZlbnQoX3R5cGVBcmcsIF9jYW5CdWJibGVBcmcsIF9jYW5jZWxhYmxlQXJnLCBfdmlld0FyZywgX2RldGFpbEFyZywgX3NjcmVlblhBcmcsIF9zY3JlZW5ZQXJnLCBfY2xpZW50WEFyZywgX2NsaWVudFlBcmcsIF9jdHJsS2V5QXJnLCBfYWx0S2V5QXJnLCBfc2hpZnRLZXlBcmcsIF9tZXRhS2V5QXJnLCBfYnV0dG9uQXJnLCBfcmVsYXRlZFRhcmdldEFyZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZlZGVyYXRlZE1vdXNlRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZE1vdXNlRXZlbnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmVkZXJhdGVkTW91c2VFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkTW91c2VFdmVudC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEZlZGVyYXRlZFBvaW50ZXJFdmVudCBleHRlbmRzIEZlZGVyYXRlZE1vdXNlRXZlbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgcG9pbnRlcidzIGNvbnRhY3QgYWxvbmcgdGhlIHgtYXhpcywgbWVhc3VyZWQgaW4gQ1NTIHBpeGVscy5cbiAgICAgKiByYWRpdXNYIG9mIFRvdWNoRXZlbnRzIHdpbGwgYmUgcmVwcmVzZW50ZWQgYnkgdGhpcyB2YWx1ZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb2ludGVyRXZlbnQvd2lkdGhcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBwb2ludGVyJ3MgY29udGFjdCBhbG9uZyB0aGUgeS1heGlzLCBtZWFzdXJlZCBpbiBDU1MgcGl4ZWxzLlxuICAgICAqIHJhZGl1c1kgb2YgVG91Y2hFdmVudHMgd2lsbCBiZSByZXByZXNlbnRlZCBieSB0aGlzIHZhbHVlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BvaW50ZXJFdmVudC9oZWlnaHRcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBwb2ludGVyIGRldmljZSB0aGF0IGNyZWF0ZWQgdGhlIGV2ZW50IGlzIHRoZSBwcmltYXJ5IHBvaW50ZXIuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9pbnRlckV2ZW50L2lzUHJpbWFyeVxuICAgICAqL1xuICAgIHRoaXMuaXNQcmltYXJ5ID0gZmFsc2U7XG4gIH1cbiAgLy8gT25seSBpbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzIGZvciBub3dcbiAgZ2V0Q29hbGVzY2VkRXZlbnRzKCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IFwicG9pbnRlcm1vdmVcIiB8fCB0aGlzLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgfHwgdGhpcy50eXBlID09PSBcInRvdWNobW92ZVwiKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gT25seSBpbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzIGZvciBub3dcbiAgZ2V0UHJlZGljdGVkRXZlbnRzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImdldFByZWRpY3RlZEV2ZW50cyBpcyBub3Qgc3VwcG9ydGVkIVwiKTtcbiAgfVxufVxuXG5leHBvcnQgeyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRmVkZXJhdGVkV2hlZWxFdmVudCBleHRlbmRzIEZlZGVyYXRlZE1vdXNlRXZlbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKiBVbml0cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiAqL1xuICAgIHRoaXMuRE9NX0RFTFRBX1BJWEVMID0gMDtcbiAgICAvKiogVW5pdHMgc3BlY2lmaWVkIGluIGxpbmVzLiAqL1xuICAgIHRoaXMuRE9NX0RFTFRBX0xJTkUgPSAxO1xuICAgIC8qKiBVbml0cyBzcGVjaWZpZWQgaW4gcGFnZXMuICovXG4gICAgdGhpcy5ET01fREVMVEFfUEFHRSA9IDI7XG4gIH1cbn1cbi8qKiBVbml0cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiAqL1xuRmVkZXJhdGVkV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwgPSAwO1xuLyoqIFVuaXRzIHNwZWNpZmllZCBpbiBsaW5lcy4gKi9cbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUgPSAxO1xuLyoqIFVuaXRzIHNwZWNpZmllZCBpbiBwYWdlcy4gKi9cbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0UgPSAyO1xuXG5leHBvcnQgeyBGZWRlcmF0ZWRXaGVlbEV2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRXaGVlbEV2ZW50Lm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBFdmVudHNUaWNrZXIgfSBmcm9tICcuL0V2ZW50VGlja2VyLm1qcyc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkV2hlZWxFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkV2hlZWxFdmVudC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IFBST1BBR0FUSU9OX0xJTUlUID0gMjA0ODtcbmNvbnN0IHRlbXBIaXRMb2NhdGlvbiA9IG5ldyBQb2ludCgpO1xuY29uc3QgdGVtcExvY2FsTWFwcGluZyA9IG5ldyBQb2ludCgpO1xuY2xhc3MgRXZlbnRCb3VuZGFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcm9vdFRhcmdldCAtIFRoZSBob2xkZXIgb2YgdGhlIGV2ZW50IGJvdW5kYXJ5LlxuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdFRhcmdldCkge1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGV2ZW50cyBhZnRlciB0aGV5IHdlcmUgZGlzcGF0Y2hlZCBpbnRvIHRoZSBzY2VuZSBncmFwaC5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGdsb2JhbCBldmVudHMgbGlzdGVuaW5nLCByZWdhcmRsZXNzIG9mIHRoZSBzY2VuZSBncmFwaCBiZWluZyB1c2VkLiBJdCBzaG91bGRcbiAgICAgKiBub3QgYmUgdXNlZCBieSBpbnRlcmFjdGl2ZSBsaWJyYXJpZXMgZm9yIG5vcm1hbCB1c2UuXG4gICAgICpcbiAgICAgKiBTcGVjaWFsIGV2ZW50cyB0aGF0IGRvIG5vdCBidWJibGUgYWxsIHRoZSB3YXkgdG8gdGhlIHJvb3QgdGFyZ2V0IGFyZSBub3QgZW1pdHRlZCBmcm9tIGhlcmUsXG4gICAgICogZS5nLiBwb2ludGVyZW50ZXIsIHBvaW50ZXJsZWF2ZSwgY2xpY2suXG4gICAgICovXG4gICAgdGhpcy5kaXNwYXRjaCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZsYWcgd291bGQgZW1pdCBgcG9pbnRlcm1vdmVgLCBgdG91Y2htb3ZlYCwgYW5kIGBtb3VzZW1vdmVgIGV2ZW50cyBvbiBhbGwgQ29udGFpbmVycy5cbiAgICAgKlxuICAgICAqIFRoZSBgbW92ZU9uQWxsYCBzZW1hbnRpY3MgbWlycm9yIHRob3NlIG9mIGVhcmxpZXIgdmVyc2lvbnMgb2YgUGl4aUpTLiBUaGlzIHdhcyBkaXNhYmxlZCBpbiBmYXZvciBvZlxuICAgICAqIHRoZSBQb2ludGVyIEV2ZW50IEFQSSdzIGFwcHJvYWNoLlxuICAgICAqL1xuICAgIHRoaXMubW92ZU9uQWxsID0gZmFsc2U7XG4gICAgLyoqIEVuYWJsZXMgdGhlIGdsb2JhbCBtb3ZlIGV2ZW50cy4gYGdsb2JhbHBvaW50ZXJtb3ZlYCwgYGdsb2JhbHRvdWNobW92ZWAsIGFuZCBgZ2xvYmFsbW91c2Vtb3ZlYCAqL1xuICAgIHRoaXMuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA9IHRydWU7XG4gICAgLyoqXG4gICAgICogU3RhdGUgb2JqZWN0IGZvciBtYXBwaW5nIG1ldGhvZHMuXG4gICAgICogQHNlZSBFdmVudEJvdW5kYXJ5I3RyYWNraW5nRGF0YVxuICAgICAqL1xuICAgIHRoaXMubWFwcGluZ1N0YXRlID0ge1xuICAgICAgdHJhY2tpbmdEYXRhOiB7fVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHBvb2wgbWFwcyBldmVudCBjb25zdHJ1Y3RvcnMgdG8gYW4gZnJlZSBwb29sIG9mIGluc3RhbmNlcyBvZiB0aG9zZSBzcGVjaWZpYyBldmVudHMuXG4gICAgICogQHNlZSBFdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnRcbiAgICAgKiBAc2VlIEV2ZW50Qm91bmRhcnkjZnJlZUV2ZW50XG4gICAgICovXG4gICAgdGhpcy5ldmVudFBvb2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8qKiBFdmVyeSBpbnRlcmFjdGl2ZSBlbGVtZW50IGdhdGhlcmVkIGZyb20gdGhlIHNjZW5lLiBPbmx5IHVzZWQgaW4gYHBvaW50ZXJtb3ZlYCAqL1xuICAgIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMgPSBbXTtcbiAgICAvKiogRXZlcnkgZWxlbWVudCB0aGF0IHBhc3NlZCB0aGUgaGl0IHRlc3QuIE9ubHkgdXNlZCBpbiBgcG9pbnRlcm1vdmVgICovXG4gICAgdGhpcy5faGl0RWxlbWVudHMgPSBbXTtcbiAgICAvKiogV2hldGhlciBvciBub3QgdG8gY29sbGVjdCBhbGwgdGhlIGludGVyYWN0aXZlIGVsZW1lbnRzIGZyb20gdGhlIHNjZW5lLiBFbmFibGVkIGluIGBwb2ludGVybW92ZWAgKi9cbiAgICB0aGlzLl9pc1BvaW50ZXJNb3ZlRXZlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnJvb3RUYXJnZXQgPSByb290VGFyZ2V0O1xuICAgIHRoaXMuaGl0UHJ1bmVGbiA9IHRoaXMuaGl0UHJ1bmVGbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGl0VGVzdEZuID0gdGhpcy5oaXRUZXN0Rm4uYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFBvaW50ZXJEb3duID0gdGhpcy5tYXBQb2ludGVyRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFwUG9pbnRlck1vdmUgPSB0aGlzLm1hcFBvaW50ZXJNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyT3V0ID0gdGhpcy5tYXBQb2ludGVyT3V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyT3ZlciA9IHRoaXMubWFwUG9pbnRlck92ZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFBvaW50ZXJVcCA9IHRoaXMubWFwUG9pbnRlclVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyVXBPdXRzaWRlID0gdGhpcy5tYXBQb2ludGVyVXBPdXRzaWRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBXaGVlbCA9IHRoaXMubWFwV2hlZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcHBpbmdUYWJsZSA9IHt9O1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcmRvd25cIiwgdGhpcy5tYXBQb2ludGVyRG93bik7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVybW92ZVwiLCB0aGlzLm1hcFBvaW50ZXJNb3ZlKTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJvdXRcIiwgdGhpcy5tYXBQb2ludGVyT3V0KTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLm1hcFBvaW50ZXJPdXQpO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5tYXBQb2ludGVyT3Zlcik7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVydXBcIiwgdGhpcy5tYXBQb2ludGVyVXApO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcnVwb3V0c2lkZVwiLCB0aGlzLm1hcFBvaW50ZXJVcE91dHNpZGUpO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwid2hlZWxcIiwgdGhpcy5tYXBXaGVlbCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbWFwcGluZyBmb3IgdGhlIGV2ZW50IGB0eXBlYCBoYW5kbGVkIGJ5IGBmbmAuXG4gICAqXG4gICAqIEV2ZW50IG1hcHBpbmdzIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBhZGRpdGlvbmFsIG9yIGN1c3RvbSBldmVudHMuIFRoZXkgdGFrZSBhbiBldmVudFxuICAgKiBjb21pbmcgZnJvbSB0aGUgdXBzdHJlYW0gc2NlbmUgKG9yIGRpcmVjdGx5IGZyb20gdGhlIHtAbGluayBFdmVudFN5c3RlbX0pIGFuZCBkaXNwYXRjaCBuZXcgZG93bnN0cmVhbSBldmVudHNcbiAgICogZ2VuZXJhbGx5IHRyaWNrbGluZyBkb3duIGFuZCBidWJibGluZyB1cCB0byB7QGxpbmsgRXZlbnRCb3VuZGFyeS5yb290VGFyZ2V0IHRoaXMucm9vdFRhcmdldH0uXG4gICAqXG4gICAqIFRvIG1vZGlmeSB0aGUgc2VtYW50aWNzIG9mIGV4aXN0aW5nIGV2ZW50cywgdGhlIGJ1aWx0LWluIG1hcHBpbmcgbWV0aG9kcyBvZiBFdmVudEJvdW5kYXJ5IHNob3VsZCBiZSBvdmVycmlkZGVuXG4gICAqIGluc3RlYWQuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdXBzdHJlYW0gZXZlbnQgdG8gbWFwLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbWFwcGluZyBtZXRob2QuIFRoZSBjb250ZXh0IG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBib3VuZCBtYW51YWxseSwgaWYgZGVzaXJlZC5cbiAgICovXG4gIGFkZEV2ZW50TWFwcGluZyh0eXBlLCBmbikge1xuICAgIGlmICghdGhpcy5tYXBwaW5nVGFibGVbdHlwZV0pIHtcbiAgICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdID0gW107XG4gICAgfVxuICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdLnB1c2goe1xuICAgICAgZm4sXG4gICAgICBwcmlvcml0eTogMFxuICAgIH0pO1xuICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB0aGUgZ2l2ZW4gZXZlbnRcbiAgICogQHBhcmFtIGUgLSBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdG8gZGlzcGF0Y2guIERlZmF1bHRzIHRvIGBlLnR5cGVgLlxuICAgKi9cbiAgZGlzcGF0Y2hFdmVudChlLCB0eXBlKSB7XG4gICAgZS5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wYWdhdGUoZSwgdHlwZSk7XG4gICAgdGhpcy5kaXNwYXRjaC5lbWl0KHR5cGUgfHwgZS50eXBlLCBlKTtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgZ2l2ZW4gdXBzdHJlYW0gZXZlbnQgdGhyb3VnaCB0aGUgZXZlbnQgYm91bmRhcnkgYW5kIHByb3BhZ2F0ZXMgaXQgZG93bnN0cmVhbS5cbiAgICogQHBhcmFtIGUgLSBUaGUgZXZlbnQgdG8gbWFwLlxuICAgKi9cbiAgbWFwRXZlbnQoZSkge1xuICAgIGlmICghdGhpcy5yb290VGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1hcHBlcnMgPSB0aGlzLm1hcHBpbmdUYWJsZVtlLnR5cGVdO1xuICAgIGlmIChtYXBwZXJzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IG1hcHBlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIG1hcHBlcnNbaV0uZm4oZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oYFtFdmVudEJvdW5kYXJ5XTogRXZlbnQgbWFwcGluZyBub3QgZGVmaW5lZCBmb3IgJHtlLnR5cGV9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgQ29udGFpbmVyIHRoYXQgaXMgdGhlIHRhcmdldCBvZiBhIGV2ZW50IGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICpcbiAgICogVGhlIHBhc3NlZCAoeCx5KSBjb29yZGluYXRlcyBhcmUgaW4gdGhlIHdvcmxkIHNwYWNlIGFib3ZlIHRoaXMgZXZlbnQgYm91bmRhcnkuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBoaXRUZXN0KHgsIHkpIHtcbiAgICBFdmVudHNUaWNrZXIucGF1c2VVcGRhdGUgPSB0cnVlO1xuICAgIGNvbnN0IHVzZU1vdmUgPSB0aGlzLl9pc1BvaW50ZXJNb3ZlRXZlbnQgJiYgdGhpcy5lbmFibGVHbG9iYWxNb3ZlRXZlbnRzO1xuICAgIGNvbnN0IGZuID0gdXNlTW92ZSA/IFwiaGl0VGVzdE1vdmVSZWN1cnNpdmVcIiA6IFwiaGl0VGVzdFJlY3Vyc2l2ZVwiO1xuICAgIGNvbnN0IGludmVydGVkUGF0aCA9IHRoaXNbZm5dKFxuICAgICAgdGhpcy5yb290VGFyZ2V0LFxuICAgICAgdGhpcy5yb290VGFyZ2V0LmV2ZW50TW9kZSxcbiAgICAgIHRlbXBIaXRMb2NhdGlvbi5zZXQoeCwgeSksXG4gICAgICB0aGlzLmhpdFRlc3RGbixcbiAgICAgIHRoaXMuaGl0UHJ1bmVGblxuICAgICk7XG4gICAgcmV0dXJuIGludmVydGVkUGF0aCAmJiBpbnZlcnRlZFBhdGhbMF07XG4gIH1cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZSB0aGUgcGFzc2VkIGV2ZW50IGZyb20gZnJvbSB7QGxpbmsgRXZlbnRCb3VuZGFyeS5yb290VGFyZ2V0IHRoaXMucm9vdFRhcmdldH0gdG8gaXRzXG4gICAqIHRhcmdldCB7QGNvZGUgZS50YXJnZXR9LlxuICAgKiBAcGFyYW0gZSAtIFRoZSBldmVudCB0byBwcm9wYWdhdGUuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdG8gcHJvcGFnYXRlLiBEZWZhdWx0cyB0byBgZS50eXBlYC5cbiAgICovXG4gIHByb3BhZ2F0ZShlLCB0eXBlKSB7XG4gICAgaWYgKCFlLnRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb21wb3NlZFBhdGggPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIGUuZXZlbnRQaGFzZSA9IGUuQ0FQVFVSSU5HX1BIQVNFO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gY29tcG9zZWRQYXRoLmxlbmd0aCAtIDE7IGkgPCBqOyBpKyspIHtcbiAgICAgIGUuY3VycmVudFRhcmdldCA9IGNvbXBvc2VkUGF0aFtpXTtcbiAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIHR5cGUpO1xuICAgICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5ldmVudFBoYXNlID0gZS5BVF9UQVJHRVQ7XG4gICAgZS5jdXJyZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgdHlwZSk7XG4gICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkIHx8IGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQpXG4gICAgICByZXR1cm47XG4gICAgZS5ldmVudFBoYXNlID0gZS5CVUJCTElOR19QSEFTRTtcbiAgICBmb3IgKGxldCBpID0gY29tcG9zZWRQYXRoLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBlLmN1cnJlbnRUYXJnZXQgPSBjb21wb3NlZFBhdGhbaV07XG4gICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCB0eXBlKTtcbiAgICAgIGlmIChlLnByb3BhZ2F0aW9uU3RvcHBlZCB8fCBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgZXZlbnQge0Bjb2RlIGV9IHRvIGFsbCBpbnRlcmFjdGl2ZSBjb250YWluZXJzLiBUaGUgZXZlbnQgaXMgcHJvcGFnYXRlZCBpbiB0aGUgYnViYmxpbmcgcGhhc2UgYWx3YXlzLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIGBnbG9iYWxwb2ludGVybW92ZWAgZXZlbnQuXG4gICAqIEBwYXJhbSBlIC0gVGhlIGVtaXR0ZWQgZXZlbnQuXG4gICAqIEBwYXJhbSB0eXBlIC0gVGhlIGxpc3RlbmVycyB0byBub3RpZnkuXG4gICAqIEBwYXJhbSB0YXJnZXRzIC0gVGhlIHRhcmdldHMgdG8gbm90aWZ5LlxuICAgKi9cbiAgYWxsKGUsIHR5cGUsIHRhcmdldHMgPSB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGUuZXZlbnRQaGFzZSA9IGUuQlVCQkxJTkdfUEhBU0U7XG4gICAgY29uc3QgZXZlbnRzID0gQXJyYXkuaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgZm9yIChsZXQgaSA9IHRhcmdldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBwcm9wYWdhdGlvbiBwYXRoIGZyb20ge0BsaW5rIEV2ZW50Qm91bmRhcnkucm9vdFRhcmdldCByb290VGFyZ2V0fSB0byB0aGUgcGFzc2VkXG4gICAqIHtAY29kZSB0YXJnZXR9LiBUaGUgbGFzdCBlbGVtZW50IGluIHRoZSBwYXRoIGlzIHtAY29kZSB0YXJnZXR9LlxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiBwYXRoIHRvLlxuICAgKi9cbiAgcHJvcGFnYXRpb25QYXRoKHRhcmdldCkge1xuICAgIGNvbnN0IHByb3BhZ2F0aW9uUGF0aCA9IFt0YXJnZXRdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUFJPUEFHQVRJT05fTElNSVQgJiYgKHRhcmdldCAhPT0gdGhpcy5yb290VGFyZ2V0ICYmIHRhcmdldC5wYXJlbnQpOyBpKyspIHtcbiAgICAgIGlmICghdGFyZ2V0LnBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBwcm9wYWdhdGlvbiBwYXRoIHRvIGRpc2Nvbm5lY3RlZCB0YXJnZXRcIik7XG4gICAgICB9XG4gICAgICBwcm9wYWdhdGlvblBhdGgucHVzaCh0YXJnZXQucGFyZW50KTtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgfVxuICAgIHByb3BhZ2F0aW9uUGF0aC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHByb3BhZ2F0aW9uUGF0aDtcbiAgfVxuICBoaXRUZXN0TW92ZVJlY3Vyc2l2ZShjdXJyZW50VGFyZ2V0LCBldmVudE1vZGUsIGxvY2F0aW9uLCB0ZXN0Rm4sIHBydW5lRm4sIGlnbm9yZSA9IGZhbHNlKSB7XG4gICAgbGV0IHNob3VsZFJldHVybiA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9pbnRlcmFjdGl2ZVBydW5lKGN1cnJlbnRUYXJnZXQpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQuZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIiB8fCBldmVudE1vZGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICBFdmVudHNUaWNrZXIucGF1c2VVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRUYXJnZXQuaW50ZXJhY3RpdmVDaGlsZHJlbiAmJiBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGN1cnJlbnRUYXJnZXQuY2hpbGRyZW47XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgbmVzdGVkSGl0ID0gdGhpcy5oaXRUZXN0TW92ZVJlY3Vyc2l2ZShcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSkgPyBldmVudE1vZGUgOiBjaGlsZC5ldmVudE1vZGUsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgdGVzdEZuLFxuICAgICAgICAgIHBydW5lRm4sXG4gICAgICAgICAgaWdub3JlIHx8IHBydW5lRm4oY3VycmVudFRhcmdldCwgbG9jYXRpb24pXG4gICAgICAgICk7XG4gICAgICAgIGlmIChuZXN0ZWRIaXQpIHtcbiAgICAgICAgICBpZiAobmVzdGVkSGl0Lmxlbmd0aCA+IDAgJiYgIW5lc3RlZEhpdFtuZXN0ZWRIaXQubGVuZ3RoIC0gMV0ucGFyZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNJbnRlcmFjdGl2ZSA9IGN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpO1xuICAgICAgICAgIGlmIChuZXN0ZWRIaXQubGVuZ3RoID4gMCB8fCBpc0ludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoaXNJbnRlcmFjdGl2ZSlcbiAgICAgICAgICAgICAgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5wdXNoKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgbmVzdGVkSGl0LnB1c2goY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9oaXRFbGVtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aGlzLl9oaXRFbGVtZW50cyA9IG5lc3RlZEhpdDtcbiAgICAgICAgICBzaG91bGRSZXR1cm4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzSW50ZXJhY3RpdmVNb2RlID0gdGhpcy5faXNJbnRlcmFjdGl2ZShldmVudE1vZGUpO1xuICAgIGNvbnN0IGlzSW50ZXJhY3RpdmVUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICBpZiAoaXNJbnRlcmFjdGl2ZVRhcmdldCAmJiBpc0ludGVyYWN0aXZlVGFyZ2V0KVxuICAgICAgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5wdXNoKGN1cnJlbnRUYXJnZXQpO1xuICAgIGlmIChpZ25vcmUgfHwgdGhpcy5faGl0RWxlbWVudHMubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChzaG91bGRSZXR1cm4pXG4gICAgICByZXR1cm4gdGhpcy5faGl0RWxlbWVudHM7XG4gICAgaWYgKGlzSW50ZXJhY3RpdmVNb2RlICYmICghcHJ1bmVGbihjdXJyZW50VGFyZ2V0LCBsb2NhdGlvbikgJiYgdGVzdEZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSkpIHtcbiAgICAgIHJldHVybiBpc0ludGVyYWN0aXZlVGFyZ2V0ID8gW2N1cnJlbnRUYXJnZXRdIDogW107XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gZm9yIHtAbGluayBFdmVudEJvdW5kYXJ5LmhpdFRlc3QgaGl0VGVzdH0uXG4gICAqIEBwYXJhbSBjdXJyZW50VGFyZ2V0IC0gVGhlIENvbnRhaW5lciB0aGF0IGlzIHRvIGJlIGhpdCB0ZXN0ZWQuXG4gICAqIEBwYXJhbSBldmVudE1vZGUgLSBUaGUgZXZlbnQgbW9kZSBmb3IgdGhlIGBjdXJyZW50VGFyZ2V0YCBvciBvbmUgb2YgaXRzIHBhcmVudHMuXG4gICAqIEBwYXJhbSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0aGF0IGlzIGJlaW5nIHRlc3RlZCBmb3Igb3ZlcmxhcC5cbiAgICogQHBhcmFtIHRlc3RGbiAtIENhbGxiYWNrIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB0YXJnZXQgcGFzc2VzIGhpdCB0ZXN0aW5nLiBUaGlzIGNhbGxiYWNrXG4gICAqICBjYW4gYXNzdW1lIHRoYXQgYHBydW5lRm5gIGZhaWxlZCB0byBwcnVuZSB0aGUgY29udGFpbmVyLlxuICAgKiBAcGFyYW0gcHJ1bmVGbiAtIENhbGxiYWNrIHRoYXQgZGV0ZXJtaW5lc3Mgd2hldGhlciB0aGUgdGFyZ2V0IGFuZCBhbGwgb2YgaXRzIGNoaWxkcmVuXG4gICAqICBjYW5ub3QgcGFzcyB0aGUgaGl0IHRlc3QuIEl0IGlzIHVzZWQgYXMgYSBwcmVsaW1pbmFyeSBvcHRpbWl6YXRpb24gdG8gcHJ1bmUgZW50aXJlIHN1YnRyZWVzXG4gICAqICBvZiB0aGUgc2NlbmUgZ3JhcGguXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IGhvbGRpbmcgdGhlIGhpdCB0ZXN0aW5nIHRhcmdldCBhbmQgYWxsIGl0cyBhbmNlc3RvcnMgaW4gb3JkZXIuIFRoZSBmaXJzdCBlbGVtZW50XG4gICAqICBpcyB0aGUgdGFyZ2V0IGl0c2VsZiBhbmQgdGhlIGxhc3QgaXMge0BsaW5rIEV2ZW50Qm91bmRhcnkucm9vdFRhcmdldCByb290VGFyZ2V0fS4gVGhpcyBpcyB0aGUgb3Bwb3NpdGVcbiAgICogIG9yZGVyIHcuci50LiB0aGUgcHJvcGFnYXRpb24gcGF0aC4gSWYgbm8gaGl0IHRlc3RpbmcgdGFyZ2V0IGlzIGZvdW5kLCBudWxsIGlzIHJldHVybmVkLlxuICAgKi9cbiAgaGl0VGVzdFJlY3Vyc2l2ZShjdXJyZW50VGFyZ2V0LCBldmVudE1vZGUsIGxvY2F0aW9uLCB0ZXN0Rm4sIHBydW5lRm4pIHtcbiAgICBpZiAodGhpcy5faW50ZXJhY3RpdmVQcnVuZShjdXJyZW50VGFyZ2V0KSB8fCBwcnVuZUZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VGFyZ2V0LmV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCIgfHwgZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIikge1xuICAgICAgRXZlbnRzVGlja2VyLnBhdXNlVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VGFyZ2V0LmludGVyYWN0aXZlQ2hpbGRyZW4gJiYgY3VycmVudFRhcmdldC5jaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuO1xuICAgICAgY29uc3QgcmVsYXRpdmVMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IG5lc3RlZEhpdCA9IHRoaXMuaGl0VGVzdFJlY3Vyc2l2ZShcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSkgPyBldmVudE1vZGUgOiBjaGlsZC5ldmVudE1vZGUsXG4gICAgICAgICAgcmVsYXRpdmVMb2NhdGlvbixcbiAgICAgICAgICB0ZXN0Rm4sXG4gICAgICAgICAgcHJ1bmVGblxuICAgICAgICApO1xuICAgICAgICBpZiAobmVzdGVkSGl0KSB7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwICYmICFuZXN0ZWRIaXRbbmVzdGVkSGl0Lmxlbmd0aCAtIDFdLnBhcmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICAgICAgICBpZiAobmVzdGVkSGl0Lmxlbmd0aCA+IDAgfHwgaXNJbnRlcmFjdGl2ZSlcbiAgICAgICAgICAgIG5lc3RlZEhpdC5wdXNoKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgIHJldHVybiBuZXN0ZWRIaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZU1vZGUgPSB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSk7XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZVRhcmdldCA9IGN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpO1xuICAgIGlmIChpc0ludGVyYWN0aXZlTW9kZSAmJiB0ZXN0Rm4oY3VycmVudFRhcmdldCwgbG9jYXRpb24pKSB7XG4gICAgICByZXR1cm4gaXNJbnRlcmFjdGl2ZVRhcmdldCA/IFtjdXJyZW50VGFyZ2V0XSA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfaXNJbnRlcmFjdGl2ZShpbnQpIHtcbiAgICByZXR1cm4gaW50ID09PSBcInN0YXRpY1wiIHx8IGludCA9PT0gXCJkeW5hbWljXCI7XG4gIH1cbiAgX2ludGVyYWN0aXZlUHJ1bmUoY29udGFpbmVyKSB7XG4gICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci52aXNpYmxlIHx8ICFjb250YWluZXIucmVuZGVyYWJsZSB8fCAhY29udGFpbmVyLmluY2x1ZGVJbkJ1aWxkIHx8ICFjb250YWluZXIubWVhc3VyYWJsZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb250YWluZXIuZXZlbnRNb2RlID09PSBcIm5vbmVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb250YWluZXIuZXZlbnRNb2RlID09PSBcInBhc3NpdmVcIiAmJiAhY29udGFpbmVyLmludGVyYWN0aXZlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBjb250YWluZXIgb3IgYW55IG9mIGl0cyBjaGlsZHJlbiBjYW5ub3QgcGFzcyB0aGUgaGl0IHRlc3QgYXQgYWxsLlxuICAgKlxuICAgKiB7QGxpbmsgRXZlbnRCb3VuZGFyeX0ncyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSB7QGxpbmsgQ29udGFpbmVyLmhpdEFyZWEgaGl0QXJlYX1cbiAgICogYW5kIHtAbGluayBDb250YWluZXIuX21hc2tFZmZlY3R9IGZvciBwcnVuaW5nLlxuICAgKiBAcGFyYW0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciB0byBwcnVuZS5cbiAgICogQHBhcmFtIGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIHRvIHRlc3QgZm9yIG92ZXJsYXAuXG4gICAqL1xuICBoaXRQcnVuZUZuKGNvbnRhaW5lciwgbG9jYXRpb24pIHtcbiAgICBpZiAoY29udGFpbmVyLmhpdEFyZWEpIHtcbiAgICAgIGNvbnRhaW5lci53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UobG9jYXRpb24sIHRlbXBMb2NhbE1hcHBpbmcpO1xuICAgICAgaWYgKCFjb250YWluZXIuaGl0QXJlYS5jb250YWlucyh0ZW1wTG9jYWxNYXBwaW5nLngsIHRlbXBMb2NhbE1hcHBpbmcueSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250YWluZXIuZWZmZWN0cyAmJiBjb250YWluZXIuZWZmZWN0cy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVyLmVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gY29udGFpbmVyLmVmZmVjdHNbaV07XG4gICAgICAgIGlmIChlZmZlY3QuY29udGFpbnNQb2ludCkge1xuICAgICAgICAgIGNvbnN0IGVmZmVjdENvbnRhaW5zUG9pbnQgPSBlZmZlY3QuY29udGFpbnNQb2ludChsb2NhdGlvbiwgdGhpcy5oaXRUZXN0Rm4pO1xuICAgICAgICAgIGlmICghZWZmZWN0Q29udGFpbnNQb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGNvbnRhaW5lciBwYXNzZXMgaGl0IHRlc3RpbmcgZm9yIHRoZSBnaXZlbiBsb2NhdGlvbi5cbiAgICogQHBhcmFtIGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gdGVzdC5cbiAgICogQHBhcmFtIGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIHRvIHRlc3QgZm9yIG92ZXJsYXAuXG4gICAqIEByZXR1cm5zIC0gV2hldGhlciBgY29udGFpbmVyYCBwYXNzZXMgaGl0IHRlc3RpbmcgZm9yIGBsb2NhdGlvbmAuXG4gICAqL1xuICBoaXRUZXN0Rm4oY29udGFpbmVyLCBsb2NhdGlvbikge1xuICAgIGlmIChjb250YWluZXIuaGl0QXJlYSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb250YWluZXI/LmNvbnRhaW5zUG9pbnQpIHtcbiAgICAgIGNvbnRhaW5lci53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UobG9jYXRpb24sIHRlbXBMb2NhbE1hcHBpbmcpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5jb250YWluc1BvaW50KHRlbXBMb2NhbE1hcHBpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIE5vdGlmeSBhbGwgdGhlIGxpc3RlbmVycyB0byB0aGUgZXZlbnQncyBgY3VycmVudFRhcmdldGAuXG4gICAqXG4gICAqIElmIHRoZSBgY3VycmVudFRhcmdldGAgY29udGFpbnMgdGhlIHByb3BlcnR5IGBvbjx0eXBlPmAsIHRoZW4gaXQgaXMgY2FsbGVkIGhlcmUsXG4gICAqIHNpbXVsYXRpbmcgdGhlIGJlaGF2aW9yIGZyb20gdmVyc2lvbiA2LnggYW5kIHByaW9yLlxuICAgKiBAcGFyYW0gZSAtIFRoZSBldmVudCBwYXNzZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiBldmVudCB0byBub3RpZnkuIERlZmF1bHRzIHRvIGBlLnR5cGVgLlxuICAgKi9cbiAgbm90aWZ5VGFyZ2V0KGUsIHR5cGUpIHtcbiAgICBpZiAoIWUuY3VycmVudFRhcmdldC5pc0ludGVyYWN0aXZlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHlwZSA9IHR5cGUgPz8gZS50eXBlO1xuICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBgb24ke3R5cGV9YDtcbiAgICBlLmN1cnJlbnRUYXJnZXRbaGFuZGxlcktleV0/LihlKTtcbiAgICBjb25zdCBrZXkgPSBlLmV2ZW50UGhhc2UgPT09IGUuQ0FQVFVSSU5HX1BIQVNFIHx8IGUuZXZlbnRQaGFzZSA9PT0gZS5BVF9UQVJHRVQgPyBgJHt0eXBlfWNhcHR1cmVgIDogdHlwZTtcbiAgICB0aGlzLl9ub3RpZnlMaXN0ZW5lcnMoZSwga2V5KTtcbiAgICBpZiAoZS5ldmVudFBoYXNlID09PSBlLkFUX1RBUkdFVCkge1xuICAgICAgdGhpcy5fbm90aWZ5TGlzdGVuZXJzKGUsIHR5cGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgdXBzdHJlYW0gYHBvaW50ZXJkb3duYCBldmVudHMgdG8gYSBkb3duc3RyZWFtIGBwb2ludGVyZG93bmAgZXZlbnQuXG4gICAqXG4gICAqIGB0b3VjaHN0YXJ0YCwgYHJpZ2h0ZG93bmAsIGBtb3VzZWRvd25gIGV2ZW50cyBhcmUgYWxzbyBkaXNwYXRjaGVkIGZvciBzcGVjaWZpYyBwb2ludGVyIHR5cGVzLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgcG9pbnRlcmRvd25gIGV2ZW50LlxuICAgKi9cbiAgbWFwUG9pbnRlckRvd24oZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICB3YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcmRvd25cIik7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwidG91Y2hzdGFydFwiKTtcbiAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSB7XG4gICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gZS5idXR0b24gPT09IDI7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHRkb3duXCIgOiBcIm1vdXNlZG93blwiKTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl0gPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcm1vdmVgIHRvIGRvd25zdHJlYW0gYHBvaW50ZXJvdXRgLCBgcG9pbnRlcm92ZXJgLCBhbmQgYHBvaW50ZXJtb3ZlYCBldmVudHMsIGluIHRoYXQgb3JkZXIuXG4gICAqXG4gICAqIFRoZSB0cmFja2luZyBkYXRhIGZvciB0aGUgc3BlY2lmaWMgcG9pbnRlciBoYXMgYW4gdXBkYXRlZCBgb3ZlclRhcmdldGAuIGBtb3VzZW91dGAsIGBtb3VzZW92ZXJgLFxuICAgKiBgbW91c2Vtb3ZlYCwgYW5kIGB0b3VjaG1vdmVgIGV2ZW50cyBhcmUgZmlyZWQgYXMgd2VsbCBmb3Igc3BlY2lmaWMgcG9pbnRlciB0eXBlcy5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgdXBzdHJlYW0gYHBvaW50ZXJtb3ZlYCBldmVudC5cbiAgICovXG4gIG1hcFBvaW50ZXJNb3ZlKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgd2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gdHJ1ZTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gZmFsc2U7XG4gICAgY29uc3QgaXNNb3VzZSA9IGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiO1xuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBjb25zdCBvdXRUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyk7XG4gICAgaWYgKHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cz8ubGVuZ3RoID4gMCAmJiBvdXRUYXJnZXQgIT09IGUudGFyZ2V0KSB7XG4gICAgICBjb25zdCBvdXRUeXBlID0gZnJvbS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJtb3VzZW91dFwiIDogXCJwb2ludGVyb3V0XCI7XG4gICAgICBjb25zdCBvdXRFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIG91dFR5cGUsIG91dFRhcmdldCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwicG9pbnRlcm91dFwiKTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwibW91c2VvdXRcIik7XG4gICAgICBpZiAoIWUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMob3V0VGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBsZWF2ZUV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgXCJwb2ludGVybGVhdmVcIiwgb3V0VGFyZ2V0KTtcbiAgICAgICAgbGVhdmVFdmVudC5ldmVudFBoYXNlID0gbGVhdmVFdmVudC5BVF9UQVJHRVQ7XG4gICAgICAgIHdoaWxlIChsZWF2ZUV2ZW50LnRhcmdldCAmJiAhZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhsZWF2ZUV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICBsZWF2ZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldDtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChsZWF2ZUV2ZW50KTtcbiAgICAgICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQsIFwibW91c2VsZWF2ZVwiKTtcbiAgICAgICAgICBsZWF2ZUV2ZW50LnRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWVFdmVudChsZWF2ZUV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlZUV2ZW50KG91dEV2ZW50KTtcbiAgICB9XG4gICAgaWYgKG91dFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgIGNvbnN0IG92ZXJUeXBlID0gZnJvbS50eXBlID09PSBcIm1vdXNlbW92ZVwiID8gXCJtb3VzZW92ZXJcIiA6IFwicG9pbnRlcm92ZXJcIjtcbiAgICAgIGNvbnN0IG92ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgb3ZlclR5cGUpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG92ZXJFdmVudCwgXCJwb2ludGVyb3ZlclwiKTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3ZlckV2ZW50LCBcIm1vdXNlb3ZlclwiKTtcbiAgICAgIGxldCBvdmVyVGFyZ2V0QW5jZXN0b3IgPSBvdXRUYXJnZXQ/LnBhcmVudDtcbiAgICAgIHdoaWxlIChvdmVyVGFyZ2V0QW5jZXN0b3IgJiYgb3ZlclRhcmdldEFuY2VzdG9yICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50KSB7XG4gICAgICAgIGlmIChvdmVyVGFyZ2V0QW5jZXN0b3IgPT09IGUudGFyZ2V0KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvdmVyVGFyZ2V0QW5jZXN0b3IgPSBvdmVyVGFyZ2V0QW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgZGlkUG9pbnRlckVudGVyID0gIW92ZXJUYXJnZXRBbmNlc3RvciB8fCBvdmVyVGFyZ2V0QW5jZXN0b3IgPT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQ7XG4gICAgICBpZiAoZGlkUG9pbnRlckVudGVyKSB7XG4gICAgICAgIGNvbnN0IGVudGVyRXZlbnQgPSB0aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsIFwicG9pbnRlcmVudGVyXCIpO1xuICAgICAgICBlbnRlckV2ZW50LmV2ZW50UGhhc2UgPSBlbnRlckV2ZW50LkFUX1RBUkdFVDtcbiAgICAgICAgd2hpbGUgKGVudGVyRXZlbnQudGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSBvdXRUYXJnZXQgJiYgZW50ZXJFdmVudC50YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQpIHtcbiAgICAgICAgICBlbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldDtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlbnRlckV2ZW50KTtcbiAgICAgICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQsIFwibW91c2VlbnRlclwiKTtcbiAgICAgICAgICBlbnRlckV2ZW50LnRhcmdldCA9IGVudGVyRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWVFdmVudChlbnRlckV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJlZUV2ZW50KG92ZXJFdmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGFsbE1ldGhvZHMgPSBbXTtcbiAgICBjb25zdCBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgPSB0aGlzLmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPz8gdHJ1ZTtcbiAgICB0aGlzLm1vdmVPbkFsbCA/IGFsbE1ldGhvZHMucHVzaChcInBvaW50ZXJtb3ZlXCIpIDogdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcm1vdmVcIik7XG4gICAgYWxsb3dHbG9iYWxQb2ludGVyRXZlbnRzICYmIGFsbE1ldGhvZHMucHVzaChcImdsb2JhbHBvaW50ZXJtb3ZlXCIpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgIHRoaXMubW92ZU9uQWxsID8gYWxsTWV0aG9kcy5zcGxpY2UoMSwgMCwgXCJ0b3VjaG1vdmVcIikgOiB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJ0b3VjaG1vdmVcIik7XG4gICAgICBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgJiYgYWxsTWV0aG9kcy5wdXNoKFwiZ2xvYmFsdG91Y2htb3ZlXCIpO1xuICAgIH1cbiAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgdGhpcy5tb3ZlT25BbGwgPyBhbGxNZXRob2RzLnNwbGljZSgxLCAwLCBcIm1vdXNlbW92ZVwiKSA6IHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcIm1vdXNlbW92ZVwiKTtcbiAgICAgIGFsbG93R2xvYmFsUG9pbnRlckV2ZW50cyAmJiBhbGxNZXRob2RzLnB1c2goXCJnbG9iYWxtb3VzZW1vdmVcIik7XG4gICAgICB0aGlzLmN1cnNvciA9IGUudGFyZ2V0Py5jdXJzb3I7XG4gICAgfVxuICAgIGlmIChhbGxNZXRob2RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWxsKGUsIGFsbE1ldGhvZHMpO1xuICAgIH1cbiAgICB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5faGl0RWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcm92ZXJgIHRvIGRvd25zdHJlYW0gYHBvaW50ZXJvdmVyYCBhbmQgYHBvaW50ZXJlbnRlcmAgZXZlbnRzLCBpbiB0aGF0IG9yZGVyLlxuICAgKlxuICAgKiBUaGUgdHJhY2tpbmcgZGF0YSBmb3IgdGhlIHNwZWNpZmljIHBvaW50ZXIgZ2V0cyBhIG5ldyBgb3ZlclRhcmdldGAuXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHVwc3RyZWFtIGBwb2ludGVyb3ZlcmAgZXZlbnQuXG4gICAqL1xuICBtYXBQb2ludGVyT3Zlcihmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIHdhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgY29uc3QgaXNNb3VzZSA9IGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInBvaW50ZXJvdmVyXCIpO1xuICAgIGlmIChpc01vdXNlKVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwibW91c2VvdmVyXCIpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpXG4gICAgICB0aGlzLmN1cnNvciA9IGUudGFyZ2V0Py5jdXJzb3I7XG4gICAgY29uc3QgZW50ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgXCJwb2ludGVyZW50ZXJcIik7XG4gICAgZW50ZXJFdmVudC5ldmVudFBoYXNlID0gZW50ZXJFdmVudC5BVF9UQVJHRVQ7XG4gICAgd2hpbGUgKGVudGVyRXZlbnQudGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50KSB7XG4gICAgICBlbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldDtcbiAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQpO1xuICAgICAgaWYgKGlzTW91c2UpXG4gICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQsIFwibW91c2VlbnRlclwiKTtcbiAgICAgIGVudGVyRXZlbnQudGFyZ2V0ID0gZW50ZXJFdmVudC50YXJnZXQucGFyZW50O1xuICAgIH1cbiAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGVudGVyRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgcG9pbnRlcm91dGAgdG8gZG93bnN0cmVhbSBgcG9pbnRlcm91dGAsIGBwb2ludGVybGVhdmVgIGV2ZW50cywgaW4gdGhhdCBvcmRlci5cbiAgICpcbiAgICogVGhlIHRyYWNraW5nIGRhdGEgZm9yIHRoZSBzcGVjaWZpYyBwb2ludGVyIGlzIGNsZWFyZWQgb2YgYSBgb3ZlclRhcmdldGAuXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHVwc3RyZWFtIGBwb2ludGVyb3V0YCBldmVudC5cbiAgICovXG4gIG1hcFBvaW50ZXJPdXQoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICB3YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFja2luZ0RhdGEgPSB0aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCk7XG4gICAgaWYgKHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cykge1xuICAgICAgY29uc3QgaXNNb3VzZSA9IGZyb20ucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBmcm9tLnBvaW50ZXJUeXBlID09PSBcInBlblwiO1xuICAgICAgY29uc3Qgb3V0VGFyZ2V0ID0gdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEub3ZlclRhcmdldHMpO1xuICAgICAgY29uc3Qgb3V0RXZlbnQgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tLCBcInBvaW50ZXJvdXRcIiwgb3V0VGFyZ2V0KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChvdXRFdmVudCk7XG4gICAgICBpZiAoaXNNb3VzZSlcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG91dEV2ZW50LCBcIm1vdXNlb3V0XCIpO1xuICAgICAgY29uc3QgbGVhdmVFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIFwicG9pbnRlcmxlYXZlXCIsIG91dFRhcmdldCk7XG4gICAgICBsZWF2ZUV2ZW50LmV2ZW50UGhhc2UgPSBsZWF2ZUV2ZW50LkFUX1RBUkdFVDtcbiAgICAgIHdoaWxlIChsZWF2ZUV2ZW50LnRhcmdldCAmJiBsZWF2ZUV2ZW50LnRhcmdldCAhPT0gdGhpcy5yb290VGFyZ2V0LnBhcmVudCkge1xuICAgICAgICBsZWF2ZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldDtcbiAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQobGVhdmVFdmVudCk7XG4gICAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQsIFwibW91c2VsZWF2ZVwiKTtcbiAgICAgICAgbGVhdmVFdmVudC50YXJnZXQgPSBsZWF2ZUV2ZW50LnRhcmdldC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBudWxsO1xuICAgICAgdGhpcy5mcmVlRXZlbnQob3V0RXZlbnQpO1xuICAgICAgdGhpcy5mcmVlRXZlbnQobGVhdmVFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTWFwcyB0aGUgdXBzdHJlYW0gYHBvaW50ZXJ1cGAgZXZlbnQgdG8gZG93bnN0cmVhbSBgcG9pbnRlcnVwYCwgYHBvaW50ZXJ1cG91dHNpZGVgLFxuICAgKiBhbmQgYGNsaWNrYC9gcmlnaHRjbGlja2AvYHBvaW50ZXJ0YXBgIGV2ZW50cywgaW4gdGhhdCBvcmRlci5cbiAgICpcbiAgICogVGhlIGBwb2ludGVydXBvdXRzaWRlYCBldmVudCBidWJibGVzIGZyb20gdGhlIG9yaWdpbmFsIGBwb2ludGVyZG93bmAgdGFyZ2V0IHRvIHRoZSBtb3N0IHNwZWNpZmljXG4gICAqIGFuY2VzdG9yIG9mIHRoZSBgcG9pbnRlcmRvd25gIGFuZCBgcG9pbnRlcnVwYCB0YXJnZXRzLCB3aGljaCBpcyBhbHNvIHRoZSBgY2xpY2tgIGV2ZW50J3MgdGFyZ2V0LiBgdG91Y2hlbmRgLFxuICAgKiBgcmlnaHR1cGAsIGBtb3VzZXVwYCwgYHRvdWNoZW5kb3V0c2lkZWAsIGByaWdodHVwb3V0c2lkZWAsIGBtb3VzZXVwb3V0c2lkZWAsIGFuZCBgdGFwYCBhcmUgZmlyZWQgYXMgd2VsbCBmb3JcbiAgICogc3BlY2lmaWMgcG9pbnRlciB0eXBlcy5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgdXBzdHJlYW0gYHBvaW50ZXJ1cGAgZXZlbnQuXG4gICAqL1xuICBtYXBQb2ludGVyVXAoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICB3YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcnVwXCIpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInRvdWNoZW5kXCIpO1xuICAgIH0gZWxzZSBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCIpIHtcbiAgICAgIGNvbnN0IGlzUmlnaHRCdXR0b24gPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBpc1JpZ2h0QnV0dG9uID8gXCJyaWdodHVwXCIgOiBcIm1vdXNldXBcIik7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBjb25zdCBwcmVzc1RhcmdldCA9IHRoaXMuZmluZE1vdW50ZWRUYXJnZXQodHJhY2tpbmdEYXRhLnByZXNzVGFyZ2V0c0J5QnV0dG9uW2Zyb20uYnV0dG9uXSk7XG4gICAgbGV0IGNsaWNrVGFyZ2V0ID0gcHJlc3NUYXJnZXQ7XG4gICAgaWYgKHByZXNzVGFyZ2V0ICYmICFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKHByZXNzVGFyZ2V0KSkge1xuICAgICAgbGV0IGN1cnJlbnRUYXJnZXQgPSBwcmVzc1RhcmdldDtcbiAgICAgIHdoaWxlIChjdXJyZW50VGFyZ2V0ICYmICFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgIGUuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIFwicG9pbnRlcnVwb3V0c2lkZVwiKTtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIFwidG91Y2hlbmRvdXRzaWRlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSB7XG4gICAgICAgICAgY29uc3QgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyO1xuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIGlzUmlnaHRCdXR0b24gPyBcInJpZ2h0dXBvdXRzaWRlXCIgOiBcIm1vdXNldXBvdXRzaWRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dO1xuICAgICAgY2xpY2tUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoY2xpY2tUYXJnZXQpIHtcbiAgICAgIGNvbnN0IGNsaWNrRXZlbnQgPSB0aGlzLmNsb25lUG9pbnRlckV2ZW50KGUsIFwiY2xpY2tcIik7XG4gICAgICBjbGlja0V2ZW50LnRhcmdldCA9IGNsaWNrVGFyZ2V0O1xuICAgICAgY2xpY2tFdmVudC5wYXRoID0gbnVsbDtcbiAgICAgIGlmICghdHJhY2tpbmdEYXRhLmNsaWNrc0J5QnV0dG9uW2Zyb20uYnV0dG9uXSkge1xuICAgICAgICB0cmFja2luZ0RhdGEuY2xpY2tzQnlCdXR0b25bZnJvbS5idXR0b25dID0ge1xuICAgICAgICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgICAgICAgdGFyZ2V0OiBjbGlja0V2ZW50LnRhcmdldCxcbiAgICAgICAgICB0aW1lU3RhbXA6IG5vd1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY2xpY2tIaXN0b3J5ID0gdHJhY2tpbmdEYXRhLmNsaWNrc0J5QnV0dG9uW2Zyb20uYnV0dG9uXTtcbiAgICAgIGlmIChjbGlja0hpc3RvcnkudGFyZ2V0ID09PSBjbGlja0V2ZW50LnRhcmdldCAmJiBub3cgLSBjbGlja0hpc3RvcnkudGltZVN0YW1wIDwgMjAwKSB7XG4gICAgICAgICsrY2xpY2tIaXN0b3J5LmNsaWNrQ291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGlja0hpc3RvcnkuY2xpY2tDb3VudCA9IDE7XG4gICAgICB9XG4gICAgICBjbGlja0hpc3RvcnkudGFyZ2V0ID0gY2xpY2tFdmVudC50YXJnZXQ7XG4gICAgICBjbGlja0hpc3RvcnkudGltZVN0YW1wID0gbm93O1xuICAgICAgY2xpY2tFdmVudC5kZXRhaWwgPSBjbGlja0hpc3RvcnkuY2xpY2tDb3VudDtcbiAgICAgIGlmIChjbGlja0V2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpIHtcbiAgICAgICAgY29uc3QgaXNSaWdodEJ1dHRvbiA9IGNsaWNrRXZlbnQuYnV0dG9uID09PSAyO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHRjbGlja1wiIDogXCJjbGlja1wiKTtcbiAgICAgIH0gZWxzZSBpZiAoY2xpY2tFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50LCBcInRhcFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50LCBcInBvaW50ZXJ0YXBcIik7XG4gICAgICB0aGlzLmZyZWVFdmVudChjbGlja0V2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5mcmVlRXZlbnQoZSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgdGhlIHVwc3RyZWFtIGBwb2ludGVydXBvdXRzaWRlYCBldmVudCB0byBhIGRvd25zdHJlYW0gYHBvaW50ZXJ1cG91dHNpZGVgIGV2ZW50LCBidWJibGluZyBmcm9tIHRoZSBvcmlnaW5hbFxuICAgKiBgcG9pbnRlcmRvd25gIHRhcmdldCB0byBgcm9vdFRhcmdldGAuXG4gICAqXG4gICAqIChUaGUgbW9zdCBzcGVjaWZpYyBhbmNlc3RvciBvZiB0aGUgYHBvaW50ZXJkb3duYCBldmVudCBhbmQgdGhlIGBwb2ludGVydXBgIGV2ZW50IG11c3QgdGhlXG4gICAqIGB7QGxpbmsgRXZlbnRCb3VuZGFyeX0ncyByb290IGJlY2F1c2UgdGhlIGBwb2ludGVydXBgIGV2ZW50IG9jY3VycmVkIG91dHNpZGUgb2YgdGhlIGJvdW5kYXJ5LilcbiAgICpcbiAgICogYHRvdWNoZW5kb3V0c2lkZWAsIGBtb3VzZXVwb3V0c2lkZWAsIGFuZCBgcmlnaHR1cG91dHNpZGVgIGV2ZW50cyBhcmUgZmlyZWQgYXMgd2VsbCBmb3Igc3BlY2lmaWMgcG9pbnRlclxuICAgKiB0eXBlcy4gVGhlIHRyYWNraW5nIGRhdGEgZm9yIHRoZSBzcGVjaWZpYyBwb2ludGVyIGlzIGNsZWFyZWQgb2YgYSBgcHJlc3NUYXJnZXRgLlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgcG9pbnRlcnVwb3V0c2lkZWAgZXZlbnQuXG4gICAqL1xuICBtYXBQb2ludGVyVXBPdXRzaWRlKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgd2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIGNvbnN0IHByZXNzVGFyZ2V0ID0gdGhpcy5maW5kTW91bnRlZFRhcmdldCh0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dKTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgaWYgKHByZXNzVGFyZ2V0KSB7XG4gICAgICBsZXQgY3VycmVudFRhcmdldCA9IHByZXNzVGFyZ2V0O1xuICAgICAgd2hpbGUgKGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJwb2ludGVydXBvdXRzaWRlXCIpO1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgXCJ0b3VjaGVuZG91dHNpZGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCIpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBlLmJ1dHRvbiA9PT0gMiA/IFwicmlnaHR1cG91dHNpZGVcIiA6IFwibW91c2V1cG91dHNpZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQucGFyZW50O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl07XG4gICAgfVxuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHRoZSB1cHN0cmVhbSBgd2hlZWxgIGV2ZW50IHRvIGEgZG93bnN0cmVhbSBgd2hlZWxgIGV2ZW50LlxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSB1cHN0cmVhbSBgd2hlZWxgIGV2ZW50LlxuICAgKi9cbiAgbWFwV2hlZWwoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRXaGVlbEV2ZW50KSkge1xuICAgICAgd2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi13aGVlbCBldmVudCBhcyBhIHdoZWVsIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aGVlbEV2ZW50ID0gdGhpcy5jcmVhdGVXaGVlbEV2ZW50KGZyb20pO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh3aGVlbEV2ZW50KTtcbiAgICB0aGlzLmZyZWVFdmVudCh3aGVlbEV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIG1vc3Qgc3BlY2lmaWMgZXZlbnQtdGFyZ2V0IGluIHRoZSBnaXZlbiBwcm9wYWdhdGlvbiBwYXRoIHRoYXQgaXMgc3RpbGwgbW91bnRlZCBpbiB0aGUgc2NlbmUgZ3JhcGguXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZCB0byBmaW5kIHRoZSBjb3JyZWN0IGBwb2ludGVydXBgIGFuZCBgcG9pbnRlcm91dGAgdGFyZ2V0IGluIHRoZSBjYXNlIHRoYXQgdGhlIG9yaWdpbmFsIGBwb2ludGVyZG93bmBcbiAgICogb3IgYHBvaW50ZXJvdmVyYCB0YXJnZXQgd2FzIHVubW91bnRlZCBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAgICogQHBhcmFtIHByb3BhZ2F0aW9uUGF0aCAtIFRoZSBwcm9wYWdhdGlvbiBwYXRoIHdhcyB2YWxpZCBpbiB0aGUgcGFzdC5cbiAgICogQHJldHVybnMgLSBUaGUgbW9zdCBzcGVjaWZpYyBldmVudC10YXJnZXQgc3RpbGwgbW91bnRlZCBhdCB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgc2NlbmUgZ3JhcGguXG4gICAqL1xuICBmaW5kTW91bnRlZFRhcmdldChwcm9wYWdhdGlvblBhdGgpIHtcbiAgICBpZiAoIXByb3BhZ2F0aW9uUGF0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gcHJvcGFnYXRpb25QYXRoWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcGFnYXRpb25QYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvcGFnYXRpb25QYXRoW2ldLnBhcmVudCA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgICBjdXJyZW50VGFyZ2V0ID0gcHJvcGFnYXRpb25QYXRoW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VGFyZ2V0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV2ZW50IHdob3NlIHtAY29kZSBvcmlnaW5hbEV2ZW50fSBpcyB7QGNvZGUgZnJvbX0sIHdpdGggYW4gb3B0aW9uYWwgYHR5cGVgIGFuZCBgdGFyZ2V0YCBvdmVycmlkZS5cbiAgICpcbiAgICogVGhlIGV2ZW50IGlzIGFsbG9jYXRlZCB1c2luZyB7QGxpbmsgRXZlbnRCb3VuZGFyeSNhbGxvY2F0ZUV2ZW50IHRoaXMuYWxsb2NhdGVFdmVudH0uXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHtAY29kZSBvcmlnaW5hbEV2ZW50fSBmb3IgdGhlIHJldHVybmVkIGV2ZW50LlxuICAgKiBAcGFyYW0gW3R5cGU9ZnJvbS50eXBlXSAtIFRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBldmVudC5cbiAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2YgdGhlIHJldHVybmVkIGV2ZW50LlxuICAgKi9cbiAgY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIHR5cGUsIHRhcmdldCkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgdGhpcy5jb3B5UG9pbnRlckRhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCk7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBmcm9tLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tO1xuICAgIGV2ZW50LnRhcmdldCA9IHRhcmdldCA/PyB0aGlzLmhpdFRlc3QoZXZlbnQuZ2xvYmFsLngsIGV2ZW50Lmdsb2JhbC55KSA/PyB0aGlzLl9oaXRFbGVtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB3aGVlbCBldmVudCB3aG9zZSB7QGNvZGUgb3JpZ2luYWxFdmVudH0gaXMge0Bjb2RlIGZyb219LlxuICAgKlxuICAgKiBUaGUgZXZlbnQgaXMgYWxsb2NhdGVkIHVzaW5nIHtAbGluayBFdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnQgdGhpcy5hbGxvY2F0ZUV2ZW50fS5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgdXBzdHJlYW0gd2hlZWwgZXZlbnQuXG4gICAqL1xuICBjcmVhdGVXaGVlbEV2ZW50KGZyb20pIHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuYWxsb2NhdGVFdmVudChGZWRlcmF0ZWRXaGVlbEV2ZW50KTtcbiAgICB0aGlzLmNvcHlXaGVlbERhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCk7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBmcm9tLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tO1xuICAgIGV2ZW50LnRhcmdldCA9IHRoaXMuaGl0VGVzdChldmVudC5nbG9iYWwueCwgZXZlbnQuZ2xvYmFsLnkpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBldmVudCB7QGNvZGUgZnJvbX0sIHdpdGggYW4gb3B0aW9uYWwge0Bjb2RlIHR5cGV9IG92ZXJyaWRlLlxuICAgKlxuICAgKiBUaGUgZXZlbnQgaXMgYWxsb2NhdGVkIHVzaW5nIHtAbGluayBFdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnQgdGhpcy5hbGxvY2F0ZUV2ZW50fS5cbiAgICogQHBhcmFtIGZyb20gLSBUaGUgZXZlbnQgdG8gY2xvbmUuXG4gICAqIEBwYXJhbSBbdHlwZT1mcm9tLnR5cGVdIC0gVGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGV2ZW50LlxuICAgKi9cbiAgY2xvbmVQb2ludGVyRXZlbnQoZnJvbSwgdHlwZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hbGxvY2F0ZUV2ZW50KEZlZGVyYXRlZFBvaW50ZXJFdmVudCk7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBmcm9tLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tLm9yaWdpbmFsRXZlbnQ7XG4gICAgdGhpcy5jb3B5UG9pbnRlckRhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCk7XG4gICAgZXZlbnQudGFyZ2V0ID0gZnJvbS50YXJnZXQ7XG4gICAgZXZlbnQucGF0aCA9IGZyb20uY29tcG9zZWRQYXRoKCkuc2xpY2UoKTtcbiAgICBldmVudC50eXBlID0gdHlwZSA/PyBldmVudC50eXBlO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHdoZWVsIHtAbGluayBGZWRlcmF0ZWRXaGVlbEV2ZW50fSBkYXRhIGZyb20ge0Bjb2RlIGZyb219IGludG8ge0Bjb2RlIHRvfS5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQ6XG4gICAqICsgZGVsdGFNb2RlXG4gICAqICsgZGVsdGFYXG4gICAqICsgZGVsdGFZXG4gICAqICsgZGVsdGFaXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIGV2ZW50IHRvIGNvcHkgZGF0YSBmcm9tLlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZXZlbnQgdG8gY29weSBkYXRhIGludG8uXG4gICAqL1xuICBjb3B5V2hlZWxEYXRhKGZyb20sIHRvKSB7XG4gICAgdG8uZGVsdGFNb2RlID0gZnJvbS5kZWx0YU1vZGU7XG4gICAgdG8uZGVsdGFYID0gZnJvbS5kZWx0YVg7XG4gICAgdG8uZGVsdGFZID0gZnJvbS5kZWx0YVk7XG4gICAgdG8uZGVsdGFaID0gZnJvbS5kZWx0YVo7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBwb2ludGVyIHtAbGluayBGZWRlcmF0ZWRQb2ludGVyRXZlbnR9IGRhdGEgZnJvbSB7QGNvZGUgZnJvbX0gaW50byB7QGNvZGUgdG99LlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGNvcGllZDpcbiAgICogKyBwb2ludGVySWRcbiAgICogKyB3aWR0aFxuICAgKiArIGhlaWdodFxuICAgKiArIGlzUHJpbWFyeVxuICAgKiArIHBvaW50ZXJUeXBlXG4gICAqICsgcHJlc3N1cmVcbiAgICogKyB0YW5nZW50aWFsUHJlc3N1cmVcbiAgICogKyB0aWx0WFxuICAgKiArIHRpbHRZXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIGV2ZW50IHRvIGNvcHkgZGF0YSBmcm9tLlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZXZlbnQgdG8gY29weSBkYXRhIGludG8uXG4gICAqL1xuICBjb3B5UG9pbnRlckRhdGEoZnJvbSwgdG8pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50ICYmIHRvIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSlcbiAgICAgIHJldHVybjtcbiAgICB0by5wb2ludGVySWQgPSBmcm9tLnBvaW50ZXJJZDtcbiAgICB0by53aWR0aCA9IGZyb20ud2lkdGg7XG4gICAgdG8uaGVpZ2h0ID0gZnJvbS5oZWlnaHQ7XG4gICAgdG8uaXNQcmltYXJ5ID0gZnJvbS5pc1ByaW1hcnk7XG4gICAgdG8ucG9pbnRlclR5cGUgPSBmcm9tLnBvaW50ZXJUeXBlO1xuICAgIHRvLnByZXNzdXJlID0gZnJvbS5wcmVzc3VyZTtcbiAgICB0by50YW5nZW50aWFsUHJlc3N1cmUgPSBmcm9tLnRhbmdlbnRpYWxQcmVzc3VyZTtcbiAgICB0by50aWx0WCA9IGZyb20udGlsdFg7XG4gICAgdG8udGlsdFkgPSBmcm9tLnRpbHRZO1xuICAgIHRvLnR3aXN0ID0gZnJvbS50d2lzdDtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIG1vdXNlIHtAbGluayBGZWRlcmF0ZWRNb3VzZUV2ZW50fSBkYXRhIGZyb20ge0Bjb2RlIGZyb219IHRvIHtAY29kZSB0b30uXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgY29waWVkOlxuICAgKiArIGFsdEtleVxuICAgKiArIGJ1dHRvblxuICAgKiArIGJ1dHRvbnNcbiAgICogKyBjbGllbnRYXG4gICAqICsgY2xpZW50WVxuICAgKiArIG1ldGFLZXlcbiAgICogKyBtb3ZlbWVudFhcbiAgICogKyBtb3ZlbWVudFlcbiAgICogKyBwYWdlWFxuICAgKiArIHBhZ2VZXG4gICAqICsgeFxuICAgKiArIHlcbiAgICogKyBzY3JlZW5cbiAgICogKyBzaGlmdEtleVxuICAgKiArIGdsb2JhbFxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBldmVudCB0byBjb3B5IGRhdGEgZnJvbS5cbiAgICogQHBhcmFtIHRvIC0gVGhlIGV2ZW50IHRvIGNvcHkgZGF0YSBpbnRvLlxuICAgKi9cbiAgY29weU1vdXNlRGF0YShmcm9tLCB0bykge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRNb3VzZUV2ZW50ICYmIHRvIGluc3RhbmNlb2YgRmVkZXJhdGVkTW91c2VFdmVudCkpXG4gICAgICByZXR1cm47XG4gICAgdG8uYWx0S2V5ID0gZnJvbS5hbHRLZXk7XG4gICAgdG8uYnV0dG9uID0gZnJvbS5idXR0b247XG4gICAgdG8uYnV0dG9ucyA9IGZyb20uYnV0dG9ucztcbiAgICB0by5jbGllbnQuY29weUZyb20oZnJvbS5jbGllbnQpO1xuICAgIHRvLmN0cmxLZXkgPSBmcm9tLmN0cmxLZXk7XG4gICAgdG8ubWV0YUtleSA9IGZyb20ubWV0YUtleTtcbiAgICB0by5tb3ZlbWVudC5jb3B5RnJvbShmcm9tLm1vdmVtZW50KTtcbiAgICB0by5zY3JlZW4uY29weUZyb20oZnJvbS5zY3JlZW4pO1xuICAgIHRvLnNoaWZ0S2V5ID0gZnJvbS5zaGlmdEtleTtcbiAgICB0by5nbG9iYWwuY29weUZyb20oZnJvbS5nbG9iYWwpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYmFzZSB7QGxpbmsgRmVkZXJhdGVkRXZlbnR9IGRhdGEgZnJvbSB7QGNvZGUgZnJvbX0gaW50byB7QGNvZGUgdG99LlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGNvcGllZDpcbiAgICogKyBpc1RydXN0ZWRcbiAgICogKyBzcmNFbGVtZW50XG4gICAqICsgdGltZVN0YW1wXG4gICAqICsgdHlwZVxuICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBldmVudCB0byBjb3B5IGRhdGEgZnJvbS5cbiAgICogQHBhcmFtIHRvIC0gVGhlIGV2ZW50IHRvIGNvcHkgZGF0YSBpbnRvLlxuICAgKi9cbiAgY29weURhdGEoZnJvbSwgdG8pIHtcbiAgICB0by5pc1RydXN0ZWQgPSBmcm9tLmlzVHJ1c3RlZDtcbiAgICB0by5zcmNFbGVtZW50ID0gZnJvbS5zcmNFbGVtZW50O1xuICAgIHRvLnRpbWVTdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRvLnR5cGUgPSBmcm9tLnR5cGU7XG4gICAgdG8uZGV0YWlsID0gZnJvbS5kZXRhaWw7XG4gICAgdG8udmlldyA9IGZyb20udmlldztcbiAgICB0by53aGljaCA9IGZyb20ud2hpY2g7XG4gICAgdG8ubGF5ZXIuY29weUZyb20oZnJvbS5sYXllcik7XG4gICAgdG8ucGFnZS5jb3B5RnJvbShmcm9tLnBhZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gaWQgLSBUaGUgcG9pbnRlciBJRC5cbiAgICogQHJldHVybnMgVGhlIHRyYWNraW5nIGRhdGEgc3RvcmVkIGZvciB0aGUgZ2l2ZW4gcG9pbnRlci4gSWYgbm8gZGF0YSBleGlzdHMsIGEgYmxhbmtcbiAgICogIHN0YXRlIHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIHRyYWNraW5nRGF0YShpZCkge1xuICAgIGlmICghdGhpcy5tYXBwaW5nU3RhdGUudHJhY2tpbmdEYXRhW2lkXSkge1xuICAgICAgdGhpcy5tYXBwaW5nU3RhdGUudHJhY2tpbmdEYXRhW2lkXSA9IHtcbiAgICAgICAgcHJlc3NUYXJnZXRzQnlCdXR0b246IHt9LFxuICAgICAgICBjbGlja3NCeUJ1dHRvbjoge30sXG4gICAgICAgIG92ZXJUYXJnZXQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hcHBpbmdTdGF0ZS50cmFja2luZ0RhdGFbaWRdO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvY2F0ZSBhIHNwZWNpZmljIHR5cGUgb2YgZXZlbnQgZnJvbSB7QGxpbmsgRXZlbnRCb3VuZGFyeSNldmVudFBvb2wgdGhpcy5ldmVudFBvb2x9LlxuICAgKlxuICAgKiBUaGlzIGFsbG9jYXRpb24gaXMgY29uc3RydWN0b3ItYWdub3N0aWMsIGFzIGxvbmcgYXMgaXQgb25seSB0YWtlcyBvbmUgYXJndW1lbnQgLSB0aGlzIGV2ZW50XG4gICAqIGJvdW5kYXJ5LlxuICAgKiBAcGFyYW0gY29uc3RydWN0b3IgLSBUaGUgZXZlbnQncyBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGFsbG9jYXRlRXZlbnQoY29uc3RydWN0b3IpIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRQb29sLmhhcyhjb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRoaXMuZXZlbnRQb29sLnNldChjb25zdHJ1Y3RvciwgW10pO1xuICAgIH1cbiAgICBjb25zdCBldmVudCA9IHRoaXMuZXZlbnRQb29sLmdldChjb25zdHJ1Y3RvcikucG9wKCkgfHwgbmV3IGNvbnN0cnVjdG9yKHRoaXMpO1xuICAgIGV2ZW50LmV2ZW50UGhhc2UgPSBldmVudC5OT05FO1xuICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIGV2ZW50LnBhdGggPSBudWxsO1xuICAgIGV2ZW50LnRhcmdldCA9IG51bGw7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBGcmVlcyB0aGUgZXZlbnQgYW5kIHB1dHMgaXQgYmFjayBpbnRvIHRoZSBldmVudCBwb29sLlxuICAgKlxuICAgKiBJdCBpcyBpbGxlZ2FsIHRvIHJldXNlIHRoZSBldmVudCB1bnRpbCBpdCBpcyBhbGxvY2F0ZWQgYWdhaW4sIHVzaW5nIGB0aGlzLmFsbG9jYXRlRXZlbnRgLlxuICAgKlxuICAgKiBJdCBpcyBhbHNvIGFkdmlzZWQgdGhhdCBldmVudHMgbm90IGFsbG9jYXRlZCBmcm9tIHtAbGluayBFdmVudEJvdW5kYXJ5I2FsbG9jYXRlRXZlbnQgdGhpcy5hbGxvY2F0ZUV2ZW50fVxuICAgKiBub3QgYmUgZnJlZWQuIFRoaXMgaXMgYmVjYXVzZSBvZiB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgc2FtZSBldmVudCBpcyBmcmVlZCB0d2ljZSwgd2hpY2ggY2FuIGNhdXNlXG4gICAqIGl0IHRvIGJlIGFsbG9jYXRlZCB0d2ljZSAmIHJlc3VsdCBpbiBvdmVyd3JpdGluZy5cbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IHRvIGJlIGZyZWVkLlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBldmVudCBpcyBtYW5hZ2VkIGJ5IGFub3RoZXIgZXZlbnQgYm91bmRhcnkuXG4gICAqL1xuICBmcmVlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQubWFuYWdlciAhPT0gdGhpcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0IGlzIGlsbGVnYWwgdG8gZnJlZSBhbiBldmVudCBub3QgbWFuYWdlZCBieSB0aGlzIEV2ZW50Qm91bmRhcnkhXCIpO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZXZlbnQuY29uc3RydWN0b3I7XG4gICAgaWYgKCF0aGlzLmV2ZW50UG9vbC5oYXMoY29uc3RydWN0b3IpKSB7XG4gICAgICB0aGlzLmV2ZW50UG9vbC5zZXQoY29uc3RydWN0b3IsIFtdKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudFBvb2wuZ2V0KGNvbnN0cnVjdG9yKS5wdXNoKGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogU2ltaWxhciB0byB7QGxpbmsgRXZlbnRFbWl0dGVyLmVtaXR9LCBleGNlcHQgaXQgc3RvcHMgaWYgdGhlIGBwcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZGAgZmxhZ1xuICAgKiBpcyBzZXQgb24gdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0gZSAtIFRoZSBldmVudCB0byBjYWxsIGVhY2ggbGlzdGVuZXIgd2l0aC5cbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgZXZlbnQga2V5LlxuICAgKi9cbiAgX25vdGlmeUxpc3RlbmVycyhlLCB0eXBlKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gZS5jdXJyZW50VGFyZ2V0Ll9ldmVudHNbdHlwZV07XG4gICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICByZXR1cm47XG4gICAgaWYgKFwiZm5cIiBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGlmIChsaXN0ZW5lcnMub25jZSlcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycy5mbiwgdm9pZCAwLCB0cnVlKTtcbiAgICAgIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaiAmJiAhZS5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSlcbiAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldLmZuLCB2b2lkIDAsIHRydWUpO1xuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEV2ZW50Qm91bmRhcnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50Qm91bmRhcnkubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgRXZlbnRCb3VuZGFyeSB9IGZyb20gJy4vRXZlbnRCb3VuZGFyeS5tanMnO1xuaW1wb3J0IHsgRXZlbnRzVGlja2VyIH0gZnJvbSAnLi9FdmVudFRpY2tlci5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRQb2ludGVyRXZlbnQubWpzJztcbmltcG9ydCB7IEZlZGVyYXRlZFdoZWVsRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZFdoZWVsRXZlbnQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBNT1VTRV9QT0lOVEVSX0lEID0gMTtcbmNvbnN0IFRPVUNIX1RPX1BPSU5URVIgPSB7XG4gIHRvdWNoc3RhcnQ6IFwicG9pbnRlcmRvd25cIixcbiAgdG91Y2hlbmQ6IFwicG9pbnRlcnVwXCIsXG4gIHRvdWNoZW5kb3V0c2lkZTogXCJwb2ludGVydXBvdXRzaWRlXCIsXG4gIHRvdWNobW92ZTogXCJwb2ludGVybW92ZVwiLFxuICB0b3VjaGNhbmNlbDogXCJwb2ludGVyY2FuY2VsXCJcbn07XG5jb25zdCBfRXZlbnRTeXN0ZW0gPSBjbGFzcyBfRXZlbnRTeXN0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgLyoqIERvZXMgdGhlIGRldmljZSBzdXBwb3J0IHRvdWNoIGV2ZW50cyBodHRwczovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzLyAqL1xuICAgIHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyA9IFwib250b3VjaHN0YXJ0XCIgaW4gZ2xvYmFsVGhpcztcbiAgICAvKiogRG9lcyB0aGUgZGV2aWNlIHN1cHBvcnQgcG9pbnRlciBldmVudHMgaHR0cHM6Ly93d3cudzMub3JnL1N1Ym1pc3Npb24vcG9pbnRlci1ldmVudHMvICovXG4gICAgdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgPSAhIWdsb2JhbFRoaXMuUG9pbnRlckV2ZW50O1xuICAgIC8qKlxuICAgICAqIFRoZSBET00gZWxlbWVudCB0byB3aGljaCB0aGUgcm9vdCBldmVudCBsaXN0ZW5lcnMgYXJlIGJvdW5kLiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvXG4gICAgICogdGhlIHJlbmRlcmVyJ3Mge0BsaW5rIFJlbmRlcmVyI3ZpZXcgdmlld30uXG4gICAgICovXG4gICAgdGhpcy5kb21FbGVtZW50ID0gbnVsbDtcbiAgICAvKiogVGhlIHJlc29sdXRpb24gdXNlZCB0byBjb252ZXJ0IGJldHdlZW4gdGhlIERPTSBjbGllbnQgc3BhY2UgaW50byB3b3JsZCBzcGFjZS4gKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeSA9IG5ldyBFdmVudEJvdW5kYXJ5KG51bGwpO1xuICAgIEV2ZW50c1RpY2tlci5pbml0KHRoaXMpO1xuICAgIHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICB0aGlzLl9ldmVudHNBZGRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jvb3RQb2ludGVyRXZlbnQgPSBuZXcgRmVkZXJhdGVkUG9pbnRlckV2ZW50KG51bGwpO1xuICAgIHRoaXMuX3Jvb3RXaGVlbEV2ZW50ID0gbmV3IEZlZGVyYXRlZFdoZWVsRXZlbnQobnVsbCk7XG4gICAgdGhpcy5jdXJzb3JTdHlsZXMgPSB7XG4gICAgICBkZWZhdWx0OiBcImluaGVyaXRcIixcbiAgICAgIHBvaW50ZXI6IFwicG9pbnRlclwiXG4gICAgfTtcbiAgICB0aGlzLmZlYXR1cmVzID0gbmV3IFByb3h5KHsgLi4uX0V2ZW50U3lzdGVtLmRlZmF1bHRFdmVudEZlYXR1cmVzIH0sIHtcbiAgICAgIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoa2V5ID09PSBcImdsb2JhbE1vdmVcIikge1xuICAgICAgICAgIHRoaXMucm9vdEJvdW5kYXJ5LmVuYWJsZUdsb2JhbE1vdmVFdmVudHMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9vblBvaW50ZXJEb3duID0gdGhpcy5fb25Qb2ludGVyRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUG9pbnRlck1vdmUgPSB0aGlzLl9vblBvaW50ZXJNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Qb2ludGVyVXAgPSB0aGlzLl9vblBvaW50ZXJVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUG9pbnRlck92ZXJPdXQgPSB0aGlzLl9vblBvaW50ZXJPdmVyT3V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbldoZWVsID0gdGhpcy5vbldoZWVsLmJpbmQodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGludGVyYWN0aW9uIG1vZGUgZm9yIGFsbCBkaXNwbGF5IG9iamVjdHMuXG4gICAqIEBzZWUgQ29udGFpbmVyLmV2ZW50TW9kZVxuICAgKiBAdHlwZSB7RXZlbnRNb2RlfVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHNpbmNlIDcuMi4wXG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRFdmVudE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRFdmVudE1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJ1bm5lciBpbml0IGNhbGxlZCwgdmlldyBpcyBhdmFpbGFibGUgYXQgdGhpcyBwb2ludC5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjYW52YXMsIHJlc29sdXRpb24gfSA9IHRoaXMucmVuZGVyZXI7XG4gICAgdGhpcy5zZXRUYXJnZXRFbGVtZW50KGNhbnZhcyk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBfRXZlbnRTeXN0ZW0uX2RlZmF1bHRFdmVudE1vZGUgPSBvcHRpb25zLmV2ZW50TW9kZSA/PyBcInBhc3NpdmVcIjtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZmVhdHVyZXMsIG9wdGlvbnMuZXZlbnRGZWF0dXJlcyA/PyB7fSk7XG4gICAgdGhpcy5yb290Qm91bmRhcnkuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA9IHRoaXMuZmVhdHVyZXMuZ2xvYmFsTW92ZTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGNoYW5naW5nIHJlc29sdXRpb24uXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHJlc29sdXRpb25DaGFuZ2UocmVzb2x1dGlvbikge1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gIH1cbiAgLyoqIERlc3Ryb3lzIGFsbCBldmVudCBsaXN0ZW5lcnMgYW5kIGRldGFjaGVzIHRoZSByZW5kZXJlci4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNldFRhcmdldEVsZW1lbnQobnVsbCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5fY3VycmVudEN1cnNvciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgY3Vyc29yIG1vZGUsIGhhbmRsaW5nIGFueSBjYWxsYmFja3Mgb3IgQ1NTIHN0eWxlIGNoYW5nZXMuXG4gICAqIEBwYXJhbSBtb2RlIC0gY3Vyc29yIG1vZGUsIGEga2V5IGZyb20gdGhlIGN1cnNvclN0eWxlcyBkaWN0aW9uYXJ5XG4gICAqL1xuICBzZXRDdXJzb3IobW9kZSkge1xuICAgIG1vZGUgPSBtb2RlIHx8IFwiZGVmYXVsdFwiO1xuICAgIGxldCBhcHBseVN0eWxlcyA9IHRydWU7XG4gICAgaWYgKGdsb2JhbFRoaXMuT2Zmc2NyZWVuQ2FudmFzICYmIHRoaXMuZG9tRWxlbWVudCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgYXBwbHlTdHlsZXMgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRDdXJzb3IgPT09IG1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudEN1cnNvciA9IG1vZGU7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmN1cnNvclN0eWxlc1ttb2RlXTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHN0eWxlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBpZiAoYXBwbHlTdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5jdXJzb3IgPSBzdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHN0eWxlKG1vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgaWYgKGFwcGx5U3R5bGVzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZG9tRWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFwcGx5U3R5bGVzICYmIHR5cGVvZiBtb2RlID09PSBcInN0cmluZ1wiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jdXJzb3JTdHlsZXMsIG1vZGUpKSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gbW9kZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBnbG9iYWwgcG9pbnRlciBldmVudC5cbiAgICogVXNlZnVsIGZvciBnZXR0aW5nIHRoZSBwb2ludGVyIHBvc2l0aW9uIHdpdGhvdXQgbGlzdGVuaW5nIHRvIGV2ZW50cy5cbiAgICogQHNpbmNlIDcuMi4wXG4gICAqL1xuICBnZXQgcG9pbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdFBvaW50ZXJFdmVudDtcbiAgfVxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgcG9pbnRlciBkb3duIGV2ZW50cyBvbiB7QGxpbmsgRXZlbnRTeXN0ZW0jZG9tRWxlbWVudCB0aGlzLmRvbUVsZW1lbnR9LlxuICAgKiBAcGFyYW0gbmF0aXZlRXZlbnQgLSBUaGUgbmF0aXZlIG1vdXNlL3BvaW50ZXIvdG91Y2ggZXZlbnQuXG4gICAqL1xuICBfb25Qb2ludGVyRG93bihuYXRpdmVFdmVudCkge1xuICAgIGlmICghdGhpcy5mZWF0dXJlcy5jbGljaylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5yb290VGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5fbm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgaWYgKHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0ICYmIGV2ZW50c1swXS5pc05vcm1hbGl6ZWQpIHtcbiAgICAgIGNvbnN0IGNhbmNlbGFibGUgPSBuYXRpdmVFdmVudC5jYW5jZWxhYmxlIHx8ICEoXCJjYW5jZWxhYmxlXCIgaW4gbmF0aXZlRXZlbnQpO1xuICAgICAgaWYgKGNhbmNlbGFibGUpIHtcbiAgICAgICAgbmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBldmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCBuYXRpdmVFdmVudDIgPSBldmVudHNbaV07XG4gICAgICBjb25zdCBmZWRlcmF0ZWRFdmVudCA9IHRoaXMuX2Jvb3RzdHJhcEV2ZW50KHRoaXMuX3Jvb3RQb2ludGVyRXZlbnQsIG5hdGl2ZUV2ZW50Mik7XG4gICAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChmZWRlcmF0ZWRFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHBvaW50ZXIgbW92ZSBldmVudHMgb24gb24ge0BsaW5rIEV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgdGhpcy5kb21FbGVtZW50fS5cbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50IC0gVGhlIG5hdGl2ZSBtb3VzZS9wb2ludGVyL3RvdWNoIGV2ZW50cy5cbiAgICovXG4gIF9vblBvaW50ZXJNb3ZlKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLm1vdmUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIEV2ZW50c1RpY2tlci5wb2ludGVyTW92ZWQoKTtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gdGhpcy5fbm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBub3JtYWxpemVkRXZlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLl9ib290c3RyYXBFdmVudCh0aGlzLl9yb290UG9pbnRlckV2ZW50LCBub3JtYWxpemVkRXZlbnRzW2ldKTtcbiAgICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IodGhpcy5yb290Qm91bmRhcnkuY3Vyc29yKTtcbiAgfVxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgcG9pbnRlciB1cCBldmVudHMgb24ge0BsaW5rIEV2ZW50U3lzdGVtI2RvbUVsZW1lbnQgdGhpcy5kb21FbGVtZW50fS5cbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50IC0gVGhlIG5hdGl2ZSBtb3VzZS9wb2ludGVyL3RvdWNoIGV2ZW50LlxuICAgKi9cbiAgX29uUG9pbnRlclVwKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLmNsaWNrKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgICBsZXQgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0O1xuICAgIGlmIChuYXRpdmVFdmVudC5jb21wb3NlZFBhdGggJiYgbmF0aXZlRXZlbnQuY29tcG9zZWRQYXRoKCkubGVuZ3RoID4gMCkge1xuICAgICAgdGFyZ2V0ID0gbmF0aXZlRXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgfVxuICAgIGNvbnN0IG91dHNpZGUgPSB0YXJnZXQgIT09IHRoaXMuZG9tRWxlbWVudCA/IFwib3V0c2lkZVwiIDogXCJcIjtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gdGhpcy5fbm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBub3JtYWxpemVkRXZlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLl9ib290c3RyYXBFdmVudCh0aGlzLl9yb290UG9pbnRlckV2ZW50LCBub3JtYWxpemVkRXZlbnRzW2ldKTtcbiAgICAgIGV2ZW50LnR5cGUgKz0gb3V0c2lkZTtcbiAgICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IodGhpcy5yb290Qm91bmRhcnkuY3Vyc29yKTtcbiAgfVxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgcG9pbnRlciBvdmVyICYgb3V0IGV2ZW50cyBvbiB7QGxpbmsgRXZlbnRTeXN0ZW0jZG9tRWxlbWVudCB0aGlzLmRvbUVsZW1lbnR9LlxuICAgKiBAcGFyYW0gbmF0aXZlRXZlbnQgLSBUaGUgbmF0aXZlIG1vdXNlL3BvaW50ZXIvdG91Y2ggZXZlbnQuXG4gICAqL1xuICBfb25Qb2ludGVyT3Zlck91dChuYXRpdmVFdmVudCkge1xuICAgIGlmICghdGhpcy5mZWF0dXJlcy5jbGljaylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5yb290VGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50cyA9IHRoaXMuX25vcm1hbGl6ZVRvUG9pbnRlckRhdGEobmF0aXZlRXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gbm9ybWFsaXplZEV2ZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fYm9vdHN0cmFwRXZlbnQodGhpcy5fcm9vdFBvaW50ZXJFdmVudCwgbm9ybWFsaXplZEV2ZW50c1tpXSk7XG4gICAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3NpdmUgaGFuZGxlciBmb3IgYHdoZWVsYCBldmVudHMgb24ge0BsaW5rIEV2ZW50U3lzdGVtLmRvbUVsZW1lbnQgdGhpcy5kb21FbGVtZW50fS5cbiAgICogQHBhcmFtIG5hdGl2ZUV2ZW50IC0gVGhlIG5hdGl2ZSB3aGVlbCBldmVudC5cbiAgICovXG4gIG9uV2hlZWwobmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMud2hlZWwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgd2hlZWxFdmVudCA9IHRoaXMubm9ybWFsaXplV2hlZWxFdmVudChuYXRpdmVFdmVudCk7XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KHdoZWVsRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB7QGxpbmsgRXZlbnRTeXN0ZW0jZG9tRWxlbWVudCBkb21FbGVtZW50fSBhbmQgYmluZHMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBUbyBkZXJlZ2lzdGVyIHRoZSBjdXJyZW50IERPTSBlbGVtZW50IHdpdGhvdXQgc2V0dGluZyBhIG5ldyBvbmUsIHBhc3Mge0Bjb2RlIG51bGx9LlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBuZXcgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBzZXRUYXJnZXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLl9yZW1vdmVFdmVudHMoKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBlbGVtZW50O1xuICAgIEV2ZW50c1RpY2tlci5kb21FbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9hZGRFdmVudHMoKTtcbiAgfVxuICAvKiogUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIG9uIHtAbGluayBSZW5kZXJlciNkb21FbGVtZW50IHRoaXMuZG9tRWxlbWVudH0uICovXG4gIF9hZGRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50c0FkZGVkIHx8ICF0aGlzLmRvbUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRXZlbnRzVGlja2VyLmFkZFRpY2tlckxpc3RlbmVyKCk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmRvbUVsZW1lbnQuc3R5bGU7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBpZiAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgICBzdHlsZS5tc0NvbnRlbnRab29taW5nID0gXCJub25lXCI7XG4gICAgICAgIHN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIm5vbmVcIjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgc3R5bGUudG91Y2hBY3Rpb24gPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICBnbG9iYWxUaGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLl9vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy5fb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLl9vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm92ZXJcIiwgdGhpcy5fb25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5fb25Qb2ludGVyVXAsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWxUaGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9vblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5fb25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCB0aGlzLl9vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fb25Qb2ludGVyVXAsIHRydWUpO1xuICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cykge1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fb25Qb2ludGVyVXAsIHRydWUpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwsIHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fZXZlbnRzQWRkZWQgPSB0cnVlO1xuICB9XG4gIC8qKiBVbnJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBvbiB7QGxpbmsgRXZlbnRTeXN0ZW0jZG9tRWxlbWVudCB0aGlzLmRvbUVsZW1lbnR9LiAqL1xuICBfcmVtb3ZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzQWRkZWQgfHwgIXRoaXMuZG9tRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBFdmVudHNUaWNrZXIucmVtb3ZlVGlja2VyTGlzdGVuZXIoKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZG9tRWxlbWVudC5zdHlsZTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGlmIChnbG9iYWxUaGlzLm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgIHN0eWxlLm1zQ29udGVudFpvb21pbmcgPSBcIlwiO1xuICAgICAgICBzdHlsZS5tc1RvdWNoQWN0aW9uID0gXCJcIjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgc3R5bGUudG91Y2hBY3Rpb24gPSBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuX29uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLl9vblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIHRoaXMuX29uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyb3ZlclwiLCB0aGlzLl9vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLl9vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX29uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCB0aGlzLl9vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMuX29uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9vblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl9vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX29uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwgdHJ1ZSk7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9ldmVudHNBZGRlZCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIHggYW5kIHkgY29vcmRzIGZyb20gYSBET00gb2JqZWN0IGFuZCBtYXBzIHRoZW0gY29ycmVjdGx5IHRvIHRoZSBQaXhpSlMgdmlldy4gVGhlXG4gICAqIHJlc3VsdGluZyB2YWx1ZSBpcyBzdG9yZWQgaW4gdGhlIHBvaW50LiBUaGlzIHRha2VzIGludG8gYWNjb3VudCB0aGUgZmFjdCB0aGF0IHRoZSBET01cbiAgICogZWxlbWVudCBjb3VsZCBiZSBzY2FsZWQgYW5kIHBvc2l0aW9uZWQgYW55d2hlcmUgb24gdGhlIHNjcmVlbi5cbiAgICogQHBhcmFtICB7UG9pbnREYXRhfSBwb2ludCAtIHRoZSBwb2ludCB0aGF0IHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgaW5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IC0gdGhlIHggY29vcmQgb2YgdGhlIHBvc2l0aW9uIHRvIG1hcFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB0aGUgeSBjb29yZCBvZiB0aGUgcG9zaXRpb24gdG8gbWFwXG4gICAqL1xuICBtYXBQb3NpdGlvblRvUG9pbnQocG9pbnQsIHgsIHkpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5kb21FbGVtZW50LmlzQ29ubmVjdGVkID8gdGhpcy5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogdGhpcy5kb21FbGVtZW50LndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmRvbUVsZW1lbnQuaGVpZ2h0LFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH07XG4gICAgY29uc3QgcmVzb2x1dGlvbk11bHRpcGxpZXIgPSAxIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHBvaW50LnggPSAoeCAtIHJlY3QubGVmdCkgKiAodGhpcy5kb21FbGVtZW50LndpZHRoIC8gcmVjdC53aWR0aCkgKiByZXNvbHV0aW9uTXVsdGlwbGllcjtcbiAgICBwb2ludC55ID0gKHkgLSByZWN0LnRvcCkgKiAodGhpcy5kb21FbGVtZW50LmhlaWdodCAvIHJlY3QuaGVpZ2h0KSAqIHJlc29sdXRpb25NdWx0aXBsaWVyO1xuICB9XG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdCBjb250YWlucyBhbGwgZGF0YSB0aGF0IGEgcmVndWxhciBwb2ludGVyIGV2ZW50IHdvdWxkIGhhdmVcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50IGRhdGEgZnJvbSBhIHRvdWNoIG9yIG1vdXNlIGV2ZW50XG4gICAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYSBzaW5nbGUgbm9ybWFsaXplZCBwb2ludGVyIGV2ZW50LCBpbiB0aGUgY2FzZSBvZiBhIHBvaW50ZXJcbiAgICogIG9yIG1vdXNlIGV2ZW50LCBvciBhIG11bHRpcGxlIG5vcm1hbGl6ZWQgcG9pbnRlciBldmVudHMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGNoYW5nZWQgdG91Y2hlc1xuICAgKi9cbiAgX25vcm1hbGl6ZVRvUG9pbnRlckRhdGEoZXZlbnQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gW107XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsaSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSA8IGxpOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5idXR0b24gPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2guYnV0dG9uID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5idXR0b25zID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLmJ1dHRvbnMgPSAxO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmlzUHJpbWFyeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRvdWNoLmlzUHJpbWFyeSA9IGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxICYmIGV2ZW50LnR5cGUgPT09IFwidG91Y2hzdGFydFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gud2lkdGggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gud2lkdGggPSB0b3VjaC5yYWRpdXNYIHx8IDE7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2guaGVpZ2h0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLmhlaWdodCA9IHRvdWNoLnJhZGl1c1kgfHwgMTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50aWx0WCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC50aWx0WCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGlsdFkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gudGlsdFkgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnBvaW50ZXJUeXBlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnBvaW50ZXJUeXBlID0gXCJ0b3VjaFwiO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnBvaW50ZXJJZCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5wb2ludGVySWQgPSB0b3VjaC5pZGVudGlmaWVyIHx8IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gucHJlc3N1cmUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gucHJlc3N1cmUgPSB0b3VjaC5mb3JjZSB8fCAwLjU7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gudHdpc3QgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gudHdpc3QgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnRhbmdlbnRpYWxQcmVzc3VyZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC50YW5nZW50aWFsUHJlc3N1cmUgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmxheWVyWCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5sYXllclggPSB0b3VjaC5vZmZzZXRYID0gdG91Y2guY2xpZW50WDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5sYXllclkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gubGF5ZXJZID0gdG91Y2gub2Zmc2V0WSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICAgIHRvdWNoLmlzTm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRvdWNoLnR5cGUgPSBldmVudC50eXBlO1xuICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2godG91Y2gpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdsb2JhbFRoaXMuTW91c2VFdmVudCB8fCBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgJiYgKCF0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyB8fCAhKGV2ZW50IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5Qb2ludGVyRXZlbnQpKSkge1xuICAgICAgY29uc3QgdGVtcEV2ZW50ID0gZXZlbnQ7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC5pc1ByaW1hcnkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC5pc1ByaW1hcnkgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQud2lkdGggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC53aWR0aCA9IDE7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC5oZWlnaHQgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC5oZWlnaHQgPSAxO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQudGlsdFggPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC50aWx0WCA9IDA7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC50aWx0WSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnRpbHRZID0gMDtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnBvaW50ZXJUeXBlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQucG9pbnRlclR5cGUgPSBcIm1vdXNlXCI7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC5wb2ludGVySWQgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC5wb2ludGVySWQgPSBNT1VTRV9QT0lOVEVSX0lEO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQucHJlc3N1cmUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC5wcmVzc3VyZSA9IDAuNTtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnR3aXN0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQudHdpc3QgPSAwO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQudGFuZ2VudGlhbFByZXNzdXJlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQudGFuZ2VudGlhbFByZXNzdXJlID0gMDtcbiAgICAgIHRlbXBFdmVudC5pc05vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKHRlbXBFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRFdmVudHMucHVzaChldmVudCk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkRXZlbnRzO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHRoZSBuYXRpdmUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby91aWV2ZW50cy8jaW50ZXJmYWNlLXdoZWVsZXZlbnQgV2hlZWxFdmVudH0uXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCB7QGxpbmsgRmVkZXJhdGVkV2hlZWxFdmVudH0gaXMgYSBzaGFyZWQgaW5zdGFuY2UuIEl0IHdpbGwgbm90IHBlcnNpc3QgYWNyb3NzXG4gICAqIG11bHRpcGxlIG5hdGl2ZSB3aGVlbCBldmVudHMuXG4gICAqIEBwYXJhbSBuYXRpdmVFdmVudCAtIFRoZSBuYXRpdmUgd2hlZWwgZXZlbnQgdGhhdCBvY2N1cnJlZCBvbiB0aGUgY2FudmFzLlxuICAgKiBAcmV0dXJucyBBIGZlZGVyYXRlZCB3aGVlbCBldmVudC5cbiAgICovXG4gIG5vcm1hbGl6ZVdoZWVsRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuX3Jvb3RXaGVlbEV2ZW50O1xuICAgIHRoaXMuX3RyYW5zZmVyTW91c2VEYXRhKGV2ZW50LCBuYXRpdmVFdmVudCk7XG4gICAgZXZlbnQuZGVsdGFYID0gbmF0aXZlRXZlbnQuZGVsdGFYO1xuICAgIGV2ZW50LmRlbHRhWSA9IG5hdGl2ZUV2ZW50LmRlbHRhWTtcbiAgICBldmVudC5kZWx0YVogPSBuYXRpdmVFdmVudC5kZWx0YVo7XG4gICAgZXZlbnQuZGVsdGFNb2RlID0gbmF0aXZlRXZlbnQuZGVsdGFNb2RlO1xuICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KGV2ZW50LnNjcmVlbiwgbmF0aXZlRXZlbnQuY2xpZW50WCwgbmF0aXZlRXZlbnQuY2xpZW50WSk7XG4gICAgZXZlbnQuZ2xvYmFsLmNvcHlGcm9tKGV2ZW50LnNjcmVlbik7XG4gICAgZXZlbnQub2Zmc2V0LmNvcHlGcm9tKGV2ZW50LnNjcmVlbik7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBldmVudC50eXBlID0gbmF0aXZlRXZlbnQudHlwZTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIGBuYXRpdmVFdmVudGAgaW50byBhIGZlZGVyYXRlZWQge0BsaW5rIEZlZGVyYXRlZFBvaW50ZXJFdmVudH0uXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gbmF0aXZlRXZlbnRcbiAgICovXG4gIF9ib290c3RyYXBFdmVudChldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICBldmVudC5vcmlnaW5hbEV2ZW50ID0gbnVsbDtcbiAgICBldmVudC5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50LnBvaW50ZXJJZCA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJJZDtcbiAgICBldmVudC53aWR0aCA9IG5hdGl2ZUV2ZW50LndpZHRoO1xuICAgIGV2ZW50LmhlaWdodCA9IG5hdGl2ZUV2ZW50LmhlaWdodDtcbiAgICBldmVudC5pc1ByaW1hcnkgPSBuYXRpdmVFdmVudC5pc1ByaW1hcnk7XG4gICAgZXZlbnQucG9pbnRlclR5cGUgPSBuYXRpdmVFdmVudC5wb2ludGVyVHlwZTtcbiAgICBldmVudC5wcmVzc3VyZSA9IG5hdGl2ZUV2ZW50LnByZXNzdXJlO1xuICAgIGV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IG5hdGl2ZUV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZTtcbiAgICBldmVudC50aWx0WCA9IG5hdGl2ZUV2ZW50LnRpbHRYO1xuICAgIGV2ZW50LnRpbHRZID0gbmF0aXZlRXZlbnQudGlsdFk7XG4gICAgZXZlbnQudHdpc3QgPSBuYXRpdmVFdmVudC50d2lzdDtcbiAgICB0aGlzLl90cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpO1xuICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KGV2ZW50LnNjcmVlbiwgbmF0aXZlRXZlbnQuY2xpZW50WCwgbmF0aXZlRXZlbnQuY2xpZW50WSk7XG4gICAgZXZlbnQuZ2xvYmFsLmNvcHlGcm9tKGV2ZW50LnNjcmVlbik7XG4gICAgZXZlbnQub2Zmc2V0LmNvcHlGcm9tKGV2ZW50LnNjcmVlbik7XG4gICAgZXZlbnQuaXNUcnVzdGVkID0gbmF0aXZlRXZlbnQuaXNUcnVzdGVkO1xuICAgIGlmIChldmVudC50eXBlID09PSBcInBvaW50ZXJsZWF2ZVwiKSB7XG4gICAgICBldmVudC50eXBlID0gXCJwb2ludGVyb3V0XCI7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJtb3VzZVwiKSkge1xuICAgICAgZXZlbnQudHlwZSA9IGV2ZW50LnR5cGUucmVwbGFjZShcIm1vdXNlXCIsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcInRvdWNoXCIpKSB7XG4gICAgICBldmVudC50eXBlID0gVE9VQ0hfVE9fUE9JTlRFUltldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZmVycyBiYXNlICYgbW91c2UgZXZlbnQgZGF0YSBmcm9tIHRoZSB7QGNvZGUgbmF0aXZlRXZlbnR9IHRvIHRoZSBmZWRlcmF0ZWQgZXZlbnQuXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gbmF0aXZlRXZlbnRcbiAgICovXG4gIF90cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpIHtcbiAgICBldmVudC5pc1RydXN0ZWQgPSBuYXRpdmVFdmVudC5pc1RydXN0ZWQ7XG4gICAgZXZlbnQuc3JjRWxlbWVudCA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgZXZlbnQudGltZVN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZXZlbnQudHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGU7XG4gICAgZXZlbnQuYWx0S2V5ID0gbmF0aXZlRXZlbnQuYWx0S2V5O1xuICAgIGV2ZW50LmJ1dHRvbiA9IG5hdGl2ZUV2ZW50LmJ1dHRvbjtcbiAgICBldmVudC5idXR0b25zID0gbmF0aXZlRXZlbnQuYnV0dG9ucztcbiAgICBldmVudC5jbGllbnQueCA9IG5hdGl2ZUV2ZW50LmNsaWVudFg7XG4gICAgZXZlbnQuY2xpZW50LnkgPSBuYXRpdmVFdmVudC5jbGllbnRZO1xuICAgIGV2ZW50LmN0cmxLZXkgPSBuYXRpdmVFdmVudC5jdHJsS2V5O1xuICAgIGV2ZW50Lm1ldGFLZXkgPSBuYXRpdmVFdmVudC5tZXRhS2V5O1xuICAgIGV2ZW50Lm1vdmVtZW50LnggPSBuYXRpdmVFdmVudC5tb3ZlbWVudFg7XG4gICAgZXZlbnQubW92ZW1lbnQueSA9IG5hdGl2ZUV2ZW50Lm1vdmVtZW50WTtcbiAgICBldmVudC5wYWdlLnggPSBuYXRpdmVFdmVudC5wYWdlWDtcbiAgICBldmVudC5wYWdlLnkgPSBuYXRpdmVFdmVudC5wYWdlWTtcbiAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICBldmVudC5zaGlmdEtleSA9IG5hdGl2ZUV2ZW50LnNoaWZ0S2V5O1xuICB9XG59O1xuLyoqIEBpZ25vcmUgKi9cbl9FdmVudFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIG5hbWU6IFwiZXZlbnRzXCIsXG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVU3lzdGVtXG4gIF0sXG4gIHByaW9yaXR5OiAtMVxufTtcbi8qKlxuICogVGhlIGV2ZW50IGZlYXR1cmVzIHRoYXQgYXJlIGVuYWJsZWQgYnkgdGhlIEV2ZW50U3lzdGVtXG4gKiAoaW5jbHVkZWQgaW4gdGhlICoqcGl4aS5qcyoqIGFuZCAqKnBpeGkuanMtbGVnYWN5KiogYnVuZGxlKSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAqIEBzaW5jZSA3LjIuMFxuICovXG5fRXZlbnRTeXN0ZW0uZGVmYXVsdEV2ZW50RmVhdHVyZXMgPSB7XG4gIC8qKiBFbmFibGVzIHBvaW50ZXIgZXZlbnRzIGFzc29jaWF0ZWQgd2l0aCBwb2ludGVyIG1vdmVtZW50LiAqL1xuICBtb3ZlOiB0cnVlLFxuICAvKiogRW5hYmxlcyBnbG9iYWwgcG9pbnRlciBtb3ZlIGV2ZW50cy4gKi9cbiAgZ2xvYmFsTW92ZTogdHJ1ZSxcbiAgLyoqIEVuYWJsZXMgcG9pbnRlciBldmVudHMgYXNzb2NpYXRlZCB3aXRoIGNsaWNraW5nLiAqL1xuICBjbGljazogdHJ1ZSxcbiAgLyoqIEVuYWJsZXMgd2hlZWwgZXZlbnRzLiAqL1xuICB3aGVlbDogdHJ1ZVxufTtcbmxldCBFdmVudFN5c3RlbSA9IF9FdmVudFN5c3RlbTtcblxuZXhwb3J0IHsgRXZlbnRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV2ZW50U3lzdGVtIH0gZnJvbSAnLi9FdmVudFN5c3RlbS5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZEV2ZW50Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgRmVkZXJhdGVkQ29udGFpbmVyID0ge1xuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBjbGlja2AgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gY2xpY2tcbiAgICogfVxuICAgKi9cbiAgb25jbGljazogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2Vkb3duYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ubW91c2Vkb3duID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gbW91c2Vkb3duXG4gICAqIH1cbiAgICovXG4gIG9ubW91c2Vkb3duOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBtb3VzZWVudGVyYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ubW91c2VlbnRlciA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNlZW50ZXJcbiAgICogfVxuICAgKi9cbiAgb25tb3VzZWVudGVyOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBtb3VzZWxlYXZlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ubW91c2VsZWF2ZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNlbGVhdmVcbiAgICogfVxuICAgKi9cbiAgb25tb3VzZWxlYXZlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBtb3VzZW1vdmVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25tb3VzZW1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBtb3VzZW1vdmVcbiAgICogfVxuICAgKi9cbiAgb25tb3VzZW1vdmU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYGdsb2JhbG1vdXNlbW92ZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbmdsb2JhbG1vdXNlbW92ZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIGdsb2JhbG1vdXNlbW92ZVxuICAgKiB9XG4gICAqL1xuICBvbmdsb2JhbG1vdXNlbW92ZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2VvdXRgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25tb3VzZW91dCA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNlb3V0XG4gICAqIH1cbiAgICovXG4gIG9ubW91c2VvdXQ6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYG1vdXNlb3ZlcmAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbm1vdXNlb3ZlciA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNlb3ZlclxuICAgKiB9XG4gICAqL1xuICBvbm1vdXNlb3ZlcjogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2V1cGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbm1vdXNldXAgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBtb3VzZXVwXG4gICAqIH1cbiAgICovXG4gIG9ubW91c2V1cDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgbW91c2V1cG91dHNpZGVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25tb3VzZXVwb3V0c2lkZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIG1vdXNldXBvdXRzaWRlXG4gICAqIH1cbiAgICovXG4gIG9ubW91c2V1cG91dHNpZGU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHBvaW50ZXJjYW5jZWxgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25wb2ludGVyY2FuY2VsID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcG9pbnRlcmNhbmNlbFxuICAgKiB9XG4gICAqL1xuICBvbnBvaW50ZXJjYW5jZWw6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHBvaW50ZXJkb3duYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcmRvd24gPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBwb2ludGVyZG93blxuICAgKiB9XG4gICAqL1xuICBvbnBvaW50ZXJkb3duOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVyZW50ZXJgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25wb2ludGVyZW50ZXIgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBwb2ludGVyZW50ZXJcbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVyZW50ZXI6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHBvaW50ZXJsZWF2ZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnBvaW50ZXJsZWF2ZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJsZWF2ZVxuICAgKiB9XG4gICAqL1xuICBvbnBvaW50ZXJsZWF2ZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcG9pbnRlcm1vdmVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25wb2ludGVybW92ZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJtb3ZlXG4gICAqIH1cbiAgICovXG4gIG9ucG9pbnRlcm1vdmU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYGdsb2JhbHBvaW50ZXJtb3ZlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9uZ2xvYmFscG9pbnRlcm1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBnbG9iYWxwb2ludGVybW92ZVxuICAgKiB9XG4gICAqL1xuICBvbmdsb2JhbHBvaW50ZXJtb3ZlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVyb3V0YCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcm91dCA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJvdXRcbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVyb3V0OiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVyb3ZlcmAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnBvaW50ZXJvdmVyID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcG9pbnRlcm92ZXJcbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVyb3ZlcjogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcG9pbnRlcnRhcGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnBvaW50ZXJ0YXAgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiBwb2ludGVydGFwXG4gICAqIH1cbiAgICovXG4gIG9ucG9pbnRlcnRhcDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgcG9pbnRlcnVwYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcnVwID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcG9pbnRlcnVwXG4gICAqIH1cbiAgICovXG4gIG9ucG9pbnRlcnVwOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGBwb2ludGVydXBvdXRzaWRlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucG9pbnRlcnVwb3V0c2lkZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHBvaW50ZXJ1cG91dHNpZGVcbiAgICogfVxuICAgKi9cbiAgb25wb2ludGVydXBvdXRzaWRlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGByaWdodGNsaWNrYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucmlnaHRjbGljayA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHJpZ2h0Y2xpY2tcbiAgICogfVxuICAgKi9cbiAgb25yaWdodGNsaWNrOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGByaWdodGRvd25gIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25yaWdodGRvd24gPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiByaWdodGRvd25cbiAgICogfVxuICAgKi9cbiAgb25yaWdodGRvd246IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHJpZ2h0dXBgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub25yaWdodHVwID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gcmlnaHR1cFxuICAgKiB9XG4gICAqL1xuICBvbnJpZ2h0dXA6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHJpZ2h0dXBvdXRzaWRlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9ucmlnaHR1cG91dHNpZGUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiByaWdodHVwb3V0c2lkZVxuICAgKiB9XG4gICAqL1xuICBvbnJpZ2h0dXBvdXRzaWRlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGB0YXBgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub250YXAgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiB0YXBcbiAgICogfVxuICAgKi9cbiAgb250YXA6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYHRvdWNoY2FuY2VsYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9udG91Y2hjYW5jZWwgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiB0b3VjaGNhbmNlbFxuICAgKiB9XG4gICAqL1xuICBvbnRvdWNoY2FuY2VsOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGB0b3VjaGVuZGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnRvdWNoZW5kID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gdG91Y2hlbmRcbiAgICogfVxuICAgKi9cbiAgb250b3VjaGVuZDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgdG91Y2hlbmRvdXRzaWRlYCBldmVudC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLm9udG91Y2hlbmRvdXRzaWRlID0gKGV2ZW50KSA9PiB7XG4gICAqICAvL3NvbWUgZnVuY3Rpb24gaGVyZSB0aGF0IGhhcHBlbnMgb24gdG91Y2hlbmRvdXRzaWRlXG4gICAqIH1cbiAgICovXG4gIG9udG91Y2hlbmRvdXRzaWRlOiBudWxsLFxuICAvKipcbiAgICogUHJvcGVydHktYmFzZWQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGB0b3VjaG1vdmVgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub250b3VjaG1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiB0b3VjaG1vdmVcbiAgICogfVxuICAgKi9cbiAgb250b3VjaG1vdmU6IG51bGwsXG4gIC8qKlxuICAgKiBQcm9wZXJ0eS1iYXNlZCBldmVudCBoYW5kbGVyIGZvciB0aGUgYGdsb2JhbHRvdWNobW92ZWAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbmdsb2JhbHRvdWNobW92ZSA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIGdsb2JhbHRvdWNobW92ZVxuICAgKiB9XG4gICAqL1xuICBvbmdsb2JhbHRvdWNobW92ZTogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgdG91Y2hzdGFydGAgZXZlbnQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5vbnRvdWNoc3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICogIC8vc29tZSBmdW5jdGlvbiBoZXJlIHRoYXQgaGFwcGVucyBvbiB0b3VjaHN0YXJ0XG4gICAqIH1cbiAgICovXG4gIG9udG91Y2hzdGFydDogbnVsbCxcbiAgLyoqXG4gICAqIFByb3BlcnR5LWJhc2VkIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBgd2hlZWxgIGV2ZW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMub253aGVlbCA9IChldmVudCkgPT4ge1xuICAgKiAgLy9zb21lIGZ1bmN0aW9uIGhlcmUgdGhhdCBoYXBwZW5zIG9uIHdoZWVsXG4gICAqIH1cbiAgICovXG4gIG9ud2hlZWw6IG51bGwsXG4gIC8qKlxuICAgKiBFbmFibGUgaW50ZXJhY3Rpb24gZXZlbnRzIGZvciB0aGUgQ29udGFpbmVyLiBUb3VjaCwgcG9pbnRlciBhbmQgbW91c2VcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldCBpbnRlcmFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudE1vZGUgPT09IFwiZHluYW1pY1wiIHx8IHRoaXMuZXZlbnRNb2RlID09PSBcInN0YXRpY1wiO1xuICB9LFxuICBzZXQgaW50ZXJhY3RpdmUodmFsdWUpIHtcbiAgICB0aGlzLmV2ZW50TW9kZSA9IHZhbHVlID8gXCJzdGF0aWNcIiA6IFwicGFzc2l2ZVwiO1xuICB9LFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX2ludGVybmFsRXZlbnRNb2RlOiB2b2lkIDAsXG4gIC8qKlxuICAgKiBFbmFibGUgaW50ZXJhY3Rpb24gZXZlbnRzIGZvciB0aGUgQ29udGFpbmVyLiBUb3VjaCwgcG9pbnRlciBhbmQgbW91c2UuXG4gICAqIFRoZXJlIGFyZSA1IHR5cGVzIG9mIGludGVyYWN0aW9uIHNldHRpbmdzOlxuICAgKiAtIGAnbm9uZSdgOiBJZ25vcmVzIGFsbCBpbnRlcmFjdGlvbiBldmVudHMsIGV2ZW4gb24gaXRzIGNoaWxkcmVuLlxuICAgKiAtIGAncGFzc2l2ZSdgOiAqKihkZWZhdWx0KSoqIERvZXMgbm90IGVtaXQgZXZlbnRzIGFuZCBpZ25vcmVzIGFsbCBoaXQgdGVzdGluZyBvbiBpdHNlbGYgYW5kIG5vbi1pbnRlcmFjdGl2ZSBjaGlsZHJlbi5cbiAgICogSW50ZXJhY3RpdmUgY2hpbGRyZW4gd2lsbCBzdGlsbCBlbWl0IGV2ZW50cy5cbiAgICogLSBgJ2F1dG8nYDogRG9lcyBub3QgZW1pdCBldmVudHMgYnV0IGlzIGhpdCB0ZXN0ZWQgaWYgcGFyZW50IGlzIGludGVyYWN0aXZlLiBTYW1lIGFzIGBpbnRlcmFjdGl2ZSA9IGZhbHNlYCBpbiB2N1xuICAgKiAtIGAnc3RhdGljJ2A6IEVtaXQgZXZlbnRzIGFuZCBpcyBoaXQgdGVzdGVkLiBTYW1lIGFzIGBpbnRlcmFjdGlvbiA9IHRydWVgIGluIHY3XG4gICAqIC0gYCdkeW5hbWljJ2A6IEVtaXRzIGV2ZW50cyBhbmQgaXMgaGl0IHRlc3RlZCBidXQgd2lsbCBhbHNvIHJlY2VpdmUgbW9jayBpbnRlcmFjdGlvbiBldmVudHMgZmlyZWQgZnJvbSBhIHRpY2tlciB0b1xuICAgKiBhbGxvdyBmb3IgaW50ZXJhY3Rpb24gd2hlbiB0aGUgbW91c2UgaXNuJ3QgbW92aW5nXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IFNwcml0ZSB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgU3ByaXRlKHRleHR1cmUpO1xuICAgKiBzcHJpdGUuZXZlbnRNb2RlID0gJ3N0YXRpYyc7XG4gICAqIHNwcml0ZS5vbigndGFwJywgKGV2ZW50KSA9PiB7XG4gICAqICAgICAvLyBIYW5kbGUgZXZlbnRcbiAgICogfSk7XG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBzaW5jZSA3LjIuMFxuICAgKi9cbiAgZ2V0IGV2ZW50TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxFdmVudE1vZGUgPz8gRXZlbnRTeXN0ZW0uZGVmYXVsdEV2ZW50TW9kZTtcbiAgfSxcbiAgc2V0IGV2ZW50TW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuX2ludGVybmFsRXZlbnRNb2RlID0gdmFsdWU7XG4gIH0sXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBjb250YWluZXIgaXMgaW50ZXJhY3RpdmUgb3Igbm90XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBjb250YWluZXIgaXMgaW50ZXJhY3RpdmUgb3Igbm90XG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBzaW5jZSA3LjIuMFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBTcHJpdGUgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcbiAgICogc3ByaXRlLmV2ZW50TW9kZSA9ICdzdGF0aWMnO1xuICAgKiBzcHJpdGUuaXNJbnRlcmFjdGl2ZSgpOyAvLyB0cnVlXG4gICAqXG4gICAqIHNwcml0ZS5ldmVudE1vZGUgPSAnZHluYW1pYyc7XG4gICAqIHNwcml0ZS5pc0ludGVyYWN0aXZlKCk7IC8vIHRydWVcbiAgICpcbiAgICogc3ByaXRlLmV2ZW50TW9kZSA9ICdub25lJztcbiAgICogc3ByaXRlLmlzSW50ZXJhY3RpdmUoKTsgLy8gZmFsc2VcbiAgICpcbiAgICogc3ByaXRlLmV2ZW50TW9kZSA9ICdwYXNzaXZlJztcbiAgICogc3ByaXRlLmlzSW50ZXJhY3RpdmUoKTsgLy8gZmFsc2VcbiAgICpcbiAgICogc3ByaXRlLmV2ZW50TW9kZSA9ICdhdXRvJztcbiAgICogc3ByaXRlLmlzSW50ZXJhY3RpdmUoKTsgLy8gZmFsc2VcbiAgICovXG4gIGlzSW50ZXJhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRNb2RlID09PSBcInN0YXRpY1wiIHx8IHRoaXMuZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIjtcbiAgfSxcbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIGNoaWxkcmVuIHRvIHRoZSBjb250YWluZXIgY2FuIGJlIGNsaWNrZWQvdG91Y2hlZFxuICAgKiBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgYWxsb3dzIFBpeGlKUyB0byBieXBhc3MgYSByZWN1cnNpdmUgYGhpdFRlc3RgIGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBpbnRlcmFjdGl2ZUNoaWxkcmVuOiB0cnVlLFxuICAvKipcbiAgICogSW50ZXJhY3Rpb24gc2hhcGUuIENoaWxkcmVuIHdpbGwgYmUgaGl0IGZpcnN0LCB0aGVuIHRoaXMgc2hhcGUgd2lsbCBiZSBjaGVja2VkLlxuICAgKiBTZXR0aW5nIHRoaXMgd2lsbCBjYXVzZSB0aGlzIHNoYXBlIHRvIGJlIGNoZWNrZWQgaW4gaGl0IHRlc3RzIHJhdGhlciB0aGFuIHRoZSBjb250YWluZXIncyBib3VuZHMuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IFJlY3RhbmdsZSwgU3ByaXRlIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAqIHNwcml0ZS5oaXRBcmVhID0gbmV3IFJlY3RhbmdsZSgwLCAwLCAxMDAsIDEwMCk7XG4gICAqIEBtZW1iZXIge0lIaXRBcmVhfVxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgaGl0QXJlYTogbnVsbCxcbiAgLyoqXG4gICAqIFVubGlrZSBgb25gIG9yIGBhZGRMaXN0ZW5lcmAgd2hpY2ggYXJlIG1ldGhvZHMgZnJvbSBFdmVudEVtaXR0ZXIsIGBhZGRFdmVudExpc3RlbmVyYFxuICAgKiBzZWVrcyB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIERPTSdzIGBhZGRFdmVudExpc3RlbmVyYCB3aXRoIHN1cHBvcnQgZm9yIG9wdGlvbnMuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXJcbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiBldmVudCB0byBsaXN0ZW4gdG8uXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBjYWxsYmFjayBvciBvYmplY3QuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGVuZXIgb3B0aW9ucywgdXNlZCBmb3IgY2FwdHVyZSBwaGFzZS5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gVGVsbCB0aGUgdXNlciB3aGV0aGVyIHRoZXkgZGlkIGEgc2luZ2xlLCBkb3VibGUsIHRyaXBsZSwgb3IgbnRoIGNsaWNrLlxuICAgKiBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB7XG4gICAqICAgICBoYW5kbGVFdmVudChlKToge1xuICAgKiAgICAgICAgIGxldCBwcmVmaXg7XG4gICAqXG4gICAqICAgICAgICAgc3dpdGNoIChlLmRldGFpbCkge1xuICAgKiAgICAgICAgICAgICBjYXNlIDE6IHByZWZpeCA9ICdzaW5nbGUnOyBicmVhaztcbiAgICogICAgICAgICAgICAgY2FzZSAyOiBwcmVmaXggPSAnZG91YmxlJzsgYnJlYWs7XG4gICAqICAgICAgICAgICAgIGNhc2UgMzogcHJlZml4ID0gJ3RyaXBsZSc7IGJyZWFrO1xuICAgKiAgICAgICAgICAgICBkZWZhdWx0OiBwcmVmaXggPSBlLmRldGFpbCArICd0aCc7IGJyZWFrO1xuICAgKiAgICAgICAgIH1cbiAgICpcbiAgICogICAgICAgICBjb25zb2xlLmxvZygnVGhhdCB3YXMgYSAnICsgcHJlZml4ICsgJ2NsaWNrJyk7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBCdXQgc2tpcCB0aGUgZmlyc3QgY2xpY2shXG4gICAqIGJ1dHRvbi5wYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBibG9ja0NsaWNrT25jZShlKSB7XG4gICAqICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgKiAgICAgYnV0dG9uLnBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGJsb2NrQ2xpY2tPbmNlLCB0cnVlKTtcbiAgICogfSwge1xuICAgKiAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICogfSk7XG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FwdHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiAmJiBvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuY2FwdHVyZTtcbiAgICBjb25zdCBzaWduYWwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuc2lnbmFsIDogdm9pZCAwO1xuICAgIGNvbnN0IG9uY2UgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMub25jZSA9PT0gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiA/IHZvaWQgMCA6IGxpc3RlbmVyO1xuICAgIHR5cGUgPSBjYXB0dXJlID8gYCR7dHlwZX1jYXB0dXJlYCA6IHR5cGU7XG4gICAgY29uc3QgbGlzdGVuZXJGbiA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiID8gbGlzdGVuZXIgOiBsaXN0ZW5lci5oYW5kbGVFdmVudDtcbiAgICBjb25zdCBlbWl0dGVyID0gdGhpcztcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgZW1pdHRlci5vZmYodHlwZSwgbGlzdGVuZXJGbiwgY29udGV4dCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZSh0eXBlLCBsaXN0ZW5lckZuLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbih0eXBlLCBsaXN0ZW5lckZuLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBVbmxpa2UgYG9mZmAgb3IgYHJlbW92ZUxpc3RlbmVyYCB3aGljaCBhcmUgbWV0aG9kcyBmcm9tIEV2ZW50RW1pdHRlciwgYHJlbW92ZUV2ZW50TGlzdGVuZXJgXG4gICAqIHNlZWtzIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgRE9NJ3MgYHJlbW92ZUV2ZW50TGlzdGVuZXJgIHdpdGggc3VwcG9ydCBmb3Igb3B0aW9ucy5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lclxuICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHRoZSBsaXN0ZW5lciBpcyBib3VuZCB0by5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGNhbGxiYWNrIG9yIG9iamVjdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3JpZ2luYWwgbGlzdGVuZXIgb3B0aW9ucy4gVGhpcyBpcyByZXF1aXJlZCB0byBkZXJlZ2lzdGVyIGEgY2FwdHVyZSBwaGFzZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXB0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiICYmIG9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5jYXB0dXJlO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiA/IHZvaWQgMCA6IGxpc3RlbmVyO1xuICAgIHR5cGUgPSBjYXB0dXJlID8gYCR7dHlwZX1jYXB0dXJlYCA6IHR5cGU7XG4gICAgbGlzdGVuZXIgPSB0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiA/IGxpc3RlbmVyIDogbGlzdGVuZXIuaGFuZGxlRXZlbnQ7XG4gICAgdGhpcy5vZmYodHlwZSwgbGlzdGVuZXIsIGNvbnRleHQpO1xuICB9LFxuICAvKipcbiAgICogRGlzcGF0Y2ggdGhlIGV2ZW50IG9uIHRoaXMge0BsaW5rIENvbnRhaW5lcn0gdXNpbmcgdGhlIGV2ZW50J3Mge0BsaW5rIEV2ZW50Qm91bmRhcnl9LlxuICAgKlxuICAgKiBUaGUgdGFyZ2V0IG9mIHRoZSBldmVudCBpcyBzZXQgdG8gYHRoaXNgIGFuZCB0aGUgYGRlZmF1bHRQcmV2ZW50ZWRgIGZsYWcgaXMgY2xlYXJlZCBiZWZvcmUgZGlzcGF0Y2guXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXJcbiAgICogQHBhcmFtIGUgLSBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHtAbGluayBGZWRlcmF0ZWRFdmVudC5wcmV2ZW50RGVmYXVsdCBwcmV2ZW50RGVmYXVsdH0oKSBtZXRob2Qgd2FzIG5vdCBpbnZva2VkLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBSZXVzZSBhIGNsaWNrIGV2ZW50IVxuICAgKiBidXR0b24uZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICovXG4gIGRpc3BhdGNoRXZlbnQoZSkge1xuICAgIGlmICghKGUgaW5zdGFuY2VvZiBGZWRlcmF0ZWRFdmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhaW5lciBjYW5ub3QgcHJvcGFnYXRlIGV2ZW50cyBvdXRzaWRlIG9mIHRoZSBGZWRlcmF0ZWQgRXZlbnRzIEFQSVwiKTtcbiAgICB9XG4gICAgZS5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgZS5wYXRoID0gbnVsbDtcbiAgICBlLnRhcmdldCA9IHRoaXM7XG4gICAgZS5tYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgcmV0dXJuICFlLmRlZmF1bHRQcmV2ZW50ZWQ7XG4gIH1cbn07XG5cbmV4cG9ydCB7IEZlZGVyYXRlZENvbnRhaW5lciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmVkZXJhdGVkRXZlbnRUYXJnZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgRXZlbnRTeXN0ZW0gfSBmcm9tICcuL0V2ZW50U3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRDb250YWluZXIgfSBmcm9tICcuL0ZlZGVyYXRlZEV2ZW50VGFyZ2V0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoRXZlbnRTeXN0ZW0pO1xuQ29udGFpbmVyLm1peGluKEZlZGVyYXRlZENvbnRhaW5lcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiIsImltcG9ydCAnLi4vYWNjZXNzaWJpbGl0eS9pbml0Lm1qcyc7XG5pbXBvcnQgJy4uL2FwcC9pbml0Lm1qcyc7XG5pbXBvcnQgJy4uL2V2ZW50cy9pbml0Lm1qcyc7XG5pbXBvcnQgJy4uL3Nwcml0ZXNoZWV0L2luaXQubWpzJztcbmltcG9ydCAnLi4vcmVuZGVyaW5nL2luaXQubWpzJztcbmltcG9ydCAnLi4vc2NlbmUvZ3JhcGhpY3MvaW5pdC5tanMnO1xuaW1wb3J0ICcuLi9zY2VuZS9tZXNoL2luaXQubWpzJztcbmltcG9ydCAnLi4vc2NlbmUvdGV4dC9pbml0Lm1qcyc7XG5pbXBvcnQgJy4uL3NjZW5lL3RleHQtYml0bWFwL2luaXQubWpzJztcbmltcG9ydCAnLi4vc2NlbmUvdGV4dC1odG1sL2luaXQubWpzJztcbmltcG9ydCAnLi4vc2NlbmUvc3ByaXRlLXRpbGluZy9pbml0Lm1qcyc7XG5pbXBvcnQgJy4uL3NjZW5lL3Nwcml0ZS1uaW5lLXNsaWNlL2luaXQubWpzJztcbmltcG9ydCAnLi4vZmlsdGVycy9pbml0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3NlckFsbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8148\n')}}]);